#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: Mercuna

#include "Basic.hpp"

#include "Mercuna_classes.hpp"
#include "Mercuna_parameters.hpp"


namespace SDK
{

// Function Mercuna.Mercuna3DNavigationComponent.AddDestinationLocation
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// const struct FVector&                   NextDestination                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMercuna3DNavigationComponent::AddDestinationLocation(const struct FVector& NextDestination)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Mercuna3DNavigationComponent", "AddDestinationLocation");

	Params::Mercuna3DNavigationComponent_AddDestinationLocation Parms{};

	Parms.NextDestination = std::move(NextDestination);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Mercuna.Mercuna3DNavigationComponent.CancelLookAt
// (Final, Native, Public, BlueprintCallable)

void UMercuna3DNavigationComponent::CancelLookAt()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Mercuna3DNavigationComponent", "CancelLookAt");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Mercuna.Mercuna3DNavigationComponent.CancelMovement
// (Final, Native, Public, BlueprintCallable)

void UMercuna3DNavigationComponent::CancelMovement()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Mercuna3DNavigationComponent", "CancelMovement");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Mercuna.Mercuna3DNavigationComponent.ClearAvoidanceExclusions
// (Native, Public, BlueprintCallable)

void UMercuna3DNavigationComponent::ClearAvoidanceExclusions()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Mercuna3DNavigationComponent", "ClearAvoidanceExclusions");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Mercuna.Mercuna3DNavigationComponent.Configure
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const struct FMercuna3DNavigationConfiguration&NewConfiguration                                       (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)

void UMercuna3DNavigationComponent::Configure(const struct FMercuna3DNavigationConfiguration& NewConfiguration)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Mercuna3DNavigationComponent", "Configure");

	Params::Mercuna3DNavigationComponent_Configure Parms{};

	Parms.NewConfiguration = std::move(NewConfiguration);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Mercuna.Mercuna3DNavigationComponent.ConfigureMovement
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bUsePathfinding                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EMercunaAvoidanceMode                   NewAvoidanceMode                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMercuna3DNavigationComponent::ConfigureMovement(bool bUsePathfinding, EMercunaAvoidanceMode NewAvoidanceMode)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Mercuna3DNavigationComponent", "ConfigureMovement");

	Params::Mercuna3DNavigationComponent_ConfigureMovement Parms{};

	Parms.bUsePathfinding = bUsePathfinding;
	Parms.NewAvoidanceMode = NewAvoidanceMode;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Mercuna.Mercuna3DNavigationComponent.GetPathInfo
// (Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// bool*                                   Valid                                                  (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float*                                  DistanceToEnd                                          (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMercuna3DNavigationComponent::GetPathInfo(bool* Valid, float* DistanceToEnd)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Mercuna3DNavigationComponent", "GetPathInfo");

	Params::Mercuna3DNavigationComponent_GetPathInfo Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Valid != nullptr)
		*Valid = Parms.Valid;

	if (DistanceToEnd != nullptr)
		*DistanceToEnd = Parms.DistanceToEnd;
}


// Function Mercuna.Mercuna3DNavigationComponent.GetRemainingPathLength
// (Native, Public, BlueprintCallable)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UMercuna3DNavigationComponent::GetRemainingPathLength()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Mercuna3DNavigationComponent", "GetRemainingPathLength");

	Params::Mercuna3DNavigationComponent_GetRemainingPathLength Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Mercuna.Mercuna3DNavigationComponent.InvalidateContextualSteeringParams
// (Native, Public, BlueprintCallable)

void UMercuna3DNavigationComponent::InvalidateContextualSteeringParams()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Mercuna3DNavigationComponent", "InvalidateContextualSteeringParams");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Mercuna.Mercuna3DNavigationComponent.InvalidateContextualSteeringParamsAgainstActor
// (Native, Public, BlueprintCallable)
// Parameters:
// class AActor*                           Actor                                                  (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMercuna3DNavigationComponent::InvalidateContextualSteeringParamsAgainstActor(class AActor* Actor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Mercuna3DNavigationComponent", "InvalidateContextualSteeringParamsAgainstActor");

	Params::Mercuna3DNavigationComponent_InvalidateContextualSteeringParamsAgainstActor Parms{};

	Parms.Actor = Actor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Mercuna.Mercuna3DNavigationComponent.IsReachable
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// const struct FVector&                   Point                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool*                                   Success                                                (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FLatentActionInfo&         LatentInfo                                             (Parm, NoDestructor, NativeAccessSpecifierPublic)

void UMercuna3DNavigationComponent::IsReachable(const struct FVector& Point, bool* Success, class UObject* WorldContextObject, const struct FLatentActionInfo& LatentInfo)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Mercuna3DNavigationComponent", "IsReachable");

	Params::Mercuna3DNavigationComponent_IsReachable Parms{};

	Parms.Point = std::move(Point);
	Parms.WorldContextObject = WorldContextObject;
	Parms.LatentInfo = std::move(LatentInfo);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Success != nullptr)
		*Success = Parms.Success;
}


// Function Mercuna.Mercuna3DNavigationComponent.LookAlongAcceleration
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   MaxPitch                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMercuna3DNavigationComponent::LookAlongAcceleration(float MaxPitch)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Mercuna3DNavigationComponent", "LookAlongAcceleration");

	Params::Mercuna3DNavigationComponent_LookAlongAcceleration Parms{};

	Parms.MaxPitch = MaxPitch;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Mercuna.Mercuna3DNavigationComponent.LookAt
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class AActor*                           Actor                                                  (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   MaxPitch                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMercuna3DNavigationComponent::LookAt(class AActor* Actor, float MaxPitch)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Mercuna3DNavigationComponent", "LookAt");

	Params::Mercuna3DNavigationComponent_LookAt Parms{};

	Parms.Actor = Actor;
	Parms.MaxPitch = MaxPitch;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Mercuna.Mercuna3DNavigationComponent.LookInDirection
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// const struct FVector&                   Direction                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   MaxPitch                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMercuna3DNavigationComponent::LookInDirection(const struct FVector& Direction, float MaxPitch)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Mercuna3DNavigationComponent", "LookInDirection");

	Params::Mercuna3DNavigationComponent_LookInDirection Parms{};

	Parms.Direction = std::move(Direction);
	Parms.MaxPitch = MaxPitch;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Mercuna.Mercuna3DNavigationComponent.MoveToActor
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class AActor*                           Actor                                                  (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   EndDistance                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Speed                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    UsePartialPath                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMercuna3DNavigationComponent::MoveToActor(class AActor* Actor, float EndDistance, float Speed, bool UsePartialPath)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Mercuna3DNavigationComponent", "MoveToActor");

	Params::Mercuna3DNavigationComponent_MoveToActor Parms{};

	Parms.Actor = Actor;
	Parms.EndDistance = EndDistance;
	Parms.Speed = Speed;
	Parms.UsePartialPath = UsePartialPath;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Mercuna.Mercuna3DNavigationComponent.MoveToLocation
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// const struct FVector&                   Destination                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   EndDistance                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Speed                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    UsePartialPath                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMercuna3DNavigationComponent::MoveToLocation(const struct FVector& Destination, float EndDistance, float Speed, bool UsePartialPath)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Mercuna3DNavigationComponent", "MoveToLocation");

	Params::Mercuna3DNavigationComponent_MoveToLocation Parms{};

	Parms.Destination = std::move(Destination);
	Parms.EndDistance = EndDistance;
	Parms.Speed = Speed;
	Parms.UsePartialPath = UsePartialPath;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Mercuna.Mercuna3DNavigationComponent.MoveToLocations
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const TArray<struct FVector>&           Destinations                                           (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// float                                   EndDistance                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Speed                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    UsePartialPath                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMercuna3DNavigationComponent::MoveToLocations(const TArray<struct FVector>& Destinations, float EndDistance, float Speed, bool UsePartialPath)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Mercuna3DNavigationComponent", "MoveToLocations");

	Params::Mercuna3DNavigationComponent_MoveToLocations Parms{};

	Parms.Destinations = std::move(Destinations);
	Parms.EndDistance = EndDistance;
	Parms.Speed = Speed;
	Parms.UsePartialPath = UsePartialPath;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Mercuna.Mercuna3DNavigationComponent.OverrideSpeedMultiplier
// (Native, Public, BlueprintCallable)
// Parameters:
// const float                             NewSpeedMultiplier                                     (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UMercuna3DNavigationComponent::OverrideSpeedMultiplier(const float NewSpeedMultiplier)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Mercuna3DNavigationComponent", "OverrideSpeedMultiplier");

	Params::Mercuna3DNavigationComponent_OverrideSpeedMultiplier Parms{};

	Parms.NewSpeedMultiplier = NewSpeedMultiplier;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Mercuna.Mercuna3DNavigationComponent.PauseNavigation
// (Final, Native, Public, BlueprintCallable)

void UMercuna3DNavigationComponent::PauseNavigation()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Mercuna3DNavigationComponent", "PauseNavigation");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Mercuna.Mercuna3DNavigationComponent.ResumeNavigation
// (Final, Native, Public, BlueprintCallable)

void UMercuna3DNavigationComponent::ResumeNavigation()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Mercuna3DNavigationComponent", "ResumeNavigation");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Mercuna.Mercuna3DNavigationComponent.SetAvoidanceAgainst
// (Native, Public, BlueprintCallable)
// Parameters:
// class AActor*                           Actor                                                  (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    Enable                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMercuna3DNavigationComponent::SetAvoidanceAgainst(class AActor* Actor, bool Enable)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Mercuna3DNavigationComponent", "SetAvoidanceAgainst");

	Params::Mercuna3DNavigationComponent_SetAvoidanceAgainst Parms{};

	Parms.Actor = Actor;
	Parms.Enable = Enable;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Mercuna.Mercuna3DNavigationComponent.SetNavOctree
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class AMercunaNavOctree*                NavOctree_0                                            (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMercuna3DNavigationComponent::SetNavOctree(class AMercunaNavOctree* NavOctree_0)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Mercuna3DNavigationComponent", "SetNavOctree");

	Params::Mercuna3DNavigationComponent_SetNavOctree Parms{};

	Parms.NavOctree_0 = NavOctree_0;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Mercuna.Mercuna3DNavigationComponent.SetNavOctreeToBest
// (Final, Native, Public, BlueprintCallable)

void UMercuna3DNavigationComponent::SetNavOctreeToBest()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Mercuna3DNavigationComponent", "SetNavOctreeToBest");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Mercuna.Mercuna3DNavigationComponent.SetUsageSpec
// (Native, Public, BlueprintCallable)
// Parameters:
// const struct FMercunaUsageSpec&         NewUsageSpec                                           (Parm, NoDestructor, NativeAccessSpecifierPublic)

void UMercuna3DNavigationComponent::SetUsageSpec(const struct FMercunaUsageSpec& NewUsageSpec)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Mercuna3DNavigationComponent", "SetUsageSpec");

	Params::Mercuna3DNavigationComponent_SetUsageSpec Parms{};

	Parms.NewUsageSpec = std::move(NewUsageSpec);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Mercuna.Mercuna3DNavigationComponent.Stop
// (Final, Native, Public, BlueprintCallable)

void UMercuna3DNavigationComponent::Stop()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Mercuna3DNavigationComponent", "Stop");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Mercuna.Mercuna3DNavigationComponent.TrackActor
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// class AActor*                           Actor                                                  (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Distance                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Speed                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FVector&                   Offset                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMercuna3DNavigationComponent::TrackActor(class AActor* Actor, float Distance, float Speed, const struct FVector& Offset)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Mercuna3DNavigationComponent", "TrackActor");

	Params::Mercuna3DNavigationComponent_TrackActor Parms{};

	Parms.Actor = Actor;
	Parms.Distance = Distance;
	Parms.Speed = Speed;
	Parms.Offset = std::move(Offset);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Mercuna.Mercuna3DNavigationComponent.GetNavOctree
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class AMercunaNavOctree*                ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AMercunaNavOctree* UMercuna3DNavigationComponent::GetNavOctree() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Mercuna3DNavigationComponent", "GetNavOctree");

	Params::Mercuna3DNavigationComponent_GetNavOctree Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Mercuna.Mercuna3DNavigationComponent.GetUsageSpec
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const struct FMercunaUsageSpec          ReturnValue                                            (ConstParm, Parm, OutParm, ReturnParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)

const struct FMercunaUsageSpec UMercuna3DNavigationComponent::GetUsageSpec() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Mercuna3DNavigationComponent", "GetUsageSpec");

	Params::Mercuna3DNavigationComponent_GetUsageSpec Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Mercuna.MercunaNavLink.AddBetweenNavGrids
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class AMercunaNavGraph2D*               LeftNavGrid_0                                          (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AMercunaNavGraph2D*               RightNavGrid_0                                         (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AMercunaNavLink::AddBetweenNavGrids(class AMercunaNavGraph2D* LeftNavGrid_0, class AMercunaNavGraph2D* RightNavGrid_0)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MercunaNavLink", "AddBetweenNavGrids");

	Params::MercunaNavLink_AddBetweenNavGrids Parms{};

	Parms.LeftNavGrid_0 = LeftNavGrid_0;
	Parms.RightNavGrid_0 = RightNavGrid_0;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Mercuna.MercunaNavLink.AddToAllGrids
// (Final, Native, Public, BlueprintCallable)

void AMercunaNavLink::AddToAllGrids()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MercunaNavLink", "AddToAllGrids");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Mercuna.MercunaNavLink.AddToNavGrid
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class AMercunaNavGraph2D*               NavGrid_0                                              (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AMercunaNavLink::AddToNavGrid(class AMercunaNavGraph2D* NavGrid_0)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MercunaNavLink", "AddToNavGrid");

	Params::MercunaNavLink_AddToNavGrid Parms{};

	Parms.NavGrid_0 = NavGrid_0;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Mercuna.MercunaNavLink.ReceiveNavLinkEnd
// (Event, Public, BlueprintEvent)
// Parameters:
// class APawn*                            Pawn                                                   (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AMercunaNavLink::ReceiveNavLinkEnd(class APawn* Pawn)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MercunaNavLink", "ReceiveNavLinkEnd");

	Params::MercunaNavLink_ReceiveNavLinkEnd Parms{};

	Parms.Pawn = Pawn;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Mercuna.MercunaNavLink.ReceiveNavLinkStart
// (Event, Public, HasDefaults, BlueprintEvent)
// Parameters:
// class APawn*                            Pawn                                                   (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EMercunaNavigationLinkDirection         Direction                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FVector&                   Destination                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AMercunaNavLink::ReceiveNavLinkStart(class APawn* Pawn, EMercunaNavigationLinkDirection Direction, const struct FVector& Destination)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MercunaNavLink", "ReceiveNavLinkStart");

	Params::MercunaNavLink_ReceiveNavLinkStart Parms{};

	Parms.Pawn = Pawn;
	Parms.Direction = Direction;
	Parms.Destination = std::move(Destination);

	UObject::ProcessEvent(Func, &Parms);
}


// Function Mercuna.MercunaNavLink.SetEnabled
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bEnabled_0                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class FString&                    Reason                                                 (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AMercunaNavLink::SetEnabled(bool bEnabled_0, const class FString& Reason)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MercunaNavLink", "SetEnabled");

	Params::MercunaNavLink_SetEnabled Parms{};

	Parms.bEnabled_0 = bEnabled_0;
	Parms.Reason = std::move(Reason);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Mercuna.MercunaNavLink.GetLeftPosition
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector AMercunaNavLink::GetLeftPosition() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MercunaNavLink", "GetLeftPosition");

	Params::MercunaNavLink_GetLeftPosition Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Mercuna.MercunaNavLink.GetLeftRotation
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FRotator                         ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

struct FRotator AMercunaNavLink::GetLeftRotation() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MercunaNavLink", "GetLeftRotation");

	Params::MercunaNavLink_GetLeftRotation Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Mercuna.MercunaNavLink.GetLeftTransform
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FTransform                       ReturnValue                                            (Parm, OutParm, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FTransform AMercunaNavLink::GetLeftTransform() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MercunaNavLink", "GetLeftTransform");

	Params::MercunaNavLink_GetLeftTransform Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Mercuna.MercunaNavLink.GetRightPosition
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector AMercunaNavLink::GetRightPosition() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MercunaNavLink", "GetRightPosition");

	Params::MercunaNavLink_GetRightPosition Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Mercuna.MercunaNavLink.GetRightRotation
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FRotator                         ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

struct FRotator AMercunaNavLink::GetRightRotation() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MercunaNavLink", "GetRightRotation");

	Params::MercunaNavLink_GetRightRotation Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Mercuna.MercunaNavLink.GetRightTransform
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FTransform                       ReturnValue                                            (Parm, OutParm, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FTransform AMercunaNavLink::GetRightTransform() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MercunaNavLink", "GetRightTransform");

	Params::MercunaNavLink_GetRightTransform Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Mercuna.MercunaNavLink.InUse
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AMercunaNavLink::InUse() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MercunaNavLink", "InUse");

	Params::MercunaNavLink_InUse Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Mercuna.MercunaGroundTask_MoveTo.MoveTo
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable)
// Parameters:
// class AAIController*                    Controller                                             (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FVector&                   GoalLocation                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           GoalActor                                              (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   EndDistance                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    AcceptPartialPath                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bLockAILogic                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UMercunaGroundTask_MoveTo*        ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UMercunaGroundTask_MoveTo* UMercunaGroundTask_MoveTo::MoveTo(class AAIController* Controller, const struct FVector& GoalLocation, class AActor* GoalActor, float EndDistance, bool AcceptPartialPath, bool bLockAILogic)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MercunaGroundTask_MoveTo", "MoveTo");

	Params::MercunaGroundTask_MoveTo_MoveTo Parms{};

	Parms.Controller = Controller;
	Parms.GoalLocation = std::move(GoalLocation);
	Parms.GoalActor = GoalActor;
	Parms.EndDistance = EndDistance;
	Parms.AcceptPartialPath = AcceptPartialPath;
	Parms.bLockAILogic = bLockAILogic;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Mercuna.MercunaGroundTask_MoveTo.OnMoveComplete
// (Native, Protected)
// Parameters:
// const struct FAIRequestID&              RequestID                                              (Parm, NoDestructor, NativeAccessSpecifierPublic)
// EMercunaMoveResult                      Result                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMercunaGroundTask_MoveTo::OnMoveComplete(const struct FAIRequestID& RequestID, EMercunaMoveResult Result)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MercunaGroundTask_MoveTo", "OnMoveComplete");

	Params::MercunaGroundTask_MoveTo_OnMoveComplete Parms{};

	Parms.RequestID = std::move(RequestID);
	Parms.Result = Result;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Mercuna.Mercuna3DMoveToProxy.MoveToActor
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class APawn*                            Pawn_0                                                 (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           Actor                                                  (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   EndDistance                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Speed                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    UsePartialPath                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UMercuna3DMoveToProxy*            ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UMercuna3DMoveToProxy* UMercuna3DMoveToProxy::MoveToActor(class UObject* WorldContextObject, class APawn* Pawn_0, class AActor* Actor, float EndDistance, float Speed, bool UsePartialPath)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("Mercuna3DMoveToProxy", "MoveToActor");

	Params::Mercuna3DMoveToProxy_MoveToActor Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.Pawn_0 = Pawn_0;
	Parms.Actor = Actor;
	Parms.EndDistance = EndDistance;
	Parms.Speed = Speed;
	Parms.UsePartialPath = UsePartialPath;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Mercuna.Mercuna3DMoveToProxy.MoveToLocation
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class APawn*                            Pawn_0                                                 (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FVector&                   Destination                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   EndDistance                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Speed                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    UsePartialPath                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UMercuna3DMoveToProxy*            ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UMercuna3DMoveToProxy* UMercuna3DMoveToProxy::MoveToLocation(class UObject* WorldContextObject, class APawn* Pawn_0, const struct FVector& Destination, float EndDistance, float Speed, bool UsePartialPath)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("Mercuna3DMoveToProxy", "MoveToLocation");

	Params::Mercuna3DMoveToProxy_MoveToLocation Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.Pawn_0 = Pawn_0;
	Parms.Destination = std::move(Destination);
	Parms.EndDistance = EndDistance;
	Parms.Speed = Speed;
	Parms.UsePartialPath = UsePartialPath;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Mercuna.Mercuna3DMoveToProxy.MoveToLocations
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class APawn*                            Pawn_0                                                 (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const TArray<struct FVector>&           Destinations                                           (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// float                                   EndDistance                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Speed                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    UsePartialPath                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UMercuna3DMoveToProxy*            ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UMercuna3DMoveToProxy* UMercuna3DMoveToProxy::MoveToLocations(class UObject* WorldContextObject, class APawn* Pawn_0, const TArray<struct FVector>& Destinations, float EndDistance, float Speed, bool UsePartialPath)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("Mercuna3DMoveToProxy", "MoveToLocations");

	Params::Mercuna3DMoveToProxy_MoveToLocations Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.Pawn_0 = Pawn_0;
	Parms.Destinations = std::move(Destinations);
	Parms.EndDistance = EndDistance;
	Parms.Speed = Speed;
	Parms.UsePartialPath = UsePartialPath;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Mercuna.Mercuna3DMoveToProxy.OnMoveComplete
// (Final, Native, Private)
// Parameters:
// const struct FAIRequestID&              RequestID                                              (Parm, NoDestructor, NativeAccessSpecifierPublic)
// EMercunaMoveResult                      Result                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMercuna3DMoveToProxy::OnMoveComplete(const struct FAIRequestID& RequestID, EMercunaMoveResult Result)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Mercuna3DMoveToProxy", "OnMoveComplete");

	Params::Mercuna3DMoveToProxy_OnMoveComplete Parms{};

	Parms.RequestID = std::move(RequestID);
	Parms.Result = Result;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Mercuna.MercunaGroundNavigationComponent.AddDestinationLocation
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// const struct FVector&                   NextDestination                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bSmoothTransition                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMercunaGroundNavigationComponent::AddDestinationLocation(const struct FVector& NextDestination, bool bSmoothTransition)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MercunaGroundNavigationComponent", "AddDestinationLocation");

	Params::MercunaGroundNavigationComponent_AddDestinationLocation Parms{};

	Parms.NextDestination = std::move(NextDestination);
	Parms.bSmoothTransition = bSmoothTransition;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Mercuna.MercunaGroundNavigationComponent.CancelMovement
// (Final, Native, Public, BlueprintCallable)

void UMercunaGroundNavigationComponent::CancelMovement()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MercunaGroundNavigationComponent", "CancelMovement");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Mercuna.MercunaGroundNavigationComponent.ClearAvoidanceExclusions
// (Native, Public, BlueprintCallable)

void UMercunaGroundNavigationComponent::ClearAvoidanceExclusions()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MercunaGroundNavigationComponent", "ClearAvoidanceExclusions");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Mercuna.MercunaGroundNavigationComponent.Configure
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const struct FMercunaGroundNavigationConfiguration&NewConfiguration                                       (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)

void UMercunaGroundNavigationComponent::Configure(const struct FMercunaGroundNavigationConfiguration& NewConfiguration)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MercunaGroundNavigationComponent", "Configure");

	Params::MercunaGroundNavigationComponent_Configure Parms{};

	Parms.NewConfiguration = std::move(NewConfiguration);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Mercuna.MercunaGroundNavigationComponent.ConfigureMovement
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// EMercunaAvoidanceMode                   NewAvoidanceMode                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMercunaGroundNavigationComponent::ConfigureMovement(EMercunaAvoidanceMode NewAvoidanceMode)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MercunaGroundNavigationComponent", "ConfigureMovement");

	Params::MercunaGroundNavigationComponent_ConfigureMovement Parms{};

	Parms.NewAvoidanceMode = NewAvoidanceMode;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Mercuna.MercunaGroundNavigationComponent.ConfigureSteering
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const struct FMercunaGroundNavigationSteeringParameters&NewSteering                                            (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)

void UMercunaGroundNavigationComponent::ConfigureSteering(const struct FMercunaGroundNavigationSteeringParameters& NewSteering)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MercunaGroundNavigationComponent", "ConfigureSteering");

	Params::MercunaGroundNavigationComponent_ConfigureSteering Parms{};

	Parms.NewSteering = std::move(NewSteering);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Mercuna.MercunaGroundNavigationComponent.GetLookDirection
// (Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector UMercunaGroundNavigationComponent::GetLookDirection()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MercunaGroundNavigationComponent", "GetLookDirection");

	Params::MercunaGroundNavigationComponent_GetLookDirection Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Mercuna.MercunaGroundNavigationComponent.GetPathInfo
// (Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// bool*                                   Valid                                                  (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float*                                  DistanceToEnd                                          (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMercunaGroundNavigationComponent::GetPathInfo(bool* Valid, float* DistanceToEnd)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MercunaGroundNavigationComponent", "GetPathInfo");

	Params::MercunaGroundNavigationComponent_GetPathInfo Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Valid != nullptr)
		*Valid = Parms.Valid;

	if (DistanceToEnd != nullptr)
		*DistanceToEnd = Parms.DistanceToEnd;
}


// Function Mercuna.MercunaGroundNavigationComponent.GetRemainingPathLength
// (Native, Public, BlueprintCallable)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UMercunaGroundNavigationComponent::GetRemainingPathLength()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MercunaGroundNavigationComponent", "GetRemainingPathLength");

	Params::MercunaGroundNavigationComponent_GetRemainingPathLength Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Mercuna.MercunaGroundNavigationComponent.InvalidateContextualSteeringParams
// (Native, Public, BlueprintCallable)

void UMercunaGroundNavigationComponent::InvalidateContextualSteeringParams()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MercunaGroundNavigationComponent", "InvalidateContextualSteeringParams");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Mercuna.MercunaGroundNavigationComponent.InvalidateContextualSteeringParamsAgainstActor
// (Native, Public, BlueprintCallable)
// Parameters:
// class AActor*                           Actor                                                  (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMercunaGroundNavigationComponent::InvalidateContextualSteeringParamsAgainstActor(class AActor* Actor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MercunaGroundNavigationComponent", "InvalidateContextualSteeringParamsAgainstActor");

	Params::MercunaGroundNavigationComponent_InvalidateContextualSteeringParamsAgainstActor Parms{};

	Parms.Actor = Actor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Mercuna.MercunaGroundNavigationComponent.MoveToActor
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class AActor*                           Actor                                                  (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   EndDistance                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Speed                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    UsePartialPath                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMercunaGroundNavigationComponent::MoveToActor(class AActor* Actor, float EndDistance, float Speed, bool UsePartialPath)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MercunaGroundNavigationComponent", "MoveToActor");

	Params::MercunaGroundNavigationComponent_MoveToActor Parms{};

	Parms.Actor = Actor;
	Parms.EndDistance = EndDistance;
	Parms.Speed = Speed;
	Parms.UsePartialPath = UsePartialPath;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Mercuna.MercunaGroundNavigationComponent.MoveToLocation
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// const struct FVector&                   Destination                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FVector&                   EndDirection                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   EndDistance                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Speed                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    UsePartialPath                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMercunaGroundNavigationComponent::MoveToLocation(const struct FVector& Destination, const struct FVector& EndDirection, float EndDistance, float Speed, bool UsePartialPath)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MercunaGroundNavigationComponent", "MoveToLocation");

	Params::MercunaGroundNavigationComponent_MoveToLocation Parms{};

	Parms.Destination = std::move(Destination);
	Parms.EndDirection = std::move(EndDirection);
	Parms.EndDistance = EndDistance;
	Parms.Speed = Speed;
	Parms.UsePartialPath = UsePartialPath;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Mercuna.MercunaGroundNavigationComponent.MoveToLocations
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// const TArray<struct FVector>&           Destinations                                           (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// const struct FVector&                   EndDirection                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   EndDistance                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Speed                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    UsePartialPath                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMercunaGroundNavigationComponent::MoveToLocations(const TArray<struct FVector>& Destinations, const struct FVector& EndDirection, float EndDistance, float Speed, bool UsePartialPath)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MercunaGroundNavigationComponent", "MoveToLocations");

	Params::MercunaGroundNavigationComponent_MoveToLocations Parms{};

	Parms.Destinations = std::move(Destinations);
	Parms.EndDirection = std::move(EndDirection);
	Parms.EndDistance = EndDistance;
	Parms.Speed = Speed;
	Parms.UsePartialPath = UsePartialPath;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Mercuna.MercunaGroundNavigationComponent.NavLinkComplete
// (Native, Public, BlueprintCallable)

void UMercunaGroundNavigationComponent::NavLinkComplete()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MercunaGroundNavigationComponent", "NavLinkComplete");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Mercuna.MercunaGroundNavigationComponent.OverrideSpeedMultiplier
// (Native, Public, BlueprintCallable)
// Parameters:
// const float                             NewSpeedMultiplier                                     (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UMercunaGroundNavigationComponent::OverrideSpeedMultiplier(const float NewSpeedMultiplier)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MercunaGroundNavigationComponent", "OverrideSpeedMultiplier");

	Params::MercunaGroundNavigationComponent_OverrideSpeedMultiplier Parms{};

	Parms.NewSpeedMultiplier = NewSpeedMultiplier;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Mercuna.MercunaGroundNavigationComponent.PauseNavigation
// (Native, Public, BlueprintCallable)

void UMercunaGroundNavigationComponent::PauseNavigation()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MercunaGroundNavigationComponent", "PauseNavigation");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Mercuna.MercunaGroundNavigationComponent.ResumeNavigation
// (Native, Public, BlueprintCallable)

void UMercunaGroundNavigationComponent::ResumeNavigation()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MercunaGroundNavigationComponent", "ResumeNavigation");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Mercuna.MercunaGroundNavigationComponent.SetAgentType
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// const struct FMercunaGroundAgentType&   NewAgentType                                           (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMercunaGroundNavigationComponent::SetAgentType(const struct FMercunaGroundAgentType& NewAgentType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MercunaGroundNavigationComponent", "SetAgentType");

	Params::MercunaGroundNavigationComponent_SetAgentType Parms{};

	Parms.NewAgentType = std::move(NewAgentType);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Mercuna.MercunaGroundNavigationComponent.SetAvoidanceAgainst
// (Native, Public, BlueprintCallable)
// Parameters:
// class AActor*                           Actor                                                  (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    Enable                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMercunaGroundNavigationComponent::SetAvoidanceAgainst(class AActor* Actor, bool Enable)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MercunaGroundNavigationComponent", "SetAvoidanceAgainst");

	Params::MercunaGroundNavigationComponent_SetAvoidanceAgainst Parms{};

	Parms.Actor = Actor;
	Parms.Enable = Enable;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Mercuna.MercunaGroundNavigationComponent.SetNavGrid
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class AMercunaNavGroundGrid*            NavGrid_0                                              (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMercunaGroundNavigationComponent::SetNavGrid(class AMercunaNavGroundGrid* NavGrid_0)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MercunaGroundNavigationComponent", "SetNavGrid");

	Params::MercunaGroundNavigationComponent_SetNavGrid Parms{};

	Parms.NavGrid_0 = NavGrid_0;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Mercuna.MercunaGroundNavigationComponent.SetNavGridToBest
// (Final, Native, Public, BlueprintCallable)

void UMercunaGroundNavigationComponent::SetNavGridToBest()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MercunaGroundNavigationComponent", "SetNavGridToBest");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Mercuna.MercunaGroundNavigationComponent.SetUsageSpec
// (Native, Public, BlueprintCallable)
// Parameters:
// const struct FMercunaUsageSpec&         NewUsageSpec                                           (Parm, NoDestructor, NativeAccessSpecifierPublic)

void UMercunaGroundNavigationComponent::SetUsageSpec(const struct FMercunaUsageSpec& NewUsageSpec)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MercunaGroundNavigationComponent", "SetUsageSpec");

	Params::MercunaGroundNavigationComponent_SetUsageSpec Parms{};

	Parms.NewUsageSpec = std::move(NewUsageSpec);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Mercuna.MercunaGroundNavigationComponent.Stop
// (Final, Native, Public, BlueprintCallable)

void UMercunaGroundNavigationComponent::Stop()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MercunaGroundNavigationComponent", "Stop");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Mercuna.MercunaGroundNavigationComponent.TrackActor
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// class AActor*                           Actor                                                  (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Distance                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Speed                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FVector&                   Offset                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    UsePartialPath                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMercunaGroundNavigationComponent::TrackActor(class AActor* Actor, float Distance, float Speed, const struct FVector& Offset, bool UsePartialPath)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MercunaGroundNavigationComponent", "TrackActor");

	Params::MercunaGroundNavigationComponent_TrackActor Parms{};

	Parms.Actor = Actor;
	Parms.Distance = Distance;
	Parms.Speed = Speed;
	Parms.Offset = std::move(Offset);
	Parms.UsePartialPath = UsePartialPath;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Mercuna.MercunaGroundNavigationComponent.UpdateDynamicSteeringParams
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const struct FMercunaGroundNavigationDynamicSteeringParameters&NewDynamicSteeringParams                               (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)

void UMercunaGroundNavigationComponent::UpdateDynamicSteeringParams(const struct FMercunaGroundNavigationDynamicSteeringParameters& NewDynamicSteeringParams)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MercunaGroundNavigationComponent", "UpdateDynamicSteeringParams");

	Params::MercunaGroundNavigationComponent_UpdateDynamicSteeringParams Parms{};

	Parms.NewDynamicSteeringParams = std::move(NewDynamicSteeringParams);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Mercuna.MercunaGroundNavigationComponent.GetConfiguration
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FMercunaGroundNavigationConfigurationReturnValue                                            (Parm, OutParm, ReturnParm, NoDestructor, NativeAccessSpecifierPublic)

struct FMercunaGroundNavigationConfiguration UMercunaGroundNavigationComponent::GetConfiguration() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MercunaGroundNavigationComponent", "GetConfiguration");

	Params::MercunaGroundNavigationComponent_GetConfiguration Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Mercuna.MercunaGroundNavigationComponent.GetDynamicSteeringParameters
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FMercunaGroundNavigationDynamicSteeringParametersReturnValue                                            (Parm, OutParm, ReturnParm, NoDestructor, NativeAccessSpecifierPublic)

struct FMercunaGroundNavigationDynamicSteeringParameters UMercunaGroundNavigationComponent::GetDynamicSteeringParameters() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MercunaGroundNavigationComponent", "GetDynamicSteeringParameters");

	Params::MercunaGroundNavigationComponent_GetDynamicSteeringParameters Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Mercuna.MercunaGroundNavigationComponent.GetLastInputVector
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector UMercunaGroundNavigationComponent::GetLastInputVector() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MercunaGroundNavigationComponent", "GetLastInputVector");

	Params::MercunaGroundNavigationComponent_GetLastInputVector Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Mercuna.MercunaGroundNavigationComponent.GetNavGrid
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class AMercunaNavGroundGrid*            ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AMercunaNavGroundGrid* UMercunaGroundNavigationComponent::GetNavGrid() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MercunaGroundNavigationComponent", "GetNavGrid");

	Params::MercunaGroundNavigationComponent_GetNavGrid Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Mercuna.MercunaGroundNavigationComponent.GetNextNavLink
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool*                                   bNextNavLinkFound                                      (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float*                                  DistanceToNextNavLink                                  (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float*                                  TimeToNextNavLink                                      (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector*                         TraversalStart                                         (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector*                         TraversalEnd                                           (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool*                                   bIsAutoGenerated                                       (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AMercunaNavLink**                 NavLink                                                (Parm, OutParm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FMercunaAutoNavLink*             AutoGeneratedNavLink                                   (Parm, OutParm, NoDestructor, NativeAccessSpecifierPublic)
// float                                   MaxLookAhead                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMercunaGroundNavigationComponent::GetNextNavLink(bool* bNextNavLinkFound, float* DistanceToNextNavLink, float* TimeToNextNavLink, struct FVector* TraversalStart, struct FVector* TraversalEnd, bool* bIsAutoGenerated, class AMercunaNavLink** NavLink, struct FMercunaAutoNavLink* AutoGeneratedNavLink, float MaxLookAhead) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MercunaGroundNavigationComponent", "GetNextNavLink");

	Params::MercunaGroundNavigationComponent_GetNextNavLink Parms{};

	Parms.MaxLookAhead = MaxLookAhead;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (bNextNavLinkFound != nullptr)
		*bNextNavLinkFound = Parms.bNextNavLinkFound;

	if (DistanceToNextNavLink != nullptr)
		*DistanceToNextNavLink = Parms.DistanceToNextNavLink;

	if (TimeToNextNavLink != nullptr)
		*TimeToNextNavLink = Parms.TimeToNextNavLink;

	if (TraversalStart != nullptr)
		*TraversalStart = std::move(Parms.TraversalStart);

	if (TraversalEnd != nullptr)
		*TraversalEnd = std::move(Parms.TraversalEnd);

	if (bIsAutoGenerated != nullptr)
		*bIsAutoGenerated = Parms.bIsAutoGenerated;

	if (NavLink != nullptr)
		*NavLink = Parms.NavLink;

	if (AutoGeneratedNavLink != nullptr)
		*AutoGeneratedNavLink = std::move(Parms.AutoGeneratedNavLink);
}


// Function Mercuna.MercunaGroundNavigationComponent.GetSteeringParameters
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FMercunaGroundNavigationSteeringParametersReturnValue                                            (Parm, OutParm, ReturnParm, NoDestructor, NativeAccessSpecifierPublic)

struct FMercunaGroundNavigationSteeringParameters UMercunaGroundNavigationComponent::GetSteeringParameters() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MercunaGroundNavigationComponent", "GetSteeringParameters");

	Params::MercunaGroundNavigationComponent_GetSteeringParameters Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Mercuna.MercunaGroundNavigationComponent.GetTrajectory
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FTrajectorySampleRange*          TrajectorySampleRange                                  (Parm, OutParm, NativeAccessSpecifierPublic)
// float                                   LookAhead                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   SampleRate                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnAbsoluteTimes                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EMerNavigationTrajectory                ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

EMerNavigationTrajectory UMercunaGroundNavigationComponent::GetTrajectory(struct FTrajectorySampleRange* TrajectorySampleRange, float LookAhead, int32 SampleRate, bool ReturnAbsoluteTimes) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MercunaGroundNavigationComponent", "GetTrajectory");

	Params::MercunaGroundNavigationComponent_GetTrajectory Parms{};

	Parms.LookAhead = LookAhead;
	Parms.SampleRate = SampleRate;
	Parms.ReturnAbsoluteTimes = ReturnAbsoluteTimes;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (TrajectorySampleRange != nullptr)
		*TrajectorySampleRange = std::move(Parms.TrajectorySampleRange);

	return Parms.ReturnValue;
}


// Function Mercuna.MercunaGroundNavigationComponent.GetUsageSpec
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const struct FMercunaUsageSpec          ReturnValue                                            (ConstParm, Parm, OutParm, ReturnParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)

const struct FMercunaUsageSpec UMercunaGroundNavigationComponent::GetUsageSpec() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MercunaGroundNavigationComponent", "GetUsageSpec");

	Params::MercunaGroundNavigationComponent_GetUsageSpec Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Mercuna.MercunaNavGraph.SaveToFile
// (Final, Native, Public, BlueprintCallable, Const)
// Parameters:
// const class FString&                    Filename                                               (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AMercunaNavGraph::SaveToFile(const class FString& Filename) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MercunaNavGraph", "SaveToFile");

	Params::MercunaNavGraph_SaveToFile Parms{};

	Parms.Filename = std::move(Filename);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Mercuna.MercunaNavGroundGrid.Build
// (Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const TArray<struct FVector>&           PriorityPositions                                      (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)

void AMercunaNavGroundGrid::Build(const TArray<struct FVector>& PriorityPositions)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MercunaNavGroundGrid", "Build");

	Params::MercunaNavGroundGrid_Build Parms{};

	Parms.PriorityPositions = std::move(PriorityPositions);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Mercuna.MercunaNavGroundGrid.Create
// (Final, Native, Public, BlueprintCallable)

void AMercunaNavGroundGrid::Create()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MercunaNavGroundGrid", "Create");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Mercuna.MercunaNavGroundGrid.DisableAutoGenNavLinksByIdentifier
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const TArray<struct FMercunaNavLinkIdentifier>&Identifiers                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)

void AMercunaNavGroundGrid::DisableAutoGenNavLinksByIdentifier(const TArray<struct FMercunaNavLinkIdentifier>& Identifiers)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MercunaNavGroundGrid", "DisableAutoGenNavLinksByIdentifier");

	Params::MercunaNavGroundGrid_DisableAutoGenNavLinksByIdentifier Parms{};

	Parms.Identifiers = std::move(Identifiers);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Mercuna.MercunaNavGroundGrid.DisableAutoGenNavLinksInVolume
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// const struct FMercunaGroundAgentType&   AgentType                                              (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FBox&                      Volume                                                 (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

void AMercunaNavGroundGrid::DisableAutoGenNavLinksInVolume(const struct FMercunaGroundAgentType& AgentType, const struct FBox& Volume)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MercunaNavGroundGrid", "DisableAutoGenNavLinksInVolume");

	Params::MercunaNavGroundGrid_DisableAutoGenNavLinksInVolume Parms{};

	Parms.AgentType = std::move(AgentType);
	Parms.Volume = std::move(Volume);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Mercuna.MercunaNavGroundGrid.EnableAutoGenNavLinksByIdentifier
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const TArray<struct FMercunaNavLinkIdentifier>&Identifiers                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)

void AMercunaNavGroundGrid::EnableAutoGenNavLinksByIdentifier(const TArray<struct FMercunaNavLinkIdentifier>& Identifiers)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MercunaNavGroundGrid", "EnableAutoGenNavLinksByIdentifier");

	Params::MercunaNavGroundGrid_EnableAutoGenNavLinksByIdentifier Parms{};

	Parms.Identifiers = std::move(Identifiers);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Mercuna.MercunaNavGroundGrid.EnableAutoGenNavLinksInVolume
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// const struct FMercunaGroundAgentType&   AgentType                                              (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FBox&                      Volume                                                 (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

void AMercunaNavGroundGrid::EnableAutoGenNavLinksInVolume(const struct FMercunaGroundAgentType& AgentType, const struct FBox& Volume)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MercunaNavGroundGrid", "EnableAutoGenNavLinksInVolume");

	Params::MercunaNavGroundGrid_EnableAutoGenNavLinksInVolume Parms{};

	Parms.AgentType = std::move(AgentType);
	Parms.Volume = std::move(Volume);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Mercuna.MercunaNavGroundGrid.FindPathToLocation
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// const struct FMercunaGroundAgentType&   AgentType                                              (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const TDelegate<void(EMercunaPathEvent PathEvent)>&OnPathUpdated                                          (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FVector&                   Start                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FVector&                   StartDir                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FVector&                   End                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   MinTurnRadius                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   IdealTurnRadius                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   MaxSpeed                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    AllowPartial                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   MaxPathLength                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   SlopePenalty                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FMercunaUsageSpec&         UsageSpec                                              (ConstParm, Parm, NoDestructor, NativeAccessSpecifierPublic)
// class UMercunaPath*                     ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UMercunaPath* AMercunaNavGroundGrid::FindPathToLocation(const struct FMercunaGroundAgentType& AgentType, const TDelegate<void(EMercunaPathEvent PathEvent)>& OnPathUpdated, const struct FVector& Start, const struct FVector& StartDir, const struct FVector& End, float MinTurnRadius, float IdealTurnRadius, float MaxSpeed, bool AllowPartial, float MaxPathLength, float SlopePenalty, const struct FMercunaUsageSpec& UsageSpec)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MercunaNavGroundGrid", "FindPathToLocation");

	Params::MercunaNavGroundGrid_FindPathToLocation Parms{};

	Parms.AgentType = std::move(AgentType);
	Parms.OnPathUpdated = OnPathUpdated;
	Parms.Start = std::move(Start);
	Parms.StartDir = std::move(StartDir);
	Parms.End = std::move(End);
	Parms.MinTurnRadius = MinTurnRadius;
	Parms.IdealTurnRadius = IdealTurnRadius;
	Parms.MaxSpeed = MaxSpeed;
	Parms.AllowPartial = AllowPartial;
	Parms.MaxPathLength = MaxPathLength;
	Parms.SlopePenalty = SlopePenalty;
	Parms.UsageSpec = std::move(UsageSpec);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Mercuna.MercunaNavGroundGrid.FindPathToLocations
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// const struct FMercunaGroundAgentType&   AgentType                                              (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const TDelegate<void(EMercunaPathEvent PathEvent)>&OnPathUpdated                                          (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FVector&                   Start                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FVector&                   StartDir                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const TArray<struct FVector>&           Destinations                                           (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// float                                   MinTurnRadius                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   IdealTurnRadius                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   MaxSpeed                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    AllowPartial                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   MaxPathLength                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   SlopePenalty                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FMercunaUsageSpec&         UsageSpec                                              (ConstParm, Parm, NoDestructor, NativeAccessSpecifierPublic)
// class UMercunaPath*                     ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UMercunaPath* AMercunaNavGroundGrid::FindPathToLocations(const struct FMercunaGroundAgentType& AgentType, const TDelegate<void(EMercunaPathEvent PathEvent)>& OnPathUpdated, const struct FVector& Start, const struct FVector& StartDir, const TArray<struct FVector>& Destinations, float MinTurnRadius, float IdealTurnRadius, float MaxSpeed, bool AllowPartial, float MaxPathLength, float SlopePenalty, const struct FMercunaUsageSpec& UsageSpec)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MercunaNavGroundGrid", "FindPathToLocations");

	Params::MercunaNavGroundGrid_FindPathToLocations Parms{};

	Parms.AgentType = std::move(AgentType);
	Parms.OnPathUpdated = OnPathUpdated;
	Parms.Start = std::move(Start);
	Parms.StartDir = std::move(StartDir);
	Parms.Destinations = std::move(Destinations);
	Parms.MinTurnRadius = MinTurnRadius;
	Parms.IdealTurnRadius = IdealTurnRadius;
	Parms.MaxSpeed = MaxSpeed;
	Parms.AllowPartial = AllowPartial;
	Parms.MaxPathLength = MaxPathLength;
	Parms.SlopePenalty = SlopePenalty;
	Parms.UsageSpec = std::move(UsageSpec);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Mercuna.MercunaNavGroundGrid.FindSmoothPathToLocation
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// const struct FMercunaGroundAgentType&   AgentType                                              (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const TDelegate<void(EMercunaPathEvent PathEvent)>&OnPathUpdated                                          (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FVector&                   Start                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FVector&                   StartDir                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FVector&                   End                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   MinTurnRadius                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   IdealTurnRadius                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   MaxSpeed                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   MaxSpeedReverse                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    AllowPartial                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   MaxPathLength                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   SlopePenalty                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FMercunaUsageSpec&         UsageSpec                                              (ConstParm, Parm, NoDestructor, NativeAccessSpecifierPublic)
// class UMercunaSmoothPath*               ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UMercunaSmoothPath* AMercunaNavGroundGrid::FindSmoothPathToLocation(const struct FMercunaGroundAgentType& AgentType, const TDelegate<void(EMercunaPathEvent PathEvent)>& OnPathUpdated, const struct FVector& Start, const struct FVector& StartDir, const struct FVector& End, float MinTurnRadius, float IdealTurnRadius, float MaxSpeed, float MaxSpeedReverse, bool AllowPartial, float MaxPathLength, float SlopePenalty, const struct FMercunaUsageSpec& UsageSpec)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MercunaNavGroundGrid", "FindSmoothPathToLocation");

	Params::MercunaNavGroundGrid_FindSmoothPathToLocation Parms{};

	Parms.AgentType = std::move(AgentType);
	Parms.OnPathUpdated = OnPathUpdated;
	Parms.Start = std::move(Start);
	Parms.StartDir = std::move(StartDir);
	Parms.End = std::move(End);
	Parms.MinTurnRadius = MinTurnRadius;
	Parms.IdealTurnRadius = IdealTurnRadius;
	Parms.MaxSpeed = MaxSpeed;
	Parms.MaxSpeedReverse = MaxSpeedReverse;
	Parms.AllowPartial = AllowPartial;
	Parms.MaxPathLength = MaxPathLength;
	Parms.SlopePenalty = SlopePenalty;
	Parms.UsageSpec = std::move(UsageSpec);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Mercuna.MercunaNavGroundGrid.FindSmoothPathToLocations
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// const struct FMercunaGroundAgentType&   AgentType                                              (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const TDelegate<void(EMercunaPathEvent PathEvent)>&OnPathUpdated                                          (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FVector&                   Start                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FVector&                   StartDir                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const TArray<struct FVector>&           Destinations                                           (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// float                                   MinTurnRadius                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   IdealTurnRadius                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   MaxSpeed                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   MaxSpeedReverse                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    AllowPartial                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   MaxPathLength                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   SlopePenalty                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FMercunaUsageSpec&         UsageSpec                                              (ConstParm, Parm, NoDestructor, NativeAccessSpecifierPublic)
// class UMercunaSmoothPath*               ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UMercunaSmoothPath* AMercunaNavGroundGrid::FindSmoothPathToLocations(const struct FMercunaGroundAgentType& AgentType, const TDelegate<void(EMercunaPathEvent PathEvent)>& OnPathUpdated, const struct FVector& Start, const struct FVector& StartDir, const TArray<struct FVector>& Destinations, float MinTurnRadius, float IdealTurnRadius, float MaxSpeed, float MaxSpeedReverse, bool AllowPartial, float MaxPathLength, float SlopePenalty, const struct FMercunaUsageSpec& UsageSpec)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MercunaNavGroundGrid", "FindSmoothPathToLocations");

	Params::MercunaNavGroundGrid_FindSmoothPathToLocations Parms{};

	Parms.AgentType = std::move(AgentType);
	Parms.OnPathUpdated = OnPathUpdated;
	Parms.Start = std::move(Start);
	Parms.StartDir = std::move(StartDir);
	Parms.Destinations = std::move(Destinations);
	Parms.MinTurnRadius = MinTurnRadius;
	Parms.IdealTurnRadius = IdealTurnRadius;
	Parms.MaxSpeed = MaxSpeed;
	Parms.MaxSpeedReverse = MaxSpeedReverse;
	Parms.AllowPartial = AllowPartial;
	Parms.MaxPathLength = MaxPathLength;
	Parms.SlopePenalty = SlopePenalty;
	Parms.UsageSpec = std::move(UsageSpec);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Mercuna.MercunaNavGroundGrid.GenerateRandomPointsInBox
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// const struct FMercunaGroundAgentType&   AgentType                                              (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FBox&                      Volume                                                 (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// int32                                   NumPoints                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<struct FVector>*                 Results                                                (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
// const struct FRotator&                  Rotator                                                (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// const struct FMercunaUsageSpec&         UsageSpec                                              (ConstParm, Parm, NoDestructor, AdvancedDisplay, NativeAccessSpecifierPublic)
// bool                                    bIgnoreStationaryObstacles                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AMercunaNavGroundGrid::GenerateRandomPointsInBox(const struct FMercunaGroundAgentType& AgentType, const struct FBox& Volume, int32 NumPoints, TArray<struct FVector>* Results, const struct FRotator& Rotator, const struct FMercunaUsageSpec& UsageSpec, bool bIgnoreStationaryObstacles)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MercunaNavGroundGrid", "GenerateRandomPointsInBox");

	Params::MercunaNavGroundGrid_GenerateRandomPointsInBox Parms{};

	Parms.AgentType = std::move(AgentType);
	Parms.Volume = std::move(Volume);
	Parms.NumPoints = NumPoints;
	Parms.Rotator = std::move(Rotator);
	Parms.UsageSpec = std::move(UsageSpec);
	Parms.bIgnoreStationaryObstacles = bIgnoreStationaryObstacles;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Results != nullptr)
		*Results = std::move(Parms.Results);
}


// Function Mercuna.MercunaNavGroundGrid.RebuildChanges
// (Native, Public, BlueprintCallable)

void AMercunaNavGroundGrid::RebuildChanges()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MercunaNavGroundGrid", "RebuildChanges");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Mercuna.MercunaNavGroundGrid.RebuildVolume
// (Native, Public, BlueprintCallable)
// Parameters:
// const class AActor*                     Volume                                                 (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bApplyNavSeeds                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AMercunaNavGroundGrid::RebuildVolume(const class AActor* Volume, bool bApplyNavSeeds)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MercunaNavGroundGrid", "RebuildVolume");

	Params::MercunaNavGroundGrid_RebuildVolume Parms{};

	Parms.Volume = Volume;
	Parms.bApplyNavSeeds = bApplyNavSeeds;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Mercuna.MercunaNavGroundGrid.RebuildVolumes
// (Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const TArray<struct FBox>&              Volumes                                                (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// bool                                    bMergeVolumes                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bOnlyUnbuilt                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bApplyNavSeeds                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AMercunaNavGroundGrid::RebuildVolumes(const TArray<struct FBox>& Volumes, bool bMergeVolumes, bool bOnlyUnbuilt, bool bApplyNavSeeds)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MercunaNavGroundGrid", "RebuildVolumes");

	Params::MercunaNavGroundGrid_RebuildVolumes Parms{};

	Parms.Volumes = std::move(Volumes);
	Parms.bMergeVolumes = bMergeVolumes;
	Parms.bOnlyUnbuilt = bOnlyUnbuilt;
	Parms.bApplyNavSeeds = bApplyNavSeeds;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Mercuna.MercunaNavGroundGrid.RegisterNavInvoker
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class AActor*                           Actor                                                  (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             AgentType                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   GenerationRadius                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   RemovalRadius                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AMercunaNavGroundGrid::RegisterNavInvoker(class AActor* Actor, class FName AgentType, float GenerationRadius, float RemovalRadius)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MercunaNavGroundGrid", "RegisterNavInvoker");

	Params::MercunaNavGroundGrid_RegisterNavInvoker Parms{};

	Parms.Actor = Actor;
	Parms.AgentType = AgentType;
	Parms.GenerationRadius = GenerationRadius;
	Parms.RemovalRadius = RemovalRadius;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Mercuna.MercunaNavGroundGrid.UnregisterNavInvoker
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class AActor*                           Actor                                                  (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AMercunaNavGroundGrid::UnregisterNavInvoker(class AActor* Actor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MercunaNavGroundGrid", "UnregisterNavInvoker");

	Params::MercunaNavGroundGrid_UnregisterNavInvoker Parms{};

	Parms.Actor = Actor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Mercuna.MercunaNavGroundGrid.UpdateAutoGenNavLinks
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const TArray<struct FMercunaAutoNavLinkForUpdate>&LinksToUpdate                                          (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)

void AMercunaNavGroundGrid::UpdateAutoGenNavLinks(const TArray<struct FMercunaAutoNavLinkForUpdate>& LinksToUpdate)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MercunaNavGroundGrid", "UpdateAutoGenNavLinks");

	Params::MercunaNavGroundGrid_UpdateAutoGenNavLinks Parms{};

	Parms.LinksToUpdate = std::move(LinksToUpdate);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Mercuna.MercunaNavGroundGrid.ClampToNavigable
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable, Const)
// Parameters:
// const struct FMercunaGroundAgentType&   AgentType                                              (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FVector&                   Position                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   SearchRadius                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   HeightRange                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool*                                   bResult                                                (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector*                         ClampedPosition                                        (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FMercunaUsageTypes*              ClampedUsageTypes                                      (Parm, OutParm, NoDestructor, NativeAccessSpecifierPublic)
// const struct FMercunaUsageSpec&         UsageSpec                                              (ConstParm, Parm, NoDestructor, AdvancedDisplay, NativeAccessSpecifierPublic)
// bool                                    bIgnoreStationaryObstacles                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AMercunaNavGroundGrid::ClampToNavigable(const struct FMercunaGroundAgentType& AgentType, const struct FVector& Position, float SearchRadius, float HeightRange, bool* bResult, struct FVector* ClampedPosition, struct FMercunaUsageTypes* ClampedUsageTypes, const struct FMercunaUsageSpec& UsageSpec, bool bIgnoreStationaryObstacles) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MercunaNavGroundGrid", "ClampToNavigable");

	Params::MercunaNavGroundGrid_ClampToNavigable Parms{};

	Parms.AgentType = std::move(AgentType);
	Parms.Position = std::move(Position);
	Parms.SearchRadius = SearchRadius;
	Parms.HeightRange = HeightRange;
	Parms.UsageSpec = std::move(UsageSpec);
	Parms.bIgnoreStationaryObstacles = bIgnoreStationaryObstacles;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (bResult != nullptr)
		*bResult = Parms.bResult;

	if (ClampedPosition != nullptr)
		*ClampedPosition = std::move(Parms.ClampedPosition);

	if (ClampedUsageTypes != nullptr)
		*ClampedUsageTypes = std::move(Parms.ClampedUsageTypes);
}


// Function Mercuna.MercunaNavGroundGrid.GenerateRandomPoints
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable, Const)
// Parameters:
// const struct FMercunaGroundAgentType&   AgentType                                              (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FVector&                   Position                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   MaxDistance                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   NumPoints                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<struct FVector>*                 Results                                                (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
// bool                                    MaxDistanceIsPathDistance                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EMercunaNavLinkQueryMode                FollowNavLinks                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FMercunaUsageSpec&         UsageSpec                                              (ConstParm, Parm, NoDestructor, AdvancedDisplay, NativeAccessSpecifierPublic)
// bool                                    bIgnoreStationaryObstacles                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AMercunaNavGroundGrid::GenerateRandomPoints(const struct FMercunaGroundAgentType& AgentType, const struct FVector& Position, float MaxDistance, int32 NumPoints, TArray<struct FVector>* Results, bool MaxDistanceIsPathDistance, EMercunaNavLinkQueryMode FollowNavLinks, const struct FMercunaUsageSpec& UsageSpec, bool bIgnoreStationaryObstacles) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MercunaNavGroundGrid", "GenerateRandomPoints");

	Params::MercunaNavGroundGrid_GenerateRandomPoints Parms{};

	Parms.AgentType = std::move(AgentType);
	Parms.Position = std::move(Position);
	Parms.MaxDistance = MaxDistance;
	Parms.NumPoints = NumPoints;
	Parms.MaxDistanceIsPathDistance = MaxDistanceIsPathDistance;
	Parms.FollowNavLinks = FollowNavLinks;
	Parms.UsageSpec = std::move(UsageSpec);
	Parms.bIgnoreStationaryObstacles = bIgnoreStationaryObstacles;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Results != nullptr)
		*Results = std::move(Parms.Results);
}


// Function Mercuna.MercunaNavGroundGrid.GetAutoGenNavLinksInVolume
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable, Const)
// Parameters:
// const struct FMercunaGroundAgentType&   AgentType                                              (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FBox&                      Volume                                                 (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// TArray<struct FMercunaAutoNavLink>*     Results                                                (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)

void AMercunaNavGroundGrid::GetAutoGenNavLinksInVolume(const struct FMercunaGroundAgentType& AgentType, const struct FBox& Volume, TArray<struct FMercunaAutoNavLink>* Results) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MercunaNavGroundGrid", "GetAutoGenNavLinksInVolume");

	Params::MercunaNavGroundGrid_GetAutoGenNavLinksInVolume Parms{};

	Parms.AgentType = std::move(AgentType);
	Parms.Volume = std::move(Volume);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Results != nullptr)
		*Results = std::move(Parms.Results);
}


// Function Mercuna.MercunaNavGroundGrid.GetClosestNavMeshEdge
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable, Const)
// Parameters:
// const struct FMercunaGroundAgentType&   AgentType                                              (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FVector&                   Position                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool*                                   bResult                                                (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FMercunaNavMeshEdge*             ClosestEdge                                            (Parm, OutParm, NoDestructor, NativeAccessSpecifierPublic)
// struct FVector*                         ClosestPoint                                           (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const float                             MaxDistance                                            (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    MaxDistanceIsPathDistance                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EMercunaNavLinkQueryMode                FollowNavLinks                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FMercunaUsageSpec&         UsageSpec                                              (ConstParm, Parm, NoDestructor, AdvancedDisplay, NativeAccessSpecifierPublic)
// bool                                    bIgnoreStationaryObstacles                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AMercunaNavGroundGrid::GetClosestNavMeshEdge(const struct FMercunaGroundAgentType& AgentType, const struct FVector& Position, bool* bResult, struct FMercunaNavMeshEdge* ClosestEdge, struct FVector* ClosestPoint, const float MaxDistance, bool MaxDistanceIsPathDistance, EMercunaNavLinkQueryMode FollowNavLinks, const struct FMercunaUsageSpec& UsageSpec, bool bIgnoreStationaryObstacles) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MercunaNavGroundGrid", "GetClosestNavMeshEdge");

	Params::MercunaNavGroundGrid_GetClosestNavMeshEdge Parms{};

	Parms.AgentType = std::move(AgentType);
	Parms.Position = std::move(Position);
	Parms.MaxDistance = MaxDistance;
	Parms.MaxDistanceIsPathDistance = MaxDistanceIsPathDistance;
	Parms.FollowNavLinks = FollowNavLinks;
	Parms.UsageSpec = std::move(UsageSpec);
	Parms.bIgnoreStationaryObstacles = bIgnoreStationaryObstacles;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (bResult != nullptr)
		*bResult = Parms.bResult;

	if (ClosestEdge != nullptr)
		*ClosestEdge = std::move(Parms.ClosestEdge);

	if (ClosestPoint != nullptr)
		*ClosestPoint = std::move(Parms.ClosestPoint);
}


// Function Mercuna.MercunaNavGroundGrid.GetClosestPosInWater
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable, Const)
// Parameters:
// const struct FMercunaGroundAgentType&   AgentType                                              (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FVector&                   Position                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool*                                   bResult                                                (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector*                         ClosestPosition                                        (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   MaxPathDistance                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EMercunaNavLinkQueryMode                FollowNavLinks                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FMercunaUsageSpec&         UsageSpec                                              (Parm, NoDestructor, AdvancedDisplay, NativeAccessSpecifierPublic)
// bool                                    bIgnoreStationaryObstacles                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AMercunaNavGroundGrid::GetClosestPosInWater(const struct FMercunaGroundAgentType& AgentType, const struct FVector& Position, bool* bResult, struct FVector* ClosestPosition, float MaxPathDistance, EMercunaNavLinkQueryMode FollowNavLinks, const struct FMercunaUsageSpec& UsageSpec, bool bIgnoreStationaryObstacles) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MercunaNavGroundGrid", "GetClosestPosInWater");

	Params::MercunaNavGroundGrid_GetClosestPosInWater Parms{};

	Parms.AgentType = std::move(AgentType);
	Parms.Position = std::move(Position);
	Parms.MaxPathDistance = MaxPathDistance;
	Parms.FollowNavLinks = FollowNavLinks;
	Parms.UsageSpec = std::move(UsageSpec);
	Parms.bIgnoreStationaryObstacles = bIgnoreStationaryObstacles;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (bResult != nullptr)
		*bResult = Parms.bResult;

	if (ClosestPosition != nullptr)
		*ClosestPosition = std::move(Parms.ClosestPosition);
}


// Function Mercuna.MercunaNavGroundGrid.GetClosestPosOutOfWater
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable, Const)
// Parameters:
// const struct FMercunaGroundAgentType&   AgentType                                              (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FVector&                   Position                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool*                                   bResult                                                (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector*                         ClosestPosition                                        (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   MaxPathDistance                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EMercunaNavLinkQueryMode                FollowNavLinks                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FMercunaUsageSpec&         UsageSpec                                              (Parm, NoDestructor, AdvancedDisplay, NativeAccessSpecifierPublic)
// bool                                    bIgnoreStationaryObstacles                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AMercunaNavGroundGrid::GetClosestPosOutOfWater(const struct FMercunaGroundAgentType& AgentType, const struct FVector& Position, bool* bResult, struct FVector* ClosestPosition, float MaxPathDistance, EMercunaNavLinkQueryMode FollowNavLinks, const struct FMercunaUsageSpec& UsageSpec, bool bIgnoreStationaryObstacles) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MercunaNavGroundGrid", "GetClosestPosOutOfWater");

	Params::MercunaNavGroundGrid_GetClosestPosOutOfWater Parms{};

	Parms.AgentType = std::move(AgentType);
	Parms.Position = std::move(Position);
	Parms.MaxPathDistance = MaxPathDistance;
	Parms.FollowNavLinks = FollowNavLinks;
	Parms.UsageSpec = std::move(UsageSpec);
	Parms.bIgnoreStationaryObstacles = bIgnoreStationaryObstacles;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (bResult != nullptr)
		*bResult = Parms.bResult;

	if (ClosestPosition != nullptr)
		*ClosestPosition = std::move(Parms.ClosestPosition);
}


// Function Mercuna.MercunaNavGroundGrid.GetNavMeshEdges
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable, Const)
// Parameters:
// const struct FMercunaGroundAgentType&   AgentType                                              (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FVector&                   Position                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const float                             MaxRadius                                              (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<struct FMercunaNavMeshEdge>*     NavMeshEdges                                           (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
// EMercunaNavLinkQueryMode                FollowNavLinks                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FMercunaUsageSpec&         UsageSpec                                              (ConstParm, Parm, NoDestructor, AdvancedDisplay, NativeAccessSpecifierPublic)
// bool                                    bIgnoreStationaryObstacles                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AMercunaNavGroundGrid::GetNavMeshEdges(const struct FMercunaGroundAgentType& AgentType, const struct FVector& Position, const float MaxRadius, TArray<struct FMercunaNavMeshEdge>* NavMeshEdges, EMercunaNavLinkQueryMode FollowNavLinks, const struct FMercunaUsageSpec& UsageSpec, bool bIgnoreStationaryObstacles) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MercunaNavGroundGrid", "GetNavMeshEdges");

	Params::MercunaNavGroundGrid_GetNavMeshEdges Parms{};

	Parms.AgentType = std::move(AgentType);
	Parms.Position = std::move(Position);
	Parms.MaxRadius = MaxRadius;
	Parms.FollowNavLinks = FollowNavLinks;
	Parms.UsageSpec = std::move(UsageSpec);
	Parms.bIgnoreStationaryObstacles = bIgnoreStationaryObstacles;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (NavMeshEdges != nullptr)
		*NavMeshEdges = std::move(Parms.NavMeshEdges);
}


// Function Mercuna.MercunaNavGroundGrid.GetNumBoxesBuilding
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 AMercunaNavGroundGrid::GetNumBoxesBuilding() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MercunaNavGroundGrid", "GetNumBoxesBuilding");

	Params::MercunaNavGroundGrid_GetNumBoxesBuilding Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Mercuna.MercunaNavGroundGrid.GetWaterEdges
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable, Const)
// Parameters:
// const struct FMercunaGroundAgentType&   AgentType                                              (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FVector&                   Position                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   MaxPathDistance                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<struct FMercunaNavEdge>*         Edges                                                  (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
// EMercunaNavLinkQueryMode                FollowNavLinks                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FMercunaUsageSpec&         UsageSpec                                              (Parm, NoDestructor, AdvancedDisplay, NativeAccessSpecifierPublic)
// bool                                    bIgnoreStationaryObstacles                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AMercunaNavGroundGrid::GetWaterEdges(const struct FMercunaGroundAgentType& AgentType, const struct FVector& Position, float MaxPathDistance, TArray<struct FMercunaNavEdge>* Edges, EMercunaNavLinkQueryMode FollowNavLinks, const struct FMercunaUsageSpec& UsageSpec, bool bIgnoreStationaryObstacles) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MercunaNavGroundGrid", "GetWaterEdges");

	Params::MercunaNavGroundGrid_GetWaterEdges Parms{};

	Parms.AgentType = std::move(AgentType);
	Parms.Position = std::move(Position);
	Parms.MaxPathDistance = MaxPathDistance;
	Parms.FollowNavLinks = FollowNavLinks;
	Parms.UsageSpec = std::move(UsageSpec);
	Parms.bIgnoreStationaryObstacles = bIgnoreStationaryObstacles;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Edges != nullptr)
		*Edges = std::move(Parms.Edges);
}


// Function Mercuna.MercunaNavGroundGrid.IsAnyWorkInProgress
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AMercunaNavGroundGrid::IsAnyWorkInProgress() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MercunaNavGroundGrid", "IsAnyWorkInProgress");

	Params::MercunaNavGroundGrid_IsAnyWorkInProgress Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Mercuna.MercunaNavGroundGrid.IsBuilding
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AMercunaNavGroundGrid::IsBuilding() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MercunaNavGroundGrid", "IsBuilding");

	Params::MercunaNavGroundGrid_IsBuilding Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Mercuna.MercunaNavGroundGrid.IsBuilt
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const struct FMercunaGroundAgentType&   AgentType                                              (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FVector&                   Pos                                                    (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AMercunaNavGroundGrid::IsBuilt(const struct FMercunaGroundAgentType& AgentType, const struct FVector& Pos) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MercunaNavGroundGrid", "IsBuilt");

	Params::MercunaNavGroundGrid_IsBuilt Parms{};

	Parms.AgentType = std::move(AgentType);
	Parms.Pos = std::move(Pos);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Mercuna.MercunaNavGroundGrid.IsBuiltWithinBox
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const struct FMercunaGroundAgentType&   AgentType                                              (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FBox&                      Box                                                    (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AMercunaNavGroundGrid::IsBuiltWithinBox(const struct FMercunaGroundAgentType& AgentType, const struct FBox& Box) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MercunaNavGroundGrid", "IsBuiltWithinBox");

	Params::MercunaNavGroundGrid_IsBuiltWithinBox Parms{};

	Parms.AgentType = std::move(AgentType);
	Parms.Box = std::move(Box);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Mercuna.MercunaNavGroundGrid.IsNavigable
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable, Const)
// Parameters:
// const struct FMercunaGroundAgentType&   AgentType                                              (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FVector&                   Position                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool*                                   bResult                                                (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FMercunaUsageSpec&         UsageSpec                                              (ConstParm, Parm, NoDestructor, AdvancedDisplay, NativeAccessSpecifierPublic)
// bool                                    bIgnoreStationaryObstacles                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AMercunaNavGroundGrid::IsNavigable(const struct FMercunaGroundAgentType& AgentType, const struct FVector& Position, bool* bResult, const struct FMercunaUsageSpec& UsageSpec, bool bIgnoreStationaryObstacles) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MercunaNavGroundGrid", "IsNavigable");

	Params::MercunaNavGroundGrid_IsNavigable Parms{};

	Parms.AgentType = std::move(AgentType);
	Parms.Position = std::move(Position);
	Parms.UsageSpec = std::move(UsageSpec);
	Parms.bIgnoreStationaryObstacles = bIgnoreStationaryObstacles;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (bResult != nullptr)
		*bResult = Parms.bResult;
}


// Function Mercuna.MercunaNavGroundGrid.IsNavigableMulti
// (Final, Native, Public, HasOutParams, BlueprintCallable, Const)
// Parameters:
// const struct FMercunaGroundAgentType&   AgentType                                              (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const TArray<struct FVector>&           Positions                                              (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// TArray<bool>*                           Results                                                (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
// const struct FMercunaUsageSpec&         UsageSpec                                              (ConstParm, Parm, NoDestructor, AdvancedDisplay, NativeAccessSpecifierPublic)
// bool                                    bIgnoreStationaryObstacles                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AMercunaNavGroundGrid::IsNavigableMulti(const struct FMercunaGroundAgentType& AgentType, const TArray<struct FVector>& Positions, TArray<bool>* Results, const struct FMercunaUsageSpec& UsageSpec, bool bIgnoreStationaryObstacles) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MercunaNavGroundGrid", "IsNavigableMulti");

	Params::MercunaNavGroundGrid_IsNavigableMulti Parms{};

	Parms.AgentType = std::move(AgentType);
	Parms.Positions = std::move(Positions);
	Parms.UsageSpec = std::move(UsageSpec);
	Parms.bIgnoreStationaryObstacles = bIgnoreStationaryObstacles;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Results != nullptr)
		*Results = std::move(Parms.Results);
}


// Function Mercuna.MercunaNavGroundGrid.IsReachable
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable, Const)
// Parameters:
// const struct FMercunaGroundAgentType&   AgentType                                              (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FVector&                   From                                                   (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FVector&                   To                                                     (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   MaxPathLength                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EMercunaNavLinkQueryMode                FollowNavLinks                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FMercunaUsageSpec&         UsageSpec                                              (ConstParm, Parm, NoDestructor, AdvancedDisplay, NativeAccessSpecifierPublic)
// bool                                    bIgnoreStationaryObstacles                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AMercunaNavGroundGrid::IsReachable(const struct FMercunaGroundAgentType& AgentType, const struct FVector& From, const struct FVector& To, float MaxPathLength, EMercunaNavLinkQueryMode FollowNavLinks, const struct FMercunaUsageSpec& UsageSpec, bool bIgnoreStationaryObstacles) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MercunaNavGroundGrid", "IsReachable");

	Params::MercunaNavGroundGrid_IsReachable Parms{};

	Parms.AgentType = std::move(AgentType);
	Parms.From = std::move(From);
	Parms.To = std::move(To);
	Parms.MaxPathLength = MaxPathLength;
	Parms.FollowNavLinks = FollowNavLinks;
	Parms.UsageSpec = std::move(UsageSpec);
	Parms.bIgnoreStationaryObstacles = bIgnoreStationaryObstacles;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Mercuna.MercunaNavGroundGrid.IsReachableLatent
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable, Const)
// Parameters:
// const struct FMercunaGroundAgentType&   AgentType                                              (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FVector&                   From                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const TArray<struct FVector>&           To                                                     (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// TArray<bool>*                           Result                                                 (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
// TArray<struct FVector>*                 ClampedTo                                              (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FLatentActionInfo&         LatentInfo                                             (Parm, NoDestructor, NativeAccessSpecifierPublic)
// float                                   MaxPathLength                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   FromSearchRadius                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ToSearchRadius                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EMercunaNavLinkQueryMode                FollowNavLinks                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FMercunaUsageSpec&         UsageSpec                                              (ConstParm, Parm, NoDestructor, AdvancedDisplay, NativeAccessSpecifierPublic)
// bool                                    bIgnoreStationaryObstacles                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AMercunaNavGroundGrid::IsReachableLatent(const struct FMercunaGroundAgentType& AgentType, const struct FVector& From, const TArray<struct FVector>& To, TArray<bool>* Result, TArray<struct FVector>* ClampedTo, class UObject* WorldContextObject, const struct FLatentActionInfo& LatentInfo, float MaxPathLength, float FromSearchRadius, float ToSearchRadius, EMercunaNavLinkQueryMode FollowNavLinks, const struct FMercunaUsageSpec& UsageSpec, bool bIgnoreStationaryObstacles) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MercunaNavGroundGrid", "IsReachableLatent");

	Params::MercunaNavGroundGrid_IsReachableLatent Parms{};

	Parms.AgentType = std::move(AgentType);
	Parms.From = std::move(From);
	Parms.To = std::move(To);
	Parms.WorldContextObject = WorldContextObject;
	Parms.LatentInfo = std::move(LatentInfo);
	Parms.MaxPathLength = MaxPathLength;
	Parms.FromSearchRadius = FromSearchRadius;
	Parms.ToSearchRadius = ToSearchRadius;
	Parms.FollowNavLinks = FollowNavLinks;
	Parms.UsageSpec = std::move(UsageSpec);
	Parms.bIgnoreStationaryObstacles = bIgnoreStationaryObstacles;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Result != nullptr)
		*Result = std::move(Parms.Result);

	if (ClampedTo != nullptr)
		*ClampedTo = std::move(Parms.ClampedTo);
}


// Function Mercuna.MercunaNavGroundGrid.ProjectToNavigable
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable, Const)
// Parameters:
// const struct FMercunaGroundAgentType&   AgentType                                              (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FVector&                   Position                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EMercunaProjectionDirection             Direction                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool*                                   bResult                                                (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector*                         ProjectedPosition                                      (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   SearchHeight                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FMercunaUsageSpec&         UsageSpec                                              (ConstParm, Parm, NoDestructor, AdvancedDisplay, NativeAccessSpecifierPublic)
// bool                                    bIgnoreStationaryObstacles                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AMercunaNavGroundGrid::ProjectToNavigable(const struct FMercunaGroundAgentType& AgentType, const struct FVector& Position, EMercunaProjectionDirection Direction, bool* bResult, struct FVector* ProjectedPosition, float SearchHeight, const struct FMercunaUsageSpec& UsageSpec, bool bIgnoreStationaryObstacles) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MercunaNavGroundGrid", "ProjectToNavigable");

	Params::MercunaNavGroundGrid_ProjectToNavigable Parms{};

	Parms.AgentType = std::move(AgentType);
	Parms.Position = std::move(Position);
	Parms.Direction = Direction;
	Parms.SearchHeight = SearchHeight;
	Parms.UsageSpec = std::move(UsageSpec);
	Parms.bIgnoreStationaryObstacles = bIgnoreStationaryObstacles;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (bResult != nullptr)
		*bResult = Parms.bResult;

	if (ProjectedPosition != nullptr)
		*ProjectedPosition = std::move(Parms.ProjectedPosition);
}


// Function Mercuna.MercunaNavGroundGrid.Raycast
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable, Const)
// Parameters:
// const struct FMercunaGroundAgentType&   AgentType                                              (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FVector&                   From                                                   (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FVector&                   To                                                     (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool*                                   bRayHit                                                (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector*                         HitPosition                                            (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FMercunaUsageSpec&         UsageSpec                                              (ConstParm, Parm, NoDestructor, AdvancedDisplay, NativeAccessSpecifierPublic)
// bool                                    bIgnoreStationaryObstacles                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AMercunaNavGroundGrid::Raycast(const struct FMercunaGroundAgentType& AgentType, const struct FVector& From, const struct FVector& To, bool* bRayHit, struct FVector* HitPosition, const struct FMercunaUsageSpec& UsageSpec, bool bIgnoreStationaryObstacles) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MercunaNavGroundGrid", "Raycast");

	Params::MercunaNavGroundGrid_Raycast Parms{};

	Parms.AgentType = std::move(AgentType);
	Parms.From = std::move(From);
	Parms.To = std::move(To);
	Parms.UsageSpec = std::move(UsageSpec);
	Parms.bIgnoreStationaryObstacles = bIgnoreStationaryObstacles;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (bRayHit != nullptr)
		*bRayHit = Parms.bRayHit;

	if (HitPosition != nullptr)
		*HitPosition = std::move(Parms.HitPosition);
}


// Function Mercuna.MercunaNavGroundGrid.SaveToObjFile
// (Final, Native, Public, BlueprintCallable, Const)
// Parameters:
// const struct FMercunaGroundAgentType&   AgentType                                              (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bDrawPolyMesh                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AMercunaNavGroundGrid::SaveToObjFile(const struct FMercunaGroundAgentType& AgentType, bool bDrawPolyMesh) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MercunaNavGroundGrid", "SaveToObjFile");

	Params::MercunaNavGroundGrid_SaveToObjFile Parms{};

	Parms.AgentType = std::move(AgentType);
	Parms.bDrawPolyMesh = bDrawPolyMesh;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Mercuna.MercunaObstacleComponent.OnCharacterMovementModeChanged
// (Final, Native, Private)
// Parameters:
// class ACharacter*                       Character                                              (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EMovementMode                           PrevMovementMode                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// uint8                                   PreviousCustomMode                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMercunaObstacleComponent::OnCharacterMovementModeChanged(class ACharacter* Character, EMovementMode PrevMovementMode, uint8 PreviousCustomMode)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MercunaObstacleComponent", "OnCharacterMovementModeChanged");

	Params::MercunaObstacleComponent_OnCharacterMovementModeChanged Parms{};

	Parms.Character = Character;
	Parms.PrevMovementMode = PrevMovementMode;
	Parms.PreviousCustomMode = PreviousCustomMode;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Mercuna.MercunaObstacleComponent.UpdateMovementType
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const EMercunaObstacleMovementType&     NewMovementType                                        (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMercunaObstacleComponent::UpdateMovementType(const EMercunaObstacleMovementType& NewMovementType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MercunaObstacleComponent", "UpdateMovementType");

	Params::MercunaObstacleComponent_UpdateMovementType Parms{};

	Parms.NewMovementType = NewMovementType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Mercuna.MercunaNavVolume.SetNavigationRotation
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// const struct FRotator&                  Rotation                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

void AMercunaNavVolume::SetNavigationRotation(const struct FRotator& Rotation)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MercunaNavVolume", "SetNavigationRotation");

	Params::MercunaNavVolume_SetNavigationRotation Parms{};

	Parms.Rotation = std::move(Rotation);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Mercuna.MercunaNavVolume.SetSize
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// const struct FVector&                   Size                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AMercunaNavVolume::SetSize(const struct FVector& Size)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MercunaNavVolume", "SetSize");

	Params::MercunaNavVolume_SetSize Parms{};

	Parms.Size = std::move(Size);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Mercuna.MercunaNavVolume.GetSize
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector AMercunaNavVolume::GetSize() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MercunaNavVolume", "GetSize");

	Params::MercunaNavVolume_GetSize Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Mercuna.MercunaNavModifierComponent.SetCostMultiplier
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   NewCostMultiplier                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMercunaNavModifierComponent::SetCostMultiplier(float NewCostMultiplier)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MercunaNavModifierComponent", "SetCostMultiplier");

	Params::MercunaNavModifierComponent_SetCostMultiplier Parms{};

	Parms.NewCostMultiplier = NewCostMultiplier;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Mercuna.MercunaNavModifierComponent.SetEnabled
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    Enabled                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMercunaNavModifierComponent::SetEnabled(bool Enabled)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MercunaNavModifierComponent", "SetEnabled");

	Params::MercunaNavModifierComponent_SetEnabled Parms{};

	Parms.Enabled = Enabled;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Mercuna.MercunaNavModifierComponent.SetSize
// (Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// const struct FVector&                   NewSize                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMercunaNavModifierComponent::SetSize(const struct FVector& NewSize)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MercunaNavModifierComponent", "SetSize");

	Params::MercunaNavModifierComponent_SetSize Parms{};

	Parms.NewSize = std::move(NewSize);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Mercuna.MercunaNavModifierComponent.SetUsageTypes
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const struct FMercunaUsageTypes&        NewUsageTypes                                          (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)

void UMercunaNavModifierComponent::SetUsageTypes(const struct FMercunaUsageTypes& NewUsageTypes)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MercunaNavModifierComponent", "SetUsageTypes");

	Params::MercunaNavModifierComponent_SetUsageTypes Parms{};

	Parms.NewUsageTypes = std::move(NewUsageTypes);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Mercuna.MercunaNavModifierComponent.GetSize
// (Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector UMercunaNavModifierComponent::GetSize() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MercunaNavModifierComponent", "GetSize");

	Params::MercunaNavModifierComponent_GetSize Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Mercuna.MercunaNavGridModifierComponent.AddToGrid
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class AMercunaNavGraph2D*               NewNavGrid                                             (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bRebuildGraph                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMercunaNavGridModifierComponent::AddToGrid(class AMercunaNavGraph2D* NewNavGrid, bool bRebuildGraph)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MercunaNavGridModifierComponent", "AddToGrid");

	Params::MercunaNavGridModifierComponent_AddToGrid Parms{};

	Parms.NewNavGrid = NewNavGrid;
	Parms.bRebuildGraph = bRebuildGraph;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Mercuna.MercunaNavGridModifierComponent.OverrideCostMultiplier
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const struct FMercunaAgentType&         AgentType                                              (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   NewCostMultiplier                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMercunaNavGridModifierComponent::OverrideCostMultiplier(const struct FMercunaAgentType& AgentType, float NewCostMultiplier)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MercunaNavGridModifierComponent", "OverrideCostMultiplier");

	Params::MercunaNavGridModifierComponent_OverrideCostMultiplier Parms{};

	Parms.AgentType = std::move(AgentType);
	Parms.NewCostMultiplier = NewCostMultiplier;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Mercuna.MercunaNavGridModifierComponent.OverrideUsageTypes
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const struct FMercunaAgentType&         AgentType                                              (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FMercunaUsageTypes&        NewUsageTypes                                          (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)

void UMercunaNavGridModifierComponent::OverrideUsageTypes(const struct FMercunaAgentType& AgentType, const struct FMercunaUsageTypes& NewUsageTypes)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MercunaNavGridModifierComponent", "OverrideUsageTypes");

	Params::MercunaNavGridModifierComponent_OverrideUsageTypes Parms{};

	Parms.AgentType = std::move(AgentType);
	Parms.NewUsageTypes = std::move(NewUsageTypes);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Mercuna.MercunaNavGridModifierComponent.RemoveFromGrid
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bRebuildGraph                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMercunaNavGridModifierComponent::RemoveFromGrid(bool bRebuildGraph)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MercunaNavGridModifierComponent", "RemoveFromGrid");

	Params::MercunaNavGridModifierComponent_RemoveFromGrid Parms{};

	Parms.bRebuildGraph = bRebuildGraph;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Mercuna.MercunaNavGridModifierComponent.SetPrismVertices
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const TArray<struct FVector2D>&         NewVertices                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)

void UMercunaNavGridModifierComponent::SetPrismVertices(const TArray<struct FVector2D>& NewVertices)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MercunaNavGridModifierComponent", "SetPrismVertices");

	Params::MercunaNavGridModifierComponent_SetPrismVertices Parms{};

	Parms.NewVertices = std::move(NewVertices);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Mercuna.MercunaNavGridModifierComponent.SetShape
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// EMercunaModifierVolumeShape             NewShape                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMercunaNavGridModifierComponent::SetShape(EMercunaModifierVolumeShape NewShape)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MercunaNavGridModifierComponent", "SetShape");

	Params::MercunaNavGridModifierComponent_SetShape Parms{};

	Parms.NewShape = NewShape;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Mercuna.MercunaNavGridModifierComponent.GetShape
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// EMercunaModifierVolumeShape             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

EMercunaModifierVolumeShape UMercunaNavGridModifierComponent::GetShape() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MercunaNavGridModifierComponent", "GetShape");

	Params::MercunaNavGridModifierComponent_GetShape Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Mercuna.Mercuna3DTrackActorProxy.TrackActor
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class APawn*                            Pawn_0                                                 (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           Actor                                                  (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Distance                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Speed                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FVector&                   Offset                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UMercuna3DTrackActorProxy*        ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UMercuna3DTrackActorProxy* UMercuna3DTrackActorProxy::TrackActor(class UObject* WorldContextObject, class APawn* Pawn_0, class AActor* Actor, float Distance, float Speed, const struct FVector& Offset)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("Mercuna3DTrackActorProxy", "TrackActor");

	Params::Mercuna3DTrackActorProxy_TrackActor Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.Pawn_0 = Pawn_0;
	Parms.Actor = Actor;
	Parms.Distance = Distance;
	Parms.Speed = Speed;
	Parms.Offset = std::move(Offset);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Mercuna.Mercuna3DTrackActorProxy.OnMoveComplete
// (Final, Native, Private)
// Parameters:
// const struct FAIRequestID&              RequestID                                              (Parm, NoDestructor, NativeAccessSpecifierPublic)
// EMercunaMoveResult                      Result                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMercuna3DTrackActorProxy::OnMoveComplete(const struct FAIRequestID& RequestID, EMercunaMoveResult Result)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Mercuna3DTrackActorProxy", "OnMoveComplete");

	Params::Mercuna3DTrackActorProxy_OnMoveComplete Parms{};

	Parms.RequestID = std::move(RequestID);
	Parms.Result = Result;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Mercuna.Mercuna3DTask_MoveTo.MoveTo
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable)
// Parameters:
// class AAIController*                    Controller                                             (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FVector&                   GoalLocation                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           GoalActor                                              (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   EndDistance                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    AcceptPartialPath                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bLockAILogic                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UMercuna3DTask_MoveTo*            ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UMercuna3DTask_MoveTo* UMercuna3DTask_MoveTo::MoveTo(class AAIController* Controller, const struct FVector& GoalLocation, class AActor* GoalActor, float EndDistance, bool AcceptPartialPath, bool bLockAILogic)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("Mercuna3DTask_MoveTo", "MoveTo");

	Params::Mercuna3DTask_MoveTo_MoveTo Parms{};

	Parms.Controller = Controller;
	Parms.GoalLocation = std::move(GoalLocation);
	Parms.GoalActor = GoalActor;
	Parms.EndDistance = EndDistance;
	Parms.AcceptPartialPath = AcceptPartialPath;
	Parms.bLockAILogic = bLockAILogic;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Mercuna.Mercuna3DTask_MoveTo.OnMoveComplete
// (Native, Protected)
// Parameters:
// const struct FAIRequestID&              RequestID                                              (Parm, NoDestructor, NativeAccessSpecifierPublic)
// EMercunaMoveResult                      Result                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMercuna3DTask_MoveTo::OnMoveComplete(const struct FAIRequestID& RequestID, EMercunaMoveResult Result)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Mercuna3DTask_MoveTo", "OnMoveComplete");

	Params::Mercuna3DTask_MoveTo_OnMoveComplete Parms{};

	Parms.RequestID = std::move(RequestID);
	Parms.Result = Result;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Mercuna.MercunaBlueprintLibrary.ClearDebugActor
// (Final, Native, Static, Public, BlueprintCallable)

void UMercunaBlueprintLibrary::ClearDebugActor()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MercunaBlueprintLibrary", "ClearDebugActor");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Mercuna.MercunaBlueprintLibrary.HasUsageType
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// const struct FMercunaUsageTypes&        UsageTypes                                             (Parm, NoDestructor, NativeAccessSpecifierPublic)
// class FName                             UsageTypeName                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UMercunaBlueprintLibrary::HasUsageType(const struct FMercunaUsageTypes& UsageTypes, class FName UsageTypeName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MercunaBlueprintLibrary", "HasUsageType");

	Params::MercunaBlueprintLibrary_HasUsageType Parms{};

	Parms.UsageTypes = std::move(UsageTypes);
	Parms.UsageTypeName = UsageTypeName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Mercuna.MercunaBlueprintLibrary.MercunaFlushLog
// (Final, Native, Static, Public, BlueprintCallable)

void UMercunaBlueprintLibrary::MercunaFlushLog()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MercunaBlueprintLibrary", "MercunaFlushLog");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Mercuna.MercunaBlueprintLibrary.MercunaLog
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// const class FString&                    Message                                                (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMercunaBlueprintLibrary::MercunaLog(const class FString& Message)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MercunaBlueprintLibrary", "MercunaLog");

	Params::MercunaBlueprintLibrary_MercunaLog Parms{};

	Parms.Message = std::move(Message);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Mercuna.MercunaBlueprintLibrary.SetDebugActor
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AActor*                           Actor                                                  (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMercunaBlueprintLibrary::SetDebugActor(class AActor* Actor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MercunaBlueprintLibrary", "SetDebugActor");

	Params::MercunaBlueprintLibrary_SetDebugActor Parms{};

	Parms.Actor = Actor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Mercuna.MercunaGroundMoveToProxy.MoveToActor
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class APawn*                            Pawn_0                                                 (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           Actor                                                  (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   EndDistance                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Speed                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    UsePartialPath                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UMercunaGroundMoveToProxy*        ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UMercunaGroundMoveToProxy* UMercunaGroundMoveToProxy::MoveToActor(class UObject* WorldContextObject, class APawn* Pawn_0, class AActor* Actor, float EndDistance, float Speed, bool UsePartialPath)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MercunaGroundMoveToProxy", "MoveToActor");

	Params::MercunaGroundMoveToProxy_MoveToActor Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.Pawn_0 = Pawn_0;
	Parms.Actor = Actor;
	Parms.EndDistance = EndDistance;
	Parms.Speed = Speed;
	Parms.UsePartialPath = UsePartialPath;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Mercuna.MercunaGroundMoveToProxy.MoveToLocation
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class APawn*                            Pawn_0                                                 (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FVector&                   Destination                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   EndDistance                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Speed                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    UsePartialPath                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FVector&                   EndDirection                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UMercunaGroundMoveToProxy*        ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UMercunaGroundMoveToProxy* UMercunaGroundMoveToProxy::MoveToLocation(class UObject* WorldContextObject, class APawn* Pawn_0, const struct FVector& Destination, float EndDistance, float Speed, bool UsePartialPath, const struct FVector& EndDirection)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MercunaGroundMoveToProxy", "MoveToLocation");

	Params::MercunaGroundMoveToProxy_MoveToLocation Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.Pawn_0 = Pawn_0;
	Parms.Destination = std::move(Destination);
	Parms.EndDistance = EndDistance;
	Parms.Speed = Speed;
	Parms.UsePartialPath = UsePartialPath;
	Parms.EndDirection = std::move(EndDirection);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Mercuna.MercunaGroundMoveToProxy.MoveToLocations
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class APawn*                            Pawn_0                                                 (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const TArray<struct FVector>&           Destinations                                           (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// float                                   EndDistance                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Speed                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    UsePartialPath                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FVector&                   EndDirection                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UMercunaGroundMoveToProxy*        ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UMercunaGroundMoveToProxy* UMercunaGroundMoveToProxy::MoveToLocations(class UObject* WorldContextObject, class APawn* Pawn_0, const TArray<struct FVector>& Destinations, float EndDistance, float Speed, bool UsePartialPath, const struct FVector& EndDirection)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MercunaGroundMoveToProxy", "MoveToLocations");

	Params::MercunaGroundMoveToProxy_MoveToLocations Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.Pawn_0 = Pawn_0;
	Parms.Destinations = std::move(Destinations);
	Parms.EndDistance = EndDistance;
	Parms.Speed = Speed;
	Parms.UsePartialPath = UsePartialPath;
	Parms.EndDirection = std::move(EndDirection);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Mercuna.MercunaGroundMoveToProxy.OnMoveComplete
// (Final, Native, Private)
// Parameters:
// const struct FAIRequestID&              RequestID                                              (Parm, NoDestructor, NativeAccessSpecifierPublic)
// EMercunaMoveResult                      Result                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMercunaGroundMoveToProxy::OnMoveComplete(const struct FAIRequestID& RequestID, EMercunaMoveResult Result)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MercunaGroundMoveToProxy", "OnMoveComplete");

	Params::MercunaGroundMoveToProxy_OnMoveComplete Parms{};

	Parms.RequestID = std::move(RequestID);
	Parms.Result = Result;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Mercuna.MercunaGroundTrackActorProxy.TrackActor
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class APawn*                            Pawn_0                                                 (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           Actor                                                  (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Distance                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Speed                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FVector&                   Offset                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    UsePartialPath                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UMercunaGroundTrackActorProxy*    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UMercunaGroundTrackActorProxy* UMercunaGroundTrackActorProxy::TrackActor(class UObject* WorldContextObject, class APawn* Pawn_0, class AActor* Actor, float Distance, float Speed, const struct FVector& Offset, bool UsePartialPath)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MercunaGroundTrackActorProxy", "TrackActor");

	Params::MercunaGroundTrackActorProxy_TrackActor Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.Pawn_0 = Pawn_0;
	Parms.Actor = Actor;
	Parms.Distance = Distance;
	Parms.Speed = Speed;
	Parms.Offset = std::move(Offset);
	Parms.UsePartialPath = UsePartialPath;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Mercuna.MercunaGroundTrackActorProxy.OnMoveComplete
// (Final, Native, Private)
// Parameters:
// const struct FAIRequestID&              RequestID                                              (Parm, NoDestructor, NativeAccessSpecifierPublic)
// EMercunaMoveResult                      Result                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMercunaGroundTrackActorProxy::OnMoveComplete(const struct FAIRequestID& RequestID, EMercunaMoveResult Result)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MercunaGroundTrackActorProxy", "OnMoveComplete");

	Params::MercunaGroundTrackActorProxy_OnMoveComplete Parms{};

	Parms.RequestID = std::move(RequestID);
	Parms.Result = Result;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Mercuna.MercunaNavExclusionVolume.AddToAllGraphs
// (Final, Native, Public, BlueprintCallable)

void AMercunaNavExclusionVolume::AddToAllGraphs()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MercunaNavExclusionVolume", "AddToAllGraphs");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Mercuna.MercunaNavExclusionVolume.AddToGraph
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class AMercunaNavGraph*                 NavGraph_0                                             (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AMercunaNavExclusionVolume::AddToGraph(class AMercunaNavGraph* NavGraph_0)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MercunaNavExclusionVolume", "AddToGraph");

	Params::MercunaNavExclusionVolume_AddToGraph Parms{};

	Parms.NavGraph_0 = NavGraph_0;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Mercuna.MercunaNavExclusionVolume.RemoveFromGraphs
// (Final, Native, Public, BlueprintCallable)

void AMercunaNavExclusionVolume::RemoveFromGraphs()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MercunaNavExclusionVolume", "RemoveFromGraphs");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Mercuna.MercunaNavExclusionVolume.SetSize
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// const struct FVector&                   Size                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AMercunaNavExclusionVolume::SetSize(const struct FVector& Size)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MercunaNavExclusionVolume", "SetSize");

	Params::MercunaNavExclusionVolume_SetSize Parms{};

	Parms.Size = std::move(Size);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Mercuna.MercunaNavExclusionVolume.GetSize
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector AMercunaNavExclusionVolume::GetSize() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MercunaNavExclusionVolume", "GetSize");

	Params::MercunaNavExclusionVolume_GetSize Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Mercuna.MercunaNavGridModifierVolume.AddToGrid
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class AMercunaNavGraph2D*               NavGrid                                                (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AMercunaNavGridModifierVolume::AddToGrid(class AMercunaNavGraph2D* NavGrid)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MercunaNavGridModifierVolume", "AddToGrid");

	Params::MercunaNavGridModifierVolume_AddToGrid Parms{};

	Parms.NavGrid = NavGrid;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Mercuna.MercunaNavGridModifierVolume.OverrideCostMultiplier
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const struct FMercunaAgentType&         AgentType                                              (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   NewCostMultiplier                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AMercunaNavGridModifierVolume::OverrideCostMultiplier(const struct FMercunaAgentType& AgentType, float NewCostMultiplier)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MercunaNavGridModifierVolume", "OverrideCostMultiplier");

	Params::MercunaNavGridModifierVolume_OverrideCostMultiplier Parms{};

	Parms.AgentType = std::move(AgentType);
	Parms.NewCostMultiplier = NewCostMultiplier;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Mercuna.MercunaNavGridModifierVolume.OverrideUsageTypes
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const struct FMercunaAgentType&         AgentType                                              (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FMercunaUsageTypes&        NewUsageTypes                                          (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)

void AMercunaNavGridModifierVolume::OverrideUsageTypes(const struct FMercunaAgentType& AgentType, const struct FMercunaUsageTypes& NewUsageTypes)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MercunaNavGridModifierVolume", "OverrideUsageTypes");

	Params::MercunaNavGridModifierVolume_OverrideUsageTypes Parms{};

	Parms.AgentType = std::move(AgentType);
	Parms.NewUsageTypes = std::move(NewUsageTypes);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Mercuna.MercunaNavGridModifierVolume.RemoveFromGrid
// (Final, Native, Public, BlueprintCallable)

void AMercunaNavGridModifierVolume::RemoveFromGrid()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MercunaNavGridModifierVolume", "RemoveFromGrid");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Mercuna.MercunaNavGridModifierVolume.SetCostMultiplier
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   NewCostMultiplier                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AMercunaNavGridModifierVolume::SetCostMultiplier(float NewCostMultiplier)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MercunaNavGridModifierVolume", "SetCostMultiplier");

	Params::MercunaNavGridModifierVolume_SetCostMultiplier Parms{};

	Parms.NewCostMultiplier = NewCostMultiplier;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Mercuna.MercunaNavGridModifierVolume.SetEnabled
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    Enabled                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AMercunaNavGridModifierVolume::SetEnabled(bool Enabled)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MercunaNavGridModifierVolume", "SetEnabled");

	Params::MercunaNavGridModifierVolume_SetEnabled Parms{};

	Parms.Enabled = Enabled;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Mercuna.MercunaNavGridModifierVolume.SetPrismVertices
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const TArray<struct FVector2D>&         NewVertices                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)

void AMercunaNavGridModifierVolume::SetPrismVertices(const TArray<struct FVector2D>& NewVertices)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MercunaNavGridModifierVolume", "SetPrismVertices");

	Params::MercunaNavGridModifierVolume_SetPrismVertices Parms{};

	Parms.NewVertices = std::move(NewVertices);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Mercuna.MercunaNavGridModifierVolume.SetShape
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// EMercunaModifierVolumeShape             NewShape                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AMercunaNavGridModifierVolume::SetShape(EMercunaModifierVolumeShape NewShape)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MercunaNavGridModifierVolume", "SetShape");

	Params::MercunaNavGridModifierVolume_SetShape Parms{};

	Parms.NewShape = NewShape;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Mercuna.MercunaNavGridModifierVolume.SetSize
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// const struct FVector&                   Size                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AMercunaNavGridModifierVolume::SetSize(const struct FVector& Size)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MercunaNavGridModifierVolume", "SetSize");

	Params::MercunaNavGridModifierVolume_SetSize Parms{};

	Parms.Size = std::move(Size);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Mercuna.MercunaNavGridModifierVolume.SetUsageTypes
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const struct FMercunaUsageTypes&        NewUsageTypes                                          (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)

void AMercunaNavGridModifierVolume::SetUsageTypes(const struct FMercunaUsageTypes& NewUsageTypes)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MercunaNavGridModifierVolume", "SetUsageTypes");

	Params::MercunaNavGridModifierVolume_SetUsageTypes Parms{};

	Parms.NewUsageTypes = std::move(NewUsageTypes);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Mercuna.MercunaNavGridModifierVolume.GetShape
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// EMercunaModifierVolumeShape             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

EMercunaModifierVolumeShape AMercunaNavGridModifierVolume::GetShape() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MercunaNavGridModifierVolume", "GetShape");

	Params::MercunaNavGridModifierVolume_GetShape Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Mercuna.MercunaNavGridModifierVolume.GetSize
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector AMercunaNavGridModifierVolume::GetSize() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MercunaNavGridModifierVolume", "GetSize");

	Params::MercunaNavGridModifierVolume_GetSize Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Mercuna.MercunaNavTestingActor.OnNavGraphBuildComplete
// (Final, Native, Protected)
// Parameters:
// bool                                    Success                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AMercunaNavTestingActor::OnNavGraphBuildComplete(bool Success)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MercunaNavTestingActor", "OnNavGraphBuildComplete");

	Params::MercunaNavTestingActor_OnNavGraphBuildComplete Parms{};

	Parms.Success = Success;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Mercuna.MercunaNavTestingActor.OnPathUpdate
// (Final, Native, Protected)
// Parameters:
// EMercunaPathEvent                       PathEvent                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AMercunaNavTestingActor::OnPathUpdate(EMercunaPathEvent PathEvent)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MercunaNavTestingActor", "OnPathUpdate");

	Params::MercunaNavTestingActor_OnPathUpdate Parms{};

	Parms.PathEvent = PathEvent;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Mercuna.MercunaNavTestingActor.PathfindLatent
// (Final, Native, Protected, HasOutParams, BlueprintCallable)
// Parameters:
// bool*                                   Result                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FLatentActionInfo&         LatentInfo                                             (Parm, NoDestructor, NativeAccessSpecifierPublic)
// bool                                    bAllowPartial                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AMercunaNavTestingActor::PathfindLatent(bool* Result, class UObject* WorldContextObject, const struct FLatentActionInfo& LatentInfo, bool bAllowPartial)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MercunaNavTestingActor", "PathfindLatent");

	Params::MercunaNavTestingActor_PathfindLatent Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.LatentInfo = std::move(LatentInfo);
	Parms.bAllowPartial = bAllowPartial;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Result != nullptr)
		*Result = Parms.Result;
}


// Function Mercuna.MercunaNavTestingActor.Repath
// (Final, Native, Protected, BlueprintCallable)

void AMercunaNavTestingActor::Repath()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MercunaNavTestingActor", "Repath");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Mercuna.MercunaNavGridVolume.AddToGrid
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class AMercunaNavGraph2D*               NavGrid_0                                              (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AMercunaNavGridVolume::AddToGrid(class AMercunaNavGraph2D* NavGrid_0)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MercunaNavGridVolume", "AddToGrid");

	Params::MercunaNavGridVolume_AddToGrid Parms{};

	Parms.NavGrid_0 = NavGrid_0;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Mercuna.MercunaNavGridVolume.RemoveFromGrid
// (Final, Native, Public, BlueprintCallable)

void AMercunaNavGridVolume::RemoveFromGrid()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MercunaNavGridVolume", "RemoveFromGrid");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Mercuna.MercunaNavInvokerVolume.AddToGrid
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class AMercunaNavGroundGrid*            NavGrid_0                                              (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AMercunaNavInvokerVolume::AddToGrid(class AMercunaNavGroundGrid* NavGrid_0)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MercunaNavInvokerVolume", "AddToGrid");

	Params::MercunaNavInvokerVolume_AddToGrid Parms{};

	Parms.NavGrid_0 = NavGrid_0;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Mercuna.MercunaNavInvokerVolume.SetSize
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// const struct FVector&                   Size                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AMercunaNavInvokerVolume::SetSize(const struct FVector& Size)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MercunaNavInvokerVolume", "SetSize");

	Params::MercunaNavInvokerVolume_SetSize Parms{};

	Parms.Size = std::move(Size);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Mercuna.MercunaNavInvokerVolume.SetType
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const EMercunaInvokerVolumeType&        Type_0                                                 (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AMercunaNavInvokerVolume::SetType(const EMercunaInvokerVolumeType& Type_0)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MercunaNavInvokerVolume", "SetType");

	Params::MercunaNavInvokerVolume_SetType Parms{};

	Parms.Type_0 = Type_0;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Mercuna.MercunaNavInvokerVolume.GetSize
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector AMercunaNavInvokerVolume::GetSize() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MercunaNavInvokerVolume", "GetSize");

	Params::MercunaNavInvokerVolume_GetSize Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Mercuna.MercunaNavModifierVolume.AddToGraph
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class AMercunaNavGraph*                 NavGraph_0                                             (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AMercunaNavModifierVolume::AddToGraph(class AMercunaNavGraph* NavGraph_0)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MercunaNavModifierVolume", "AddToGraph");

	Params::MercunaNavModifierVolume_AddToGraph Parms{};

	Parms.NavGraph_0 = NavGraph_0;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Mercuna.MercunaNavModifierVolume.RemoveFromGraph
// (Final, Native, Public, BlueprintCallable)

void AMercunaNavModifierVolume::RemoveFromGraph()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MercunaNavModifierVolume", "RemoveFromGraph");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Mercuna.MercunaNavModifierVolume.SetCostMultiplier
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   NewCostMultiplier                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AMercunaNavModifierVolume::SetCostMultiplier(float NewCostMultiplier)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MercunaNavModifierVolume", "SetCostMultiplier");

	Params::MercunaNavModifierVolume_SetCostMultiplier Parms{};

	Parms.NewCostMultiplier = NewCostMultiplier;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Mercuna.MercunaNavModifierVolume.SetEnabled
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    Enabled                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AMercunaNavModifierVolume::SetEnabled(bool Enabled)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MercunaNavModifierVolume", "SetEnabled");

	Params::MercunaNavModifierVolume_SetEnabled Parms{};

	Parms.Enabled = Enabled;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Mercuna.MercunaNavModifierVolume.SetSize
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// const struct FVector&                   Size                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AMercunaNavModifierVolume::SetSize(const struct FVector& Size)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MercunaNavModifierVolume", "SetSize");

	Params::MercunaNavModifierVolume_SetSize Parms{};

	Parms.Size = std::move(Size);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Mercuna.MercunaNavModifierVolume.SetUsageTypes
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const struct FMercunaUsageTypes&        NewUsageTypes                                          (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)

void AMercunaNavModifierVolume::SetUsageTypes(const struct FMercunaUsageTypes& NewUsageTypes)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MercunaNavModifierVolume", "SetUsageTypes");

	Params::MercunaNavModifierVolume_SetUsageTypes Parms{};

	Parms.NewUsageTypes = std::move(NewUsageTypes);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Mercuna.MercunaNavModifierVolume.GetSize
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector AMercunaNavModifierVolume::GetSize() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MercunaNavModifierVolume", "GetSize");

	Params::MercunaNavModifierVolume_GetSize Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Mercuna.MercunaNavOctree.Build
// (Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const TArray<struct FVector>&           PriorityPositions                                      (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)

void AMercunaNavOctree::Build(const TArray<struct FVector>& PriorityPositions)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MercunaNavOctree", "Build");

	Params::MercunaNavOctree_Build Parms{};

	Parms.PriorityPositions = std::move(PriorityPositions);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Mercuna.MercunaNavOctree.ClampToNavigable
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// const struct FVector&                   Position                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   NavigationRadius                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   SearchRadius                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector*                         ClampedPosition                                        (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool*                                   Result                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AMercunaNavOctree::ClampToNavigable(const struct FVector& Position, float NavigationRadius, float SearchRadius, struct FVector* ClampedPosition, bool* Result)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MercunaNavOctree", "ClampToNavigable");

	Params::MercunaNavOctree_ClampToNavigable Parms{};

	Parms.Position = std::move(Position);
	Parms.NavigationRadius = NavigationRadius;
	Parms.SearchRadius = SearchRadius;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (ClampedPosition != nullptr)
		*ClampedPosition = std::move(Parms.ClampedPosition);

	if (Result != nullptr)
		*Result = Parms.Result;
}


// Function Mercuna.MercunaNavOctree.FindPathToActor
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// const TDelegate<void(EMercunaPathEvent PathEvent)>&OnPathUpdated                                          (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FVector&                   Start                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           GoalActor                                              (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   NavigationRadius                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    AllowPartial                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   MaxPathLength                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   HeightChangePenalty                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UMercunaPath*                     ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UMercunaPath* AMercunaNavOctree::FindPathToActor(const TDelegate<void(EMercunaPathEvent PathEvent)>& OnPathUpdated, const struct FVector& Start, class AActor* GoalActor, float NavigationRadius, bool AllowPartial, float MaxPathLength, float HeightChangePenalty)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MercunaNavOctree", "FindPathToActor");

	Params::MercunaNavOctree_FindPathToActor Parms{};

	Parms.OnPathUpdated = OnPathUpdated;
	Parms.Start = std::move(Start);
	Parms.GoalActor = GoalActor;
	Parms.NavigationRadius = NavigationRadius;
	Parms.AllowPartial = AllowPartial;
	Parms.MaxPathLength = MaxPathLength;
	Parms.HeightChangePenalty = HeightChangePenalty;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Mercuna.MercunaNavOctree.FindPathToLocation
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// const TDelegate<void(EMercunaPathEvent PathEvent)>&OnPathUpdated                                          (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FVector&                   Start                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FVector&                   End                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   NavigationRadius                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    AllowPartial                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   MaxPathLength                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   HeightChangePenalty                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UMercunaPath*                     ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UMercunaPath* AMercunaNavOctree::FindPathToLocation(const TDelegate<void(EMercunaPathEvent PathEvent)>& OnPathUpdated, const struct FVector& Start, const struct FVector& End, float NavigationRadius, bool AllowPartial, float MaxPathLength, float HeightChangePenalty)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MercunaNavOctree", "FindPathToLocation");

	Params::MercunaNavOctree_FindPathToLocation Parms{};

	Parms.OnPathUpdated = OnPathUpdated;
	Parms.Start = std::move(Start);
	Parms.End = std::move(End);
	Parms.NavigationRadius = NavigationRadius;
	Parms.AllowPartial = AllowPartial;
	Parms.MaxPathLength = MaxPathLength;
	Parms.HeightChangePenalty = HeightChangePenalty;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Mercuna.MercunaNavOctree.FindPathToLocations
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// const TDelegate<void(EMercunaPathEvent PathEvent)>&OnPathUpdated                                          (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FVector&                   Start                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const TArray<struct FVector>&           Destinations                                           (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// float                                   NavigationRadius                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    AllowPartial                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   MaxPathLength                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   HeightChangePenalty                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UMercunaPath*                     ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UMercunaPath* AMercunaNavOctree::FindPathToLocations(const TDelegate<void(EMercunaPathEvent PathEvent)>& OnPathUpdated, const struct FVector& Start, const TArray<struct FVector>& Destinations, float NavigationRadius, bool AllowPartial, float MaxPathLength, float HeightChangePenalty)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MercunaNavOctree", "FindPathToLocations");

	Params::MercunaNavOctree_FindPathToLocations Parms{};

	Parms.OnPathUpdated = OnPathUpdated;
	Parms.Start = std::move(Start);
	Parms.Destinations = std::move(Destinations);
	Parms.NavigationRadius = NavigationRadius;
	Parms.AllowPartial = AllowPartial;
	Parms.MaxPathLength = MaxPathLength;
	Parms.HeightChangePenalty = HeightChangePenalty;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Mercuna.MercunaNavOctree.FindSmoothPathToLocation
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// const TDelegate<void(EMercunaPathEvent PathEvent)>&OnPathUpdated                                          (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FVector&                   Start                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FVector&                   End                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   NavigationRadius                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   MaxSpeed                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   MaxAcceleration                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    AllowPartial                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   MaxPathLength                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UMercunaSmoothPath*               ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UMercunaSmoothPath* AMercunaNavOctree::FindSmoothPathToLocation(const TDelegate<void(EMercunaPathEvent PathEvent)>& OnPathUpdated, const struct FVector& Start, const struct FVector& End, float NavigationRadius, float MaxSpeed, float MaxAcceleration, bool AllowPartial, float MaxPathLength)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MercunaNavOctree", "FindSmoothPathToLocation");

	Params::MercunaNavOctree_FindSmoothPathToLocation Parms{};

	Parms.OnPathUpdated = OnPathUpdated;
	Parms.Start = std::move(Start);
	Parms.End = std::move(End);
	Parms.NavigationRadius = NavigationRadius;
	Parms.MaxSpeed = MaxSpeed;
	Parms.MaxAcceleration = MaxAcceleration;
	Parms.AllowPartial = AllowPartial;
	Parms.MaxPathLength = MaxPathLength;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Mercuna.MercunaNavOctree.FindSmoothPathToLocations
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// const TDelegate<void(EMercunaPathEvent PathEvent)>&OnPathUpdated                                          (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FVector&                   Start                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const TArray<struct FVector>&           Destinations                                           (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// float                                   NavigationRadius                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   MaxSpeed                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   MaxAcceleration                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    AllowPartial                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   MaxPathLength                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UMercunaSmoothPath*               ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UMercunaSmoothPath* AMercunaNavOctree::FindSmoothPathToLocations(const TDelegate<void(EMercunaPathEvent PathEvent)>& OnPathUpdated, const struct FVector& Start, const TArray<struct FVector>& Destinations, float NavigationRadius, float MaxSpeed, float MaxAcceleration, bool AllowPartial, float MaxPathLength)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MercunaNavOctree", "FindSmoothPathToLocations");

	Params::MercunaNavOctree_FindSmoothPathToLocations Parms{};

	Parms.OnPathUpdated = OnPathUpdated;
	Parms.Start = std::move(Start);
	Parms.Destinations = std::move(Destinations);
	Parms.NavigationRadius = NavigationRadius;
	Parms.MaxSpeed = MaxSpeed;
	Parms.MaxAcceleration = MaxAcceleration;
	Parms.AllowPartial = AllowPartial;
	Parms.MaxPathLength = MaxPathLength;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Mercuna.MercunaNavOctree.IsNavigable
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// const struct FVector&                   Position                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   NavigationRadius                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool*                                   Result                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AMercunaNavOctree::IsNavigable(const struct FVector& Position, float NavigationRadius, bool* Result)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MercunaNavOctree", "IsNavigable");

	Params::MercunaNavOctree_IsNavigable Parms{};

	Parms.Position = std::move(Position);
	Parms.NavigationRadius = NavigationRadius;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Result != nullptr)
		*Result = Parms.Result;
}


// Function Mercuna.MercunaNavOctree.IsNavigableMulti
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const TArray<struct FVector>&           Positions                                              (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// float                                   NavigationRadius                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<bool>*                           Results                                                (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)

void AMercunaNavOctree::IsNavigableMulti(const TArray<struct FVector>& Positions, float NavigationRadius, TArray<bool>* Results)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MercunaNavOctree", "IsNavigableMulti");

	Params::MercunaNavOctree_IsNavigableMulti Parms{};

	Parms.Positions = std::move(Positions);
	Parms.NavigationRadius = NavigationRadius;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Results != nullptr)
		*Results = std::move(Parms.Results);
}


// Function Mercuna.MercunaNavOctree.IsReachable
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// const struct FVector&                   Start                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FVector&                   End                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   NavigationRadius                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   MaxPathLength                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AMercunaNavOctree::IsReachable(const struct FVector& Start, const struct FVector& End, float NavigationRadius, float MaxPathLength)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MercunaNavOctree", "IsReachable");

	Params::MercunaNavOctree_IsReachable Parms{};

	Parms.Start = std::move(Start);
	Parms.End = std::move(End);
	Parms.NavigationRadius = NavigationRadius;
	Parms.MaxPathLength = MaxPathLength;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Mercuna.MercunaNavOctree.IsReachableLatent
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// const struct FVector&                   Start                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const TArray<struct FVector>&           EndPos                                                 (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// float                                   NavigationRadius                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<bool>*                           Result                                                 (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
// TArray<struct FVector>*                 ClampedPos                                             (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FLatentActionInfo&         LatentInfo                                             (Parm, NoDestructor, NativeAccessSpecifierPublic)
// float                                   MaxPathLength                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    AccuratePathLength                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   StartSearchRadius                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   EndSearchRadius                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AMercunaNavOctree::IsReachableLatent(const struct FVector& Start, const TArray<struct FVector>& EndPos, float NavigationRadius, TArray<bool>* Result, TArray<struct FVector>* ClampedPos, class UObject* WorldContextObject, const struct FLatentActionInfo& LatentInfo, float MaxPathLength, bool AccuratePathLength, float StartSearchRadius, float EndSearchRadius)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MercunaNavOctree", "IsReachableLatent");

	Params::MercunaNavOctree_IsReachableLatent Parms{};

	Parms.Start = std::move(Start);
	Parms.EndPos = std::move(EndPos);
	Parms.NavigationRadius = NavigationRadius;
	Parms.WorldContextObject = WorldContextObject;
	Parms.LatentInfo = std::move(LatentInfo);
	Parms.MaxPathLength = MaxPathLength;
	Parms.AccuratePathLength = AccuratePathLength;
	Parms.StartSearchRadius = StartSearchRadius;
	Parms.EndSearchRadius = EndSearchRadius;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Result != nullptr)
		*Result = std::move(Parms.Result);

	if (ClampedPos != nullptr)
		*ClampedPos = std::move(Parms.ClampedPos);
}


// Function Mercuna.MercunaNavOctree.Raycast
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// const struct FVector&                   Start                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FVector&                   End                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   NavigationRadius                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector*                         HitPosition                                            (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool*                                   RayHit                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AMercunaNavOctree::Raycast(const struct FVector& Start, const struct FVector& End, float NavigationRadius, struct FVector* HitPosition, bool* RayHit)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MercunaNavOctree", "Raycast");

	Params::MercunaNavOctree_Raycast Parms{};

	Parms.Start = std::move(Start);
	Parms.End = std::move(End);
	Parms.NavigationRadius = NavigationRadius;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (HitPosition != nullptr)
		*HitPosition = std::move(Parms.HitPosition);

	if (RayHit != nullptr)
		*RayHit = Parms.RayHit;
}


// Function Mercuna.MercunaNavOctree.RebuildChanges
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    StagedBuild                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    RemoveUnseeded                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AMercunaNavOctree::RebuildChanges(bool StagedBuild, bool RemoveUnseeded)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MercunaNavOctree", "RebuildChanges");

	Params::MercunaNavOctree_RebuildChanges Parms{};

	Parms.StagedBuild = StagedBuild;
	Parms.RemoveUnseeded = RemoveUnseeded;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Mercuna.MercunaNavOctree.RebuildVolume
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// const class AActor*                     Volume                                                 (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    StagedBuild                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    RemoveUnseeded                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AMercunaNavOctree::RebuildVolume(const class AActor* Volume, bool StagedBuild, bool RemoveUnseeded)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MercunaNavOctree", "RebuildVolume");

	Params::MercunaNavOctree_RebuildVolume Parms{};

	Parms.Volume = Volume;
	Parms.StagedBuild = StagedBuild;
	Parms.RemoveUnseeded = RemoveUnseeded;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Mercuna.MercunaNavOctree.RebuildVolumes
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const TArray<struct FBox>&              Volumes                                                (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// bool                                    bStagedBuild                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bRemoveUnseeded                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bMergeVolumes                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AMercunaNavOctree::RebuildVolumes(const TArray<struct FBox>& Volumes, bool bStagedBuild, bool bRemoveUnseeded, bool bMergeVolumes)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MercunaNavOctree", "RebuildVolumes");

	Params::MercunaNavOctree_RebuildVolumes Parms{};

	Parms.Volumes = std::move(Volumes);
	Parms.bStagedBuild = bStagedBuild;
	Parms.bRemoveUnseeded = bRemoveUnseeded;
	Parms.bMergeVolumes = bMergeVolumes;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Mercuna.MercunaNavOctree.SetNavigationRotation
// (Native, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// const struct FRotator&                  Rotation                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

void AMercunaNavOctree::SetNavigationRotation(const struct FRotator& Rotation)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MercunaNavOctree", "SetNavigationRotation");

	Params::MercunaNavOctree_SetNavigationRotation Parms{};

	Parms.Rotation = std::move(Rotation);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Mercuna.MercunaNavOctree.IsBuilding
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AMercunaNavOctree::IsBuilding() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MercunaNavOctree", "IsBuilding");

	Params::MercunaNavOctree_IsBuilding Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Mercuna.MercunaNavOctreeModifierComponent.AddToOctree
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class AMercunaNavOctree*                NewNavOctree                                           (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMercunaNavOctreeModifierComponent::AddToOctree(class AMercunaNavOctree* NewNavOctree)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MercunaNavOctreeModifierComponent", "AddToOctree");

	Params::MercunaNavOctreeModifierComponent_AddToOctree Parms{};

	Parms.NewNavOctree = NewNavOctree;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Mercuna.MercunaNavOctreeModifierComponent.RemoveFromOctree
// (Final, Native, Public, BlueprintCallable)

void UMercunaNavOctreeModifierComponent::RemoveFromOctree()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MercunaNavOctreeModifierComponent", "RemoveFromOctree");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Mercuna.MercunaNavOctreeModifierVolume.AddToOctree
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class AMercunaNavOctree*                NavOctree                                              (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AMercunaNavOctreeModifierVolume::AddToOctree(class AMercunaNavOctree* NavOctree)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MercunaNavOctreeModifierVolume", "AddToOctree");

	Params::MercunaNavOctreeModifierVolume_AddToOctree Parms{};

	Parms.NavOctree = NavOctree;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Mercuna.MercunaNavOctreeModifierVolume.RemoveFromOctree
// (Final, Native, Public, BlueprintCallable)

void AMercunaNavOctreeModifierVolume::RemoveFromOctree()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MercunaNavOctreeModifierVolume", "RemoveFromOctree");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Mercuna.MercunaNavOctreeModifierVolume.SetCostMultiplier
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   NewCostMultiplier                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AMercunaNavOctreeModifierVolume::SetCostMultiplier(float NewCostMultiplier)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MercunaNavOctreeModifierVolume", "SetCostMultiplier");

	Params::MercunaNavOctreeModifierVolume_SetCostMultiplier Parms{};

	Parms.NewCostMultiplier = NewCostMultiplier;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Mercuna.MercunaNavOctreeModifierVolume.SetEnabled
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    Enabled                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AMercunaNavOctreeModifierVolume::SetEnabled(bool Enabled)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MercunaNavOctreeModifierVolume", "SetEnabled");

	Params::MercunaNavOctreeModifierVolume_SetEnabled Parms{};

	Parms.Enabled = Enabled;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Mercuna.MercunaNavOctreeModifierVolume.SetSize
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// const struct FVector&                   Size                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AMercunaNavOctreeModifierVolume::SetSize(const struct FVector& Size)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MercunaNavOctreeModifierVolume", "SetSize");

	Params::MercunaNavOctreeModifierVolume_SetSize Parms{};

	Parms.Size = std::move(Size);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Mercuna.MercunaNavOctreeModifierVolume.SetUsageTypes
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const struct FMercunaUsageTypes&        NewUsageTypes                                          (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)

void AMercunaNavOctreeModifierVolume::SetUsageTypes(const struct FMercunaUsageTypes& NewUsageTypes)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MercunaNavOctreeModifierVolume", "SetUsageTypes");

	Params::MercunaNavOctreeModifierVolume_SetUsageTypes Parms{};

	Parms.NewUsageTypes = std::move(NewUsageTypes);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Mercuna.MercunaNavOctreeModifierVolume.GetSize
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector AMercunaNavOctreeModifierVolume::GetSize() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MercunaNavOctreeModifierVolume", "GetSize");

	Params::MercunaNavOctreeModifierVolume_GetSize Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Mercuna.MercunaNavOctreeVolume.AddToOctree
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class AMercunaNavOctree*                NavOctree_0                                            (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AMercunaNavOctreeVolume::AddToOctree(class AMercunaNavOctree* NavOctree_0)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MercunaNavOctreeVolume", "AddToOctree");

	Params::MercunaNavOctreeVolume_AddToOctree Parms{};

	Parms.NavOctree_0 = NavOctree_0;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Mercuna.MercunaNavOctreeVolume.RemoveFromOctree
// (Final, Native, Public, BlueprintCallable)

void AMercunaNavOctreeVolume::RemoveFromOctree()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MercunaNavOctreeVolume", "RemoveFromOctree");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Mercuna.MercunaNavSurfaceGrid.Build
// (Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const TArray<struct FVector>&           PriorityPositions                                      (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)

void AMercunaNavSurfaceGrid::Build(const TArray<struct FVector>& PriorityPositions)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MercunaNavSurfaceGrid", "Build");

	Params::MercunaNavSurfaceGrid_Build Parms{};

	Parms.PriorityPositions = std::move(PriorityPositions);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Mercuna.MercunaNavSurfaceGrid.FindPathToLocation
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// const struct FMercunaSurfaceAgentType&  AgentType                                              (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const TDelegate<void(EMercunaPathEvent PathEvent)>&OnPathUpdated                                          (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FVector&                   Start                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FVector&                   StartUp                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FVector&                   End                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   IdealTurnRadius                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   MaxSpeed                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    AllowPartial                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   MaxPathLength                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FMercunaUsageSpec&         UsageSpec                                              (ConstParm, Parm, NoDestructor, NativeAccessSpecifierPublic)
// class UMercunaPath*                     ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UMercunaPath* AMercunaNavSurfaceGrid::FindPathToLocation(const struct FMercunaSurfaceAgentType& AgentType, const TDelegate<void(EMercunaPathEvent PathEvent)>& OnPathUpdated, const struct FVector& Start, const struct FVector& StartUp, const struct FVector& End, float IdealTurnRadius, float MaxSpeed, bool AllowPartial, float MaxPathLength, const struct FMercunaUsageSpec& UsageSpec)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MercunaNavSurfaceGrid", "FindPathToLocation");

	Params::MercunaNavSurfaceGrid_FindPathToLocation Parms{};

	Parms.AgentType = std::move(AgentType);
	Parms.OnPathUpdated = OnPathUpdated;
	Parms.Start = std::move(Start);
	Parms.StartUp = std::move(StartUp);
	Parms.End = std::move(End);
	Parms.IdealTurnRadius = IdealTurnRadius;
	Parms.MaxSpeed = MaxSpeed;
	Parms.AllowPartial = AllowPartial;
	Parms.MaxPathLength = MaxPathLength;
	Parms.UsageSpec = std::move(UsageSpec);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Mercuna.MercunaNavSurfaceGrid.FindPathToLocations
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// const struct FMercunaSurfaceAgentType&  AgentType                                              (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const TDelegate<void(EMercunaPathEvent PathEvent)>&OnPathUpdated                                          (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FVector&                   Start                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FVector&                   StartUp                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const TArray<struct FVector>&           Destinations                                           (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// float                                   IdealTurnRadius                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   MaxSpeed                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    AllowPartial                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   MaxPathLength                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FMercunaUsageSpec&         UsageSpec                                              (ConstParm, Parm, NoDestructor, NativeAccessSpecifierPublic)
// class UMercunaPath*                     ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UMercunaPath* AMercunaNavSurfaceGrid::FindPathToLocations(const struct FMercunaSurfaceAgentType& AgentType, const TDelegate<void(EMercunaPathEvent PathEvent)>& OnPathUpdated, const struct FVector& Start, const struct FVector& StartUp, const TArray<struct FVector>& Destinations, float IdealTurnRadius, float MaxSpeed, bool AllowPartial, float MaxPathLength, const struct FMercunaUsageSpec& UsageSpec)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MercunaNavSurfaceGrid", "FindPathToLocations");

	Params::MercunaNavSurfaceGrid_FindPathToLocations Parms{};

	Parms.AgentType = std::move(AgentType);
	Parms.OnPathUpdated = OnPathUpdated;
	Parms.Start = std::move(Start);
	Parms.StartUp = std::move(StartUp);
	Parms.Destinations = std::move(Destinations);
	Parms.IdealTurnRadius = IdealTurnRadius;
	Parms.MaxSpeed = MaxSpeed;
	Parms.AllowPartial = AllowPartial;
	Parms.MaxPathLength = MaxPathLength;
	Parms.UsageSpec = std::move(UsageSpec);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Mercuna.MercunaNavSurfaceGrid.FindSmoothPathToLocation
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// const struct FMercunaSurfaceAgentType&  AgentType                                              (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const TDelegate<void(EMercunaPathEvent PathEvent)>&OnPathUpdated                                          (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FVector&                   Start                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FVector&                   StartUp                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FVector&                   End                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   IdealTurnRadius                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   MaxSpeed                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    AllowPartial                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   MaxPathLength                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FMercunaUsageSpec&         UsageSpec                                              (ConstParm, Parm, NoDestructor, NativeAccessSpecifierPublic)
// class UMercunaSmoothPath*               ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UMercunaSmoothPath* AMercunaNavSurfaceGrid::FindSmoothPathToLocation(const struct FMercunaSurfaceAgentType& AgentType, const TDelegate<void(EMercunaPathEvent PathEvent)>& OnPathUpdated, const struct FVector& Start, const struct FVector& StartUp, const struct FVector& End, float IdealTurnRadius, float MaxSpeed, bool AllowPartial, float MaxPathLength, const struct FMercunaUsageSpec& UsageSpec)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MercunaNavSurfaceGrid", "FindSmoothPathToLocation");

	Params::MercunaNavSurfaceGrid_FindSmoothPathToLocation Parms{};

	Parms.AgentType = std::move(AgentType);
	Parms.OnPathUpdated = OnPathUpdated;
	Parms.Start = std::move(Start);
	Parms.StartUp = std::move(StartUp);
	Parms.End = std::move(End);
	Parms.IdealTurnRadius = IdealTurnRadius;
	Parms.MaxSpeed = MaxSpeed;
	Parms.AllowPartial = AllowPartial;
	Parms.MaxPathLength = MaxPathLength;
	Parms.UsageSpec = std::move(UsageSpec);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Mercuna.MercunaNavSurfaceGrid.FindSmoothPathToLocations
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// const struct FMercunaSurfaceAgentType&  AgentType                                              (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const TDelegate<void(EMercunaPathEvent PathEvent)>&OnPathUpdated                                          (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FVector&                   Start                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FVector&                   StartUp                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const TArray<struct FVector>&           Destinations                                           (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// float                                   IdealTurnRadius                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   MaxSpeed                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    AllowPartial                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   MaxPathLength                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FMercunaUsageSpec&         UsageSpec                                              (ConstParm, Parm, NoDestructor, NativeAccessSpecifierPublic)
// class UMercunaSmoothPath*               ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UMercunaSmoothPath* AMercunaNavSurfaceGrid::FindSmoothPathToLocations(const struct FMercunaSurfaceAgentType& AgentType, const TDelegate<void(EMercunaPathEvent PathEvent)>& OnPathUpdated, const struct FVector& Start, const struct FVector& StartUp, const TArray<struct FVector>& Destinations, float IdealTurnRadius, float MaxSpeed, bool AllowPartial, float MaxPathLength, const struct FMercunaUsageSpec& UsageSpec)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MercunaNavSurfaceGrid", "FindSmoothPathToLocations");

	Params::MercunaNavSurfaceGrid_FindSmoothPathToLocations Parms{};

	Parms.AgentType = std::move(AgentType);
	Parms.OnPathUpdated = OnPathUpdated;
	Parms.Start = std::move(Start);
	Parms.StartUp = std::move(StartUp);
	Parms.Destinations = std::move(Destinations);
	Parms.IdealTurnRadius = IdealTurnRadius;
	Parms.MaxSpeed = MaxSpeed;
	Parms.AllowPartial = AllowPartial;
	Parms.MaxPathLength = MaxPathLength;
	Parms.UsageSpec = std::move(UsageSpec);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Mercuna.MercunaNavSurfaceGrid.RebuildChanges
// (Native, Public, BlueprintCallable)

void AMercunaNavSurfaceGrid::RebuildChanges()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MercunaNavSurfaceGrid", "RebuildChanges");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Mercuna.MercunaNavSurfaceGrid.RebuildVolume
// (Native, Public, BlueprintCallable)
// Parameters:
// const class AActor*                     Volume                                                 (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bApplyNavSeeds                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AMercunaNavSurfaceGrid::RebuildVolume(const class AActor* Volume, bool bApplyNavSeeds)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MercunaNavSurfaceGrid", "RebuildVolume");

	Params::MercunaNavSurfaceGrid_RebuildVolume Parms{};

	Parms.Volume = Volume;
	Parms.bApplyNavSeeds = bApplyNavSeeds;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Mercuna.MercunaNavSurfaceGrid.RebuildVolumes
// (Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const TArray<struct FBox>&              Volumes                                                (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// bool                                    bMergeVolumes                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bOnlyUnbuilt                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bApplyNavSeeds                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AMercunaNavSurfaceGrid::RebuildVolumes(const TArray<struct FBox>& Volumes, bool bMergeVolumes, bool bOnlyUnbuilt, bool bApplyNavSeeds)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MercunaNavSurfaceGrid", "RebuildVolumes");

	Params::MercunaNavSurfaceGrid_RebuildVolumes Parms{};

	Parms.Volumes = std::move(Volumes);
	Parms.bMergeVolumes = bMergeVolumes;
	Parms.bOnlyUnbuilt = bOnlyUnbuilt;
	Parms.bApplyNavSeeds = bApplyNavSeeds;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Mercuna.MercunaNavSurfaceGrid.ClampToNavigable
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable, Const)
// Parameters:
// const struct FMercunaSurfaceAgentType&  AgentType                                              (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FVector&                   Position                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FVector&                   Up                                                     (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   SearchRadius                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   HeightRange                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool*                                   bResult                                                (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector*                         ClampedPosition                                        (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector*                         ClampedUp                                              (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FMercunaUsageTypes*              ClampedUsageTypes                                      (Parm, OutParm, NoDestructor, NativeAccessSpecifierPublic)
// const struct FMercunaUsageSpec&         UsageSpec                                              (ConstParm, Parm, NoDestructor, AdvancedDisplay, NativeAccessSpecifierPublic)

void AMercunaNavSurfaceGrid::ClampToNavigable(const struct FMercunaSurfaceAgentType& AgentType, const struct FVector& Position, const struct FVector& Up, float SearchRadius, float HeightRange, bool* bResult, struct FVector* ClampedPosition, struct FVector* ClampedUp, struct FMercunaUsageTypes* ClampedUsageTypes, const struct FMercunaUsageSpec& UsageSpec) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MercunaNavSurfaceGrid", "ClampToNavigable");

	Params::MercunaNavSurfaceGrid_ClampToNavigable Parms{};

	Parms.AgentType = std::move(AgentType);
	Parms.Position = std::move(Position);
	Parms.Up = std::move(Up);
	Parms.SearchRadius = SearchRadius;
	Parms.HeightRange = HeightRange;
	Parms.UsageSpec = std::move(UsageSpec);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (bResult != nullptr)
		*bResult = Parms.bResult;

	if (ClampedPosition != nullptr)
		*ClampedPosition = std::move(Parms.ClampedPosition);

	if (ClampedUp != nullptr)
		*ClampedUp = std::move(Parms.ClampedUp);

	if (ClampedUsageTypes != nullptr)
		*ClampedUsageTypes = std::move(Parms.ClampedUsageTypes);
}


// Function Mercuna.MercunaNavSurfaceGrid.GetNumBoxesBuilding
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 AMercunaNavSurfaceGrid::GetNumBoxesBuilding() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MercunaNavSurfaceGrid", "GetNumBoxesBuilding");

	Params::MercunaNavSurfaceGrid_GetNumBoxesBuilding Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Mercuna.MercunaNavSurfaceGrid.IsAnyWorkInProgress
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AMercunaNavSurfaceGrid::IsAnyWorkInProgress() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MercunaNavSurfaceGrid", "IsAnyWorkInProgress");

	Params::MercunaNavSurfaceGrid_IsAnyWorkInProgress Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Mercuna.MercunaNavSurfaceGrid.IsBuilding
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AMercunaNavSurfaceGrid::IsBuilding() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MercunaNavSurfaceGrid", "IsBuilding");

	Params::MercunaNavSurfaceGrid_IsBuilding Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Mercuna.MercunaNavSurfaceGrid.IsBuilt
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const struct FMercunaSurfaceAgentType&  AgentType                                              (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FVector&                   Pos                                                    (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AMercunaNavSurfaceGrid::IsBuilt(const struct FMercunaSurfaceAgentType& AgentType, const struct FVector& Pos) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MercunaNavSurfaceGrid", "IsBuilt");

	Params::MercunaNavSurfaceGrid_IsBuilt Parms{};

	Parms.AgentType = std::move(AgentType);
	Parms.Pos = std::move(Pos);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Mercuna.MercunaNavSurfaceGrid.IsBuiltWithinBox
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const struct FMercunaSurfaceAgentType&  AgentType                                              (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FBox&                      Box                                                    (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AMercunaNavSurfaceGrid::IsBuiltWithinBox(const struct FMercunaSurfaceAgentType& AgentType, const struct FBox& Box) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MercunaNavSurfaceGrid", "IsBuiltWithinBox");

	Params::MercunaNavSurfaceGrid_IsBuiltWithinBox Parms{};

	Parms.AgentType = std::move(AgentType);
	Parms.Box = std::move(Box);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Mercuna.MercunaNavSurfaceGrid.IsNavigable
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable, Const)
// Parameters:
// const struct FMercunaSurfaceAgentType&  AgentType                                              (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FVector&                   Position                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FVector&                   Up                                                     (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool*                                   bResult                                                (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FMercunaUsageSpec&         UsageSpec                                              (ConstParm, Parm, NoDestructor, AdvancedDisplay, NativeAccessSpecifierPublic)

void AMercunaNavSurfaceGrid::IsNavigable(const struct FMercunaSurfaceAgentType& AgentType, const struct FVector& Position, const struct FVector& Up, bool* bResult, const struct FMercunaUsageSpec& UsageSpec) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MercunaNavSurfaceGrid", "IsNavigable");

	Params::MercunaNavSurfaceGrid_IsNavigable Parms{};

	Parms.AgentType = std::move(AgentType);
	Parms.Position = std::move(Position);
	Parms.Up = std::move(Up);
	Parms.UsageSpec = std::move(UsageSpec);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (bResult != nullptr)
		*bResult = Parms.bResult;
}


// Function Mercuna.MercunaNavSurfaceGrid.IsReachable
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable, Const)
// Parameters:
// const struct FMercunaSurfaceAgentType&  AgentType                                              (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FVector&                   From                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FVector&                   FromUp                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FVector&                   To                                                     (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   MaxPathLength                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EMercunaNavLinkQueryMode                FollowNavLinks                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FMercunaUsageSpec&         UsageSpec                                              (ConstParm, Parm, NoDestructor, AdvancedDisplay, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AMercunaNavSurfaceGrid::IsReachable(const struct FMercunaSurfaceAgentType& AgentType, const struct FVector& From, const struct FVector& FromUp, const struct FVector& To, float MaxPathLength, EMercunaNavLinkQueryMode FollowNavLinks, const struct FMercunaUsageSpec& UsageSpec) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MercunaNavSurfaceGrid", "IsReachable");

	Params::MercunaNavSurfaceGrid_IsReachable Parms{};

	Parms.AgentType = std::move(AgentType);
	Parms.From = std::move(From);
	Parms.FromUp = std::move(FromUp);
	Parms.To = std::move(To);
	Parms.MaxPathLength = MaxPathLength;
	Parms.FollowNavLinks = FollowNavLinks;
	Parms.UsageSpec = std::move(UsageSpec);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Mercuna.MercunaNavSurfaceGrid.IsReachableLatent
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable, Const)
// Parameters:
// const struct FMercunaSurfaceAgentType&  AgentType                                              (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FVector&                   From                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FVector&                   FromUp                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const TArray<struct FVector>&           To                                                     (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// TArray<bool>*                           Result                                                 (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
// TArray<struct FVector>*                 ClampedTo                                              (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FLatentActionInfo&         LatentInfo                                             (Parm, NoDestructor, NativeAccessSpecifierPublic)
// float                                   MaxPathLength                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   FromSearchRadius                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ToSearchRadius                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EMercunaNavLinkQueryMode                FollowNavLinks                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FMercunaUsageSpec&         UsageSpec                                              (ConstParm, Parm, NoDestructor, AdvancedDisplay, NativeAccessSpecifierPublic)

void AMercunaNavSurfaceGrid::IsReachableLatent(const struct FMercunaSurfaceAgentType& AgentType, const struct FVector& From, const struct FVector& FromUp, const TArray<struct FVector>& To, TArray<bool>* Result, TArray<struct FVector>* ClampedTo, class UObject* WorldContextObject, const struct FLatentActionInfo& LatentInfo, float MaxPathLength, float FromSearchRadius, float ToSearchRadius, EMercunaNavLinkQueryMode FollowNavLinks, const struct FMercunaUsageSpec& UsageSpec) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MercunaNavSurfaceGrid", "IsReachableLatent");

	Params::MercunaNavSurfaceGrid_IsReachableLatent Parms{};

	Parms.AgentType = std::move(AgentType);
	Parms.From = std::move(From);
	Parms.FromUp = std::move(FromUp);
	Parms.To = std::move(To);
	Parms.WorldContextObject = WorldContextObject;
	Parms.LatentInfo = std::move(LatentInfo);
	Parms.MaxPathLength = MaxPathLength;
	Parms.FromSearchRadius = FromSearchRadius;
	Parms.ToSearchRadius = ToSearchRadius;
	Parms.FollowNavLinks = FollowNavLinks;
	Parms.UsageSpec = std::move(UsageSpec);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Result != nullptr)
		*Result = std::move(Parms.Result);

	if (ClampedTo != nullptr)
		*ClampedTo = std::move(Parms.ClampedTo);
}


// Function Mercuna.MercunaNavSurfaceGrid.ProjectToNavigable
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable, Const)
// Parameters:
// const struct FMercunaSurfaceAgentType&  AgentType                                              (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FVector&                   Position                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FVector&                   Up                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EMercunaProjectionDirection             Direction                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool*                                   bResult                                                (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector*                         ProjectedPosition                                      (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   SearchDistance                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FMercunaUsageSpec&         UsageSpec                                              (ConstParm, Parm, NoDestructor, AdvancedDisplay, NativeAccessSpecifierPublic)

void AMercunaNavSurfaceGrid::ProjectToNavigable(const struct FMercunaSurfaceAgentType& AgentType, const struct FVector& Position, const struct FVector& Up, EMercunaProjectionDirection Direction, bool* bResult, struct FVector* ProjectedPosition, float SearchDistance, const struct FMercunaUsageSpec& UsageSpec) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MercunaNavSurfaceGrid", "ProjectToNavigable");

	Params::MercunaNavSurfaceGrid_ProjectToNavigable Parms{};

	Parms.AgentType = std::move(AgentType);
	Parms.Position = std::move(Position);
	Parms.Up = std::move(Up);
	Parms.Direction = Direction;
	Parms.SearchDistance = SearchDistance;
	Parms.UsageSpec = std::move(UsageSpec);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (bResult != nullptr)
		*bResult = Parms.bResult;

	if (ProjectedPosition != nullptr)
		*ProjectedPosition = std::move(Parms.ProjectedPosition);
}


// Function Mercuna.MercunaNavSurfaceGrid.Raycast
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable, Const)
// Parameters:
// const struct FMercunaSurfaceAgentType&  AgentType                                              (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FVector&                   From                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FVector&                   FromUp                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FVector&                   To                                                     (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool*                                   bRayHit                                                (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector*                         HitPosition                                            (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FMercunaUsageSpec&         UsageSpec                                              (ConstParm, Parm, NoDestructor, AdvancedDisplay, NativeAccessSpecifierPublic)

void AMercunaNavSurfaceGrid::Raycast(const struct FMercunaSurfaceAgentType& AgentType, const struct FVector& From, const struct FVector& FromUp, const struct FVector& To, bool* bRayHit, struct FVector* HitPosition, const struct FMercunaUsageSpec& UsageSpec) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MercunaNavSurfaceGrid", "Raycast");

	Params::MercunaNavSurfaceGrid_Raycast Parms{};

	Parms.AgentType = std::move(AgentType);
	Parms.From = std::move(From);
	Parms.FromUp = std::move(FromUp);
	Parms.To = std::move(To);
	Parms.UsageSpec = std::move(UsageSpec);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (bRayHit != nullptr)
		*bRayHit = Parms.bRayHit;

	if (HitPosition != nullptr)
		*HitPosition = std::move(Parms.HitPosition);
}


// Function Mercuna.MercunaNavSurfaceGrid.SaveToObjFile
// (Final, Native, Public, BlueprintCallable, Const)
// Parameters:
// const struct FMercunaSurfaceAgentType&  AgentType                                              (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bDrawPolyMesh                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AMercunaNavSurfaceGrid::SaveToObjFile(const struct FMercunaSurfaceAgentType& AgentType, bool bDrawPolyMesh) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MercunaNavSurfaceGrid", "SaveToObjFile");

	Params::MercunaNavSurfaceGrid_SaveToObjFile Parms{};

	Parms.AgentType = std::move(AgentType);
	Parms.bDrawPolyMesh = bDrawPolyMesh;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Mercuna.MercunaOctreeClampToNavigableProxy.ClampToNavigable
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject_0                                   (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FVector&                   Position                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   NavigationRadius                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   SearchRadius                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UMercunaOctreeClampToNavigableProxy*ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UMercunaOctreeClampToNavigableProxy* UMercunaOctreeClampToNavigableProxy::ClampToNavigable(class UObject* WorldContextObject_0, const struct FVector& Position, float NavigationRadius, float SearchRadius)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MercunaOctreeClampToNavigableProxy", "ClampToNavigable");

	Params::MercunaOctreeClampToNavigableProxy_ClampToNavigable Parms{};

	Parms.WorldContextObject_0 = WorldContextObject_0;
	Parms.Position = std::move(Position);
	Parms.NavigationRadius = NavigationRadius;
	Parms.SearchRadius = SearchRadius;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Mercuna.MercunaOctreeRaycastProxy.NavigationRaycast
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject_0                                   (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FVector&                   Start                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FVector&                   End                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   NavigationRadius                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UMercunaOctreeRaycastProxy*       ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UMercunaOctreeRaycastProxy* UMercunaOctreeRaycastProxy::NavigationRaycast(class UObject* WorldContextObject_0, const struct FVector& Start, const struct FVector& End, float NavigationRadius)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MercunaOctreeRaycastProxy", "NavigationRaycast");

	Params::MercunaOctreeRaycastProxy_NavigationRaycast Parms{};

	Parms.WorldContextObject_0 = WorldContextObject_0;
	Parms.Start = std::move(Start);
	Parms.End = std::move(End);
	Parms.NavigationRadius = NavigationRadius;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Mercuna.MercunaPath.Invalidate
// (Final, Native, Public, BlueprintCallable)

void UMercunaPath::Invalidate()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MercunaPath", "Invalidate");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Mercuna.MercunaPath.GetDebugInfo
// (Final, Native, Protected, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32*                                  nodesUsed                                              (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool*                                   bOutOfNodes                                            (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float*                                  queryTime                                              (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMercunaPath::GetDebugInfo(int32* nodesUsed, bool* bOutOfNodes, float* queryTime) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MercunaPath", "GetDebugInfo");

	Params::MercunaPath_GetDebugInfo Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (nodesUsed != nullptr)
		*nodesUsed = Parms.nodesUsed;

	if (bOutOfNodes != nullptr)
		*bOutOfNodes = Parms.bOutOfNodes;

	if (queryTime != nullptr)
		*queryTime = Parms.queryTime;
}


// Function Mercuna.MercunaPath.GetNumPoints
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UMercunaPath::GetNumPoints() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MercunaPath", "GetNumPoints");

	Params::MercunaPath_GetNumPoints Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Mercuna.MercunaPath.GetPathLength
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UMercunaPath::GetPathLength() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MercunaPath", "GetPathLength");

	Params::MercunaPath_GetPathLength Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Mercuna.MercunaPath.GetPoint
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   I                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector UMercunaPath::GetPoint(int32 I) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MercunaPath", "GetPoint");

	Params::MercunaPath_GetPoint Parms{};

	Parms.I = I;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Mercuna.MercunaPath.GetStatus
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString UMercunaPath::GetStatus() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MercunaPath", "GetStatus");

	Params::MercunaPath_GetStatus Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Mercuna.MercunaPath.IsPartial
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UMercunaPath::IsPartial() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MercunaPath", "IsPartial");

	Params::MercunaPath_IsPartial Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Mercuna.MercunaPath.IsReady
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UMercunaPath::IsReady() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MercunaPath", "IsReady");

	Params::MercunaPath_IsReady Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Mercuna.MercunaPath.IsValid
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UMercunaPath::IsValid() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MercunaPath", "IsValid");

	Params::MercunaPath_IsValid Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Mercuna.MercunaSmoothPath.GetPosition
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const float                             Length                                                 (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector UMercunaSmoothPath::GetPosition(const float Length) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MercunaSmoothPath", "GetPosition");

	Params::MercunaSmoothPath_GetPosition Parms{};

	Parms.Length = Length;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Mercuna.MercunaSmoothPath.GetSplinePoints
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const struct FTransform&                RelativeTo                                             (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<struct FSplinePoint>             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<struct FSplinePoint> UMercunaSmoothPath::GetSplinePoints(const struct FTransform& RelativeTo) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MercunaSmoothPath", "GetSplinePoints");

	Params::MercunaSmoothPath_GetSplinePoints Parms{};

	Parms.RelativeTo = std::move(RelativeTo);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Mercuna.MercunaSmoothPath.GetTangent
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const float                             Length                                                 (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector UMercunaSmoothPath::GetTangent(const float Length) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MercunaSmoothPath", "GetTangent");

	Params::MercunaSmoothPath_GetTangent Parms{};

	Parms.Length = Length;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Mercuna.MercunaSurfaceMoveToProxy.MoveToActor
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class APawn*                            Pawn_0                                                 (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           Actor                                                  (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   EndDistance                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Speed                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    UsePartialPath                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    UseEndActorOrientation                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UMercunaSurfaceMoveToProxy*       ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UMercunaSurfaceMoveToProxy* UMercunaSurfaceMoveToProxy::MoveToActor(class UObject* WorldContextObject, class APawn* Pawn_0, class AActor* Actor, float EndDistance, float Speed, bool UsePartialPath, bool UseEndActorOrientation)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MercunaSurfaceMoveToProxy", "MoveToActor");

	Params::MercunaSurfaceMoveToProxy_MoveToActor Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.Pawn_0 = Pawn_0;
	Parms.Actor = Actor;
	Parms.EndDistance = EndDistance;
	Parms.Speed = Speed;
	Parms.UsePartialPath = UsePartialPath;
	Parms.UseEndActorOrientation = UseEndActorOrientation;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Mercuna.MercunaSurfaceMoveToProxy.MoveToLocation
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class APawn*                            Pawn_0                                                 (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FVector&                   Destination                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   EndDistance                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Speed                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    UsePartialPath                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FVector&                   EndDirection                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UMercunaSurfaceMoveToProxy*       ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UMercunaSurfaceMoveToProxy* UMercunaSurfaceMoveToProxy::MoveToLocation(class UObject* WorldContextObject, class APawn* Pawn_0, const struct FVector& Destination, float EndDistance, float Speed, bool UsePartialPath, const struct FVector& EndDirection)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MercunaSurfaceMoveToProxy", "MoveToLocation");

	Params::MercunaSurfaceMoveToProxy_MoveToLocation Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.Pawn_0 = Pawn_0;
	Parms.Destination = std::move(Destination);
	Parms.EndDistance = EndDistance;
	Parms.Speed = Speed;
	Parms.UsePartialPath = UsePartialPath;
	Parms.EndDirection = std::move(EndDirection);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Mercuna.MercunaSurfaceMoveToProxy.MoveToLocations
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class APawn*                            Pawn_0                                                 (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const TArray<struct FVector>&           Destinations                                           (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// float                                   EndDistance                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Speed                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    UsePartialPath                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FVector&                   EndDirection                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UMercunaSurfaceMoveToProxy*       ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UMercunaSurfaceMoveToProxy* UMercunaSurfaceMoveToProxy::MoveToLocations(class UObject* WorldContextObject, class APawn* Pawn_0, const TArray<struct FVector>& Destinations, float EndDistance, float Speed, bool UsePartialPath, const struct FVector& EndDirection)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MercunaSurfaceMoveToProxy", "MoveToLocations");

	Params::MercunaSurfaceMoveToProxy_MoveToLocations Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.Pawn_0 = Pawn_0;
	Parms.Destinations = std::move(Destinations);
	Parms.EndDistance = EndDistance;
	Parms.Speed = Speed;
	Parms.UsePartialPath = UsePartialPath;
	Parms.EndDirection = std::move(EndDirection);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Mercuna.MercunaSurfaceMoveToProxy.OnMoveComplete
// (Final, Native, Private)
// Parameters:
// const struct FAIRequestID&              RequestID                                              (Parm, NoDestructor, NativeAccessSpecifierPublic)
// EMercunaMoveResult                      Result                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMercunaSurfaceMoveToProxy::OnMoveComplete(const struct FAIRequestID& RequestID, EMercunaMoveResult Result)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MercunaSurfaceMoveToProxy", "OnMoveComplete");

	Params::MercunaSurfaceMoveToProxy_OnMoveComplete Parms{};

	Parms.RequestID = std::move(RequestID);
	Parms.Result = Result;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Mercuna.MercunaSurfaceTrackActorProxy.TrackActor
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class APawn*                            Pawn_0                                                 (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           Actor                                                  (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Distance                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Speed                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FVector&                   Offset                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    UsePartialPath                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    UseEndActorOrientation                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UMercunaSurfaceTrackActorProxy*   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UMercunaSurfaceTrackActorProxy* UMercunaSurfaceTrackActorProxy::TrackActor(class UObject* WorldContextObject, class APawn* Pawn_0, class AActor* Actor, float Distance, float Speed, const struct FVector& Offset, bool UsePartialPath, bool UseEndActorOrientation)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MercunaSurfaceTrackActorProxy", "TrackActor");

	Params::MercunaSurfaceTrackActorProxy_TrackActor Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.Pawn_0 = Pawn_0;
	Parms.Actor = Actor;
	Parms.Distance = Distance;
	Parms.Speed = Speed;
	Parms.Offset = std::move(Offset);
	Parms.UsePartialPath = UsePartialPath;
	Parms.UseEndActorOrientation = UseEndActorOrientation;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Mercuna.MercunaSurfaceTrackActorProxy.OnMoveComplete
// (Final, Native, Private)
// Parameters:
// const struct FAIRequestID&              RequestID                                              (Parm, NoDestructor, NativeAccessSpecifierPublic)
// EMercunaMoveResult                      Result                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMercunaSurfaceTrackActorProxy::OnMoveComplete(const struct FAIRequestID& RequestID, EMercunaMoveResult Result)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MercunaSurfaceTrackActorProxy", "OnMoveComplete");

	Params::MercunaSurfaceTrackActorProxy_OnMoveComplete Parms{};

	Parms.RequestID = std::move(RequestID);
	Parms.Result = Result;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Mercuna.MercunaSurfaceNavigationComponent.AddDestinationLocation
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// const struct FVector&                   NextDestination                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bSmoothTransition                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMercunaSurfaceNavigationComponent::AddDestinationLocation(const struct FVector& NextDestination, bool bSmoothTransition)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MercunaSurfaceNavigationComponent", "AddDestinationLocation");

	Params::MercunaSurfaceNavigationComponent_AddDestinationLocation Parms{};

	Parms.NextDestination = std::move(NextDestination);
	Parms.bSmoothTransition = bSmoothTransition;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Mercuna.MercunaSurfaceNavigationComponent.CancelMovement
// (Final, Native, Public, BlueprintCallable)

void UMercunaSurfaceNavigationComponent::CancelMovement()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MercunaSurfaceNavigationComponent", "CancelMovement");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Mercuna.MercunaSurfaceNavigationComponent.ClearAvoidanceExclusions
// (Native, Public, BlueprintCallable)

void UMercunaSurfaceNavigationComponent::ClearAvoidanceExclusions()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MercunaSurfaceNavigationComponent", "ClearAvoidanceExclusions");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Mercuna.MercunaSurfaceNavigationComponent.Configure
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const struct FMercunaSurfaceNavigationConfiguration&NewConfiguration                                       (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)

void UMercunaSurfaceNavigationComponent::Configure(const struct FMercunaSurfaceNavigationConfiguration& NewConfiguration)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MercunaSurfaceNavigationComponent", "Configure");

	Params::MercunaSurfaceNavigationComponent_Configure Parms{};

	Parms.NewConfiguration = std::move(NewConfiguration);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Mercuna.MercunaSurfaceNavigationComponent.ConfigureMovement
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// EMercunaAvoidanceMode                   NewAvoidanceMode                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMercunaSurfaceNavigationComponent::ConfigureMovement(EMercunaAvoidanceMode NewAvoidanceMode)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MercunaSurfaceNavigationComponent", "ConfigureMovement");

	Params::MercunaSurfaceNavigationComponent_ConfigureMovement Parms{};

	Parms.NewAvoidanceMode = NewAvoidanceMode;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Mercuna.MercunaSurfaceNavigationComponent.ConfigureSteering
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const struct FMercunaSurfaceNavigationSteeringParameters&NewSteering                                            (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)

void UMercunaSurfaceNavigationComponent::ConfigureSteering(const struct FMercunaSurfaceNavigationSteeringParameters& NewSteering)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MercunaSurfaceNavigationComponent", "ConfigureSteering");

	Params::MercunaSurfaceNavigationComponent_ConfigureSteering Parms{};

	Parms.NewSteering = std::move(NewSteering);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Mercuna.MercunaSurfaceNavigationComponent.GetLookDirection
// (Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector UMercunaSurfaceNavigationComponent::GetLookDirection()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MercunaSurfaceNavigationComponent", "GetLookDirection");

	Params::MercunaSurfaceNavigationComponent_GetLookDirection Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Mercuna.MercunaSurfaceNavigationComponent.GetPathInfo
// (Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// bool*                                   Valid                                                  (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float*                                  DistanceToEnd                                          (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMercunaSurfaceNavigationComponent::GetPathInfo(bool* Valid, float* DistanceToEnd)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MercunaSurfaceNavigationComponent", "GetPathInfo");

	Params::MercunaSurfaceNavigationComponent_GetPathInfo Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Valid != nullptr)
		*Valid = Parms.Valid;

	if (DistanceToEnd != nullptr)
		*DistanceToEnd = Parms.DistanceToEnd;
}


// Function Mercuna.MercunaSurfaceNavigationComponent.GetRemainingPathLength
// (Native, Public, BlueprintCallable)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UMercunaSurfaceNavigationComponent::GetRemainingPathLength()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MercunaSurfaceNavigationComponent", "GetRemainingPathLength");

	Params::MercunaSurfaceNavigationComponent_GetRemainingPathLength Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Mercuna.MercunaSurfaceNavigationComponent.InvalidateContextualSteeringParams
// (Native, Public, BlueprintCallable)

void UMercunaSurfaceNavigationComponent::InvalidateContextualSteeringParams()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MercunaSurfaceNavigationComponent", "InvalidateContextualSteeringParams");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Mercuna.MercunaSurfaceNavigationComponent.InvalidateContextualSteeringParamsAgainstActor
// (Native, Public, BlueprintCallable)
// Parameters:
// class AActor*                           Actor                                                  (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMercunaSurfaceNavigationComponent::InvalidateContextualSteeringParamsAgainstActor(class AActor* Actor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MercunaSurfaceNavigationComponent", "InvalidateContextualSteeringParamsAgainstActor");

	Params::MercunaSurfaceNavigationComponent_InvalidateContextualSteeringParamsAgainstActor Parms{};

	Parms.Actor = Actor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Mercuna.MercunaSurfaceNavigationComponent.MoveToActor
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class AActor*                           Actor                                                  (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   EndDistance                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Speed                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    UsePartialPath                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bUseEndActorOrientation                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMercunaSurfaceNavigationComponent::MoveToActor(class AActor* Actor, float EndDistance, float Speed, bool UsePartialPath, bool bUseEndActorOrientation)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MercunaSurfaceNavigationComponent", "MoveToActor");

	Params::MercunaSurfaceNavigationComponent_MoveToActor Parms{};

	Parms.Actor = Actor;
	Parms.EndDistance = EndDistance;
	Parms.Speed = Speed;
	Parms.UsePartialPath = UsePartialPath;
	Parms.bUseEndActorOrientation = bUseEndActorOrientation;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Mercuna.MercunaSurfaceNavigationComponent.MoveToLocation
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// const struct FVector&                   Destination                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FVector&                   EndDirection                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   EndDistance                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Speed                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    UsePartialPath                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMercunaSurfaceNavigationComponent::MoveToLocation(const struct FVector& Destination, const struct FVector& EndDirection, float EndDistance, float Speed, bool UsePartialPath)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MercunaSurfaceNavigationComponent", "MoveToLocation");

	Params::MercunaSurfaceNavigationComponent_MoveToLocation Parms{};

	Parms.Destination = std::move(Destination);
	Parms.EndDirection = std::move(EndDirection);
	Parms.EndDistance = EndDistance;
	Parms.Speed = Speed;
	Parms.UsePartialPath = UsePartialPath;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Mercuna.MercunaSurfaceNavigationComponent.MoveToLocations
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// const TArray<struct FVector>&           Destinations                                           (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// const struct FVector&                   EndDirection                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   EndDistance                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Speed                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    UsePartialPath                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMercunaSurfaceNavigationComponent::MoveToLocations(const TArray<struct FVector>& Destinations, const struct FVector& EndDirection, float EndDistance, float Speed, bool UsePartialPath)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MercunaSurfaceNavigationComponent", "MoveToLocations");

	Params::MercunaSurfaceNavigationComponent_MoveToLocations Parms{};

	Parms.Destinations = std::move(Destinations);
	Parms.EndDirection = std::move(EndDirection);
	Parms.EndDistance = EndDistance;
	Parms.Speed = Speed;
	Parms.UsePartialPath = UsePartialPath;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Mercuna.MercunaSurfaceNavigationComponent.NavLinkComplete
// (Native, Public, BlueprintCallable)

void UMercunaSurfaceNavigationComponent::NavLinkComplete()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MercunaSurfaceNavigationComponent", "NavLinkComplete");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Mercuna.MercunaSurfaceNavigationComponent.OverrideSpeedMultiplier
// (Native, Public, BlueprintCallable)
// Parameters:
// const float                             NewSpeedMultiplier                                     (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UMercunaSurfaceNavigationComponent::OverrideSpeedMultiplier(const float NewSpeedMultiplier)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MercunaSurfaceNavigationComponent", "OverrideSpeedMultiplier");

	Params::MercunaSurfaceNavigationComponent_OverrideSpeedMultiplier Parms{};

	Parms.NewSpeedMultiplier = NewSpeedMultiplier;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Mercuna.MercunaSurfaceNavigationComponent.PauseNavigation
// (Native, Public, BlueprintCallable)

void UMercunaSurfaceNavigationComponent::PauseNavigation()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MercunaSurfaceNavigationComponent", "PauseNavigation");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Mercuna.MercunaSurfaceNavigationComponent.ResumeNavigation
// (Native, Public, BlueprintCallable)

void UMercunaSurfaceNavigationComponent::ResumeNavigation()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MercunaSurfaceNavigationComponent", "ResumeNavigation");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Mercuna.MercunaSurfaceNavigationComponent.SetAgentType
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// const struct FMercunaSurfaceAgentType&  NewAgentType                                           (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMercunaSurfaceNavigationComponent::SetAgentType(const struct FMercunaSurfaceAgentType& NewAgentType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MercunaSurfaceNavigationComponent", "SetAgentType");

	Params::MercunaSurfaceNavigationComponent_SetAgentType Parms{};

	Parms.NewAgentType = std::move(NewAgentType);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Mercuna.MercunaSurfaceNavigationComponent.SetAvoidanceAgainst
// (Native, Public, BlueprintCallable)
// Parameters:
// class AActor*                           Actor                                                  (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    Enable                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMercunaSurfaceNavigationComponent::SetAvoidanceAgainst(class AActor* Actor, bool Enable)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MercunaSurfaceNavigationComponent", "SetAvoidanceAgainst");

	Params::MercunaSurfaceNavigationComponent_SetAvoidanceAgainst Parms{};

	Parms.Actor = Actor;
	Parms.Enable = Enable;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Mercuna.MercunaSurfaceNavigationComponent.SetNavGrid
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class AMercunaNavSurfaceGrid*           NavSurfaceGrid_0                                       (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMercunaSurfaceNavigationComponent::SetNavGrid(class AMercunaNavSurfaceGrid* NavSurfaceGrid_0)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MercunaSurfaceNavigationComponent", "SetNavGrid");

	Params::MercunaSurfaceNavigationComponent_SetNavGrid Parms{};

	Parms.NavSurfaceGrid_0 = NavSurfaceGrid_0;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Mercuna.MercunaSurfaceNavigationComponent.SetNavGridToBest
// (Final, Native, Public, BlueprintCallable)

void UMercunaSurfaceNavigationComponent::SetNavGridToBest()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MercunaSurfaceNavigationComponent", "SetNavGridToBest");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Mercuna.MercunaSurfaceNavigationComponent.SetUsageSpec
// (Native, Public, BlueprintCallable)
// Parameters:
// const struct FMercunaUsageSpec&         NewUsageSpec                                           (Parm, NoDestructor, NativeAccessSpecifierPublic)

void UMercunaSurfaceNavigationComponent::SetUsageSpec(const struct FMercunaUsageSpec& NewUsageSpec)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MercunaSurfaceNavigationComponent", "SetUsageSpec");

	Params::MercunaSurfaceNavigationComponent_SetUsageSpec Parms{};

	Parms.NewUsageSpec = std::move(NewUsageSpec);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Mercuna.MercunaSurfaceNavigationComponent.Stop
// (Final, Native, Public, BlueprintCallable)

void UMercunaSurfaceNavigationComponent::Stop()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MercunaSurfaceNavigationComponent", "Stop");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Mercuna.MercunaSurfaceNavigationComponent.TrackActor
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// class AActor*                           Actor                                                  (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Distance                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Speed                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FVector&                   Offset                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    UsePartialPath                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bUseEndActorOrientation                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMercunaSurfaceNavigationComponent::TrackActor(class AActor* Actor, float Distance, float Speed, const struct FVector& Offset, bool UsePartialPath, bool bUseEndActorOrientation)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MercunaSurfaceNavigationComponent", "TrackActor");

	Params::MercunaSurfaceNavigationComponent_TrackActor Parms{};

	Parms.Actor = Actor;
	Parms.Distance = Distance;
	Parms.Speed = Speed;
	Parms.Offset = std::move(Offset);
	Parms.UsePartialPath = UsePartialPath;
	Parms.bUseEndActorOrientation = bUseEndActorOrientation;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Mercuna.MercunaSurfaceNavigationComponent.UpdateDynamicSteeringParams
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const struct FMercunaSurfaceNavigationDynamicSteeringParameters&NewDynamicSteeringParams                               (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)

void UMercunaSurfaceNavigationComponent::UpdateDynamicSteeringParams(const struct FMercunaSurfaceNavigationDynamicSteeringParameters& NewDynamicSteeringParams)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MercunaSurfaceNavigationComponent", "UpdateDynamicSteeringParams");

	Params::MercunaSurfaceNavigationComponent_UpdateDynamicSteeringParams Parms{};

	Parms.NewDynamicSteeringParams = std::move(NewDynamicSteeringParams);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Mercuna.MercunaSurfaceNavigationComponent.GetConfiguration
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FMercunaSurfaceNavigationConfigurationReturnValue                                            (Parm, OutParm, ReturnParm, NoDestructor, NativeAccessSpecifierPublic)

struct FMercunaSurfaceNavigationConfiguration UMercunaSurfaceNavigationComponent::GetConfiguration() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MercunaSurfaceNavigationComponent", "GetConfiguration");

	Params::MercunaSurfaceNavigationComponent_GetConfiguration Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Mercuna.MercunaSurfaceNavigationComponent.GetDynamicSteeringParameters
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FMercunaSurfaceNavigationDynamicSteeringParametersReturnValue                                            (Parm, OutParm, ReturnParm, NoDestructor, NativeAccessSpecifierPublic)

struct FMercunaSurfaceNavigationDynamicSteeringParameters UMercunaSurfaceNavigationComponent::GetDynamicSteeringParameters() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MercunaSurfaceNavigationComponent", "GetDynamicSteeringParameters");

	Params::MercunaSurfaceNavigationComponent_GetDynamicSteeringParameters Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Mercuna.MercunaSurfaceNavigationComponent.GetLastRequestedMoveVelocity
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector UMercunaSurfaceNavigationComponent::GetLastRequestedMoveVelocity() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MercunaSurfaceNavigationComponent", "GetLastRequestedMoveVelocity");

	Params::MercunaSurfaceNavigationComponent_GetLastRequestedMoveVelocity Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Mercuna.MercunaSurfaceNavigationComponent.GetNavGrid
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class AMercunaNavSurfaceGrid*           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AMercunaNavSurfaceGrid* UMercunaSurfaceNavigationComponent::GetNavGrid() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MercunaSurfaceNavigationComponent", "GetNavGrid");

	Params::MercunaSurfaceNavigationComponent_GetNavGrid Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Mercuna.MercunaSurfaceNavigationComponent.GetNextNavLink
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool*                                   bNextNavLinkFound                                      (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float*                                  DistanceToNextNavLink                                  (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float*                                  TimeToNextNavLink                                      (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector*                         TraversalStart                                         (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector*                         TraversalEnd                                           (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AMercunaNavLink**                 NavLink                                                (Parm, OutParm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   MaxLookAhead                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMercunaSurfaceNavigationComponent::GetNextNavLink(bool* bNextNavLinkFound, float* DistanceToNextNavLink, float* TimeToNextNavLink, struct FVector* TraversalStart, struct FVector* TraversalEnd, class AMercunaNavLink** NavLink, float MaxLookAhead) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MercunaSurfaceNavigationComponent", "GetNextNavLink");

	Params::MercunaSurfaceNavigationComponent_GetNextNavLink Parms{};

	Parms.MaxLookAhead = MaxLookAhead;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (bNextNavLinkFound != nullptr)
		*bNextNavLinkFound = Parms.bNextNavLinkFound;

	if (DistanceToNextNavLink != nullptr)
		*DistanceToNextNavLink = Parms.DistanceToNextNavLink;

	if (TimeToNextNavLink != nullptr)
		*TimeToNextNavLink = Parms.TimeToNextNavLink;

	if (TraversalStart != nullptr)
		*TraversalStart = std::move(Parms.TraversalStart);

	if (TraversalEnd != nullptr)
		*TraversalEnd = std::move(Parms.TraversalEnd);

	if (NavLink != nullptr)
		*NavLink = Parms.NavLink;
}


// Function Mercuna.MercunaSurfaceNavigationComponent.GetSteeringParameters
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FMercunaSurfaceNavigationSteeringParametersReturnValue                                            (Parm, OutParm, ReturnParm, NoDestructor, NativeAccessSpecifierPublic)

struct FMercunaSurfaceNavigationSteeringParameters UMercunaSurfaceNavigationComponent::GetSteeringParameters() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MercunaSurfaceNavigationComponent", "GetSteeringParameters");

	Params::MercunaSurfaceNavigationComponent_GetSteeringParameters Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Mercuna.MercunaSurfaceNavigationComponent.GetUsageSpec
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const struct FMercunaUsageSpec          ReturnValue                                            (ConstParm, Parm, OutParm, ReturnParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)

const struct FMercunaUsageSpec UMercunaSurfaceNavigationComponent::GetUsageSpec() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MercunaSurfaceNavigationComponent", "GetUsageSpec");

	Params::MercunaSurfaceNavigationComponent_GetUsageSpec Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Mercuna.MercunaSurfaceTask_MoveTo.MoveTo
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable)
// Parameters:
// class AAIController*                    Controller                                             (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FVector&                   GoalLocation                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           GoalActor                                              (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   EndDistance                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    AcceptPartialPath                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bLockAILogic                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UMercunaSurfaceTask_MoveTo*       ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UMercunaSurfaceTask_MoveTo* UMercunaSurfaceTask_MoveTo::MoveTo(class AAIController* Controller, const struct FVector& GoalLocation, class AActor* GoalActor, float EndDistance, bool AcceptPartialPath, bool bLockAILogic)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MercunaSurfaceTask_MoveTo", "MoveTo");

	Params::MercunaSurfaceTask_MoveTo_MoveTo Parms{};

	Parms.Controller = Controller;
	Parms.GoalLocation = std::move(GoalLocation);
	Parms.GoalActor = GoalActor;
	Parms.EndDistance = EndDistance;
	Parms.AcceptPartialPath = AcceptPartialPath;
	Parms.bLockAILogic = bLockAILogic;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Mercuna.MercunaSurfaceTask_MoveTo.OnMoveComplete
// (Native, Protected)
// Parameters:
// const struct FAIRequestID&              RequestID                                              (Parm, NoDestructor, NativeAccessSpecifierPublic)
// EMercunaMoveResult                      Result                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMercunaSurfaceTask_MoveTo::OnMoveComplete(const struct FAIRequestID& RequestID, EMercunaMoveResult Result)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MercunaSurfaceTask_MoveTo", "OnMoveComplete");

	Params::MercunaSurfaceTask_MoveTo_OnMoveComplete Parms{};

	Parms.RequestID = std::move(RequestID);
	Parms.Result = Result;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}

}

