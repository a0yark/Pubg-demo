#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: MultiWorld

#include "Basic.hpp"

#include "MultiWorld_structs.hpp"
#include "CoreUObject_structs.hpp"
#include "Engine_structs.hpp"


namespace SDK::Params
{

// Function MultiWorld.MultiWorldSeamTransition.OnPreWorldEnded
// 0x0008 (0x0008 - 0x0000)
struct MultiWorldSeamTransition_OnPreWorldEnded final
{
public:
	struct FMultiWorldHandle                      InWorldToEnd;                                      // 0x0000(0x0008)(Parm, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(MultiWorldSeamTransition_OnPreWorldEnded) == 0x000008, "Wrong alignment on MultiWorldSeamTransition_OnPreWorldEnded");
static_assert(sizeof(MultiWorldSeamTransition_OnPreWorldEnded) == 0x000008, "Wrong size on MultiWorldSeamTransition_OnPreWorldEnded");
static_assert(offsetof(MultiWorldSeamTransition_OnPreWorldEnded, InWorldToEnd) == 0x000000, "Member 'MultiWorldSeamTransition_OnPreWorldEnded::InWorldToEnd' has a wrong offset!");

// Function MultiWorld.MultiWorldSeamTransition.SetDefaultFXLayerZOrder
// 0x0004 (0x0004 - 0x0000)
struct MultiWorldSeamTransition_SetDefaultFXLayerZOrder final
{
public:
	int32                                         ZOrder;                                            // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MultiWorldSeamTransition_SetDefaultFXLayerZOrder) == 0x000004, "Wrong alignment on MultiWorldSeamTransition_SetDefaultFXLayerZOrder");
static_assert(sizeof(MultiWorldSeamTransition_SetDefaultFXLayerZOrder) == 0x000004, "Wrong size on MultiWorldSeamTransition_SetDefaultFXLayerZOrder");
static_assert(offsetof(MultiWorldSeamTransition_SetDefaultFXLayerZOrder, ZOrder) == 0x000000, "Member 'MultiWorldSeamTransition_SetDefaultFXLayerZOrder::ZOrder' has a wrong offset!");

// Function MultiWorld.MultiWorldSeamTransition.StartTransition
// 0x0038 (0x0038 - 0x0000)
struct MultiWorldSeamTransition_StartTransition final
{
public:
	class UObject*                                WorldContextObject;                                // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FMultiWorldHandle                      InDestinationWorldHandle;                          // 0x0008(0x0008)(Parm, NoDestructor, NativeAccessSpecifierPublic)
	class UMaterialInterface*                     TransitionMaterial;                                // 0x0010(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TDelegate<void()>                             OnTransitionEnd_0;                                 // 0x0018(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DurationInSeconds;                                 // 0x0028(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         WorldSwitchNormalizedTime;                         // 0x002C(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bForceWorldsTickingDuringTransition;               // 0x0030(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAutoHandleAudioFade;                              // 0x0031(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0032(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_33[0x5];                                       // 0x0033(0x0005)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(MultiWorldSeamTransition_StartTransition) == 0x000008, "Wrong alignment on MultiWorldSeamTransition_StartTransition");
static_assert(sizeof(MultiWorldSeamTransition_StartTransition) == 0x000038, "Wrong size on MultiWorldSeamTransition_StartTransition");
static_assert(offsetof(MultiWorldSeamTransition_StartTransition, WorldContextObject) == 0x000000, "Member 'MultiWorldSeamTransition_StartTransition::WorldContextObject' has a wrong offset!");
static_assert(offsetof(MultiWorldSeamTransition_StartTransition, InDestinationWorldHandle) == 0x000008, "Member 'MultiWorldSeamTransition_StartTransition::InDestinationWorldHandle' has a wrong offset!");
static_assert(offsetof(MultiWorldSeamTransition_StartTransition, TransitionMaterial) == 0x000010, "Member 'MultiWorldSeamTransition_StartTransition::TransitionMaterial' has a wrong offset!");
static_assert(offsetof(MultiWorldSeamTransition_StartTransition, OnTransitionEnd_0) == 0x000018, "Member 'MultiWorldSeamTransition_StartTransition::OnTransitionEnd_0' has a wrong offset!");
static_assert(offsetof(MultiWorldSeamTransition_StartTransition, DurationInSeconds) == 0x000028, "Member 'MultiWorldSeamTransition_StartTransition::DurationInSeconds' has a wrong offset!");
static_assert(offsetof(MultiWorldSeamTransition_StartTransition, WorldSwitchNormalizedTime) == 0x00002C, "Member 'MultiWorldSeamTransition_StartTransition::WorldSwitchNormalizedTime' has a wrong offset!");
static_assert(offsetof(MultiWorldSeamTransition_StartTransition, bForceWorldsTickingDuringTransition) == 0x000030, "Member 'MultiWorldSeamTransition_StartTransition::bForceWorldsTickingDuringTransition' has a wrong offset!");
static_assert(offsetof(MultiWorldSeamTransition_StartTransition, bAutoHandleAudioFade) == 0x000031, "Member 'MultiWorldSeamTransition_StartTransition::bAutoHandleAudioFade' has a wrong offset!");
static_assert(offsetof(MultiWorldSeamTransition_StartTransition, ReturnValue) == 0x000032, "Member 'MultiWorldSeamTransition_StartTransition::ReturnValue' has a wrong offset!");

// Function MultiWorld.MultiWorldSeamTransition.IsInTransition
// 0x0001 (0x0001 - 0x0000)
struct MultiWorldSeamTransition_IsInTransition final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MultiWorldSeamTransition_IsInTransition) == 0x000001, "Wrong alignment on MultiWorldSeamTransition_IsInTransition");
static_assert(sizeof(MultiWorldSeamTransition_IsInTransition) == 0x000001, "Wrong size on MultiWorldSeamTransition_IsInTransition");
static_assert(offsetof(MultiWorldSeamTransition_IsInTransition, ReturnValue) == 0x000000, "Member 'MultiWorldSeamTransition_IsInTransition::ReturnValue' has a wrong offset!");

// Function MultiWorld.MultiWorldSeamTransitionFXLayer.SetEffect
// 0x0008 (0x0008 - 0x0000)
struct MultiWorldSeamTransitionFXLayer_SetEffect final
{
public:
	class UMaterialInstance*                      InMaterial;                                        // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MultiWorldSeamTransitionFXLayer_SetEffect) == 0x000008, "Wrong alignment on MultiWorldSeamTransitionFXLayer_SetEffect");
static_assert(sizeof(MultiWorldSeamTransitionFXLayer_SetEffect) == 0x000008, "Wrong size on MultiWorldSeamTransitionFXLayer_SetEffect");
static_assert(offsetof(MultiWorldSeamTransitionFXLayer_SetEffect, InMaterial) == 0x000000, "Member 'MultiWorldSeamTransitionFXLayer_SetEffect::InMaterial' has a wrong offset!");

// Function MultiWorld.MultiWorldStatics.AreWorldsEquals
// 0x0018 (0x0018 - 0x0000)
struct MultiWorldStatics_AreWorldsEquals final
{
public:
	struct FMultiWorldHandle                      InWorldHandleA;                                    // 0x0000(0x0008)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
	struct FMultiWorldHandle                      InWorldHandleB;                                    // 0x0008(0x0008)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0010(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x7];                                       // 0x0011(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(MultiWorldStatics_AreWorldsEquals) == 0x000008, "Wrong alignment on MultiWorldStatics_AreWorldsEquals");
static_assert(sizeof(MultiWorldStatics_AreWorldsEquals) == 0x000018, "Wrong size on MultiWorldStatics_AreWorldsEquals");
static_assert(offsetof(MultiWorldStatics_AreWorldsEquals, InWorldHandleA) == 0x000000, "Member 'MultiWorldStatics_AreWorldsEquals::InWorldHandleA' has a wrong offset!");
static_assert(offsetof(MultiWorldStatics_AreWorldsEquals, InWorldHandleB) == 0x000008, "Member 'MultiWorldStatics_AreWorldsEquals::InWorldHandleB' has a wrong offset!");
static_assert(offsetof(MultiWorldStatics_AreWorldsEquals, ReturnValue) == 0x000010, "Member 'MultiWorldStatics_AreWorldsEquals::ReturnValue' has a wrong offset!");

// Function MultiWorld.MultiWorldStatics.EndWorld
// 0x0018 (0x0018 - 0x0000)
struct MultiWorldStatics_EndWorld final
{
public:
	const class UObject*                          WorldContextObject;                                // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FMultiWorldHandle                      InWorldHandle;                                     // 0x0008(0x0008)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          bCallImmediately;                                  // 0x0010(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x7];                                       // 0x0011(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(MultiWorldStatics_EndWorld) == 0x000008, "Wrong alignment on MultiWorldStatics_EndWorld");
static_assert(sizeof(MultiWorldStatics_EndWorld) == 0x000018, "Wrong size on MultiWorldStatics_EndWorld");
static_assert(offsetof(MultiWorldStatics_EndWorld, WorldContextObject) == 0x000000, "Member 'MultiWorldStatics_EndWorld::WorldContextObject' has a wrong offset!");
static_assert(offsetof(MultiWorldStatics_EndWorld, InWorldHandle) == 0x000008, "Member 'MultiWorldStatics_EndWorld::InWorldHandle' has a wrong offset!");
static_assert(offsetof(MultiWorldStatics_EndWorld, bCallImmediately) == 0x000010, "Member 'MultiWorldStatics_EndWorld::bCallImmediately' has a wrong offset!");

// Function MultiWorld.MultiWorldStatics.ExecuteConsoleCommandInWorld
// 0x0018 (0x0018 - 0x0000)
struct MultiWorldStatics_ExecuteConsoleCommandInWorld final
{
public:
	struct FMultiWorldHandle                      InWorldHandle;                                     // 0x0000(0x0008)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
	class FString                                 Command;                                           // 0x0008(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MultiWorldStatics_ExecuteConsoleCommandInWorld) == 0x000008, "Wrong alignment on MultiWorldStatics_ExecuteConsoleCommandInWorld");
static_assert(sizeof(MultiWorldStatics_ExecuteConsoleCommandInWorld) == 0x000018, "Wrong size on MultiWorldStatics_ExecuteConsoleCommandInWorld");
static_assert(offsetof(MultiWorldStatics_ExecuteConsoleCommandInWorld, InWorldHandle) == 0x000000, "Member 'MultiWorldStatics_ExecuteConsoleCommandInWorld::InWorldHandle' has a wrong offset!");
static_assert(offsetof(MultiWorldStatics_ExecuteConsoleCommandInWorld, Command) == 0x000008, "Member 'MultiWorldStatics_ExecuteConsoleCommandInWorld::Command' has a wrong offset!");

// Function MultiWorld.MultiWorldStatics.GetActiveWorldHandle
// 0x0010 (0x0010 - 0x0000)
struct MultiWorldStatics_GetActiveWorldHandle final
{
public:
	const class UObject*                          WorldContextObject;                                // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FMultiWorldHandle                      ReturnValue;                                       // 0x0008(0x0008)(Parm, OutParm, ReturnParm, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(MultiWorldStatics_GetActiveWorldHandle) == 0x000008, "Wrong alignment on MultiWorldStatics_GetActiveWorldHandle");
static_assert(sizeof(MultiWorldStatics_GetActiveWorldHandle) == 0x000010, "Wrong size on MultiWorldStatics_GetActiveWorldHandle");
static_assert(offsetof(MultiWorldStatics_GetActiveWorldHandle, WorldContextObject) == 0x000000, "Member 'MultiWorldStatics_GetActiveWorldHandle::WorldContextObject' has a wrong offset!");
static_assert(offsetof(MultiWorldStatics_GetActiveWorldHandle, ReturnValue) == 0x000008, "Member 'MultiWorldStatics_GetActiveWorldHandle::ReturnValue' has a wrong offset!");

// Function MultiWorld.MultiWorldStatics.GetActorOfClass
// 0x0018 (0x0018 - 0x0000)
struct MultiWorldStatics_GetActorOfClass final
{
public:
	struct FMultiWorldHandle                      InWorldHandle;                                     // 0x0000(0x0008)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
	TSubclassOf<class AActor>                     ActorClass;                                        // 0x0008(0x0008)(Parm, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 ReturnValue;                                       // 0x0010(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MultiWorldStatics_GetActorOfClass) == 0x000008, "Wrong alignment on MultiWorldStatics_GetActorOfClass");
static_assert(sizeof(MultiWorldStatics_GetActorOfClass) == 0x000018, "Wrong size on MultiWorldStatics_GetActorOfClass");
static_assert(offsetof(MultiWorldStatics_GetActorOfClass, InWorldHandle) == 0x000000, "Member 'MultiWorldStatics_GetActorOfClass::InWorldHandle' has a wrong offset!");
static_assert(offsetof(MultiWorldStatics_GetActorOfClass, ActorClass) == 0x000008, "Member 'MultiWorldStatics_GetActorOfClass::ActorClass' has a wrong offset!");
static_assert(offsetof(MultiWorldStatics_GetActorOfClass, ReturnValue) == 0x000010, "Member 'MultiWorldStatics_GetActorOfClass::ReturnValue' has a wrong offset!");

// Function MultiWorld.MultiWorldStatics.GetAllActorsOfClass
// 0x0020 (0x0020 - 0x0000)
struct MultiWorldStatics_GetAllActorsOfClass final
{
public:
	struct FMultiWorldHandle                      InWorldHandle;                                     // 0x0000(0x0008)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
	TSubclassOf<class AActor>                     ActorClass;                                        // 0x0008(0x0008)(Parm, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class AActor*>                         OutActors;                                         // 0x0010(0x0010)(Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(MultiWorldStatics_GetAllActorsOfClass) == 0x000008, "Wrong alignment on MultiWorldStatics_GetAllActorsOfClass");
static_assert(sizeof(MultiWorldStatics_GetAllActorsOfClass) == 0x000020, "Wrong size on MultiWorldStatics_GetAllActorsOfClass");
static_assert(offsetof(MultiWorldStatics_GetAllActorsOfClass, InWorldHandle) == 0x000000, "Member 'MultiWorldStatics_GetAllActorsOfClass::InWorldHandle' has a wrong offset!");
static_assert(offsetof(MultiWorldStatics_GetAllActorsOfClass, ActorClass) == 0x000008, "Member 'MultiWorldStatics_GetAllActorsOfClass::ActorClass' has a wrong offset!");
static_assert(offsetof(MultiWorldStatics_GetAllActorsOfClass, OutActors) == 0x000010, "Member 'MultiWorldStatics_GetAllActorsOfClass::OutActors' has a wrong offset!");

// Function MultiWorld.MultiWorldStatics.GetAllActorsOfClassWithTag
// 0x0028 (0x0028 - 0x0000)
struct MultiWorldStatics_GetAllActorsOfClassWithTag final
{
public:
	struct FMultiWorldHandle                      InWorldHandle;                                     // 0x0000(0x0008)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
	TSubclassOf<class AActor>                     ActorClass;                                        // 0x0008(0x0008)(Parm, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Tag;                                               // 0x0010(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class AActor*>                         OutActors;                                         // 0x0018(0x0010)(Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(MultiWorldStatics_GetAllActorsOfClassWithTag) == 0x000008, "Wrong alignment on MultiWorldStatics_GetAllActorsOfClassWithTag");
static_assert(sizeof(MultiWorldStatics_GetAllActorsOfClassWithTag) == 0x000028, "Wrong size on MultiWorldStatics_GetAllActorsOfClassWithTag");
static_assert(offsetof(MultiWorldStatics_GetAllActorsOfClassWithTag, InWorldHandle) == 0x000000, "Member 'MultiWorldStatics_GetAllActorsOfClassWithTag::InWorldHandle' has a wrong offset!");
static_assert(offsetof(MultiWorldStatics_GetAllActorsOfClassWithTag, ActorClass) == 0x000008, "Member 'MultiWorldStatics_GetAllActorsOfClassWithTag::ActorClass' has a wrong offset!");
static_assert(offsetof(MultiWorldStatics_GetAllActorsOfClassWithTag, Tag) == 0x000010, "Member 'MultiWorldStatics_GetAllActorsOfClassWithTag::Tag' has a wrong offset!");
static_assert(offsetof(MultiWorldStatics_GetAllActorsOfClassWithTag, OutActors) == 0x000018, "Member 'MultiWorldStatics_GetAllActorsOfClassWithTag::OutActors' has a wrong offset!");

// Function MultiWorld.MultiWorldStatics.GetAllActorsWithInterface
// 0x0020 (0x0020 - 0x0000)
struct MultiWorldStatics_GetAllActorsWithInterface final
{
public:
	struct FMultiWorldHandle                      InWorldHandle;                                     // 0x0000(0x0008)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
	TSubclassOf<class IInterface>                 Interface;                                         // 0x0008(0x0008)(Parm, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class AActor*>                         OutActors;                                         // 0x0010(0x0010)(Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(MultiWorldStatics_GetAllActorsWithInterface) == 0x000008, "Wrong alignment on MultiWorldStatics_GetAllActorsWithInterface");
static_assert(sizeof(MultiWorldStatics_GetAllActorsWithInterface) == 0x000020, "Wrong size on MultiWorldStatics_GetAllActorsWithInterface");
static_assert(offsetof(MultiWorldStatics_GetAllActorsWithInterface, InWorldHandle) == 0x000000, "Member 'MultiWorldStatics_GetAllActorsWithInterface::InWorldHandle' has a wrong offset!");
static_assert(offsetof(MultiWorldStatics_GetAllActorsWithInterface, Interface) == 0x000008, "Member 'MultiWorldStatics_GetAllActorsWithInterface::Interface' has a wrong offset!");
static_assert(offsetof(MultiWorldStatics_GetAllActorsWithInterface, OutActors) == 0x000010, "Member 'MultiWorldStatics_GetAllActorsWithInterface::OutActors' has a wrong offset!");

// Function MultiWorld.MultiWorldStatics.GetAllActorsWithTag
// 0x0020 (0x0020 - 0x0000)
struct MultiWorldStatics_GetAllActorsWithTag final
{
public:
	struct FMultiWorldHandle                      InWorldHandle;                                     // 0x0000(0x0008)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
	class FName                                   Tag;                                               // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class AActor*>                         OutActors;                                         // 0x0010(0x0010)(Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(MultiWorldStatics_GetAllActorsWithTag) == 0x000008, "Wrong alignment on MultiWorldStatics_GetAllActorsWithTag");
static_assert(sizeof(MultiWorldStatics_GetAllActorsWithTag) == 0x000020, "Wrong size on MultiWorldStatics_GetAllActorsWithTag");
static_assert(offsetof(MultiWorldStatics_GetAllActorsWithTag, InWorldHandle) == 0x000000, "Member 'MultiWorldStatics_GetAllActorsWithTag::InWorldHandle' has a wrong offset!");
static_assert(offsetof(MultiWorldStatics_GetAllActorsWithTag, Tag) == 0x000008, "Member 'MultiWorldStatics_GetAllActorsWithTag::Tag' has a wrong offset!");
static_assert(offsetof(MultiWorldStatics_GetAllActorsWithTag, OutActors) == 0x000010, "Member 'MultiWorldStatics_GetAllActorsWithTag::OutActors' has a wrong offset!");

// Function MultiWorld.MultiWorldStatics.GetAllObjectsWithInterface
// 0x0020 (0x0020 - 0x0000)
struct MultiWorldStatics_GetAllObjectsWithInterface final
{
public:
	struct FMultiWorldHandle                      InWorldHandle;                                     // 0x0000(0x0008)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
	TSubclassOf<class IInterface>                 Interface;                                         // 0x0008(0x0008)(Parm, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class UObject*>                        OutObjects;                                        // 0x0010(0x0010)(Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(MultiWorldStatics_GetAllObjectsWithInterface) == 0x000008, "Wrong alignment on MultiWorldStatics_GetAllObjectsWithInterface");
static_assert(sizeof(MultiWorldStatics_GetAllObjectsWithInterface) == 0x000020, "Wrong size on MultiWorldStatics_GetAllObjectsWithInterface");
static_assert(offsetof(MultiWorldStatics_GetAllObjectsWithInterface, InWorldHandle) == 0x000000, "Member 'MultiWorldStatics_GetAllObjectsWithInterface::InWorldHandle' has a wrong offset!");
static_assert(offsetof(MultiWorldStatics_GetAllObjectsWithInterface, Interface) == 0x000008, "Member 'MultiWorldStatics_GetAllObjectsWithInterface::Interface' has a wrong offset!");
static_assert(offsetof(MultiWorldStatics_GetAllObjectsWithInterface, OutObjects) == 0x000010, "Member 'MultiWorldStatics_GetAllObjectsWithInterface::OutObjects' has a wrong offset!");

// Function MultiWorld.MultiWorldStatics.GetMainWorldHandle
// 0x0010 (0x0010 - 0x0000)
struct MultiWorldStatics_GetMainWorldHandle final
{
public:
	const class UObject*                          WorldContextObject;                                // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FMultiWorldHandle                      ReturnValue;                                       // 0x0008(0x0008)(Parm, OutParm, ReturnParm, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(MultiWorldStatics_GetMainWorldHandle) == 0x000008, "Wrong alignment on MultiWorldStatics_GetMainWorldHandle");
static_assert(sizeof(MultiWorldStatics_GetMainWorldHandle) == 0x000010, "Wrong size on MultiWorldStatics_GetMainWorldHandle");
static_assert(offsetof(MultiWorldStatics_GetMainWorldHandle, WorldContextObject) == 0x000000, "Member 'MultiWorldStatics_GetMainWorldHandle::WorldContextObject' has a wrong offset!");
static_assert(offsetof(MultiWorldStatics_GetMainWorldHandle, ReturnValue) == 0x000008, "Member 'MultiWorldStatics_GetMainWorldHandle::ReturnValue' has a wrong offset!");

// Function MultiWorld.MultiWorldStatics.GetPlayerController
// 0x0018 (0x0018 - 0x0000)
struct MultiWorldStatics_GetPlayerController final
{
public:
	const class UObject*                          WorldContextObject;                                // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         PlayerIndex;                                       // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class APlayerController*                      ReturnValue;                                       // 0x0010(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MultiWorldStatics_GetPlayerController) == 0x000008, "Wrong alignment on MultiWorldStatics_GetPlayerController");
static_assert(sizeof(MultiWorldStatics_GetPlayerController) == 0x000018, "Wrong size on MultiWorldStatics_GetPlayerController");
static_assert(offsetof(MultiWorldStatics_GetPlayerController, WorldContextObject) == 0x000000, "Member 'MultiWorldStatics_GetPlayerController::WorldContextObject' has a wrong offset!");
static_assert(offsetof(MultiWorldStatics_GetPlayerController, PlayerIndex) == 0x000008, "Member 'MultiWorldStatics_GetPlayerController::PlayerIndex' has a wrong offset!");
static_assert(offsetof(MultiWorldStatics_GetPlayerController, ReturnValue) == 0x000010, "Member 'MultiWorldStatics_GetPlayerController::ReturnValue' has a wrong offset!");

// Function MultiWorld.MultiWorldStatics.GetThisWorldHandle
// 0x0010 (0x0010 - 0x0000)
struct MultiWorldStatics_GetThisWorldHandle final
{
public:
	const class UObject*                          WorldContextObject;                                // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FMultiWorldHandle                      ReturnValue;                                       // 0x0008(0x0008)(Parm, OutParm, ReturnParm, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(MultiWorldStatics_GetThisWorldHandle) == 0x000008, "Wrong alignment on MultiWorldStatics_GetThisWorldHandle");
static_assert(sizeof(MultiWorldStatics_GetThisWorldHandle) == 0x000010, "Wrong size on MultiWorldStatics_GetThisWorldHandle");
static_assert(offsetof(MultiWorldStatics_GetThisWorldHandle, WorldContextObject) == 0x000000, "Member 'MultiWorldStatics_GetThisWorldHandle::WorldContextObject' has a wrong offset!");
static_assert(offsetof(MultiWorldStatics_GetThisWorldHandle, ReturnValue) == 0x000008, "Member 'MultiWorldStatics_GetThisWorldHandle::ReturnValue' has a wrong offset!");

// Function MultiWorld.MultiWorldStatics.GetWorldHandleByName
// 0x0018 (0x0018 - 0x0000)
struct MultiWorldStatics_GetWorldHandleByName final
{
public:
	const class UObject*                          WorldContextObject;                                // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   WorldName;                                         // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FMultiWorldHandle                      ReturnValue;                                       // 0x0010(0x0008)(Parm, OutParm, ReturnParm, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(MultiWorldStatics_GetWorldHandleByName) == 0x000008, "Wrong alignment on MultiWorldStatics_GetWorldHandleByName");
static_assert(sizeof(MultiWorldStatics_GetWorldHandleByName) == 0x000018, "Wrong size on MultiWorldStatics_GetWorldHandleByName");
static_assert(offsetof(MultiWorldStatics_GetWorldHandleByName, WorldContextObject) == 0x000000, "Member 'MultiWorldStatics_GetWorldHandleByName::WorldContextObject' has a wrong offset!");
static_assert(offsetof(MultiWorldStatics_GetWorldHandleByName, WorldName) == 0x000008, "Member 'MultiWorldStatics_GetWorldHandleByName::WorldName' has a wrong offset!");
static_assert(offsetof(MultiWorldStatics_GetWorldHandleByName, ReturnValue) == 0x000010, "Member 'MultiWorldStatics_GetWorldHandleByName::ReturnValue' has a wrong offset!");

// Function MultiWorld.MultiWorldStatics.InitializeWorld
// 0x0010 (0x0010 - 0x0000)
struct MultiWorldStatics_InitializeWorld final
{
public:
	const class UObject*                          WorldContextObject;                                // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FMultiWorldHandle                      InWorldHandle;                                     // 0x0008(0x0008)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(MultiWorldStatics_InitializeWorld) == 0x000008, "Wrong alignment on MultiWorldStatics_InitializeWorld");
static_assert(sizeof(MultiWorldStatics_InitializeWorld) == 0x000010, "Wrong size on MultiWorldStatics_InitializeWorld");
static_assert(offsetof(MultiWorldStatics_InitializeWorld, WorldContextObject) == 0x000000, "Member 'MultiWorldStatics_InitializeWorld::WorldContextObject' has a wrong offset!");
static_assert(offsetof(MultiWorldStatics_InitializeWorld, InWorldHandle) == 0x000008, "Member 'MultiWorldStatics_InitializeWorld::InWorldHandle' has a wrong offset!");

// Function MultiWorld.MultiWorldStatics.IsValidHandle
// 0x0018 (0x0018 - 0x0000)
struct MultiWorldStatics_IsValidHandle final
{
public:
	const class UObject*                          WorldContextObject;                                // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FMultiWorldHandle                      InWorldHandle;                                     // 0x0008(0x0008)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0010(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x7];                                       // 0x0011(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(MultiWorldStatics_IsValidHandle) == 0x000008, "Wrong alignment on MultiWorldStatics_IsValidHandle");
static_assert(sizeof(MultiWorldStatics_IsValidHandle) == 0x000018, "Wrong size on MultiWorldStatics_IsValidHandle");
static_assert(offsetof(MultiWorldStatics_IsValidHandle, WorldContextObject) == 0x000000, "Member 'MultiWorldStatics_IsValidHandle::WorldContextObject' has a wrong offset!");
static_assert(offsetof(MultiWorldStatics_IsValidHandle, InWorldHandle) == 0x000008, "Member 'MultiWorldStatics_IsValidHandle::InWorldHandle' has a wrong offset!");
static_assert(offsetof(MultiWorldStatics_IsValidHandle, ReturnValue) == 0x000010, "Member 'MultiWorldStatics_IsValidHandle::ReturnValue' has a wrong offset!");

// Function MultiWorld.MultiWorldStatics.LoadWorldAsyncWithDelegate
// 0x0068 (0x0068 - 0x0000)
struct MultiWorldStatics_LoadWorldAsyncWithDelegate final
{
public:
	const class UObject*                          WorldContextObject;                                // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UWorld>                  InMapAsset;                                        // 0x0008(0x0030)(Parm, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FMultiWorldLoadParameters              InParams;                                          // 0x0038(0x0020)(Parm, NoDestructor, NativeAccessSpecifierPublic)
	TDelegate<void(bool Success, const struct FMultiWorldHandle& WorldHandle, const struct FMultiWorldLoadParameters& LoadParams)> OnComplete; // 0x0058(0x0010)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MultiWorldStatics_LoadWorldAsyncWithDelegate) == 0x000008, "Wrong alignment on MultiWorldStatics_LoadWorldAsyncWithDelegate");
static_assert(sizeof(MultiWorldStatics_LoadWorldAsyncWithDelegate) == 0x000068, "Wrong size on MultiWorldStatics_LoadWorldAsyncWithDelegate");
static_assert(offsetof(MultiWorldStatics_LoadWorldAsyncWithDelegate, WorldContextObject) == 0x000000, "Member 'MultiWorldStatics_LoadWorldAsyncWithDelegate::WorldContextObject' has a wrong offset!");
static_assert(offsetof(MultiWorldStatics_LoadWorldAsyncWithDelegate, InMapAsset) == 0x000008, "Member 'MultiWorldStatics_LoadWorldAsyncWithDelegate::InMapAsset' has a wrong offset!");
static_assert(offsetof(MultiWorldStatics_LoadWorldAsyncWithDelegate, InParams) == 0x000038, "Member 'MultiWorldStatics_LoadWorldAsyncWithDelegate::InParams' has a wrong offset!");
static_assert(offsetof(MultiWorldStatics_LoadWorldAsyncWithDelegate, OnComplete) == 0x000058, "Member 'MultiWorldStatics_LoadWorldAsyncWithDelegate::OnComplete' has a wrong offset!");

// Function MultiWorld.MultiWorldStatics.LoadWorldWithDelegate
// 0x0068 (0x0068 - 0x0000)
struct MultiWorldStatics_LoadWorldWithDelegate final
{
public:
	const class UObject*                          WorldContextObject;                                // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UWorld>                  InMapAsset;                                        // 0x0008(0x0030)(Parm, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FMultiWorldLoadParameters              InParams;                                          // 0x0038(0x0020)(Parm, NoDestructor, NativeAccessSpecifierPublic)
	TDelegate<void(bool Success, const struct FMultiWorldHandle& WorldHandle, const struct FMultiWorldLoadParameters& LoadParams)> OnComplete; // 0x0058(0x0010)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MultiWorldStatics_LoadWorldWithDelegate) == 0x000008, "Wrong alignment on MultiWorldStatics_LoadWorldWithDelegate");
static_assert(sizeof(MultiWorldStatics_LoadWorldWithDelegate) == 0x000068, "Wrong size on MultiWorldStatics_LoadWorldWithDelegate");
static_assert(offsetof(MultiWorldStatics_LoadWorldWithDelegate, WorldContextObject) == 0x000000, "Member 'MultiWorldStatics_LoadWorldWithDelegate::WorldContextObject' has a wrong offset!");
static_assert(offsetof(MultiWorldStatics_LoadWorldWithDelegate, InMapAsset) == 0x000008, "Member 'MultiWorldStatics_LoadWorldWithDelegate::InMapAsset' has a wrong offset!");
static_assert(offsetof(MultiWorldStatics_LoadWorldWithDelegate, InParams) == 0x000038, "Member 'MultiWorldStatics_LoadWorldWithDelegate::InParams' has a wrong offset!");
static_assert(offsetof(MultiWorldStatics_LoadWorldWithDelegate, OnComplete) == 0x000058, "Member 'MultiWorldStatics_LoadWorldWithDelegate::OnComplete' has a wrong offset!");

// Function MultiWorld.MultiWorldStatics.RequestSwitchWorld
// 0x0010 (0x0010 - 0x0000)
struct MultiWorldStatics_RequestSwitchWorld final
{
public:
	const class UObject*                          WorldContextObject;                                // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FMultiWorldHandle                      InWorldHandle;                                     // 0x0008(0x0008)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(MultiWorldStatics_RequestSwitchWorld) == 0x000008, "Wrong alignment on MultiWorldStatics_RequestSwitchWorld");
static_assert(sizeof(MultiWorldStatics_RequestSwitchWorld) == 0x000010, "Wrong size on MultiWorldStatics_RequestSwitchWorld");
static_assert(offsetof(MultiWorldStatics_RequestSwitchWorld, WorldContextObject) == 0x000000, "Member 'MultiWorldStatics_RequestSwitchWorld::WorldContextObject' has a wrong offset!");
static_assert(offsetof(MultiWorldStatics_RequestSwitchWorld, InWorldHandle) == 0x000008, "Member 'MultiWorldStatics_RequestSwitchWorld::InWorldHandle' has a wrong offset!");

// Function MultiWorld.MultiWorldStatics.ReturnToMainWorld
// 0x0010 (0x0010 - 0x0000)
struct MultiWorldStatics_ReturnToMainWorld final
{
public:
	const class UObject*                          WorldContextObject;                                // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0008(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(MultiWorldStatics_ReturnToMainWorld) == 0x000008, "Wrong alignment on MultiWorldStatics_ReturnToMainWorld");
static_assert(sizeof(MultiWorldStatics_ReturnToMainWorld) == 0x000010, "Wrong size on MultiWorldStatics_ReturnToMainWorld");
static_assert(offsetof(MultiWorldStatics_ReturnToMainWorld, WorldContextObject) == 0x000000, "Member 'MultiWorldStatics_ReturnToMainWorld::WorldContextObject' has a wrong offset!");
static_assert(offsetof(MultiWorldStatics_ReturnToMainWorld, ReturnValue) == 0x000008, "Member 'MultiWorldStatics_ReturnToMainWorld::ReturnValue' has a wrong offset!");

// Function MultiWorld.MultiWorldStatics.SetAutoHandleWidgetsForMainWorld
// 0x0010 (0x0010 - 0x0000)
struct MultiWorldStatics_SetAutoHandleWidgetsForMainWorld final
{
public:
	const class UObject*                          WorldContextObject;                                // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAutoHandleWidgets;                                // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(MultiWorldStatics_SetAutoHandleWidgetsForMainWorld) == 0x000008, "Wrong alignment on MultiWorldStatics_SetAutoHandleWidgetsForMainWorld");
static_assert(sizeof(MultiWorldStatics_SetAutoHandleWidgetsForMainWorld) == 0x000010, "Wrong size on MultiWorldStatics_SetAutoHandleWidgetsForMainWorld");
static_assert(offsetof(MultiWorldStatics_SetAutoHandleWidgetsForMainWorld, WorldContextObject) == 0x000000, "Member 'MultiWorldStatics_SetAutoHandleWidgetsForMainWorld::WorldContextObject' has a wrong offset!");
static_assert(offsetof(MultiWorldStatics_SetAutoHandleWidgetsForMainWorld, bAutoHandleWidgets) == 0x000008, "Member 'MultiWorldStatics_SetAutoHandleWidgetsForMainWorld::bAutoHandleWidgets' has a wrong offset!");

// Function MultiWorld.MultiWorldStatics.SetPhysicsActorTransform
// 0x0080 (0x0080 - 0x0000)
struct MultiWorldStatics_SetPhysicsActorTransform final
{
public:
	class AActor*                                 Actor;                                             // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_8[0x8];                                        // 0x0008(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             NewTransform;                                      // 0x0010(0x0060)(ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETeleportType                                 Teleport;                                          // 0x0070(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_71[0xF];                                       // 0x0071(0x000F)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(MultiWorldStatics_SetPhysicsActorTransform) == 0x000010, "Wrong alignment on MultiWorldStatics_SetPhysicsActorTransform");
static_assert(sizeof(MultiWorldStatics_SetPhysicsActorTransform) == 0x000080, "Wrong size on MultiWorldStatics_SetPhysicsActorTransform");
static_assert(offsetof(MultiWorldStatics_SetPhysicsActorTransform, Actor) == 0x000000, "Member 'MultiWorldStatics_SetPhysicsActorTransform::Actor' has a wrong offset!");
static_assert(offsetof(MultiWorldStatics_SetPhysicsActorTransform, NewTransform) == 0x000010, "Member 'MultiWorldStatics_SetPhysicsActorTransform::NewTransform' has a wrong offset!");
static_assert(offsetof(MultiWorldStatics_SetPhysicsActorTransform, Teleport) == 0x000070, "Member 'MultiWorldStatics_SetPhysicsActorTransform::Teleport' has a wrong offset!");

// Function MultiWorld.MultiWorldStatics.SetShouldTickWhenInBackground
// 0x0018 (0x0018 - 0x0000)
struct MultiWorldStatics_SetShouldTickWhenInBackground final
{
public:
	const class UObject*                          WorldContextObject;                                // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FMultiWorldHandle                      InWorldHandle;                                     // 0x0008(0x0008)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          bShouldTick;                                       // 0x0010(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x7];                                       // 0x0011(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(MultiWorldStatics_SetShouldTickWhenInBackground) == 0x000008, "Wrong alignment on MultiWorldStatics_SetShouldTickWhenInBackground");
static_assert(sizeof(MultiWorldStatics_SetShouldTickWhenInBackground) == 0x000018, "Wrong size on MultiWorldStatics_SetShouldTickWhenInBackground");
static_assert(offsetof(MultiWorldStatics_SetShouldTickWhenInBackground, WorldContextObject) == 0x000000, "Member 'MultiWorldStatics_SetShouldTickWhenInBackground::WorldContextObject' has a wrong offset!");
static_assert(offsetof(MultiWorldStatics_SetShouldTickWhenInBackground, InWorldHandle) == 0x000008, "Member 'MultiWorldStatics_SetShouldTickWhenInBackground::InWorldHandle' has a wrong offset!");
static_assert(offsetof(MultiWorldStatics_SetShouldTickWhenInBackground, bShouldTick) == 0x000010, "Member 'MultiWorldStatics_SetShouldTickWhenInBackground::bShouldTick' has a wrong offset!");

// Function MultiWorld.MultiWorldStatics.SpawnActorInWorld
// 0x00A0 (0x00A0 - 0x0000)
struct MultiWorldStatics_SpawnActorInWorld final
{
public:
	const class UObject*                          WorldContextObject;                                // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class AActor>                     ActorClass;                                        // 0x0008(0x0008)(Parm, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FMultiWorldHandle                      InWorldHandle;                                     // 0x0010(0x0008)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_18[0x8];                                       // 0x0018(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             SpawnTransform;                                    // 0x0020(0x0060)(ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ESpawnActorCollisionHandlingMethod            CollisionHandlingOverride;                         // 0x0080(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_81[0x7];                                       // 0x0081(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class AActor*                                 Owner;                                             // 0x0088(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 ReturnValue;                                       // 0x0090(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_98[0x8];                                       // 0x0098(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(MultiWorldStatics_SpawnActorInWorld) == 0x000010, "Wrong alignment on MultiWorldStatics_SpawnActorInWorld");
static_assert(sizeof(MultiWorldStatics_SpawnActorInWorld) == 0x0000A0, "Wrong size on MultiWorldStatics_SpawnActorInWorld");
static_assert(offsetof(MultiWorldStatics_SpawnActorInWorld, WorldContextObject) == 0x000000, "Member 'MultiWorldStatics_SpawnActorInWorld::WorldContextObject' has a wrong offset!");
static_assert(offsetof(MultiWorldStatics_SpawnActorInWorld, ActorClass) == 0x000008, "Member 'MultiWorldStatics_SpawnActorInWorld::ActorClass' has a wrong offset!");
static_assert(offsetof(MultiWorldStatics_SpawnActorInWorld, InWorldHandle) == 0x000010, "Member 'MultiWorldStatics_SpawnActorInWorld::InWorldHandle' has a wrong offset!");
static_assert(offsetof(MultiWorldStatics_SpawnActorInWorld, SpawnTransform) == 0x000020, "Member 'MultiWorldStatics_SpawnActorInWorld::SpawnTransform' has a wrong offset!");
static_assert(offsetof(MultiWorldStatics_SpawnActorInWorld, CollisionHandlingOverride) == 0x000080, "Member 'MultiWorldStatics_SpawnActorInWorld::CollisionHandlingOverride' has a wrong offset!");
static_assert(offsetof(MultiWorldStatics_SpawnActorInWorld, Owner) == 0x000088, "Member 'MultiWorldStatics_SpawnActorInWorld::Owner' has a wrong offset!");
static_assert(offsetof(MultiWorldStatics_SpawnActorInWorld, ReturnValue) == 0x000090, "Member 'MultiWorldStatics_SpawnActorInWorld::ReturnValue' has a wrong offset!");

// Function MultiWorld.MultiWorldStatics.SwitchWorld
// 0x0018 (0x0018 - 0x0000)
struct MultiWorldStatics_SwitchWorld final
{
public:
	const class UObject*                          WorldContextObject;                                // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FMultiWorldHandle                      InWorldHandle;                                     // 0x0008(0x0008)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0010(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x7];                                       // 0x0011(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(MultiWorldStatics_SwitchWorld) == 0x000008, "Wrong alignment on MultiWorldStatics_SwitchWorld");
static_assert(sizeof(MultiWorldStatics_SwitchWorld) == 0x000018, "Wrong size on MultiWorldStatics_SwitchWorld");
static_assert(offsetof(MultiWorldStatics_SwitchWorld, WorldContextObject) == 0x000000, "Member 'MultiWorldStatics_SwitchWorld::WorldContextObject' has a wrong offset!");
static_assert(offsetof(MultiWorldStatics_SwitchWorld, InWorldHandle) == 0x000008, "Member 'MultiWorldStatics_SwitchWorld::InWorldHandle' has a wrong offset!");
static_assert(offsetof(MultiWorldStatics_SwitchWorld, ReturnValue) == 0x000010, "Member 'MultiWorldStatics_SwitchWorld::ReturnValue' has a wrong offset!");

// Function MultiWorld.MultiWorldStatics.TransferActorToWorld
// 0x00A0 (0x00A0 - 0x0000)
struct MultiWorldStatics_TransferActorToWorld final
{
public:
	const class UObject*                          WorldContextObject;                                // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 InActor;                                           // 0x0008(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FMultiWorldHandle                      InWorldHandle;                                     // 0x0010(0x0008)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_18[0x8];                                       // 0x0018(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FMultiWorldTransferActorParameters     OPTIONS;                                           // 0x0020(0x0080)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(MultiWorldStatics_TransferActorToWorld) == 0x000010, "Wrong alignment on MultiWorldStatics_TransferActorToWorld");
static_assert(sizeof(MultiWorldStatics_TransferActorToWorld) == 0x0000A0, "Wrong size on MultiWorldStatics_TransferActorToWorld");
static_assert(offsetof(MultiWorldStatics_TransferActorToWorld, WorldContextObject) == 0x000000, "Member 'MultiWorldStatics_TransferActorToWorld::WorldContextObject' has a wrong offset!");
static_assert(offsetof(MultiWorldStatics_TransferActorToWorld, InActor) == 0x000008, "Member 'MultiWorldStatics_TransferActorToWorld::InActor' has a wrong offset!");
static_assert(offsetof(MultiWorldStatics_TransferActorToWorld, InWorldHandle) == 0x000010, "Member 'MultiWorldStatics_TransferActorToWorld::InWorldHandle' has a wrong offset!");
static_assert(offsetof(MultiWorldStatics_TransferActorToWorld, OPTIONS) == 0x000020, "Member 'MultiWorldStatics_TransferActorToWorld::OPTIONS' has a wrong offset!");

// Function MultiWorld.LoadWorldAction.LoadWorld
// 0x0060 (0x0060 - 0x0000)
struct LoadWorldAction_LoadWorld final
{
public:
	class UObject*                                WorldContextObject;                                // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UWorld>                  InMapAsset;                                        // 0x0008(0x0030)(Parm, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FMultiWorldLoadParameters              InParams;                                          // 0x0038(0x0020)(Parm, NoDestructor, NativeAccessSpecifierPublic)
	class ULoadWorldAction*                       ReturnValue;                                       // 0x0058(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LoadWorldAction_LoadWorld) == 0x000008, "Wrong alignment on LoadWorldAction_LoadWorld");
static_assert(sizeof(LoadWorldAction_LoadWorld) == 0x000060, "Wrong size on LoadWorldAction_LoadWorld");
static_assert(offsetof(LoadWorldAction_LoadWorld, WorldContextObject) == 0x000000, "Member 'LoadWorldAction_LoadWorld::WorldContextObject' has a wrong offset!");
static_assert(offsetof(LoadWorldAction_LoadWorld, InMapAsset) == 0x000008, "Member 'LoadWorldAction_LoadWorld::InMapAsset' has a wrong offset!");
static_assert(offsetof(LoadWorldAction_LoadWorld, InParams) == 0x000038, "Member 'LoadWorldAction_LoadWorld::InParams' has a wrong offset!");
static_assert(offsetof(LoadWorldAction_LoadWorld, ReturnValue) == 0x000058, "Member 'LoadWorldAction_LoadWorld::ReturnValue' has a wrong offset!");

// Function MultiWorld.LoadWorldAction.OnCompleted
// 0x0030 (0x0030 - 0x0000)
struct LoadWorldAction_OnCompleted final
{
public:
	bool                                          Success;                                           // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FMultiWorldHandle                      WorldHandle;                                       // 0x0008(0x0008)(Parm, NoDestructor, NativeAccessSpecifierPublic)
	struct FMultiWorldLoadParameters              LoadParams;                                        // 0x0010(0x0020)(Parm, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(LoadWorldAction_OnCompleted) == 0x000008, "Wrong alignment on LoadWorldAction_OnCompleted");
static_assert(sizeof(LoadWorldAction_OnCompleted) == 0x000030, "Wrong size on LoadWorldAction_OnCompleted");
static_assert(offsetof(LoadWorldAction_OnCompleted, Success) == 0x000000, "Member 'LoadWorldAction_OnCompleted::Success' has a wrong offset!");
static_assert(offsetof(LoadWorldAction_OnCompleted, WorldHandle) == 0x000008, "Member 'LoadWorldAction_OnCompleted::WorldHandle' has a wrong offset!");
static_assert(offsetof(LoadWorldAction_OnCompleted, LoadParams) == 0x000010, "Member 'LoadWorldAction_OnCompleted::LoadParams' has a wrong offset!");

// Function MultiWorld.LoadWorldAsyncAction.LoadWorldAsync
// 0x0060 (0x0060 - 0x0000)
struct LoadWorldAsyncAction_LoadWorldAsync final
{
public:
	class UObject*                                WorldContextObject;                                // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UWorld>                  InMapAsset;                                        // 0x0008(0x0030)(Parm, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FMultiWorldLoadParameters              InParams;                                          // 0x0038(0x0020)(Parm, NoDestructor, NativeAccessSpecifierPublic)
	class ULoadWorldAsyncAction*                  ReturnValue;                                       // 0x0058(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LoadWorldAsyncAction_LoadWorldAsync) == 0x000008, "Wrong alignment on LoadWorldAsyncAction_LoadWorldAsync");
static_assert(sizeof(LoadWorldAsyncAction_LoadWorldAsync) == 0x000060, "Wrong size on LoadWorldAsyncAction_LoadWorldAsync");
static_assert(offsetof(LoadWorldAsyncAction_LoadWorldAsync, WorldContextObject) == 0x000000, "Member 'LoadWorldAsyncAction_LoadWorldAsync::WorldContextObject' has a wrong offset!");
static_assert(offsetof(LoadWorldAsyncAction_LoadWorldAsync, InMapAsset) == 0x000008, "Member 'LoadWorldAsyncAction_LoadWorldAsync::InMapAsset' has a wrong offset!");
static_assert(offsetof(LoadWorldAsyncAction_LoadWorldAsync, InParams) == 0x000038, "Member 'LoadWorldAsyncAction_LoadWorldAsync::InParams' has a wrong offset!");
static_assert(offsetof(LoadWorldAsyncAction_LoadWorldAsync, ReturnValue) == 0x000058, "Member 'LoadWorldAsyncAction_LoadWorldAsync::ReturnValue' has a wrong offset!");

// Function MultiWorld.LoadWorldAsyncAction.OnCompleted
// 0x0030 (0x0030 - 0x0000)
struct LoadWorldAsyncAction_OnCompleted final
{
public:
	bool                                          Success;                                           // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FMultiWorldHandle                      WorldHandle;                                       // 0x0008(0x0008)(Parm, NoDestructor, NativeAccessSpecifierPublic)
	struct FMultiWorldLoadParameters              LoadParams;                                        // 0x0010(0x0020)(Parm, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(LoadWorldAsyncAction_OnCompleted) == 0x000008, "Wrong alignment on LoadWorldAsyncAction_OnCompleted");
static_assert(sizeof(LoadWorldAsyncAction_OnCompleted) == 0x000030, "Wrong size on LoadWorldAsyncAction_OnCompleted");
static_assert(offsetof(LoadWorldAsyncAction_OnCompleted, Success) == 0x000000, "Member 'LoadWorldAsyncAction_OnCompleted::Success' has a wrong offset!");
static_assert(offsetof(LoadWorldAsyncAction_OnCompleted, WorldHandle) == 0x000008, "Member 'LoadWorldAsyncAction_OnCompleted::WorldHandle' has a wrong offset!");
static_assert(offsetof(LoadWorldAsyncAction_OnCompleted, LoadParams) == 0x000010, "Member 'LoadWorldAsyncAction_OnCompleted::LoadParams' has a wrong offset!");

}

