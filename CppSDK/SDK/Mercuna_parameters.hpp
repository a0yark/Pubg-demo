#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: Mercuna

#include "Basic.hpp"

#include "Mercuna_structs.hpp"
#include "CoreUObject_structs.hpp"
#include "Engine_structs.hpp"
#include "AIModule_structs.hpp"


namespace SDK::Params
{

// Function Mercuna.Mercuna3DNavigationComponent.AddDestinationLocation
// 0x0018 (0x0018 - 0x0000)
struct Mercuna3DNavigationComponent_AddDestinationLocation final
{
public:
	struct FVector                                NextDestination;                                   // 0x0000(0x0018)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(Mercuna3DNavigationComponent_AddDestinationLocation) == 0x000008, "Wrong alignment on Mercuna3DNavigationComponent_AddDestinationLocation");
static_assert(sizeof(Mercuna3DNavigationComponent_AddDestinationLocation) == 0x000018, "Wrong size on Mercuna3DNavigationComponent_AddDestinationLocation");
static_assert(offsetof(Mercuna3DNavigationComponent_AddDestinationLocation, NextDestination) == 0x000000, "Member 'Mercuna3DNavigationComponent_AddDestinationLocation::NextDestination' has a wrong offset!");

// Function Mercuna.Mercuna3DNavigationComponent.Configure
// 0x001C (0x001C - 0x0000)
struct Mercuna3DNavigationComponent_Configure final
{
public:
	struct FMercuna3DNavigationConfiguration      NewConfiguration;                                  // 0x0000(0x001C)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(Mercuna3DNavigationComponent_Configure) == 0x000004, "Wrong alignment on Mercuna3DNavigationComponent_Configure");
static_assert(sizeof(Mercuna3DNavigationComponent_Configure) == 0x00001C, "Wrong size on Mercuna3DNavigationComponent_Configure");
static_assert(offsetof(Mercuna3DNavigationComponent_Configure, NewConfiguration) == 0x000000, "Member 'Mercuna3DNavigationComponent_Configure::NewConfiguration' has a wrong offset!");

// Function Mercuna.Mercuna3DNavigationComponent.ConfigureMovement
// 0x0002 (0x0002 - 0x0000)
struct Mercuna3DNavigationComponent_ConfigureMovement final
{
public:
	bool                                          bUsePathfinding;                                   // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EMercunaAvoidanceMode                         NewAvoidanceMode;                                  // 0x0001(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(Mercuna3DNavigationComponent_ConfigureMovement) == 0x000001, "Wrong alignment on Mercuna3DNavigationComponent_ConfigureMovement");
static_assert(sizeof(Mercuna3DNavigationComponent_ConfigureMovement) == 0x000002, "Wrong size on Mercuna3DNavigationComponent_ConfigureMovement");
static_assert(offsetof(Mercuna3DNavigationComponent_ConfigureMovement, bUsePathfinding) == 0x000000, "Member 'Mercuna3DNavigationComponent_ConfigureMovement::bUsePathfinding' has a wrong offset!");
static_assert(offsetof(Mercuna3DNavigationComponent_ConfigureMovement, NewAvoidanceMode) == 0x000001, "Member 'Mercuna3DNavigationComponent_ConfigureMovement::NewAvoidanceMode' has a wrong offset!");

// Function Mercuna.Mercuna3DNavigationComponent.GetPathInfo
// 0x0008 (0x0008 - 0x0000)
struct Mercuna3DNavigationComponent_GetPathInfo final
{
public:
	bool                                          Valid;                                             // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         DistanceToEnd;                                     // 0x0004(0x0004)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(Mercuna3DNavigationComponent_GetPathInfo) == 0x000004, "Wrong alignment on Mercuna3DNavigationComponent_GetPathInfo");
static_assert(sizeof(Mercuna3DNavigationComponent_GetPathInfo) == 0x000008, "Wrong size on Mercuna3DNavigationComponent_GetPathInfo");
static_assert(offsetof(Mercuna3DNavigationComponent_GetPathInfo, Valid) == 0x000000, "Member 'Mercuna3DNavigationComponent_GetPathInfo::Valid' has a wrong offset!");
static_assert(offsetof(Mercuna3DNavigationComponent_GetPathInfo, DistanceToEnd) == 0x000004, "Member 'Mercuna3DNavigationComponent_GetPathInfo::DistanceToEnd' has a wrong offset!");

// Function Mercuna.Mercuna3DNavigationComponent.GetRemainingPathLength
// 0x0004 (0x0004 - 0x0000)
struct Mercuna3DNavigationComponent_GetRemainingPathLength final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(Mercuna3DNavigationComponent_GetRemainingPathLength) == 0x000004, "Wrong alignment on Mercuna3DNavigationComponent_GetRemainingPathLength");
static_assert(sizeof(Mercuna3DNavigationComponent_GetRemainingPathLength) == 0x000004, "Wrong size on Mercuna3DNavigationComponent_GetRemainingPathLength");
static_assert(offsetof(Mercuna3DNavigationComponent_GetRemainingPathLength, ReturnValue) == 0x000000, "Member 'Mercuna3DNavigationComponent_GetRemainingPathLength::ReturnValue' has a wrong offset!");

// Function Mercuna.Mercuna3DNavigationComponent.InvalidateContextualSteeringParamsAgainstActor
// 0x0008 (0x0008 - 0x0000)
struct Mercuna3DNavigationComponent_InvalidateContextualSteeringParamsAgainstActor final
{
public:
	class AActor*                                 Actor;                                             // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(Mercuna3DNavigationComponent_InvalidateContextualSteeringParamsAgainstActor) == 0x000008, "Wrong alignment on Mercuna3DNavigationComponent_InvalidateContextualSteeringParamsAgainstActor");
static_assert(sizeof(Mercuna3DNavigationComponent_InvalidateContextualSteeringParamsAgainstActor) == 0x000008, "Wrong size on Mercuna3DNavigationComponent_InvalidateContextualSteeringParamsAgainstActor");
static_assert(offsetof(Mercuna3DNavigationComponent_InvalidateContextualSteeringParamsAgainstActor, Actor) == 0x000000, "Member 'Mercuna3DNavigationComponent_InvalidateContextualSteeringParamsAgainstActor::Actor' has a wrong offset!");

// Function Mercuna.Mercuna3DNavigationComponent.IsReachable
// 0x0040 (0x0040 - 0x0000)
struct Mercuna3DNavigationComponent_IsReachable final
{
public:
	struct FVector                                Point;                                             // 0x0000(0x0018)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          Success;                                           // 0x0018(0x0001)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19[0x7];                                       // 0x0019(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UObject*                                WorldContextObject;                                // 0x0020(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLatentActionInfo                      LatentInfo;                                        // 0x0028(0x0018)(Parm, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(Mercuna3DNavigationComponent_IsReachable) == 0x000008, "Wrong alignment on Mercuna3DNavigationComponent_IsReachable");
static_assert(sizeof(Mercuna3DNavigationComponent_IsReachable) == 0x000040, "Wrong size on Mercuna3DNavigationComponent_IsReachable");
static_assert(offsetof(Mercuna3DNavigationComponent_IsReachable, Point) == 0x000000, "Member 'Mercuna3DNavigationComponent_IsReachable::Point' has a wrong offset!");
static_assert(offsetof(Mercuna3DNavigationComponent_IsReachable, Success) == 0x000018, "Member 'Mercuna3DNavigationComponent_IsReachable::Success' has a wrong offset!");
static_assert(offsetof(Mercuna3DNavigationComponent_IsReachable, WorldContextObject) == 0x000020, "Member 'Mercuna3DNavigationComponent_IsReachable::WorldContextObject' has a wrong offset!");
static_assert(offsetof(Mercuna3DNavigationComponent_IsReachable, LatentInfo) == 0x000028, "Member 'Mercuna3DNavigationComponent_IsReachable::LatentInfo' has a wrong offset!");

// Function Mercuna.Mercuna3DNavigationComponent.LookAlongAcceleration
// 0x0004 (0x0004 - 0x0000)
struct Mercuna3DNavigationComponent_LookAlongAcceleration final
{
public:
	float                                         MaxPitch;                                          // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(Mercuna3DNavigationComponent_LookAlongAcceleration) == 0x000004, "Wrong alignment on Mercuna3DNavigationComponent_LookAlongAcceleration");
static_assert(sizeof(Mercuna3DNavigationComponent_LookAlongAcceleration) == 0x000004, "Wrong size on Mercuna3DNavigationComponent_LookAlongAcceleration");
static_assert(offsetof(Mercuna3DNavigationComponent_LookAlongAcceleration, MaxPitch) == 0x000000, "Member 'Mercuna3DNavigationComponent_LookAlongAcceleration::MaxPitch' has a wrong offset!");

// Function Mercuna.Mercuna3DNavigationComponent.LookAt
// 0x0010 (0x0010 - 0x0000)
struct Mercuna3DNavigationComponent_LookAt final
{
public:
	class AActor*                                 Actor;                                             // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxPitch;                                          // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(Mercuna3DNavigationComponent_LookAt) == 0x000008, "Wrong alignment on Mercuna3DNavigationComponent_LookAt");
static_assert(sizeof(Mercuna3DNavigationComponent_LookAt) == 0x000010, "Wrong size on Mercuna3DNavigationComponent_LookAt");
static_assert(offsetof(Mercuna3DNavigationComponent_LookAt, Actor) == 0x000000, "Member 'Mercuna3DNavigationComponent_LookAt::Actor' has a wrong offset!");
static_assert(offsetof(Mercuna3DNavigationComponent_LookAt, MaxPitch) == 0x000008, "Member 'Mercuna3DNavigationComponent_LookAt::MaxPitch' has a wrong offset!");

// Function Mercuna.Mercuna3DNavigationComponent.LookInDirection
// 0x0020 (0x0020 - 0x0000)
struct Mercuna3DNavigationComponent_LookInDirection final
{
public:
	struct FVector                                Direction;                                         // 0x0000(0x0018)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxPitch;                                          // 0x0018(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C[0x4];                                       // 0x001C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(Mercuna3DNavigationComponent_LookInDirection) == 0x000008, "Wrong alignment on Mercuna3DNavigationComponent_LookInDirection");
static_assert(sizeof(Mercuna3DNavigationComponent_LookInDirection) == 0x000020, "Wrong size on Mercuna3DNavigationComponent_LookInDirection");
static_assert(offsetof(Mercuna3DNavigationComponent_LookInDirection, Direction) == 0x000000, "Member 'Mercuna3DNavigationComponent_LookInDirection::Direction' has a wrong offset!");
static_assert(offsetof(Mercuna3DNavigationComponent_LookInDirection, MaxPitch) == 0x000018, "Member 'Mercuna3DNavigationComponent_LookInDirection::MaxPitch' has a wrong offset!");

// Function Mercuna.Mercuna3DNavigationComponent.MoveToActor
// 0x0018 (0x0018 - 0x0000)
struct Mercuna3DNavigationComponent_MoveToActor final
{
public:
	class AActor*                                 Actor;                                             // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         EndDistance;                                       // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Speed;                                             // 0x000C(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          UsePartialPath;                                    // 0x0010(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x7];                                       // 0x0011(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(Mercuna3DNavigationComponent_MoveToActor) == 0x000008, "Wrong alignment on Mercuna3DNavigationComponent_MoveToActor");
static_assert(sizeof(Mercuna3DNavigationComponent_MoveToActor) == 0x000018, "Wrong size on Mercuna3DNavigationComponent_MoveToActor");
static_assert(offsetof(Mercuna3DNavigationComponent_MoveToActor, Actor) == 0x000000, "Member 'Mercuna3DNavigationComponent_MoveToActor::Actor' has a wrong offset!");
static_assert(offsetof(Mercuna3DNavigationComponent_MoveToActor, EndDistance) == 0x000008, "Member 'Mercuna3DNavigationComponent_MoveToActor::EndDistance' has a wrong offset!");
static_assert(offsetof(Mercuna3DNavigationComponent_MoveToActor, Speed) == 0x00000C, "Member 'Mercuna3DNavigationComponent_MoveToActor::Speed' has a wrong offset!");
static_assert(offsetof(Mercuna3DNavigationComponent_MoveToActor, UsePartialPath) == 0x000010, "Member 'Mercuna3DNavigationComponent_MoveToActor::UsePartialPath' has a wrong offset!");

// Function Mercuna.Mercuna3DNavigationComponent.MoveToLocation
// 0x0028 (0x0028 - 0x0000)
struct Mercuna3DNavigationComponent_MoveToLocation final
{
public:
	struct FVector                                Destination;                                       // 0x0000(0x0018)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         EndDistance;                                       // 0x0018(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Speed;                                             // 0x001C(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          UsePartialPath;                                    // 0x0020(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_21[0x7];                                       // 0x0021(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(Mercuna3DNavigationComponent_MoveToLocation) == 0x000008, "Wrong alignment on Mercuna3DNavigationComponent_MoveToLocation");
static_assert(sizeof(Mercuna3DNavigationComponent_MoveToLocation) == 0x000028, "Wrong size on Mercuna3DNavigationComponent_MoveToLocation");
static_assert(offsetof(Mercuna3DNavigationComponent_MoveToLocation, Destination) == 0x000000, "Member 'Mercuna3DNavigationComponent_MoveToLocation::Destination' has a wrong offset!");
static_assert(offsetof(Mercuna3DNavigationComponent_MoveToLocation, EndDistance) == 0x000018, "Member 'Mercuna3DNavigationComponent_MoveToLocation::EndDistance' has a wrong offset!");
static_assert(offsetof(Mercuna3DNavigationComponent_MoveToLocation, Speed) == 0x00001C, "Member 'Mercuna3DNavigationComponent_MoveToLocation::Speed' has a wrong offset!");
static_assert(offsetof(Mercuna3DNavigationComponent_MoveToLocation, UsePartialPath) == 0x000020, "Member 'Mercuna3DNavigationComponent_MoveToLocation::UsePartialPath' has a wrong offset!");

// Function Mercuna.Mercuna3DNavigationComponent.MoveToLocations
// 0x0020 (0x0020 - 0x0000)
struct Mercuna3DNavigationComponent_MoveToLocations final
{
public:
	TArray<struct FVector>                        Destinations;                                      // 0x0000(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	float                                         EndDistance;                                       // 0x0010(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Speed;                                             // 0x0014(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          UsePartialPath;                                    // 0x0018(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19[0x7];                                       // 0x0019(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(Mercuna3DNavigationComponent_MoveToLocations) == 0x000008, "Wrong alignment on Mercuna3DNavigationComponent_MoveToLocations");
static_assert(sizeof(Mercuna3DNavigationComponent_MoveToLocations) == 0x000020, "Wrong size on Mercuna3DNavigationComponent_MoveToLocations");
static_assert(offsetof(Mercuna3DNavigationComponent_MoveToLocations, Destinations) == 0x000000, "Member 'Mercuna3DNavigationComponent_MoveToLocations::Destinations' has a wrong offset!");
static_assert(offsetof(Mercuna3DNavigationComponent_MoveToLocations, EndDistance) == 0x000010, "Member 'Mercuna3DNavigationComponent_MoveToLocations::EndDistance' has a wrong offset!");
static_assert(offsetof(Mercuna3DNavigationComponent_MoveToLocations, Speed) == 0x000014, "Member 'Mercuna3DNavigationComponent_MoveToLocations::Speed' has a wrong offset!");
static_assert(offsetof(Mercuna3DNavigationComponent_MoveToLocations, UsePartialPath) == 0x000018, "Member 'Mercuna3DNavigationComponent_MoveToLocations::UsePartialPath' has a wrong offset!");

// Function Mercuna.Mercuna3DNavigationComponent.OverrideSpeedMultiplier
// 0x0008 (0x0008 - 0x0000)
struct Mercuna3DNavigationComponent_OverrideSpeedMultiplier final
{
public:
	float                                         NewSpeedMultiplier;                                // 0x0000(0x0004)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0004(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5[0x3];                                        // 0x0005(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(Mercuna3DNavigationComponent_OverrideSpeedMultiplier) == 0x000004, "Wrong alignment on Mercuna3DNavigationComponent_OverrideSpeedMultiplier");
static_assert(sizeof(Mercuna3DNavigationComponent_OverrideSpeedMultiplier) == 0x000008, "Wrong size on Mercuna3DNavigationComponent_OverrideSpeedMultiplier");
static_assert(offsetof(Mercuna3DNavigationComponent_OverrideSpeedMultiplier, NewSpeedMultiplier) == 0x000000, "Member 'Mercuna3DNavigationComponent_OverrideSpeedMultiplier::NewSpeedMultiplier' has a wrong offset!");
static_assert(offsetof(Mercuna3DNavigationComponent_OverrideSpeedMultiplier, ReturnValue) == 0x000004, "Member 'Mercuna3DNavigationComponent_OverrideSpeedMultiplier::ReturnValue' has a wrong offset!");

// Function Mercuna.Mercuna3DNavigationComponent.SetAvoidanceAgainst
// 0x0010 (0x0010 - 0x0000)
struct Mercuna3DNavigationComponent_SetAvoidanceAgainst final
{
public:
	class AActor*                                 Actor;                                             // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          Enable;                                            // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(Mercuna3DNavigationComponent_SetAvoidanceAgainst) == 0x000008, "Wrong alignment on Mercuna3DNavigationComponent_SetAvoidanceAgainst");
static_assert(sizeof(Mercuna3DNavigationComponent_SetAvoidanceAgainst) == 0x000010, "Wrong size on Mercuna3DNavigationComponent_SetAvoidanceAgainst");
static_assert(offsetof(Mercuna3DNavigationComponent_SetAvoidanceAgainst, Actor) == 0x000000, "Member 'Mercuna3DNavigationComponent_SetAvoidanceAgainst::Actor' has a wrong offset!");
static_assert(offsetof(Mercuna3DNavigationComponent_SetAvoidanceAgainst, Enable) == 0x000008, "Member 'Mercuna3DNavigationComponent_SetAvoidanceAgainst::Enable' has a wrong offset!");

// Function Mercuna.Mercuna3DNavigationComponent.SetNavOctree
// 0x0008 (0x0008 - 0x0000)
struct Mercuna3DNavigationComponent_SetNavOctree final
{
public:
	class AMercunaNavOctree*                      NavOctree_0;                                       // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(Mercuna3DNavigationComponent_SetNavOctree) == 0x000008, "Wrong alignment on Mercuna3DNavigationComponent_SetNavOctree");
static_assert(sizeof(Mercuna3DNavigationComponent_SetNavOctree) == 0x000008, "Wrong size on Mercuna3DNavigationComponent_SetNavOctree");
static_assert(offsetof(Mercuna3DNavigationComponent_SetNavOctree, NavOctree_0) == 0x000000, "Member 'Mercuna3DNavigationComponent_SetNavOctree::NavOctree_0' has a wrong offset!");

// Function Mercuna.Mercuna3DNavigationComponent.SetUsageSpec
// 0x0008 (0x0008 - 0x0000)
struct Mercuna3DNavigationComponent_SetUsageSpec final
{
public:
	struct FMercunaUsageSpec                      NewUsageSpec;                                      // 0x0000(0x0008)(Parm, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(Mercuna3DNavigationComponent_SetUsageSpec) == 0x000004, "Wrong alignment on Mercuna3DNavigationComponent_SetUsageSpec");
static_assert(sizeof(Mercuna3DNavigationComponent_SetUsageSpec) == 0x000008, "Wrong size on Mercuna3DNavigationComponent_SetUsageSpec");
static_assert(offsetof(Mercuna3DNavigationComponent_SetUsageSpec, NewUsageSpec) == 0x000000, "Member 'Mercuna3DNavigationComponent_SetUsageSpec::NewUsageSpec' has a wrong offset!");

// Function Mercuna.Mercuna3DNavigationComponent.TrackActor
// 0x0028 (0x0028 - 0x0000)
struct Mercuna3DNavigationComponent_TrackActor final
{
public:
	class AActor*                                 Actor;                                             // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Distance;                                          // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Speed;                                             // 0x000C(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Offset;                                            // 0x0010(0x0018)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(Mercuna3DNavigationComponent_TrackActor) == 0x000008, "Wrong alignment on Mercuna3DNavigationComponent_TrackActor");
static_assert(sizeof(Mercuna3DNavigationComponent_TrackActor) == 0x000028, "Wrong size on Mercuna3DNavigationComponent_TrackActor");
static_assert(offsetof(Mercuna3DNavigationComponent_TrackActor, Actor) == 0x000000, "Member 'Mercuna3DNavigationComponent_TrackActor::Actor' has a wrong offset!");
static_assert(offsetof(Mercuna3DNavigationComponent_TrackActor, Distance) == 0x000008, "Member 'Mercuna3DNavigationComponent_TrackActor::Distance' has a wrong offset!");
static_assert(offsetof(Mercuna3DNavigationComponent_TrackActor, Speed) == 0x00000C, "Member 'Mercuna3DNavigationComponent_TrackActor::Speed' has a wrong offset!");
static_assert(offsetof(Mercuna3DNavigationComponent_TrackActor, Offset) == 0x000010, "Member 'Mercuna3DNavigationComponent_TrackActor::Offset' has a wrong offset!");

// Function Mercuna.Mercuna3DNavigationComponent.GetNavOctree
// 0x0008 (0x0008 - 0x0000)
struct Mercuna3DNavigationComponent_GetNavOctree final
{
public:
	class AMercunaNavOctree*                      ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(Mercuna3DNavigationComponent_GetNavOctree) == 0x000008, "Wrong alignment on Mercuna3DNavigationComponent_GetNavOctree");
static_assert(sizeof(Mercuna3DNavigationComponent_GetNavOctree) == 0x000008, "Wrong size on Mercuna3DNavigationComponent_GetNavOctree");
static_assert(offsetof(Mercuna3DNavigationComponent_GetNavOctree, ReturnValue) == 0x000000, "Member 'Mercuna3DNavigationComponent_GetNavOctree::ReturnValue' has a wrong offset!");

// Function Mercuna.Mercuna3DNavigationComponent.GetUsageSpec
// 0x0008 (0x0008 - 0x0000)
struct Mercuna3DNavigationComponent_GetUsageSpec final
{
public:
	struct FMercunaUsageSpec                      ReturnValue;                                       // 0x0000(0x0008)(ConstParm, Parm, OutParm, ReturnParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(Mercuna3DNavigationComponent_GetUsageSpec) == 0x000004, "Wrong alignment on Mercuna3DNavigationComponent_GetUsageSpec");
static_assert(sizeof(Mercuna3DNavigationComponent_GetUsageSpec) == 0x000008, "Wrong size on Mercuna3DNavigationComponent_GetUsageSpec");
static_assert(offsetof(Mercuna3DNavigationComponent_GetUsageSpec, ReturnValue) == 0x000000, "Member 'Mercuna3DNavigationComponent_GetUsageSpec::ReturnValue' has a wrong offset!");

// Function Mercuna.MercunaNavLink.AddBetweenNavGrids
// 0x0010 (0x0010 - 0x0000)
struct MercunaNavLink_AddBetweenNavGrids final
{
public:
	class AMercunaNavGraph2D*                     LeftNavGrid_0;                                     // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AMercunaNavGraph2D*                     RightNavGrid_0;                                    // 0x0008(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MercunaNavLink_AddBetweenNavGrids) == 0x000008, "Wrong alignment on MercunaNavLink_AddBetweenNavGrids");
static_assert(sizeof(MercunaNavLink_AddBetweenNavGrids) == 0x000010, "Wrong size on MercunaNavLink_AddBetweenNavGrids");
static_assert(offsetof(MercunaNavLink_AddBetweenNavGrids, LeftNavGrid_0) == 0x000000, "Member 'MercunaNavLink_AddBetweenNavGrids::LeftNavGrid_0' has a wrong offset!");
static_assert(offsetof(MercunaNavLink_AddBetweenNavGrids, RightNavGrid_0) == 0x000008, "Member 'MercunaNavLink_AddBetweenNavGrids::RightNavGrid_0' has a wrong offset!");

// Function Mercuna.MercunaNavLink.AddToNavGrid
// 0x0008 (0x0008 - 0x0000)
struct MercunaNavLink_AddToNavGrid final
{
public:
	class AMercunaNavGraph2D*                     NavGrid_0;                                         // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MercunaNavLink_AddToNavGrid) == 0x000008, "Wrong alignment on MercunaNavLink_AddToNavGrid");
static_assert(sizeof(MercunaNavLink_AddToNavGrid) == 0x000008, "Wrong size on MercunaNavLink_AddToNavGrid");
static_assert(offsetof(MercunaNavLink_AddToNavGrid, NavGrid_0) == 0x000000, "Member 'MercunaNavLink_AddToNavGrid::NavGrid_0' has a wrong offset!");

// Function Mercuna.MercunaNavLink.ReceiveNavLinkEnd
// 0x0008 (0x0008 - 0x0000)
struct MercunaNavLink_ReceiveNavLinkEnd final
{
public:
	class APawn*                                  Pawn;                                              // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MercunaNavLink_ReceiveNavLinkEnd) == 0x000008, "Wrong alignment on MercunaNavLink_ReceiveNavLinkEnd");
static_assert(sizeof(MercunaNavLink_ReceiveNavLinkEnd) == 0x000008, "Wrong size on MercunaNavLink_ReceiveNavLinkEnd");
static_assert(offsetof(MercunaNavLink_ReceiveNavLinkEnd, Pawn) == 0x000000, "Member 'MercunaNavLink_ReceiveNavLinkEnd::Pawn' has a wrong offset!");

// Function Mercuna.MercunaNavLink.ReceiveNavLinkStart
// 0x0028 (0x0028 - 0x0000)
struct MercunaNavLink_ReceiveNavLinkStart final
{
public:
	class APawn*                                  Pawn;                                              // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EMercunaNavigationLinkDirection               Direction;                                         // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                Destination;                                       // 0x0010(0x0018)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MercunaNavLink_ReceiveNavLinkStart) == 0x000008, "Wrong alignment on MercunaNavLink_ReceiveNavLinkStart");
static_assert(sizeof(MercunaNavLink_ReceiveNavLinkStart) == 0x000028, "Wrong size on MercunaNavLink_ReceiveNavLinkStart");
static_assert(offsetof(MercunaNavLink_ReceiveNavLinkStart, Pawn) == 0x000000, "Member 'MercunaNavLink_ReceiveNavLinkStart::Pawn' has a wrong offset!");
static_assert(offsetof(MercunaNavLink_ReceiveNavLinkStart, Direction) == 0x000008, "Member 'MercunaNavLink_ReceiveNavLinkStart::Direction' has a wrong offset!");
static_assert(offsetof(MercunaNavLink_ReceiveNavLinkStart, Destination) == 0x000010, "Member 'MercunaNavLink_ReceiveNavLinkStart::Destination' has a wrong offset!");

// Function Mercuna.MercunaNavLink.SetEnabled
// 0x0018 (0x0018 - 0x0000)
struct MercunaNavLink_SetEnabled final
{
public:
	bool                                          bEnabled_0;                                        // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 Reason;                                            // 0x0008(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MercunaNavLink_SetEnabled) == 0x000008, "Wrong alignment on MercunaNavLink_SetEnabled");
static_assert(sizeof(MercunaNavLink_SetEnabled) == 0x000018, "Wrong size on MercunaNavLink_SetEnabled");
static_assert(offsetof(MercunaNavLink_SetEnabled, bEnabled_0) == 0x000000, "Member 'MercunaNavLink_SetEnabled::bEnabled_0' has a wrong offset!");
static_assert(offsetof(MercunaNavLink_SetEnabled, Reason) == 0x000008, "Member 'MercunaNavLink_SetEnabled::Reason' has a wrong offset!");

// Function Mercuna.MercunaNavLink.GetLeftPosition
// 0x0018 (0x0018 - 0x0000)
struct MercunaNavLink_GetLeftPosition final
{
public:
	struct FVector                                ReturnValue;                                       // 0x0000(0x0018)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MercunaNavLink_GetLeftPosition) == 0x000008, "Wrong alignment on MercunaNavLink_GetLeftPosition");
static_assert(sizeof(MercunaNavLink_GetLeftPosition) == 0x000018, "Wrong size on MercunaNavLink_GetLeftPosition");
static_assert(offsetof(MercunaNavLink_GetLeftPosition, ReturnValue) == 0x000000, "Member 'MercunaNavLink_GetLeftPosition::ReturnValue' has a wrong offset!");

// Function Mercuna.MercunaNavLink.GetLeftRotation
// 0x0018 (0x0018 - 0x0000)
struct MercunaNavLink_GetLeftRotation final
{
public:
	struct FRotator                               ReturnValue;                                       // 0x0000(0x0018)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(MercunaNavLink_GetLeftRotation) == 0x000008, "Wrong alignment on MercunaNavLink_GetLeftRotation");
static_assert(sizeof(MercunaNavLink_GetLeftRotation) == 0x000018, "Wrong size on MercunaNavLink_GetLeftRotation");
static_assert(offsetof(MercunaNavLink_GetLeftRotation, ReturnValue) == 0x000000, "Member 'MercunaNavLink_GetLeftRotation::ReturnValue' has a wrong offset!");

// Function Mercuna.MercunaNavLink.GetLeftTransform
// 0x0060 (0x0060 - 0x0000)
struct MercunaNavLink_GetLeftTransform final
{
public:
	struct FTransform                             ReturnValue;                                       // 0x0000(0x0060)(Parm, OutParm, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MercunaNavLink_GetLeftTransform) == 0x000010, "Wrong alignment on MercunaNavLink_GetLeftTransform");
static_assert(sizeof(MercunaNavLink_GetLeftTransform) == 0x000060, "Wrong size on MercunaNavLink_GetLeftTransform");
static_assert(offsetof(MercunaNavLink_GetLeftTransform, ReturnValue) == 0x000000, "Member 'MercunaNavLink_GetLeftTransform::ReturnValue' has a wrong offset!");

// Function Mercuna.MercunaNavLink.GetRightPosition
// 0x0018 (0x0018 - 0x0000)
struct MercunaNavLink_GetRightPosition final
{
public:
	struct FVector                                ReturnValue;                                       // 0x0000(0x0018)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MercunaNavLink_GetRightPosition) == 0x000008, "Wrong alignment on MercunaNavLink_GetRightPosition");
static_assert(sizeof(MercunaNavLink_GetRightPosition) == 0x000018, "Wrong size on MercunaNavLink_GetRightPosition");
static_assert(offsetof(MercunaNavLink_GetRightPosition, ReturnValue) == 0x000000, "Member 'MercunaNavLink_GetRightPosition::ReturnValue' has a wrong offset!");

// Function Mercuna.MercunaNavLink.GetRightRotation
// 0x0018 (0x0018 - 0x0000)
struct MercunaNavLink_GetRightRotation final
{
public:
	struct FRotator                               ReturnValue;                                       // 0x0000(0x0018)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(MercunaNavLink_GetRightRotation) == 0x000008, "Wrong alignment on MercunaNavLink_GetRightRotation");
static_assert(sizeof(MercunaNavLink_GetRightRotation) == 0x000018, "Wrong size on MercunaNavLink_GetRightRotation");
static_assert(offsetof(MercunaNavLink_GetRightRotation, ReturnValue) == 0x000000, "Member 'MercunaNavLink_GetRightRotation::ReturnValue' has a wrong offset!");

// Function Mercuna.MercunaNavLink.GetRightTransform
// 0x0060 (0x0060 - 0x0000)
struct MercunaNavLink_GetRightTransform final
{
public:
	struct FTransform                             ReturnValue;                                       // 0x0000(0x0060)(Parm, OutParm, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MercunaNavLink_GetRightTransform) == 0x000010, "Wrong alignment on MercunaNavLink_GetRightTransform");
static_assert(sizeof(MercunaNavLink_GetRightTransform) == 0x000060, "Wrong size on MercunaNavLink_GetRightTransform");
static_assert(offsetof(MercunaNavLink_GetRightTransform, ReturnValue) == 0x000000, "Member 'MercunaNavLink_GetRightTransform::ReturnValue' has a wrong offset!");

// Function Mercuna.MercunaNavLink.InUse
// 0x0001 (0x0001 - 0x0000)
struct MercunaNavLink_InUse final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MercunaNavLink_InUse) == 0x000001, "Wrong alignment on MercunaNavLink_InUse");
static_assert(sizeof(MercunaNavLink_InUse) == 0x000001, "Wrong size on MercunaNavLink_InUse");
static_assert(offsetof(MercunaNavLink_InUse, ReturnValue) == 0x000000, "Member 'MercunaNavLink_InUse::ReturnValue' has a wrong offset!");

// Function Mercuna.MercunaGroundTask_MoveTo.MoveTo
// 0x0038 (0x0038 - 0x0000)
struct MercunaGroundTask_MoveTo_MoveTo final
{
public:
	class AAIController*                          Controller;                                        // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                GoalLocation;                                      // 0x0008(0x0018)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 GoalActor;                                         // 0x0020(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         EndDistance;                                       // 0x0028(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          AcceptPartialPath;                                 // 0x002C(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bLockAILogic;                                      // 0x002D(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2E[0x2];                                       // 0x002E(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	class UMercunaGroundTask_MoveTo*              ReturnValue;                                       // 0x0030(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MercunaGroundTask_MoveTo_MoveTo) == 0x000008, "Wrong alignment on MercunaGroundTask_MoveTo_MoveTo");
static_assert(sizeof(MercunaGroundTask_MoveTo_MoveTo) == 0x000038, "Wrong size on MercunaGroundTask_MoveTo_MoveTo");
static_assert(offsetof(MercunaGroundTask_MoveTo_MoveTo, Controller) == 0x000000, "Member 'MercunaGroundTask_MoveTo_MoveTo::Controller' has a wrong offset!");
static_assert(offsetof(MercunaGroundTask_MoveTo_MoveTo, GoalLocation) == 0x000008, "Member 'MercunaGroundTask_MoveTo_MoveTo::GoalLocation' has a wrong offset!");
static_assert(offsetof(MercunaGroundTask_MoveTo_MoveTo, GoalActor) == 0x000020, "Member 'MercunaGroundTask_MoveTo_MoveTo::GoalActor' has a wrong offset!");
static_assert(offsetof(MercunaGroundTask_MoveTo_MoveTo, EndDistance) == 0x000028, "Member 'MercunaGroundTask_MoveTo_MoveTo::EndDistance' has a wrong offset!");
static_assert(offsetof(MercunaGroundTask_MoveTo_MoveTo, AcceptPartialPath) == 0x00002C, "Member 'MercunaGroundTask_MoveTo_MoveTo::AcceptPartialPath' has a wrong offset!");
static_assert(offsetof(MercunaGroundTask_MoveTo_MoveTo, bLockAILogic) == 0x00002D, "Member 'MercunaGroundTask_MoveTo_MoveTo::bLockAILogic' has a wrong offset!");
static_assert(offsetof(MercunaGroundTask_MoveTo_MoveTo, ReturnValue) == 0x000030, "Member 'MercunaGroundTask_MoveTo_MoveTo::ReturnValue' has a wrong offset!");

// Function Mercuna.MercunaGroundTask_MoveTo.OnMoveComplete
// 0x0008 (0x0008 - 0x0000)
struct MercunaGroundTask_MoveTo_OnMoveComplete final
{
public:
	struct FAIRequestID                           RequestID;                                         // 0x0000(0x0004)(Parm, NoDestructor, NativeAccessSpecifierPublic)
	EMercunaMoveResult                            Result;                                            // 0x0004(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5[0x3];                                        // 0x0005(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(MercunaGroundTask_MoveTo_OnMoveComplete) == 0x000004, "Wrong alignment on MercunaGroundTask_MoveTo_OnMoveComplete");
static_assert(sizeof(MercunaGroundTask_MoveTo_OnMoveComplete) == 0x000008, "Wrong size on MercunaGroundTask_MoveTo_OnMoveComplete");
static_assert(offsetof(MercunaGroundTask_MoveTo_OnMoveComplete, RequestID) == 0x000000, "Member 'MercunaGroundTask_MoveTo_OnMoveComplete::RequestID' has a wrong offset!");
static_assert(offsetof(MercunaGroundTask_MoveTo_OnMoveComplete, Result) == 0x000004, "Member 'MercunaGroundTask_MoveTo_OnMoveComplete::Result' has a wrong offset!");

// Function Mercuna.Mercuna3DMoveToProxy.MoveToActor
// 0x0030 (0x0030 - 0x0000)
struct Mercuna3DMoveToProxy_MoveToActor final
{
public:
	class UObject*                                WorldContextObject;                                // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class APawn*                                  Pawn_0;                                            // 0x0008(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 Actor;                                             // 0x0010(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         EndDistance;                                       // 0x0018(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Speed;                                             // 0x001C(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          UsePartialPath;                                    // 0x0020(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_21[0x7];                                       // 0x0021(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UMercuna3DMoveToProxy*                  ReturnValue;                                       // 0x0028(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(Mercuna3DMoveToProxy_MoveToActor) == 0x000008, "Wrong alignment on Mercuna3DMoveToProxy_MoveToActor");
static_assert(sizeof(Mercuna3DMoveToProxy_MoveToActor) == 0x000030, "Wrong size on Mercuna3DMoveToProxy_MoveToActor");
static_assert(offsetof(Mercuna3DMoveToProxy_MoveToActor, WorldContextObject) == 0x000000, "Member 'Mercuna3DMoveToProxy_MoveToActor::WorldContextObject' has a wrong offset!");
static_assert(offsetof(Mercuna3DMoveToProxy_MoveToActor, Pawn_0) == 0x000008, "Member 'Mercuna3DMoveToProxy_MoveToActor::Pawn_0' has a wrong offset!");
static_assert(offsetof(Mercuna3DMoveToProxy_MoveToActor, Actor) == 0x000010, "Member 'Mercuna3DMoveToProxy_MoveToActor::Actor' has a wrong offset!");
static_assert(offsetof(Mercuna3DMoveToProxy_MoveToActor, EndDistance) == 0x000018, "Member 'Mercuna3DMoveToProxy_MoveToActor::EndDistance' has a wrong offset!");
static_assert(offsetof(Mercuna3DMoveToProxy_MoveToActor, Speed) == 0x00001C, "Member 'Mercuna3DMoveToProxy_MoveToActor::Speed' has a wrong offset!");
static_assert(offsetof(Mercuna3DMoveToProxy_MoveToActor, UsePartialPath) == 0x000020, "Member 'Mercuna3DMoveToProxy_MoveToActor::UsePartialPath' has a wrong offset!");
static_assert(offsetof(Mercuna3DMoveToProxy_MoveToActor, ReturnValue) == 0x000028, "Member 'Mercuna3DMoveToProxy_MoveToActor::ReturnValue' has a wrong offset!");

// Function Mercuna.Mercuna3DMoveToProxy.MoveToLocation
// 0x0040 (0x0040 - 0x0000)
struct Mercuna3DMoveToProxy_MoveToLocation final
{
public:
	class UObject*                                WorldContextObject;                                // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class APawn*                                  Pawn_0;                                            // 0x0008(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Destination;                                       // 0x0010(0x0018)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         EndDistance;                                       // 0x0028(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Speed;                                             // 0x002C(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          UsePartialPath;                                    // 0x0030(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_31[0x7];                                       // 0x0031(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UMercuna3DMoveToProxy*                  ReturnValue;                                       // 0x0038(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(Mercuna3DMoveToProxy_MoveToLocation) == 0x000008, "Wrong alignment on Mercuna3DMoveToProxy_MoveToLocation");
static_assert(sizeof(Mercuna3DMoveToProxy_MoveToLocation) == 0x000040, "Wrong size on Mercuna3DMoveToProxy_MoveToLocation");
static_assert(offsetof(Mercuna3DMoveToProxy_MoveToLocation, WorldContextObject) == 0x000000, "Member 'Mercuna3DMoveToProxy_MoveToLocation::WorldContextObject' has a wrong offset!");
static_assert(offsetof(Mercuna3DMoveToProxy_MoveToLocation, Pawn_0) == 0x000008, "Member 'Mercuna3DMoveToProxy_MoveToLocation::Pawn_0' has a wrong offset!");
static_assert(offsetof(Mercuna3DMoveToProxy_MoveToLocation, Destination) == 0x000010, "Member 'Mercuna3DMoveToProxy_MoveToLocation::Destination' has a wrong offset!");
static_assert(offsetof(Mercuna3DMoveToProxy_MoveToLocation, EndDistance) == 0x000028, "Member 'Mercuna3DMoveToProxy_MoveToLocation::EndDistance' has a wrong offset!");
static_assert(offsetof(Mercuna3DMoveToProxy_MoveToLocation, Speed) == 0x00002C, "Member 'Mercuna3DMoveToProxy_MoveToLocation::Speed' has a wrong offset!");
static_assert(offsetof(Mercuna3DMoveToProxy_MoveToLocation, UsePartialPath) == 0x000030, "Member 'Mercuna3DMoveToProxy_MoveToLocation::UsePartialPath' has a wrong offset!");
static_assert(offsetof(Mercuna3DMoveToProxy_MoveToLocation, ReturnValue) == 0x000038, "Member 'Mercuna3DMoveToProxy_MoveToLocation::ReturnValue' has a wrong offset!");

// Function Mercuna.Mercuna3DMoveToProxy.MoveToLocations
// 0x0038 (0x0038 - 0x0000)
struct Mercuna3DMoveToProxy_MoveToLocations final
{
public:
	class UObject*                                WorldContextObject;                                // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class APawn*                                  Pawn_0;                                            // 0x0008(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FVector>                        Destinations;                                      // 0x0010(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	float                                         EndDistance;                                       // 0x0020(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Speed;                                             // 0x0024(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          UsePartialPath;                                    // 0x0028(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_29[0x7];                                       // 0x0029(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UMercuna3DMoveToProxy*                  ReturnValue;                                       // 0x0030(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(Mercuna3DMoveToProxy_MoveToLocations) == 0x000008, "Wrong alignment on Mercuna3DMoveToProxy_MoveToLocations");
static_assert(sizeof(Mercuna3DMoveToProxy_MoveToLocations) == 0x000038, "Wrong size on Mercuna3DMoveToProxy_MoveToLocations");
static_assert(offsetof(Mercuna3DMoveToProxy_MoveToLocations, WorldContextObject) == 0x000000, "Member 'Mercuna3DMoveToProxy_MoveToLocations::WorldContextObject' has a wrong offset!");
static_assert(offsetof(Mercuna3DMoveToProxy_MoveToLocations, Pawn_0) == 0x000008, "Member 'Mercuna3DMoveToProxy_MoveToLocations::Pawn_0' has a wrong offset!");
static_assert(offsetof(Mercuna3DMoveToProxy_MoveToLocations, Destinations) == 0x000010, "Member 'Mercuna3DMoveToProxy_MoveToLocations::Destinations' has a wrong offset!");
static_assert(offsetof(Mercuna3DMoveToProxy_MoveToLocations, EndDistance) == 0x000020, "Member 'Mercuna3DMoveToProxy_MoveToLocations::EndDistance' has a wrong offset!");
static_assert(offsetof(Mercuna3DMoveToProxy_MoveToLocations, Speed) == 0x000024, "Member 'Mercuna3DMoveToProxy_MoveToLocations::Speed' has a wrong offset!");
static_assert(offsetof(Mercuna3DMoveToProxy_MoveToLocations, UsePartialPath) == 0x000028, "Member 'Mercuna3DMoveToProxy_MoveToLocations::UsePartialPath' has a wrong offset!");
static_assert(offsetof(Mercuna3DMoveToProxy_MoveToLocations, ReturnValue) == 0x000030, "Member 'Mercuna3DMoveToProxy_MoveToLocations::ReturnValue' has a wrong offset!");

// Function Mercuna.Mercuna3DMoveToProxy.OnMoveComplete
// 0x0008 (0x0008 - 0x0000)
struct Mercuna3DMoveToProxy_OnMoveComplete final
{
public:
	struct FAIRequestID                           RequestID;                                         // 0x0000(0x0004)(Parm, NoDestructor, NativeAccessSpecifierPublic)
	EMercunaMoveResult                            Result;                                            // 0x0004(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5[0x3];                                        // 0x0005(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(Mercuna3DMoveToProxy_OnMoveComplete) == 0x000004, "Wrong alignment on Mercuna3DMoveToProxy_OnMoveComplete");
static_assert(sizeof(Mercuna3DMoveToProxy_OnMoveComplete) == 0x000008, "Wrong size on Mercuna3DMoveToProxy_OnMoveComplete");
static_assert(offsetof(Mercuna3DMoveToProxy_OnMoveComplete, RequestID) == 0x000000, "Member 'Mercuna3DMoveToProxy_OnMoveComplete::RequestID' has a wrong offset!");
static_assert(offsetof(Mercuna3DMoveToProxy_OnMoveComplete, Result) == 0x000004, "Member 'Mercuna3DMoveToProxy_OnMoveComplete::Result' has a wrong offset!");

// Function Mercuna.MercunaGroundNavigationComponent.AddDestinationLocation
// 0x0020 (0x0020 - 0x0000)
struct MercunaGroundNavigationComponent_AddDestinationLocation final
{
public:
	struct FVector                                NextDestination;                                   // 0x0000(0x0018)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bSmoothTransition;                                 // 0x0018(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19[0x7];                                       // 0x0019(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(MercunaGroundNavigationComponent_AddDestinationLocation) == 0x000008, "Wrong alignment on MercunaGroundNavigationComponent_AddDestinationLocation");
static_assert(sizeof(MercunaGroundNavigationComponent_AddDestinationLocation) == 0x000020, "Wrong size on MercunaGroundNavigationComponent_AddDestinationLocation");
static_assert(offsetof(MercunaGroundNavigationComponent_AddDestinationLocation, NextDestination) == 0x000000, "Member 'MercunaGroundNavigationComponent_AddDestinationLocation::NextDestination' has a wrong offset!");
static_assert(offsetof(MercunaGroundNavigationComponent_AddDestinationLocation, bSmoothTransition) == 0x000018, "Member 'MercunaGroundNavigationComponent_AddDestinationLocation::bSmoothTransition' has a wrong offset!");

// Function Mercuna.MercunaGroundNavigationComponent.Configure
// 0x001C (0x001C - 0x0000)
struct MercunaGroundNavigationComponent_Configure final
{
public:
	struct FMercunaGroundNavigationConfiguration  NewConfiguration;                                  // 0x0000(0x001C)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(MercunaGroundNavigationComponent_Configure) == 0x000004, "Wrong alignment on MercunaGroundNavigationComponent_Configure");
static_assert(sizeof(MercunaGroundNavigationComponent_Configure) == 0x00001C, "Wrong size on MercunaGroundNavigationComponent_Configure");
static_assert(offsetof(MercunaGroundNavigationComponent_Configure, NewConfiguration) == 0x000000, "Member 'MercunaGroundNavigationComponent_Configure::NewConfiguration' has a wrong offset!");

// Function Mercuna.MercunaGroundNavigationComponent.ConfigureMovement
// 0x0001 (0x0001 - 0x0000)
struct MercunaGroundNavigationComponent_ConfigureMovement final
{
public:
	EMercunaAvoidanceMode                         NewAvoidanceMode;                                  // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MercunaGroundNavigationComponent_ConfigureMovement) == 0x000001, "Wrong alignment on MercunaGroundNavigationComponent_ConfigureMovement");
static_assert(sizeof(MercunaGroundNavigationComponent_ConfigureMovement) == 0x000001, "Wrong size on MercunaGroundNavigationComponent_ConfigureMovement");
static_assert(offsetof(MercunaGroundNavigationComponent_ConfigureMovement, NewAvoidanceMode) == 0x000000, "Member 'MercunaGroundNavigationComponent_ConfigureMovement::NewAvoidanceMode' has a wrong offset!");

// Function Mercuna.MercunaGroundNavigationComponent.ConfigureSteering
// 0x0020 (0x0020 - 0x0000)
struct MercunaGroundNavigationComponent_ConfigureSteering final
{
public:
	struct FMercunaGroundNavigationSteeringParameters NewSteering;                                   // 0x0000(0x0020)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(MercunaGroundNavigationComponent_ConfigureSteering) == 0x000004, "Wrong alignment on MercunaGroundNavigationComponent_ConfigureSteering");
static_assert(sizeof(MercunaGroundNavigationComponent_ConfigureSteering) == 0x000020, "Wrong size on MercunaGroundNavigationComponent_ConfigureSteering");
static_assert(offsetof(MercunaGroundNavigationComponent_ConfigureSteering, NewSteering) == 0x000000, "Member 'MercunaGroundNavigationComponent_ConfigureSteering::NewSteering' has a wrong offset!");

// Function Mercuna.MercunaGroundNavigationComponent.GetLookDirection
// 0x0018 (0x0018 - 0x0000)
struct MercunaGroundNavigationComponent_GetLookDirection final
{
public:
	struct FVector                                ReturnValue;                                       // 0x0000(0x0018)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MercunaGroundNavigationComponent_GetLookDirection) == 0x000008, "Wrong alignment on MercunaGroundNavigationComponent_GetLookDirection");
static_assert(sizeof(MercunaGroundNavigationComponent_GetLookDirection) == 0x000018, "Wrong size on MercunaGroundNavigationComponent_GetLookDirection");
static_assert(offsetof(MercunaGroundNavigationComponent_GetLookDirection, ReturnValue) == 0x000000, "Member 'MercunaGroundNavigationComponent_GetLookDirection::ReturnValue' has a wrong offset!");

// Function Mercuna.MercunaGroundNavigationComponent.GetPathInfo
// 0x0008 (0x0008 - 0x0000)
struct MercunaGroundNavigationComponent_GetPathInfo final
{
public:
	bool                                          Valid;                                             // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         DistanceToEnd;                                     // 0x0004(0x0004)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MercunaGroundNavigationComponent_GetPathInfo) == 0x000004, "Wrong alignment on MercunaGroundNavigationComponent_GetPathInfo");
static_assert(sizeof(MercunaGroundNavigationComponent_GetPathInfo) == 0x000008, "Wrong size on MercunaGroundNavigationComponent_GetPathInfo");
static_assert(offsetof(MercunaGroundNavigationComponent_GetPathInfo, Valid) == 0x000000, "Member 'MercunaGroundNavigationComponent_GetPathInfo::Valid' has a wrong offset!");
static_assert(offsetof(MercunaGroundNavigationComponent_GetPathInfo, DistanceToEnd) == 0x000004, "Member 'MercunaGroundNavigationComponent_GetPathInfo::DistanceToEnd' has a wrong offset!");

// Function Mercuna.MercunaGroundNavigationComponent.GetRemainingPathLength
// 0x0004 (0x0004 - 0x0000)
struct MercunaGroundNavigationComponent_GetRemainingPathLength final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MercunaGroundNavigationComponent_GetRemainingPathLength) == 0x000004, "Wrong alignment on MercunaGroundNavigationComponent_GetRemainingPathLength");
static_assert(sizeof(MercunaGroundNavigationComponent_GetRemainingPathLength) == 0x000004, "Wrong size on MercunaGroundNavigationComponent_GetRemainingPathLength");
static_assert(offsetof(MercunaGroundNavigationComponent_GetRemainingPathLength, ReturnValue) == 0x000000, "Member 'MercunaGroundNavigationComponent_GetRemainingPathLength::ReturnValue' has a wrong offset!");

// Function Mercuna.MercunaGroundNavigationComponent.InvalidateContextualSteeringParamsAgainstActor
// 0x0008 (0x0008 - 0x0000)
struct MercunaGroundNavigationComponent_InvalidateContextualSteeringParamsAgainstActor final
{
public:
	class AActor*                                 Actor;                                             // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MercunaGroundNavigationComponent_InvalidateContextualSteeringParamsAgainstActor) == 0x000008, "Wrong alignment on MercunaGroundNavigationComponent_InvalidateContextualSteeringParamsAgainstActor");
static_assert(sizeof(MercunaGroundNavigationComponent_InvalidateContextualSteeringParamsAgainstActor) == 0x000008, "Wrong size on MercunaGroundNavigationComponent_InvalidateContextualSteeringParamsAgainstActor");
static_assert(offsetof(MercunaGroundNavigationComponent_InvalidateContextualSteeringParamsAgainstActor, Actor) == 0x000000, "Member 'MercunaGroundNavigationComponent_InvalidateContextualSteeringParamsAgainstActor::Actor' has a wrong offset!");

// Function Mercuna.MercunaGroundNavigationComponent.MoveToActor
// 0x0018 (0x0018 - 0x0000)
struct MercunaGroundNavigationComponent_MoveToActor final
{
public:
	class AActor*                                 Actor;                                             // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         EndDistance;                                       // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Speed;                                             // 0x000C(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          UsePartialPath;                                    // 0x0010(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x7];                                       // 0x0011(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(MercunaGroundNavigationComponent_MoveToActor) == 0x000008, "Wrong alignment on MercunaGroundNavigationComponent_MoveToActor");
static_assert(sizeof(MercunaGroundNavigationComponent_MoveToActor) == 0x000018, "Wrong size on MercunaGroundNavigationComponent_MoveToActor");
static_assert(offsetof(MercunaGroundNavigationComponent_MoveToActor, Actor) == 0x000000, "Member 'MercunaGroundNavigationComponent_MoveToActor::Actor' has a wrong offset!");
static_assert(offsetof(MercunaGroundNavigationComponent_MoveToActor, EndDistance) == 0x000008, "Member 'MercunaGroundNavigationComponent_MoveToActor::EndDistance' has a wrong offset!");
static_assert(offsetof(MercunaGroundNavigationComponent_MoveToActor, Speed) == 0x00000C, "Member 'MercunaGroundNavigationComponent_MoveToActor::Speed' has a wrong offset!");
static_assert(offsetof(MercunaGroundNavigationComponent_MoveToActor, UsePartialPath) == 0x000010, "Member 'MercunaGroundNavigationComponent_MoveToActor::UsePartialPath' has a wrong offset!");

// Function Mercuna.MercunaGroundNavigationComponent.MoveToLocation
// 0x0040 (0x0040 - 0x0000)
struct MercunaGroundNavigationComponent_MoveToLocation final
{
public:
	struct FVector                                Destination;                                       // 0x0000(0x0018)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                EndDirection;                                      // 0x0018(0x0018)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         EndDistance;                                       // 0x0030(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Speed;                                             // 0x0034(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          UsePartialPath;                                    // 0x0038(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_39[0x7];                                       // 0x0039(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(MercunaGroundNavigationComponent_MoveToLocation) == 0x000008, "Wrong alignment on MercunaGroundNavigationComponent_MoveToLocation");
static_assert(sizeof(MercunaGroundNavigationComponent_MoveToLocation) == 0x000040, "Wrong size on MercunaGroundNavigationComponent_MoveToLocation");
static_assert(offsetof(MercunaGroundNavigationComponent_MoveToLocation, Destination) == 0x000000, "Member 'MercunaGroundNavigationComponent_MoveToLocation::Destination' has a wrong offset!");
static_assert(offsetof(MercunaGroundNavigationComponent_MoveToLocation, EndDirection) == 0x000018, "Member 'MercunaGroundNavigationComponent_MoveToLocation::EndDirection' has a wrong offset!");
static_assert(offsetof(MercunaGroundNavigationComponent_MoveToLocation, EndDistance) == 0x000030, "Member 'MercunaGroundNavigationComponent_MoveToLocation::EndDistance' has a wrong offset!");
static_assert(offsetof(MercunaGroundNavigationComponent_MoveToLocation, Speed) == 0x000034, "Member 'MercunaGroundNavigationComponent_MoveToLocation::Speed' has a wrong offset!");
static_assert(offsetof(MercunaGroundNavigationComponent_MoveToLocation, UsePartialPath) == 0x000038, "Member 'MercunaGroundNavigationComponent_MoveToLocation::UsePartialPath' has a wrong offset!");

// Function Mercuna.MercunaGroundNavigationComponent.MoveToLocations
// 0x0038 (0x0038 - 0x0000)
struct MercunaGroundNavigationComponent_MoveToLocations final
{
public:
	TArray<struct FVector>                        Destinations;                                      // 0x0000(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	struct FVector                                EndDirection;                                      // 0x0010(0x0018)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         EndDistance;                                       // 0x0028(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Speed;                                             // 0x002C(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          UsePartialPath;                                    // 0x0030(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_31[0x7];                                       // 0x0031(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(MercunaGroundNavigationComponent_MoveToLocations) == 0x000008, "Wrong alignment on MercunaGroundNavigationComponent_MoveToLocations");
static_assert(sizeof(MercunaGroundNavigationComponent_MoveToLocations) == 0x000038, "Wrong size on MercunaGroundNavigationComponent_MoveToLocations");
static_assert(offsetof(MercunaGroundNavigationComponent_MoveToLocations, Destinations) == 0x000000, "Member 'MercunaGroundNavigationComponent_MoveToLocations::Destinations' has a wrong offset!");
static_assert(offsetof(MercunaGroundNavigationComponent_MoveToLocations, EndDirection) == 0x000010, "Member 'MercunaGroundNavigationComponent_MoveToLocations::EndDirection' has a wrong offset!");
static_assert(offsetof(MercunaGroundNavigationComponent_MoveToLocations, EndDistance) == 0x000028, "Member 'MercunaGroundNavigationComponent_MoveToLocations::EndDistance' has a wrong offset!");
static_assert(offsetof(MercunaGroundNavigationComponent_MoveToLocations, Speed) == 0x00002C, "Member 'MercunaGroundNavigationComponent_MoveToLocations::Speed' has a wrong offset!");
static_assert(offsetof(MercunaGroundNavigationComponent_MoveToLocations, UsePartialPath) == 0x000030, "Member 'MercunaGroundNavigationComponent_MoveToLocations::UsePartialPath' has a wrong offset!");

// Function Mercuna.MercunaGroundNavigationComponent.OverrideSpeedMultiplier
// 0x0008 (0x0008 - 0x0000)
struct MercunaGroundNavigationComponent_OverrideSpeedMultiplier final
{
public:
	float                                         NewSpeedMultiplier;                                // 0x0000(0x0004)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0004(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5[0x3];                                        // 0x0005(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(MercunaGroundNavigationComponent_OverrideSpeedMultiplier) == 0x000004, "Wrong alignment on MercunaGroundNavigationComponent_OverrideSpeedMultiplier");
static_assert(sizeof(MercunaGroundNavigationComponent_OverrideSpeedMultiplier) == 0x000008, "Wrong size on MercunaGroundNavigationComponent_OverrideSpeedMultiplier");
static_assert(offsetof(MercunaGroundNavigationComponent_OverrideSpeedMultiplier, NewSpeedMultiplier) == 0x000000, "Member 'MercunaGroundNavigationComponent_OverrideSpeedMultiplier::NewSpeedMultiplier' has a wrong offset!");
static_assert(offsetof(MercunaGroundNavigationComponent_OverrideSpeedMultiplier, ReturnValue) == 0x000004, "Member 'MercunaGroundNavigationComponent_OverrideSpeedMultiplier::ReturnValue' has a wrong offset!");

// Function Mercuna.MercunaGroundNavigationComponent.SetAgentType
// 0x000C (0x000C - 0x0000)
struct MercunaGroundNavigationComponent_SetAgentType final
{
public:
	struct FMercunaGroundAgentType                NewAgentType;                                      // 0x0000(0x000C)(Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MercunaGroundNavigationComponent_SetAgentType) == 0x000004, "Wrong alignment on MercunaGroundNavigationComponent_SetAgentType");
static_assert(sizeof(MercunaGroundNavigationComponent_SetAgentType) == 0x00000C, "Wrong size on MercunaGroundNavigationComponent_SetAgentType");
static_assert(offsetof(MercunaGroundNavigationComponent_SetAgentType, NewAgentType) == 0x000000, "Member 'MercunaGroundNavigationComponent_SetAgentType::NewAgentType' has a wrong offset!");

// Function Mercuna.MercunaGroundNavigationComponent.SetAvoidanceAgainst
// 0x0010 (0x0010 - 0x0000)
struct MercunaGroundNavigationComponent_SetAvoidanceAgainst final
{
public:
	class AActor*                                 Actor;                                             // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          Enable;                                            // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(MercunaGroundNavigationComponent_SetAvoidanceAgainst) == 0x000008, "Wrong alignment on MercunaGroundNavigationComponent_SetAvoidanceAgainst");
static_assert(sizeof(MercunaGroundNavigationComponent_SetAvoidanceAgainst) == 0x000010, "Wrong size on MercunaGroundNavigationComponent_SetAvoidanceAgainst");
static_assert(offsetof(MercunaGroundNavigationComponent_SetAvoidanceAgainst, Actor) == 0x000000, "Member 'MercunaGroundNavigationComponent_SetAvoidanceAgainst::Actor' has a wrong offset!");
static_assert(offsetof(MercunaGroundNavigationComponent_SetAvoidanceAgainst, Enable) == 0x000008, "Member 'MercunaGroundNavigationComponent_SetAvoidanceAgainst::Enable' has a wrong offset!");

// Function Mercuna.MercunaGroundNavigationComponent.SetNavGrid
// 0x0008 (0x0008 - 0x0000)
struct MercunaGroundNavigationComponent_SetNavGrid final
{
public:
	class AMercunaNavGroundGrid*                  NavGrid_0;                                         // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MercunaGroundNavigationComponent_SetNavGrid) == 0x000008, "Wrong alignment on MercunaGroundNavigationComponent_SetNavGrid");
static_assert(sizeof(MercunaGroundNavigationComponent_SetNavGrid) == 0x000008, "Wrong size on MercunaGroundNavigationComponent_SetNavGrid");
static_assert(offsetof(MercunaGroundNavigationComponent_SetNavGrid, NavGrid_0) == 0x000000, "Member 'MercunaGroundNavigationComponent_SetNavGrid::NavGrid_0' has a wrong offset!");

// Function Mercuna.MercunaGroundNavigationComponent.SetUsageSpec
// 0x0008 (0x0008 - 0x0000)
struct MercunaGroundNavigationComponent_SetUsageSpec final
{
public:
	struct FMercunaUsageSpec                      NewUsageSpec;                                      // 0x0000(0x0008)(Parm, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(MercunaGroundNavigationComponent_SetUsageSpec) == 0x000004, "Wrong alignment on MercunaGroundNavigationComponent_SetUsageSpec");
static_assert(sizeof(MercunaGroundNavigationComponent_SetUsageSpec) == 0x000008, "Wrong size on MercunaGroundNavigationComponent_SetUsageSpec");
static_assert(offsetof(MercunaGroundNavigationComponent_SetUsageSpec, NewUsageSpec) == 0x000000, "Member 'MercunaGroundNavigationComponent_SetUsageSpec::NewUsageSpec' has a wrong offset!");

// Function Mercuna.MercunaGroundNavigationComponent.TrackActor
// 0x0030 (0x0030 - 0x0000)
struct MercunaGroundNavigationComponent_TrackActor final
{
public:
	class AActor*                                 Actor;                                             // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Distance;                                          // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Speed;                                             // 0x000C(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Offset;                                            // 0x0010(0x0018)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          UsePartialPath;                                    // 0x0028(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_29[0x7];                                       // 0x0029(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(MercunaGroundNavigationComponent_TrackActor) == 0x000008, "Wrong alignment on MercunaGroundNavigationComponent_TrackActor");
static_assert(sizeof(MercunaGroundNavigationComponent_TrackActor) == 0x000030, "Wrong size on MercunaGroundNavigationComponent_TrackActor");
static_assert(offsetof(MercunaGroundNavigationComponent_TrackActor, Actor) == 0x000000, "Member 'MercunaGroundNavigationComponent_TrackActor::Actor' has a wrong offset!");
static_assert(offsetof(MercunaGroundNavigationComponent_TrackActor, Distance) == 0x000008, "Member 'MercunaGroundNavigationComponent_TrackActor::Distance' has a wrong offset!");
static_assert(offsetof(MercunaGroundNavigationComponent_TrackActor, Speed) == 0x00000C, "Member 'MercunaGroundNavigationComponent_TrackActor::Speed' has a wrong offset!");
static_assert(offsetof(MercunaGroundNavigationComponent_TrackActor, Offset) == 0x000010, "Member 'MercunaGroundNavigationComponent_TrackActor::Offset' has a wrong offset!");
static_assert(offsetof(MercunaGroundNavigationComponent_TrackActor, UsePartialPath) == 0x000028, "Member 'MercunaGroundNavigationComponent_TrackActor::UsePartialPath' has a wrong offset!");

// Function Mercuna.MercunaGroundNavigationComponent.UpdateDynamicSteeringParams
// 0x0010 (0x0010 - 0x0000)
struct MercunaGroundNavigationComponent_UpdateDynamicSteeringParams final
{
public:
	struct FMercunaGroundNavigationDynamicSteeringParameters NewDynamicSteeringParams;               // 0x0000(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(MercunaGroundNavigationComponent_UpdateDynamicSteeringParams) == 0x000004, "Wrong alignment on MercunaGroundNavigationComponent_UpdateDynamicSteeringParams");
static_assert(sizeof(MercunaGroundNavigationComponent_UpdateDynamicSteeringParams) == 0x000010, "Wrong size on MercunaGroundNavigationComponent_UpdateDynamicSteeringParams");
static_assert(offsetof(MercunaGroundNavigationComponent_UpdateDynamicSteeringParams, NewDynamicSteeringParams) == 0x000000, "Member 'MercunaGroundNavigationComponent_UpdateDynamicSteeringParams::NewDynamicSteeringParams' has a wrong offset!");

// Function Mercuna.MercunaGroundNavigationComponent.GetConfiguration
// 0x001C (0x001C - 0x0000)
struct MercunaGroundNavigationComponent_GetConfiguration final
{
public:
	struct FMercunaGroundNavigationConfiguration  ReturnValue;                                       // 0x0000(0x001C)(Parm, OutParm, ReturnParm, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(MercunaGroundNavigationComponent_GetConfiguration) == 0x000004, "Wrong alignment on MercunaGroundNavigationComponent_GetConfiguration");
static_assert(sizeof(MercunaGroundNavigationComponent_GetConfiguration) == 0x00001C, "Wrong size on MercunaGroundNavigationComponent_GetConfiguration");
static_assert(offsetof(MercunaGroundNavigationComponent_GetConfiguration, ReturnValue) == 0x000000, "Member 'MercunaGroundNavigationComponent_GetConfiguration::ReturnValue' has a wrong offset!");

// Function Mercuna.MercunaGroundNavigationComponent.GetDynamicSteeringParameters
// 0x0010 (0x0010 - 0x0000)
struct MercunaGroundNavigationComponent_GetDynamicSteeringParameters final
{
public:
	struct FMercunaGroundNavigationDynamicSteeringParameters ReturnValue;                            // 0x0000(0x0010)(Parm, OutParm, ReturnParm, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(MercunaGroundNavigationComponent_GetDynamicSteeringParameters) == 0x000004, "Wrong alignment on MercunaGroundNavigationComponent_GetDynamicSteeringParameters");
static_assert(sizeof(MercunaGroundNavigationComponent_GetDynamicSteeringParameters) == 0x000010, "Wrong size on MercunaGroundNavigationComponent_GetDynamicSteeringParameters");
static_assert(offsetof(MercunaGroundNavigationComponent_GetDynamicSteeringParameters, ReturnValue) == 0x000000, "Member 'MercunaGroundNavigationComponent_GetDynamicSteeringParameters::ReturnValue' has a wrong offset!");

// Function Mercuna.MercunaGroundNavigationComponent.GetLastInputVector
// 0x0018 (0x0018 - 0x0000)
struct MercunaGroundNavigationComponent_GetLastInputVector final
{
public:
	struct FVector                                ReturnValue;                                       // 0x0000(0x0018)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MercunaGroundNavigationComponent_GetLastInputVector) == 0x000008, "Wrong alignment on MercunaGroundNavigationComponent_GetLastInputVector");
static_assert(sizeof(MercunaGroundNavigationComponent_GetLastInputVector) == 0x000018, "Wrong size on MercunaGroundNavigationComponent_GetLastInputVector");
static_assert(offsetof(MercunaGroundNavigationComponent_GetLastInputVector, ReturnValue) == 0x000000, "Member 'MercunaGroundNavigationComponent_GetLastInputVector::ReturnValue' has a wrong offset!");

// Function Mercuna.MercunaGroundNavigationComponent.GetNavGrid
// 0x0008 (0x0008 - 0x0000)
struct MercunaGroundNavigationComponent_GetNavGrid final
{
public:
	class AMercunaNavGroundGrid*                  ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MercunaGroundNavigationComponent_GetNavGrid) == 0x000008, "Wrong alignment on MercunaGroundNavigationComponent_GetNavGrid");
static_assert(sizeof(MercunaGroundNavigationComponent_GetNavGrid) == 0x000008, "Wrong size on MercunaGroundNavigationComponent_GetNavGrid");
static_assert(offsetof(MercunaGroundNavigationComponent_GetNavGrid, ReturnValue) == 0x000000, "Member 'MercunaGroundNavigationComponent_GetNavGrid::ReturnValue' has a wrong offset!");

// Function Mercuna.MercunaGroundNavigationComponent.GetNextNavLink
// 0x00F0 (0x00F0 - 0x0000)
struct MercunaGroundNavigationComponent_GetNextNavLink final
{
public:
	bool                                          bNextNavLinkFound;                                 // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         DistanceToNextNavLink;                             // 0x0004(0x0004)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TimeToNextNavLink;                                 // 0x0008(0x0004)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                TraversalStart;                                    // 0x0010(0x0018)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                TraversalEnd;                                      // 0x0028(0x0018)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsAutoGenerated;                                  // 0x0040(0x0001)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_41[0x7];                                       // 0x0041(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class AMercunaNavLink*                        NavLink;                                           // 0x0048(0x0008)(Parm, OutParm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FMercunaAutoNavLink                    AutoGeneratedNavLink;                              // 0x0050(0x0098)(Parm, OutParm, NoDestructor, NativeAccessSpecifierPublic)
	float                                         MaxLookAhead;                                      // 0x00E8(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_EC[0x4];                                       // 0x00EC(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(MercunaGroundNavigationComponent_GetNextNavLink) == 0x000008, "Wrong alignment on MercunaGroundNavigationComponent_GetNextNavLink");
static_assert(sizeof(MercunaGroundNavigationComponent_GetNextNavLink) == 0x0000F0, "Wrong size on MercunaGroundNavigationComponent_GetNextNavLink");
static_assert(offsetof(MercunaGroundNavigationComponent_GetNextNavLink, bNextNavLinkFound) == 0x000000, "Member 'MercunaGroundNavigationComponent_GetNextNavLink::bNextNavLinkFound' has a wrong offset!");
static_assert(offsetof(MercunaGroundNavigationComponent_GetNextNavLink, DistanceToNextNavLink) == 0x000004, "Member 'MercunaGroundNavigationComponent_GetNextNavLink::DistanceToNextNavLink' has a wrong offset!");
static_assert(offsetof(MercunaGroundNavigationComponent_GetNextNavLink, TimeToNextNavLink) == 0x000008, "Member 'MercunaGroundNavigationComponent_GetNextNavLink::TimeToNextNavLink' has a wrong offset!");
static_assert(offsetof(MercunaGroundNavigationComponent_GetNextNavLink, TraversalStart) == 0x000010, "Member 'MercunaGroundNavigationComponent_GetNextNavLink::TraversalStart' has a wrong offset!");
static_assert(offsetof(MercunaGroundNavigationComponent_GetNextNavLink, TraversalEnd) == 0x000028, "Member 'MercunaGroundNavigationComponent_GetNextNavLink::TraversalEnd' has a wrong offset!");
static_assert(offsetof(MercunaGroundNavigationComponent_GetNextNavLink, bIsAutoGenerated) == 0x000040, "Member 'MercunaGroundNavigationComponent_GetNextNavLink::bIsAutoGenerated' has a wrong offset!");
static_assert(offsetof(MercunaGroundNavigationComponent_GetNextNavLink, NavLink) == 0x000048, "Member 'MercunaGroundNavigationComponent_GetNextNavLink::NavLink' has a wrong offset!");
static_assert(offsetof(MercunaGroundNavigationComponent_GetNextNavLink, AutoGeneratedNavLink) == 0x000050, "Member 'MercunaGroundNavigationComponent_GetNextNavLink::AutoGeneratedNavLink' has a wrong offset!");
static_assert(offsetof(MercunaGroundNavigationComponent_GetNextNavLink, MaxLookAhead) == 0x0000E8, "Member 'MercunaGroundNavigationComponent_GetNextNavLink::MaxLookAhead' has a wrong offset!");

// Function Mercuna.MercunaGroundNavigationComponent.GetSteeringParameters
// 0x0020 (0x0020 - 0x0000)
struct MercunaGroundNavigationComponent_GetSteeringParameters final
{
public:
	struct FMercunaGroundNavigationSteeringParameters ReturnValue;                                   // 0x0000(0x0020)(Parm, OutParm, ReturnParm, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(MercunaGroundNavigationComponent_GetSteeringParameters) == 0x000004, "Wrong alignment on MercunaGroundNavigationComponent_GetSteeringParameters");
static_assert(sizeof(MercunaGroundNavigationComponent_GetSteeringParameters) == 0x000020, "Wrong size on MercunaGroundNavigationComponent_GetSteeringParameters");
static_assert(offsetof(MercunaGroundNavigationComponent_GetSteeringParameters, ReturnValue) == 0x000000, "Member 'MercunaGroundNavigationComponent_GetSteeringParameters::ReturnValue' has a wrong offset!");

// Function Mercuna.MercunaGroundNavigationComponent.GetTrajectory
// 0x0020 (0x0020 - 0x0000)
struct MercunaGroundNavigationComponent_GetTrajectory final
{
public:
	struct FTrajectorySampleRange                 TrajectorySampleRange;                             // 0x0000(0x0010)(Parm, OutParm, NativeAccessSpecifierPublic)
	float                                         LookAhead;                                         // 0x0010(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         SampleRate;                                        // 0x0014(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnAbsoluteTimes;                               // 0x0018(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EMerNavigationTrajectory                      ReturnValue;                                       // 0x0019(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1A[0x6];                                       // 0x001A(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(MercunaGroundNavigationComponent_GetTrajectory) == 0x000008, "Wrong alignment on MercunaGroundNavigationComponent_GetTrajectory");
static_assert(sizeof(MercunaGroundNavigationComponent_GetTrajectory) == 0x000020, "Wrong size on MercunaGroundNavigationComponent_GetTrajectory");
static_assert(offsetof(MercunaGroundNavigationComponent_GetTrajectory, TrajectorySampleRange) == 0x000000, "Member 'MercunaGroundNavigationComponent_GetTrajectory::TrajectorySampleRange' has a wrong offset!");
static_assert(offsetof(MercunaGroundNavigationComponent_GetTrajectory, LookAhead) == 0x000010, "Member 'MercunaGroundNavigationComponent_GetTrajectory::LookAhead' has a wrong offset!");
static_assert(offsetof(MercunaGroundNavigationComponent_GetTrajectory, SampleRate) == 0x000014, "Member 'MercunaGroundNavigationComponent_GetTrajectory::SampleRate' has a wrong offset!");
static_assert(offsetof(MercunaGroundNavigationComponent_GetTrajectory, ReturnAbsoluteTimes) == 0x000018, "Member 'MercunaGroundNavigationComponent_GetTrajectory::ReturnAbsoluteTimes' has a wrong offset!");
static_assert(offsetof(MercunaGroundNavigationComponent_GetTrajectory, ReturnValue) == 0x000019, "Member 'MercunaGroundNavigationComponent_GetTrajectory::ReturnValue' has a wrong offset!");

// Function Mercuna.MercunaGroundNavigationComponent.GetUsageSpec
// 0x0008 (0x0008 - 0x0000)
struct MercunaGroundNavigationComponent_GetUsageSpec final
{
public:
	struct FMercunaUsageSpec                      ReturnValue;                                       // 0x0000(0x0008)(ConstParm, Parm, OutParm, ReturnParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(MercunaGroundNavigationComponent_GetUsageSpec) == 0x000004, "Wrong alignment on MercunaGroundNavigationComponent_GetUsageSpec");
static_assert(sizeof(MercunaGroundNavigationComponent_GetUsageSpec) == 0x000008, "Wrong size on MercunaGroundNavigationComponent_GetUsageSpec");
static_assert(offsetof(MercunaGroundNavigationComponent_GetUsageSpec, ReturnValue) == 0x000000, "Member 'MercunaGroundNavigationComponent_GetUsageSpec::ReturnValue' has a wrong offset!");

// Function Mercuna.MercunaNavGraph.SaveToFile
// 0x0010 (0x0010 - 0x0000)
struct MercunaNavGraph_SaveToFile final
{
public:
	class FString                                 Filename;                                          // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MercunaNavGraph_SaveToFile) == 0x000008, "Wrong alignment on MercunaNavGraph_SaveToFile");
static_assert(sizeof(MercunaNavGraph_SaveToFile) == 0x000010, "Wrong size on MercunaNavGraph_SaveToFile");
static_assert(offsetof(MercunaNavGraph_SaveToFile, Filename) == 0x000000, "Member 'MercunaNavGraph_SaveToFile::Filename' has a wrong offset!");

// Function Mercuna.MercunaNavGroundGrid.Build
// 0x0010 (0x0010 - 0x0000)
struct MercunaNavGroundGrid_Build final
{
public:
	TArray<struct FVector>                        PriorityPositions;                                 // 0x0000(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(MercunaNavGroundGrid_Build) == 0x000008, "Wrong alignment on MercunaNavGroundGrid_Build");
static_assert(sizeof(MercunaNavGroundGrid_Build) == 0x000010, "Wrong size on MercunaNavGroundGrid_Build");
static_assert(offsetof(MercunaNavGroundGrid_Build, PriorityPositions) == 0x000000, "Member 'MercunaNavGroundGrid_Build::PriorityPositions' has a wrong offset!");

// Function Mercuna.MercunaNavGroundGrid.DisableAutoGenNavLinksByIdentifier
// 0x0010 (0x0010 - 0x0000)
struct MercunaNavGroundGrid_DisableAutoGenNavLinksByIdentifier final
{
public:
	TArray<struct FMercunaNavLinkIdentifier>      Identifiers;                                       // 0x0000(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(MercunaNavGroundGrid_DisableAutoGenNavLinksByIdentifier) == 0x000008, "Wrong alignment on MercunaNavGroundGrid_DisableAutoGenNavLinksByIdentifier");
static_assert(sizeof(MercunaNavGroundGrid_DisableAutoGenNavLinksByIdentifier) == 0x000010, "Wrong size on MercunaNavGroundGrid_DisableAutoGenNavLinksByIdentifier");
static_assert(offsetof(MercunaNavGroundGrid_DisableAutoGenNavLinksByIdentifier, Identifiers) == 0x000000, "Member 'MercunaNavGroundGrid_DisableAutoGenNavLinksByIdentifier::Identifiers' has a wrong offset!");

// Function Mercuna.MercunaNavGroundGrid.DisableAutoGenNavLinksInVolume
// 0x0048 (0x0048 - 0x0000)
struct MercunaNavGroundGrid_DisableAutoGenNavLinksInVolume final
{
public:
	struct FMercunaGroundAgentType                AgentType;                                         // 0x0000(0x000C)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FBox                                   Volume;                                            // 0x0010(0x0038)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(MercunaNavGroundGrid_DisableAutoGenNavLinksInVolume) == 0x000008, "Wrong alignment on MercunaNavGroundGrid_DisableAutoGenNavLinksInVolume");
static_assert(sizeof(MercunaNavGroundGrid_DisableAutoGenNavLinksInVolume) == 0x000048, "Wrong size on MercunaNavGroundGrid_DisableAutoGenNavLinksInVolume");
static_assert(offsetof(MercunaNavGroundGrid_DisableAutoGenNavLinksInVolume, AgentType) == 0x000000, "Member 'MercunaNavGroundGrid_DisableAutoGenNavLinksInVolume::AgentType' has a wrong offset!");
static_assert(offsetof(MercunaNavGroundGrid_DisableAutoGenNavLinksInVolume, Volume) == 0x000010, "Member 'MercunaNavGroundGrid_DisableAutoGenNavLinksInVolume::Volume' has a wrong offset!");

// Function Mercuna.MercunaNavGroundGrid.EnableAutoGenNavLinksByIdentifier
// 0x0010 (0x0010 - 0x0000)
struct MercunaNavGroundGrid_EnableAutoGenNavLinksByIdentifier final
{
public:
	TArray<struct FMercunaNavLinkIdentifier>      Identifiers;                                       // 0x0000(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(MercunaNavGroundGrid_EnableAutoGenNavLinksByIdentifier) == 0x000008, "Wrong alignment on MercunaNavGroundGrid_EnableAutoGenNavLinksByIdentifier");
static_assert(sizeof(MercunaNavGroundGrid_EnableAutoGenNavLinksByIdentifier) == 0x000010, "Wrong size on MercunaNavGroundGrid_EnableAutoGenNavLinksByIdentifier");
static_assert(offsetof(MercunaNavGroundGrid_EnableAutoGenNavLinksByIdentifier, Identifiers) == 0x000000, "Member 'MercunaNavGroundGrid_EnableAutoGenNavLinksByIdentifier::Identifiers' has a wrong offset!");

// Function Mercuna.MercunaNavGroundGrid.EnableAutoGenNavLinksInVolume
// 0x0048 (0x0048 - 0x0000)
struct MercunaNavGroundGrid_EnableAutoGenNavLinksInVolume final
{
public:
	struct FMercunaGroundAgentType                AgentType;                                         // 0x0000(0x000C)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FBox                                   Volume;                                            // 0x0010(0x0038)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(MercunaNavGroundGrid_EnableAutoGenNavLinksInVolume) == 0x000008, "Wrong alignment on MercunaNavGroundGrid_EnableAutoGenNavLinksInVolume");
static_assert(sizeof(MercunaNavGroundGrid_EnableAutoGenNavLinksInVolume) == 0x000048, "Wrong size on MercunaNavGroundGrid_EnableAutoGenNavLinksInVolume");
static_assert(offsetof(MercunaNavGroundGrid_EnableAutoGenNavLinksInVolume, AgentType) == 0x000000, "Member 'MercunaNavGroundGrid_EnableAutoGenNavLinksInVolume::AgentType' has a wrong offset!");
static_assert(offsetof(MercunaNavGroundGrid_EnableAutoGenNavLinksInVolume, Volume) == 0x000010, "Member 'MercunaNavGroundGrid_EnableAutoGenNavLinksInVolume::Volume' has a wrong offset!");

// Function Mercuna.MercunaNavGroundGrid.FindPathToLocation
// 0x0090 (0x0090 - 0x0000)
struct MercunaNavGroundGrid_FindPathToLocation final
{
public:
	struct FMercunaGroundAgentType                AgentType;                                         // 0x0000(0x000C)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TDelegate<void(EMercunaPathEvent PathEvent)>  OnPathUpdated;                                     // 0x000C(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C[0x4];                                       // 0x001C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                Start;                                             // 0x0020(0x0018)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                StartDir;                                          // 0x0038(0x0018)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                End;                                               // 0x0050(0x0018)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MinTurnRadius;                                     // 0x0068(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         IdealTurnRadius;                                   // 0x006C(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxSpeed;                                          // 0x0070(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          AllowPartial;                                      // 0x0074(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_75[0x3];                                       // 0x0075(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MaxPathLength;                                     // 0x0078(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SlopePenalty;                                      // 0x007C(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FMercunaUsageSpec                      UsageSpec;                                         // 0x0080(0x0008)(ConstParm, Parm, NoDestructor, NativeAccessSpecifierPublic)
	class UMercunaPath*                           ReturnValue;                                       // 0x0088(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MercunaNavGroundGrid_FindPathToLocation) == 0x000008, "Wrong alignment on MercunaNavGroundGrid_FindPathToLocation");
static_assert(sizeof(MercunaNavGroundGrid_FindPathToLocation) == 0x000090, "Wrong size on MercunaNavGroundGrid_FindPathToLocation");
static_assert(offsetof(MercunaNavGroundGrid_FindPathToLocation, AgentType) == 0x000000, "Member 'MercunaNavGroundGrid_FindPathToLocation::AgentType' has a wrong offset!");
static_assert(offsetof(MercunaNavGroundGrid_FindPathToLocation, OnPathUpdated) == 0x00000C, "Member 'MercunaNavGroundGrid_FindPathToLocation::OnPathUpdated' has a wrong offset!");
static_assert(offsetof(MercunaNavGroundGrid_FindPathToLocation, Start) == 0x000020, "Member 'MercunaNavGroundGrid_FindPathToLocation::Start' has a wrong offset!");
static_assert(offsetof(MercunaNavGroundGrid_FindPathToLocation, StartDir) == 0x000038, "Member 'MercunaNavGroundGrid_FindPathToLocation::StartDir' has a wrong offset!");
static_assert(offsetof(MercunaNavGroundGrid_FindPathToLocation, End) == 0x000050, "Member 'MercunaNavGroundGrid_FindPathToLocation::End' has a wrong offset!");
static_assert(offsetof(MercunaNavGroundGrid_FindPathToLocation, MinTurnRadius) == 0x000068, "Member 'MercunaNavGroundGrid_FindPathToLocation::MinTurnRadius' has a wrong offset!");
static_assert(offsetof(MercunaNavGroundGrid_FindPathToLocation, IdealTurnRadius) == 0x00006C, "Member 'MercunaNavGroundGrid_FindPathToLocation::IdealTurnRadius' has a wrong offset!");
static_assert(offsetof(MercunaNavGroundGrid_FindPathToLocation, MaxSpeed) == 0x000070, "Member 'MercunaNavGroundGrid_FindPathToLocation::MaxSpeed' has a wrong offset!");
static_assert(offsetof(MercunaNavGroundGrid_FindPathToLocation, AllowPartial) == 0x000074, "Member 'MercunaNavGroundGrid_FindPathToLocation::AllowPartial' has a wrong offset!");
static_assert(offsetof(MercunaNavGroundGrid_FindPathToLocation, MaxPathLength) == 0x000078, "Member 'MercunaNavGroundGrid_FindPathToLocation::MaxPathLength' has a wrong offset!");
static_assert(offsetof(MercunaNavGroundGrid_FindPathToLocation, SlopePenalty) == 0x00007C, "Member 'MercunaNavGroundGrid_FindPathToLocation::SlopePenalty' has a wrong offset!");
static_assert(offsetof(MercunaNavGroundGrid_FindPathToLocation, UsageSpec) == 0x000080, "Member 'MercunaNavGroundGrid_FindPathToLocation::UsageSpec' has a wrong offset!");
static_assert(offsetof(MercunaNavGroundGrid_FindPathToLocation, ReturnValue) == 0x000088, "Member 'MercunaNavGroundGrid_FindPathToLocation::ReturnValue' has a wrong offset!");

// Function Mercuna.MercunaNavGroundGrid.FindPathToLocations
// 0x0088 (0x0088 - 0x0000)
struct MercunaNavGroundGrid_FindPathToLocations final
{
public:
	struct FMercunaGroundAgentType                AgentType;                                         // 0x0000(0x000C)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TDelegate<void(EMercunaPathEvent PathEvent)>  OnPathUpdated;                                     // 0x000C(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C[0x4];                                       // 0x001C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                Start;                                             // 0x0020(0x0018)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                StartDir;                                          // 0x0038(0x0018)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FVector>                        Destinations;                                      // 0x0050(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	float                                         MinTurnRadius;                                     // 0x0060(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         IdealTurnRadius;                                   // 0x0064(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxSpeed;                                          // 0x0068(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          AllowPartial;                                      // 0x006C(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_6D[0x3];                                       // 0x006D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MaxPathLength;                                     // 0x0070(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SlopePenalty;                                      // 0x0074(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FMercunaUsageSpec                      UsageSpec;                                         // 0x0078(0x0008)(ConstParm, Parm, NoDestructor, NativeAccessSpecifierPublic)
	class UMercunaPath*                           ReturnValue;                                       // 0x0080(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MercunaNavGroundGrid_FindPathToLocations) == 0x000008, "Wrong alignment on MercunaNavGroundGrid_FindPathToLocations");
static_assert(sizeof(MercunaNavGroundGrid_FindPathToLocations) == 0x000088, "Wrong size on MercunaNavGroundGrid_FindPathToLocations");
static_assert(offsetof(MercunaNavGroundGrid_FindPathToLocations, AgentType) == 0x000000, "Member 'MercunaNavGroundGrid_FindPathToLocations::AgentType' has a wrong offset!");
static_assert(offsetof(MercunaNavGroundGrid_FindPathToLocations, OnPathUpdated) == 0x00000C, "Member 'MercunaNavGroundGrid_FindPathToLocations::OnPathUpdated' has a wrong offset!");
static_assert(offsetof(MercunaNavGroundGrid_FindPathToLocations, Start) == 0x000020, "Member 'MercunaNavGroundGrid_FindPathToLocations::Start' has a wrong offset!");
static_assert(offsetof(MercunaNavGroundGrid_FindPathToLocations, StartDir) == 0x000038, "Member 'MercunaNavGroundGrid_FindPathToLocations::StartDir' has a wrong offset!");
static_assert(offsetof(MercunaNavGroundGrid_FindPathToLocations, Destinations) == 0x000050, "Member 'MercunaNavGroundGrid_FindPathToLocations::Destinations' has a wrong offset!");
static_assert(offsetof(MercunaNavGroundGrid_FindPathToLocations, MinTurnRadius) == 0x000060, "Member 'MercunaNavGroundGrid_FindPathToLocations::MinTurnRadius' has a wrong offset!");
static_assert(offsetof(MercunaNavGroundGrid_FindPathToLocations, IdealTurnRadius) == 0x000064, "Member 'MercunaNavGroundGrid_FindPathToLocations::IdealTurnRadius' has a wrong offset!");
static_assert(offsetof(MercunaNavGroundGrid_FindPathToLocations, MaxSpeed) == 0x000068, "Member 'MercunaNavGroundGrid_FindPathToLocations::MaxSpeed' has a wrong offset!");
static_assert(offsetof(MercunaNavGroundGrid_FindPathToLocations, AllowPartial) == 0x00006C, "Member 'MercunaNavGroundGrid_FindPathToLocations::AllowPartial' has a wrong offset!");
static_assert(offsetof(MercunaNavGroundGrid_FindPathToLocations, MaxPathLength) == 0x000070, "Member 'MercunaNavGroundGrid_FindPathToLocations::MaxPathLength' has a wrong offset!");
static_assert(offsetof(MercunaNavGroundGrid_FindPathToLocations, SlopePenalty) == 0x000074, "Member 'MercunaNavGroundGrid_FindPathToLocations::SlopePenalty' has a wrong offset!");
static_assert(offsetof(MercunaNavGroundGrid_FindPathToLocations, UsageSpec) == 0x000078, "Member 'MercunaNavGroundGrid_FindPathToLocations::UsageSpec' has a wrong offset!");
static_assert(offsetof(MercunaNavGroundGrid_FindPathToLocations, ReturnValue) == 0x000080, "Member 'MercunaNavGroundGrid_FindPathToLocations::ReturnValue' has a wrong offset!");

// Function Mercuna.MercunaNavGroundGrid.FindSmoothPathToLocation
// 0x0098 (0x0098 - 0x0000)
struct MercunaNavGroundGrid_FindSmoothPathToLocation final
{
public:
	struct FMercunaGroundAgentType                AgentType;                                         // 0x0000(0x000C)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TDelegate<void(EMercunaPathEvent PathEvent)>  OnPathUpdated;                                     // 0x000C(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C[0x4];                                       // 0x001C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                Start;                                             // 0x0020(0x0018)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                StartDir;                                          // 0x0038(0x0018)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                End;                                               // 0x0050(0x0018)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MinTurnRadius;                                     // 0x0068(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         IdealTurnRadius;                                   // 0x006C(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxSpeed;                                          // 0x0070(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxSpeedReverse;                                   // 0x0074(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          AllowPartial;                                      // 0x0078(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_79[0x3];                                       // 0x0079(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MaxPathLength;                                     // 0x007C(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SlopePenalty;                                      // 0x0080(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FMercunaUsageSpec                      UsageSpec;                                         // 0x0084(0x0008)(ConstParm, Parm, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_8C[0x4];                                       // 0x008C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UMercunaSmoothPath*                     ReturnValue;                                       // 0x0090(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MercunaNavGroundGrid_FindSmoothPathToLocation) == 0x000008, "Wrong alignment on MercunaNavGroundGrid_FindSmoothPathToLocation");
static_assert(sizeof(MercunaNavGroundGrid_FindSmoothPathToLocation) == 0x000098, "Wrong size on MercunaNavGroundGrid_FindSmoothPathToLocation");
static_assert(offsetof(MercunaNavGroundGrid_FindSmoothPathToLocation, AgentType) == 0x000000, "Member 'MercunaNavGroundGrid_FindSmoothPathToLocation::AgentType' has a wrong offset!");
static_assert(offsetof(MercunaNavGroundGrid_FindSmoothPathToLocation, OnPathUpdated) == 0x00000C, "Member 'MercunaNavGroundGrid_FindSmoothPathToLocation::OnPathUpdated' has a wrong offset!");
static_assert(offsetof(MercunaNavGroundGrid_FindSmoothPathToLocation, Start) == 0x000020, "Member 'MercunaNavGroundGrid_FindSmoothPathToLocation::Start' has a wrong offset!");
static_assert(offsetof(MercunaNavGroundGrid_FindSmoothPathToLocation, StartDir) == 0x000038, "Member 'MercunaNavGroundGrid_FindSmoothPathToLocation::StartDir' has a wrong offset!");
static_assert(offsetof(MercunaNavGroundGrid_FindSmoothPathToLocation, End) == 0x000050, "Member 'MercunaNavGroundGrid_FindSmoothPathToLocation::End' has a wrong offset!");
static_assert(offsetof(MercunaNavGroundGrid_FindSmoothPathToLocation, MinTurnRadius) == 0x000068, "Member 'MercunaNavGroundGrid_FindSmoothPathToLocation::MinTurnRadius' has a wrong offset!");
static_assert(offsetof(MercunaNavGroundGrid_FindSmoothPathToLocation, IdealTurnRadius) == 0x00006C, "Member 'MercunaNavGroundGrid_FindSmoothPathToLocation::IdealTurnRadius' has a wrong offset!");
static_assert(offsetof(MercunaNavGroundGrid_FindSmoothPathToLocation, MaxSpeed) == 0x000070, "Member 'MercunaNavGroundGrid_FindSmoothPathToLocation::MaxSpeed' has a wrong offset!");
static_assert(offsetof(MercunaNavGroundGrid_FindSmoothPathToLocation, MaxSpeedReverse) == 0x000074, "Member 'MercunaNavGroundGrid_FindSmoothPathToLocation::MaxSpeedReverse' has a wrong offset!");
static_assert(offsetof(MercunaNavGroundGrid_FindSmoothPathToLocation, AllowPartial) == 0x000078, "Member 'MercunaNavGroundGrid_FindSmoothPathToLocation::AllowPartial' has a wrong offset!");
static_assert(offsetof(MercunaNavGroundGrid_FindSmoothPathToLocation, MaxPathLength) == 0x00007C, "Member 'MercunaNavGroundGrid_FindSmoothPathToLocation::MaxPathLength' has a wrong offset!");
static_assert(offsetof(MercunaNavGroundGrid_FindSmoothPathToLocation, SlopePenalty) == 0x000080, "Member 'MercunaNavGroundGrid_FindSmoothPathToLocation::SlopePenalty' has a wrong offset!");
static_assert(offsetof(MercunaNavGroundGrid_FindSmoothPathToLocation, UsageSpec) == 0x000084, "Member 'MercunaNavGroundGrid_FindSmoothPathToLocation::UsageSpec' has a wrong offset!");
static_assert(offsetof(MercunaNavGroundGrid_FindSmoothPathToLocation, ReturnValue) == 0x000090, "Member 'MercunaNavGroundGrid_FindSmoothPathToLocation::ReturnValue' has a wrong offset!");

// Function Mercuna.MercunaNavGroundGrid.FindSmoothPathToLocations
// 0x0090 (0x0090 - 0x0000)
struct MercunaNavGroundGrid_FindSmoothPathToLocations final
{
public:
	struct FMercunaGroundAgentType                AgentType;                                         // 0x0000(0x000C)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TDelegate<void(EMercunaPathEvent PathEvent)>  OnPathUpdated;                                     // 0x000C(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C[0x4];                                       // 0x001C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                Start;                                             // 0x0020(0x0018)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                StartDir;                                          // 0x0038(0x0018)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FVector>                        Destinations;                                      // 0x0050(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	float                                         MinTurnRadius;                                     // 0x0060(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         IdealTurnRadius;                                   // 0x0064(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxSpeed;                                          // 0x0068(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxSpeedReverse;                                   // 0x006C(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          AllowPartial;                                      // 0x0070(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_71[0x3];                                       // 0x0071(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MaxPathLength;                                     // 0x0074(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SlopePenalty;                                      // 0x0078(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FMercunaUsageSpec                      UsageSpec;                                         // 0x007C(0x0008)(ConstParm, Parm, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_84[0x4];                                       // 0x0084(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UMercunaSmoothPath*                     ReturnValue;                                       // 0x0088(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MercunaNavGroundGrid_FindSmoothPathToLocations) == 0x000008, "Wrong alignment on MercunaNavGroundGrid_FindSmoothPathToLocations");
static_assert(sizeof(MercunaNavGroundGrid_FindSmoothPathToLocations) == 0x000090, "Wrong size on MercunaNavGroundGrid_FindSmoothPathToLocations");
static_assert(offsetof(MercunaNavGroundGrid_FindSmoothPathToLocations, AgentType) == 0x000000, "Member 'MercunaNavGroundGrid_FindSmoothPathToLocations::AgentType' has a wrong offset!");
static_assert(offsetof(MercunaNavGroundGrid_FindSmoothPathToLocations, OnPathUpdated) == 0x00000C, "Member 'MercunaNavGroundGrid_FindSmoothPathToLocations::OnPathUpdated' has a wrong offset!");
static_assert(offsetof(MercunaNavGroundGrid_FindSmoothPathToLocations, Start) == 0x000020, "Member 'MercunaNavGroundGrid_FindSmoothPathToLocations::Start' has a wrong offset!");
static_assert(offsetof(MercunaNavGroundGrid_FindSmoothPathToLocations, StartDir) == 0x000038, "Member 'MercunaNavGroundGrid_FindSmoothPathToLocations::StartDir' has a wrong offset!");
static_assert(offsetof(MercunaNavGroundGrid_FindSmoothPathToLocations, Destinations) == 0x000050, "Member 'MercunaNavGroundGrid_FindSmoothPathToLocations::Destinations' has a wrong offset!");
static_assert(offsetof(MercunaNavGroundGrid_FindSmoothPathToLocations, MinTurnRadius) == 0x000060, "Member 'MercunaNavGroundGrid_FindSmoothPathToLocations::MinTurnRadius' has a wrong offset!");
static_assert(offsetof(MercunaNavGroundGrid_FindSmoothPathToLocations, IdealTurnRadius) == 0x000064, "Member 'MercunaNavGroundGrid_FindSmoothPathToLocations::IdealTurnRadius' has a wrong offset!");
static_assert(offsetof(MercunaNavGroundGrid_FindSmoothPathToLocations, MaxSpeed) == 0x000068, "Member 'MercunaNavGroundGrid_FindSmoothPathToLocations::MaxSpeed' has a wrong offset!");
static_assert(offsetof(MercunaNavGroundGrid_FindSmoothPathToLocations, MaxSpeedReverse) == 0x00006C, "Member 'MercunaNavGroundGrid_FindSmoothPathToLocations::MaxSpeedReverse' has a wrong offset!");
static_assert(offsetof(MercunaNavGroundGrid_FindSmoothPathToLocations, AllowPartial) == 0x000070, "Member 'MercunaNavGroundGrid_FindSmoothPathToLocations::AllowPartial' has a wrong offset!");
static_assert(offsetof(MercunaNavGroundGrid_FindSmoothPathToLocations, MaxPathLength) == 0x000074, "Member 'MercunaNavGroundGrid_FindSmoothPathToLocations::MaxPathLength' has a wrong offset!");
static_assert(offsetof(MercunaNavGroundGrid_FindSmoothPathToLocations, SlopePenalty) == 0x000078, "Member 'MercunaNavGroundGrid_FindSmoothPathToLocations::SlopePenalty' has a wrong offset!");
static_assert(offsetof(MercunaNavGroundGrid_FindSmoothPathToLocations, UsageSpec) == 0x00007C, "Member 'MercunaNavGroundGrid_FindSmoothPathToLocations::UsageSpec' has a wrong offset!");
static_assert(offsetof(MercunaNavGroundGrid_FindSmoothPathToLocations, ReturnValue) == 0x000088, "Member 'MercunaNavGroundGrid_FindSmoothPathToLocations::ReturnValue' has a wrong offset!");

// Function Mercuna.MercunaNavGroundGrid.GenerateRandomPointsInBox
// 0x0088 (0x0088 - 0x0000)
struct MercunaNavGroundGrid_GenerateRandomPointsInBox final
{
public:
	struct FMercunaGroundAgentType                AgentType;                                         // 0x0000(0x000C)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FBox                                   Volume;                                            // 0x0010(0x0038)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	int32                                         NumPoints;                                         // 0x0048(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4C[0x4];                                       // 0x004C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FVector>                        Results;                                           // 0x0050(0x0010)(Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
	struct FRotator                               Rotator;                                           // 0x0060(0x0018)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FMercunaUsageSpec                      UsageSpec;                                         // 0x0078(0x0008)(ConstParm, Parm, NoDestructor, AdvancedDisplay, NativeAccessSpecifierPublic)
	bool                                          bIgnoreStationaryObstacles;                        // 0x0080(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_81[0x7];                                       // 0x0081(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(MercunaNavGroundGrid_GenerateRandomPointsInBox) == 0x000008, "Wrong alignment on MercunaNavGroundGrid_GenerateRandomPointsInBox");
static_assert(sizeof(MercunaNavGroundGrid_GenerateRandomPointsInBox) == 0x000088, "Wrong size on MercunaNavGroundGrid_GenerateRandomPointsInBox");
static_assert(offsetof(MercunaNavGroundGrid_GenerateRandomPointsInBox, AgentType) == 0x000000, "Member 'MercunaNavGroundGrid_GenerateRandomPointsInBox::AgentType' has a wrong offset!");
static_assert(offsetof(MercunaNavGroundGrid_GenerateRandomPointsInBox, Volume) == 0x000010, "Member 'MercunaNavGroundGrid_GenerateRandomPointsInBox::Volume' has a wrong offset!");
static_assert(offsetof(MercunaNavGroundGrid_GenerateRandomPointsInBox, NumPoints) == 0x000048, "Member 'MercunaNavGroundGrid_GenerateRandomPointsInBox::NumPoints' has a wrong offset!");
static_assert(offsetof(MercunaNavGroundGrid_GenerateRandomPointsInBox, Results) == 0x000050, "Member 'MercunaNavGroundGrid_GenerateRandomPointsInBox::Results' has a wrong offset!");
static_assert(offsetof(MercunaNavGroundGrid_GenerateRandomPointsInBox, Rotator) == 0x000060, "Member 'MercunaNavGroundGrid_GenerateRandomPointsInBox::Rotator' has a wrong offset!");
static_assert(offsetof(MercunaNavGroundGrid_GenerateRandomPointsInBox, UsageSpec) == 0x000078, "Member 'MercunaNavGroundGrid_GenerateRandomPointsInBox::UsageSpec' has a wrong offset!");
static_assert(offsetof(MercunaNavGroundGrid_GenerateRandomPointsInBox, bIgnoreStationaryObstacles) == 0x000080, "Member 'MercunaNavGroundGrid_GenerateRandomPointsInBox::bIgnoreStationaryObstacles' has a wrong offset!");

// Function Mercuna.MercunaNavGroundGrid.RebuildVolume
// 0x0010 (0x0010 - 0x0000)
struct MercunaNavGroundGrid_RebuildVolume final
{
public:
	const class AActor*                           Volume;                                            // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bApplyNavSeeds;                                    // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(MercunaNavGroundGrid_RebuildVolume) == 0x000008, "Wrong alignment on MercunaNavGroundGrid_RebuildVolume");
static_assert(sizeof(MercunaNavGroundGrid_RebuildVolume) == 0x000010, "Wrong size on MercunaNavGroundGrid_RebuildVolume");
static_assert(offsetof(MercunaNavGroundGrid_RebuildVolume, Volume) == 0x000000, "Member 'MercunaNavGroundGrid_RebuildVolume::Volume' has a wrong offset!");
static_assert(offsetof(MercunaNavGroundGrid_RebuildVolume, bApplyNavSeeds) == 0x000008, "Member 'MercunaNavGroundGrid_RebuildVolume::bApplyNavSeeds' has a wrong offset!");

// Function Mercuna.MercunaNavGroundGrid.RebuildVolumes
// 0x0018 (0x0018 - 0x0000)
struct MercunaNavGroundGrid_RebuildVolumes final
{
public:
	TArray<struct FBox>                           Volumes;                                           // 0x0000(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	bool                                          bMergeVolumes;                                     // 0x0010(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bOnlyUnbuilt;                                      // 0x0011(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bApplyNavSeeds;                                    // 0x0012(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_13[0x5];                                       // 0x0013(0x0005)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(MercunaNavGroundGrid_RebuildVolumes) == 0x000008, "Wrong alignment on MercunaNavGroundGrid_RebuildVolumes");
static_assert(sizeof(MercunaNavGroundGrid_RebuildVolumes) == 0x000018, "Wrong size on MercunaNavGroundGrid_RebuildVolumes");
static_assert(offsetof(MercunaNavGroundGrid_RebuildVolumes, Volumes) == 0x000000, "Member 'MercunaNavGroundGrid_RebuildVolumes::Volumes' has a wrong offset!");
static_assert(offsetof(MercunaNavGroundGrid_RebuildVolumes, bMergeVolumes) == 0x000010, "Member 'MercunaNavGroundGrid_RebuildVolumes::bMergeVolumes' has a wrong offset!");
static_assert(offsetof(MercunaNavGroundGrid_RebuildVolumes, bOnlyUnbuilt) == 0x000011, "Member 'MercunaNavGroundGrid_RebuildVolumes::bOnlyUnbuilt' has a wrong offset!");
static_assert(offsetof(MercunaNavGroundGrid_RebuildVolumes, bApplyNavSeeds) == 0x000012, "Member 'MercunaNavGroundGrid_RebuildVolumes::bApplyNavSeeds' has a wrong offset!");

// Function Mercuna.MercunaNavGroundGrid.RegisterNavInvoker
// 0x0018 (0x0018 - 0x0000)
struct MercunaNavGroundGrid_RegisterNavInvoker final
{
public:
	class AActor*                                 Actor;                                             // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   AgentType;                                         // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         GenerationRadius;                                  // 0x0010(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RemovalRadius;                                     // 0x0014(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MercunaNavGroundGrid_RegisterNavInvoker) == 0x000008, "Wrong alignment on MercunaNavGroundGrid_RegisterNavInvoker");
static_assert(sizeof(MercunaNavGroundGrid_RegisterNavInvoker) == 0x000018, "Wrong size on MercunaNavGroundGrid_RegisterNavInvoker");
static_assert(offsetof(MercunaNavGroundGrid_RegisterNavInvoker, Actor) == 0x000000, "Member 'MercunaNavGroundGrid_RegisterNavInvoker::Actor' has a wrong offset!");
static_assert(offsetof(MercunaNavGroundGrid_RegisterNavInvoker, AgentType) == 0x000008, "Member 'MercunaNavGroundGrid_RegisterNavInvoker::AgentType' has a wrong offset!");
static_assert(offsetof(MercunaNavGroundGrid_RegisterNavInvoker, GenerationRadius) == 0x000010, "Member 'MercunaNavGroundGrid_RegisterNavInvoker::GenerationRadius' has a wrong offset!");
static_assert(offsetof(MercunaNavGroundGrid_RegisterNavInvoker, RemovalRadius) == 0x000014, "Member 'MercunaNavGroundGrid_RegisterNavInvoker::RemovalRadius' has a wrong offset!");

// Function Mercuna.MercunaNavGroundGrid.UnregisterNavInvoker
// 0x0008 (0x0008 - 0x0000)
struct MercunaNavGroundGrid_UnregisterNavInvoker final
{
public:
	class AActor*                                 Actor;                                             // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MercunaNavGroundGrid_UnregisterNavInvoker) == 0x000008, "Wrong alignment on MercunaNavGroundGrid_UnregisterNavInvoker");
static_assert(sizeof(MercunaNavGroundGrid_UnregisterNavInvoker) == 0x000008, "Wrong size on MercunaNavGroundGrid_UnregisterNavInvoker");
static_assert(offsetof(MercunaNavGroundGrid_UnregisterNavInvoker, Actor) == 0x000000, "Member 'MercunaNavGroundGrid_UnregisterNavInvoker::Actor' has a wrong offset!");

// Function Mercuna.MercunaNavGroundGrid.UpdateAutoGenNavLinks
// 0x0010 (0x0010 - 0x0000)
struct MercunaNavGroundGrid_UpdateAutoGenNavLinks final
{
public:
	TArray<struct FMercunaAutoNavLinkForUpdate>   LinksToUpdate;                                     // 0x0000(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(MercunaNavGroundGrid_UpdateAutoGenNavLinks) == 0x000008, "Wrong alignment on MercunaNavGroundGrid_UpdateAutoGenNavLinks");
static_assert(sizeof(MercunaNavGroundGrid_UpdateAutoGenNavLinks) == 0x000010, "Wrong size on MercunaNavGroundGrid_UpdateAutoGenNavLinks");
static_assert(offsetof(MercunaNavGroundGrid_UpdateAutoGenNavLinks, LinksToUpdate) == 0x000000, "Member 'MercunaNavGroundGrid_UpdateAutoGenNavLinks::LinksToUpdate' has a wrong offset!");

// Function Mercuna.MercunaNavGroundGrid.ClampToNavigable
// 0x0060 (0x0060 - 0x0000)
struct MercunaNavGroundGrid_ClampToNavigable final
{
public:
	struct FMercunaGroundAgentType                AgentType;                                         // 0x0000(0x000C)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                Position;                                          // 0x0010(0x0018)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SearchRadius;                                      // 0x0028(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HeightRange;                                       // 0x002C(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bResult;                                           // 0x0030(0x0001)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_31[0x7];                                       // 0x0031(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                ClampedPosition;                                   // 0x0038(0x0018)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FMercunaUsageTypes                     ClampedUsageTypes;                                 // 0x0050(0x0004)(Parm, OutParm, NoDestructor, NativeAccessSpecifierPublic)
	struct FMercunaUsageSpec                      UsageSpec;                                         // 0x0054(0x0008)(ConstParm, Parm, NoDestructor, AdvancedDisplay, NativeAccessSpecifierPublic)
	bool                                          bIgnoreStationaryObstacles;                        // 0x005C(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5D[0x3];                                       // 0x005D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(MercunaNavGroundGrid_ClampToNavigable) == 0x000008, "Wrong alignment on MercunaNavGroundGrid_ClampToNavigable");
static_assert(sizeof(MercunaNavGroundGrid_ClampToNavigable) == 0x000060, "Wrong size on MercunaNavGroundGrid_ClampToNavigable");
static_assert(offsetof(MercunaNavGroundGrid_ClampToNavigable, AgentType) == 0x000000, "Member 'MercunaNavGroundGrid_ClampToNavigable::AgentType' has a wrong offset!");
static_assert(offsetof(MercunaNavGroundGrid_ClampToNavigable, Position) == 0x000010, "Member 'MercunaNavGroundGrid_ClampToNavigable::Position' has a wrong offset!");
static_assert(offsetof(MercunaNavGroundGrid_ClampToNavigable, SearchRadius) == 0x000028, "Member 'MercunaNavGroundGrid_ClampToNavigable::SearchRadius' has a wrong offset!");
static_assert(offsetof(MercunaNavGroundGrid_ClampToNavigable, HeightRange) == 0x00002C, "Member 'MercunaNavGroundGrid_ClampToNavigable::HeightRange' has a wrong offset!");
static_assert(offsetof(MercunaNavGroundGrid_ClampToNavigable, bResult) == 0x000030, "Member 'MercunaNavGroundGrid_ClampToNavigable::bResult' has a wrong offset!");
static_assert(offsetof(MercunaNavGroundGrid_ClampToNavigable, ClampedPosition) == 0x000038, "Member 'MercunaNavGroundGrid_ClampToNavigable::ClampedPosition' has a wrong offset!");
static_assert(offsetof(MercunaNavGroundGrid_ClampToNavigable, ClampedUsageTypes) == 0x000050, "Member 'MercunaNavGroundGrid_ClampToNavigable::ClampedUsageTypes' has a wrong offset!");
static_assert(offsetof(MercunaNavGroundGrid_ClampToNavigable, UsageSpec) == 0x000054, "Member 'MercunaNavGroundGrid_ClampToNavigable::UsageSpec' has a wrong offset!");
static_assert(offsetof(MercunaNavGroundGrid_ClampToNavigable, bIgnoreStationaryObstacles) == 0x00005C, "Member 'MercunaNavGroundGrid_ClampToNavigable::bIgnoreStationaryObstacles' has a wrong offset!");

// Function Mercuna.MercunaNavGroundGrid.GenerateRandomPoints
// 0x0050 (0x0050 - 0x0000)
struct MercunaNavGroundGrid_GenerateRandomPoints final
{
public:
	struct FMercunaGroundAgentType                AgentType;                                         // 0x0000(0x000C)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                Position;                                          // 0x0010(0x0018)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxDistance;                                       // 0x0028(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         NumPoints;                                         // 0x002C(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FVector>                        Results;                                           // 0x0030(0x0010)(Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
	bool                                          MaxDistanceIsPathDistance;                         // 0x0040(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EMercunaNavLinkQueryMode                      FollowNavLinks;                                    // 0x0041(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_42[0x2];                                       // 0x0042(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	struct FMercunaUsageSpec                      UsageSpec;                                         // 0x0044(0x0008)(ConstParm, Parm, NoDestructor, AdvancedDisplay, NativeAccessSpecifierPublic)
	bool                                          bIgnoreStationaryObstacles;                        // 0x004C(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4D[0x3];                                       // 0x004D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(MercunaNavGroundGrid_GenerateRandomPoints) == 0x000008, "Wrong alignment on MercunaNavGroundGrid_GenerateRandomPoints");
static_assert(sizeof(MercunaNavGroundGrid_GenerateRandomPoints) == 0x000050, "Wrong size on MercunaNavGroundGrid_GenerateRandomPoints");
static_assert(offsetof(MercunaNavGroundGrid_GenerateRandomPoints, AgentType) == 0x000000, "Member 'MercunaNavGroundGrid_GenerateRandomPoints::AgentType' has a wrong offset!");
static_assert(offsetof(MercunaNavGroundGrid_GenerateRandomPoints, Position) == 0x000010, "Member 'MercunaNavGroundGrid_GenerateRandomPoints::Position' has a wrong offset!");
static_assert(offsetof(MercunaNavGroundGrid_GenerateRandomPoints, MaxDistance) == 0x000028, "Member 'MercunaNavGroundGrid_GenerateRandomPoints::MaxDistance' has a wrong offset!");
static_assert(offsetof(MercunaNavGroundGrid_GenerateRandomPoints, NumPoints) == 0x00002C, "Member 'MercunaNavGroundGrid_GenerateRandomPoints::NumPoints' has a wrong offset!");
static_assert(offsetof(MercunaNavGroundGrid_GenerateRandomPoints, Results) == 0x000030, "Member 'MercunaNavGroundGrid_GenerateRandomPoints::Results' has a wrong offset!");
static_assert(offsetof(MercunaNavGroundGrid_GenerateRandomPoints, MaxDistanceIsPathDistance) == 0x000040, "Member 'MercunaNavGroundGrid_GenerateRandomPoints::MaxDistanceIsPathDistance' has a wrong offset!");
static_assert(offsetof(MercunaNavGroundGrid_GenerateRandomPoints, FollowNavLinks) == 0x000041, "Member 'MercunaNavGroundGrid_GenerateRandomPoints::FollowNavLinks' has a wrong offset!");
static_assert(offsetof(MercunaNavGroundGrid_GenerateRandomPoints, UsageSpec) == 0x000044, "Member 'MercunaNavGroundGrid_GenerateRandomPoints::UsageSpec' has a wrong offset!");
static_assert(offsetof(MercunaNavGroundGrid_GenerateRandomPoints, bIgnoreStationaryObstacles) == 0x00004C, "Member 'MercunaNavGroundGrid_GenerateRandomPoints::bIgnoreStationaryObstacles' has a wrong offset!");

// Function Mercuna.MercunaNavGroundGrid.GetAutoGenNavLinksInVolume
// 0x0058 (0x0058 - 0x0000)
struct MercunaNavGroundGrid_GetAutoGenNavLinksInVolume final
{
public:
	struct FMercunaGroundAgentType                AgentType;                                         // 0x0000(0x000C)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FBox                                   Volume;                                            // 0x0010(0x0038)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	TArray<struct FMercunaAutoNavLink>            Results;                                           // 0x0048(0x0010)(Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(MercunaNavGroundGrid_GetAutoGenNavLinksInVolume) == 0x000008, "Wrong alignment on MercunaNavGroundGrid_GetAutoGenNavLinksInVolume");
static_assert(sizeof(MercunaNavGroundGrid_GetAutoGenNavLinksInVolume) == 0x000058, "Wrong size on MercunaNavGroundGrid_GetAutoGenNavLinksInVolume");
static_assert(offsetof(MercunaNavGroundGrid_GetAutoGenNavLinksInVolume, AgentType) == 0x000000, "Member 'MercunaNavGroundGrid_GetAutoGenNavLinksInVolume::AgentType' has a wrong offset!");
static_assert(offsetof(MercunaNavGroundGrid_GetAutoGenNavLinksInVolume, Volume) == 0x000010, "Member 'MercunaNavGroundGrid_GetAutoGenNavLinksInVolume::Volume' has a wrong offset!");
static_assert(offsetof(MercunaNavGroundGrid_GetAutoGenNavLinksInVolume, Results) == 0x000048, "Member 'MercunaNavGroundGrid_GetAutoGenNavLinksInVolume::Results' has a wrong offset!");

// Function Mercuna.MercunaNavGroundGrid.GetClosestNavMeshEdge
// 0x0090 (0x0090 - 0x0000)
struct MercunaNavGroundGrid_GetClosestNavMeshEdge final
{
public:
	struct FMercunaGroundAgentType                AgentType;                                         // 0x0000(0x000C)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                Position;                                          // 0x0010(0x0018)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bResult;                                           // 0x0028(0x0001)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_29[0x7];                                       // 0x0029(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FMercunaNavMeshEdge                    ClosestEdge;                                       // 0x0030(0x0030)(Parm, OutParm, NoDestructor, NativeAccessSpecifierPublic)
	struct FVector                                ClosestPoint;                                      // 0x0060(0x0018)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxDistance;                                       // 0x0078(0x0004)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          MaxDistanceIsPathDistance;                         // 0x007C(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EMercunaNavLinkQueryMode                      FollowNavLinks;                                    // 0x007D(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_7E[0x2];                                       // 0x007E(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	struct FMercunaUsageSpec                      UsageSpec;                                         // 0x0080(0x0008)(ConstParm, Parm, NoDestructor, AdvancedDisplay, NativeAccessSpecifierPublic)
	bool                                          bIgnoreStationaryObstacles;                        // 0x0088(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_89[0x7];                                       // 0x0089(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(MercunaNavGroundGrid_GetClosestNavMeshEdge) == 0x000008, "Wrong alignment on MercunaNavGroundGrid_GetClosestNavMeshEdge");
static_assert(sizeof(MercunaNavGroundGrid_GetClosestNavMeshEdge) == 0x000090, "Wrong size on MercunaNavGroundGrid_GetClosestNavMeshEdge");
static_assert(offsetof(MercunaNavGroundGrid_GetClosestNavMeshEdge, AgentType) == 0x000000, "Member 'MercunaNavGroundGrid_GetClosestNavMeshEdge::AgentType' has a wrong offset!");
static_assert(offsetof(MercunaNavGroundGrid_GetClosestNavMeshEdge, Position) == 0x000010, "Member 'MercunaNavGroundGrid_GetClosestNavMeshEdge::Position' has a wrong offset!");
static_assert(offsetof(MercunaNavGroundGrid_GetClosestNavMeshEdge, bResult) == 0x000028, "Member 'MercunaNavGroundGrid_GetClosestNavMeshEdge::bResult' has a wrong offset!");
static_assert(offsetof(MercunaNavGroundGrid_GetClosestNavMeshEdge, ClosestEdge) == 0x000030, "Member 'MercunaNavGroundGrid_GetClosestNavMeshEdge::ClosestEdge' has a wrong offset!");
static_assert(offsetof(MercunaNavGroundGrid_GetClosestNavMeshEdge, ClosestPoint) == 0x000060, "Member 'MercunaNavGroundGrid_GetClosestNavMeshEdge::ClosestPoint' has a wrong offset!");
static_assert(offsetof(MercunaNavGroundGrid_GetClosestNavMeshEdge, MaxDistance) == 0x000078, "Member 'MercunaNavGroundGrid_GetClosestNavMeshEdge::MaxDistance' has a wrong offset!");
static_assert(offsetof(MercunaNavGroundGrid_GetClosestNavMeshEdge, MaxDistanceIsPathDistance) == 0x00007C, "Member 'MercunaNavGroundGrid_GetClosestNavMeshEdge::MaxDistanceIsPathDistance' has a wrong offset!");
static_assert(offsetof(MercunaNavGroundGrid_GetClosestNavMeshEdge, FollowNavLinks) == 0x00007D, "Member 'MercunaNavGroundGrid_GetClosestNavMeshEdge::FollowNavLinks' has a wrong offset!");
static_assert(offsetof(MercunaNavGroundGrid_GetClosestNavMeshEdge, UsageSpec) == 0x000080, "Member 'MercunaNavGroundGrid_GetClosestNavMeshEdge::UsageSpec' has a wrong offset!");
static_assert(offsetof(MercunaNavGroundGrid_GetClosestNavMeshEdge, bIgnoreStationaryObstacles) == 0x000088, "Member 'MercunaNavGroundGrid_GetClosestNavMeshEdge::bIgnoreStationaryObstacles' has a wrong offset!");

// Function Mercuna.MercunaNavGroundGrid.GetClosestPosInWater
// 0x0060 (0x0060 - 0x0000)
struct MercunaNavGroundGrid_GetClosestPosInWater final
{
public:
	struct FMercunaGroundAgentType                AgentType;                                         // 0x0000(0x000C)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                Position;                                          // 0x0010(0x0018)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bResult;                                           // 0x0028(0x0001)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_29[0x7];                                       // 0x0029(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                ClosestPosition;                                   // 0x0030(0x0018)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxPathDistance;                                   // 0x0048(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EMercunaNavLinkQueryMode                      FollowNavLinks;                                    // 0x004C(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4D[0x3];                                       // 0x004D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FMercunaUsageSpec                      UsageSpec;                                         // 0x0050(0x0008)(Parm, NoDestructor, AdvancedDisplay, NativeAccessSpecifierPublic)
	bool                                          bIgnoreStationaryObstacles;                        // 0x0058(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_59[0x7];                                       // 0x0059(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(MercunaNavGroundGrid_GetClosestPosInWater) == 0x000008, "Wrong alignment on MercunaNavGroundGrid_GetClosestPosInWater");
static_assert(sizeof(MercunaNavGroundGrid_GetClosestPosInWater) == 0x000060, "Wrong size on MercunaNavGroundGrid_GetClosestPosInWater");
static_assert(offsetof(MercunaNavGroundGrid_GetClosestPosInWater, AgentType) == 0x000000, "Member 'MercunaNavGroundGrid_GetClosestPosInWater::AgentType' has a wrong offset!");
static_assert(offsetof(MercunaNavGroundGrid_GetClosestPosInWater, Position) == 0x000010, "Member 'MercunaNavGroundGrid_GetClosestPosInWater::Position' has a wrong offset!");
static_assert(offsetof(MercunaNavGroundGrid_GetClosestPosInWater, bResult) == 0x000028, "Member 'MercunaNavGroundGrid_GetClosestPosInWater::bResult' has a wrong offset!");
static_assert(offsetof(MercunaNavGroundGrid_GetClosestPosInWater, ClosestPosition) == 0x000030, "Member 'MercunaNavGroundGrid_GetClosestPosInWater::ClosestPosition' has a wrong offset!");
static_assert(offsetof(MercunaNavGroundGrid_GetClosestPosInWater, MaxPathDistance) == 0x000048, "Member 'MercunaNavGroundGrid_GetClosestPosInWater::MaxPathDistance' has a wrong offset!");
static_assert(offsetof(MercunaNavGroundGrid_GetClosestPosInWater, FollowNavLinks) == 0x00004C, "Member 'MercunaNavGroundGrid_GetClosestPosInWater::FollowNavLinks' has a wrong offset!");
static_assert(offsetof(MercunaNavGroundGrid_GetClosestPosInWater, UsageSpec) == 0x000050, "Member 'MercunaNavGroundGrid_GetClosestPosInWater::UsageSpec' has a wrong offset!");
static_assert(offsetof(MercunaNavGroundGrid_GetClosestPosInWater, bIgnoreStationaryObstacles) == 0x000058, "Member 'MercunaNavGroundGrid_GetClosestPosInWater::bIgnoreStationaryObstacles' has a wrong offset!");

// Function Mercuna.MercunaNavGroundGrid.GetClosestPosOutOfWater
// 0x0060 (0x0060 - 0x0000)
struct MercunaNavGroundGrid_GetClosestPosOutOfWater final
{
public:
	struct FMercunaGroundAgentType                AgentType;                                         // 0x0000(0x000C)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                Position;                                          // 0x0010(0x0018)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bResult;                                           // 0x0028(0x0001)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_29[0x7];                                       // 0x0029(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                ClosestPosition;                                   // 0x0030(0x0018)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxPathDistance;                                   // 0x0048(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EMercunaNavLinkQueryMode                      FollowNavLinks;                                    // 0x004C(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4D[0x3];                                       // 0x004D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FMercunaUsageSpec                      UsageSpec;                                         // 0x0050(0x0008)(Parm, NoDestructor, AdvancedDisplay, NativeAccessSpecifierPublic)
	bool                                          bIgnoreStationaryObstacles;                        // 0x0058(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_59[0x7];                                       // 0x0059(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(MercunaNavGroundGrid_GetClosestPosOutOfWater) == 0x000008, "Wrong alignment on MercunaNavGroundGrid_GetClosestPosOutOfWater");
static_assert(sizeof(MercunaNavGroundGrid_GetClosestPosOutOfWater) == 0x000060, "Wrong size on MercunaNavGroundGrid_GetClosestPosOutOfWater");
static_assert(offsetof(MercunaNavGroundGrid_GetClosestPosOutOfWater, AgentType) == 0x000000, "Member 'MercunaNavGroundGrid_GetClosestPosOutOfWater::AgentType' has a wrong offset!");
static_assert(offsetof(MercunaNavGroundGrid_GetClosestPosOutOfWater, Position) == 0x000010, "Member 'MercunaNavGroundGrid_GetClosestPosOutOfWater::Position' has a wrong offset!");
static_assert(offsetof(MercunaNavGroundGrid_GetClosestPosOutOfWater, bResult) == 0x000028, "Member 'MercunaNavGroundGrid_GetClosestPosOutOfWater::bResult' has a wrong offset!");
static_assert(offsetof(MercunaNavGroundGrid_GetClosestPosOutOfWater, ClosestPosition) == 0x000030, "Member 'MercunaNavGroundGrid_GetClosestPosOutOfWater::ClosestPosition' has a wrong offset!");
static_assert(offsetof(MercunaNavGroundGrid_GetClosestPosOutOfWater, MaxPathDistance) == 0x000048, "Member 'MercunaNavGroundGrid_GetClosestPosOutOfWater::MaxPathDistance' has a wrong offset!");
static_assert(offsetof(MercunaNavGroundGrid_GetClosestPosOutOfWater, FollowNavLinks) == 0x00004C, "Member 'MercunaNavGroundGrid_GetClosestPosOutOfWater::FollowNavLinks' has a wrong offset!");
static_assert(offsetof(MercunaNavGroundGrid_GetClosestPosOutOfWater, UsageSpec) == 0x000050, "Member 'MercunaNavGroundGrid_GetClosestPosOutOfWater::UsageSpec' has a wrong offset!");
static_assert(offsetof(MercunaNavGroundGrid_GetClosestPosOutOfWater, bIgnoreStationaryObstacles) == 0x000058, "Member 'MercunaNavGroundGrid_GetClosestPosOutOfWater::bIgnoreStationaryObstacles' has a wrong offset!");

// Function Mercuna.MercunaNavGroundGrid.GetNavMeshEdges
// 0x0050 (0x0050 - 0x0000)
struct MercunaNavGroundGrid_GetNavMeshEdges final
{
public:
	struct FMercunaGroundAgentType                AgentType;                                         // 0x0000(0x000C)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                Position;                                          // 0x0010(0x0018)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxRadius;                                         // 0x0028(0x0004)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C[0x4];                                       // 0x002C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FMercunaNavMeshEdge>            NavMeshEdges;                                      // 0x0030(0x0010)(Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
	EMercunaNavLinkQueryMode                      FollowNavLinks;                                    // 0x0040(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_41[0x3];                                       // 0x0041(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FMercunaUsageSpec                      UsageSpec;                                         // 0x0044(0x0008)(ConstParm, Parm, NoDestructor, AdvancedDisplay, NativeAccessSpecifierPublic)
	bool                                          bIgnoreStationaryObstacles;                        // 0x004C(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4D[0x3];                                       // 0x004D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(MercunaNavGroundGrid_GetNavMeshEdges) == 0x000008, "Wrong alignment on MercunaNavGroundGrid_GetNavMeshEdges");
static_assert(sizeof(MercunaNavGroundGrid_GetNavMeshEdges) == 0x000050, "Wrong size on MercunaNavGroundGrid_GetNavMeshEdges");
static_assert(offsetof(MercunaNavGroundGrid_GetNavMeshEdges, AgentType) == 0x000000, "Member 'MercunaNavGroundGrid_GetNavMeshEdges::AgentType' has a wrong offset!");
static_assert(offsetof(MercunaNavGroundGrid_GetNavMeshEdges, Position) == 0x000010, "Member 'MercunaNavGroundGrid_GetNavMeshEdges::Position' has a wrong offset!");
static_assert(offsetof(MercunaNavGroundGrid_GetNavMeshEdges, MaxRadius) == 0x000028, "Member 'MercunaNavGroundGrid_GetNavMeshEdges::MaxRadius' has a wrong offset!");
static_assert(offsetof(MercunaNavGroundGrid_GetNavMeshEdges, NavMeshEdges) == 0x000030, "Member 'MercunaNavGroundGrid_GetNavMeshEdges::NavMeshEdges' has a wrong offset!");
static_assert(offsetof(MercunaNavGroundGrid_GetNavMeshEdges, FollowNavLinks) == 0x000040, "Member 'MercunaNavGroundGrid_GetNavMeshEdges::FollowNavLinks' has a wrong offset!");
static_assert(offsetof(MercunaNavGroundGrid_GetNavMeshEdges, UsageSpec) == 0x000044, "Member 'MercunaNavGroundGrid_GetNavMeshEdges::UsageSpec' has a wrong offset!");
static_assert(offsetof(MercunaNavGroundGrid_GetNavMeshEdges, bIgnoreStationaryObstacles) == 0x00004C, "Member 'MercunaNavGroundGrid_GetNavMeshEdges::bIgnoreStationaryObstacles' has a wrong offset!");

// Function Mercuna.MercunaNavGroundGrid.GetNumBoxesBuilding
// 0x0004 (0x0004 - 0x0000)
struct MercunaNavGroundGrid_GetNumBoxesBuilding final
{
public:
	int32                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MercunaNavGroundGrid_GetNumBoxesBuilding) == 0x000004, "Wrong alignment on MercunaNavGroundGrid_GetNumBoxesBuilding");
static_assert(sizeof(MercunaNavGroundGrid_GetNumBoxesBuilding) == 0x000004, "Wrong size on MercunaNavGroundGrid_GetNumBoxesBuilding");
static_assert(offsetof(MercunaNavGroundGrid_GetNumBoxesBuilding, ReturnValue) == 0x000000, "Member 'MercunaNavGroundGrid_GetNumBoxesBuilding::ReturnValue' has a wrong offset!");

// Function Mercuna.MercunaNavGroundGrid.GetWaterEdges
// 0x0050 (0x0050 - 0x0000)
struct MercunaNavGroundGrid_GetWaterEdges final
{
public:
	struct FMercunaGroundAgentType                AgentType;                                         // 0x0000(0x000C)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                Position;                                          // 0x0010(0x0018)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxPathDistance;                                   // 0x0028(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C[0x4];                                       // 0x002C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FMercunaNavEdge>                Edges;                                             // 0x0030(0x0010)(Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
	EMercunaNavLinkQueryMode                      FollowNavLinks;                                    // 0x0040(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_41[0x3];                                       // 0x0041(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FMercunaUsageSpec                      UsageSpec;                                         // 0x0044(0x0008)(Parm, NoDestructor, AdvancedDisplay, NativeAccessSpecifierPublic)
	bool                                          bIgnoreStationaryObstacles;                        // 0x004C(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4D[0x3];                                       // 0x004D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(MercunaNavGroundGrid_GetWaterEdges) == 0x000008, "Wrong alignment on MercunaNavGroundGrid_GetWaterEdges");
static_assert(sizeof(MercunaNavGroundGrid_GetWaterEdges) == 0x000050, "Wrong size on MercunaNavGroundGrid_GetWaterEdges");
static_assert(offsetof(MercunaNavGroundGrid_GetWaterEdges, AgentType) == 0x000000, "Member 'MercunaNavGroundGrid_GetWaterEdges::AgentType' has a wrong offset!");
static_assert(offsetof(MercunaNavGroundGrid_GetWaterEdges, Position) == 0x000010, "Member 'MercunaNavGroundGrid_GetWaterEdges::Position' has a wrong offset!");
static_assert(offsetof(MercunaNavGroundGrid_GetWaterEdges, MaxPathDistance) == 0x000028, "Member 'MercunaNavGroundGrid_GetWaterEdges::MaxPathDistance' has a wrong offset!");
static_assert(offsetof(MercunaNavGroundGrid_GetWaterEdges, Edges) == 0x000030, "Member 'MercunaNavGroundGrid_GetWaterEdges::Edges' has a wrong offset!");
static_assert(offsetof(MercunaNavGroundGrid_GetWaterEdges, FollowNavLinks) == 0x000040, "Member 'MercunaNavGroundGrid_GetWaterEdges::FollowNavLinks' has a wrong offset!");
static_assert(offsetof(MercunaNavGroundGrid_GetWaterEdges, UsageSpec) == 0x000044, "Member 'MercunaNavGroundGrid_GetWaterEdges::UsageSpec' has a wrong offset!");
static_assert(offsetof(MercunaNavGroundGrid_GetWaterEdges, bIgnoreStationaryObstacles) == 0x00004C, "Member 'MercunaNavGroundGrid_GetWaterEdges::bIgnoreStationaryObstacles' has a wrong offset!");

// Function Mercuna.MercunaNavGroundGrid.IsAnyWorkInProgress
// 0x0001 (0x0001 - 0x0000)
struct MercunaNavGroundGrid_IsAnyWorkInProgress final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MercunaNavGroundGrid_IsAnyWorkInProgress) == 0x000001, "Wrong alignment on MercunaNavGroundGrid_IsAnyWorkInProgress");
static_assert(sizeof(MercunaNavGroundGrid_IsAnyWorkInProgress) == 0x000001, "Wrong size on MercunaNavGroundGrid_IsAnyWorkInProgress");
static_assert(offsetof(MercunaNavGroundGrid_IsAnyWorkInProgress, ReturnValue) == 0x000000, "Member 'MercunaNavGroundGrid_IsAnyWorkInProgress::ReturnValue' has a wrong offset!");

// Function Mercuna.MercunaNavGroundGrid.IsBuilding
// 0x0001 (0x0001 - 0x0000)
struct MercunaNavGroundGrid_IsBuilding final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MercunaNavGroundGrid_IsBuilding) == 0x000001, "Wrong alignment on MercunaNavGroundGrid_IsBuilding");
static_assert(sizeof(MercunaNavGroundGrid_IsBuilding) == 0x000001, "Wrong size on MercunaNavGroundGrid_IsBuilding");
static_assert(offsetof(MercunaNavGroundGrid_IsBuilding, ReturnValue) == 0x000000, "Member 'MercunaNavGroundGrid_IsBuilding::ReturnValue' has a wrong offset!");

// Function Mercuna.MercunaNavGroundGrid.IsBuilt
// 0x0030 (0x0030 - 0x0000)
struct MercunaNavGroundGrid_IsBuilt final
{
public:
	struct FMercunaGroundAgentType                AgentType;                                         // 0x0000(0x000C)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                Pos;                                               // 0x0010(0x0018)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0028(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_29[0x7];                                       // 0x0029(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(MercunaNavGroundGrid_IsBuilt) == 0x000008, "Wrong alignment on MercunaNavGroundGrid_IsBuilt");
static_assert(sizeof(MercunaNavGroundGrid_IsBuilt) == 0x000030, "Wrong size on MercunaNavGroundGrid_IsBuilt");
static_assert(offsetof(MercunaNavGroundGrid_IsBuilt, AgentType) == 0x000000, "Member 'MercunaNavGroundGrid_IsBuilt::AgentType' has a wrong offset!");
static_assert(offsetof(MercunaNavGroundGrid_IsBuilt, Pos) == 0x000010, "Member 'MercunaNavGroundGrid_IsBuilt::Pos' has a wrong offset!");
static_assert(offsetof(MercunaNavGroundGrid_IsBuilt, ReturnValue) == 0x000028, "Member 'MercunaNavGroundGrid_IsBuilt::ReturnValue' has a wrong offset!");

// Function Mercuna.MercunaNavGroundGrid.IsBuiltWithinBox
// 0x0050 (0x0050 - 0x0000)
struct MercunaNavGroundGrid_IsBuiltWithinBox final
{
public:
	struct FMercunaGroundAgentType                AgentType;                                         // 0x0000(0x000C)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FBox                                   Box;                                               // 0x0010(0x0038)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0048(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_49[0x7];                                       // 0x0049(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(MercunaNavGroundGrid_IsBuiltWithinBox) == 0x000008, "Wrong alignment on MercunaNavGroundGrid_IsBuiltWithinBox");
static_assert(sizeof(MercunaNavGroundGrid_IsBuiltWithinBox) == 0x000050, "Wrong size on MercunaNavGroundGrid_IsBuiltWithinBox");
static_assert(offsetof(MercunaNavGroundGrid_IsBuiltWithinBox, AgentType) == 0x000000, "Member 'MercunaNavGroundGrid_IsBuiltWithinBox::AgentType' has a wrong offset!");
static_assert(offsetof(MercunaNavGroundGrid_IsBuiltWithinBox, Box) == 0x000010, "Member 'MercunaNavGroundGrid_IsBuiltWithinBox::Box' has a wrong offset!");
static_assert(offsetof(MercunaNavGroundGrid_IsBuiltWithinBox, ReturnValue) == 0x000048, "Member 'MercunaNavGroundGrid_IsBuiltWithinBox::ReturnValue' has a wrong offset!");

// Function Mercuna.MercunaNavGroundGrid.IsNavigable
// 0x0038 (0x0038 - 0x0000)
struct MercunaNavGroundGrid_IsNavigable final
{
public:
	struct FMercunaGroundAgentType                AgentType;                                         // 0x0000(0x000C)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                Position;                                          // 0x0010(0x0018)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bResult;                                           // 0x0028(0x0001)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_29[0x3];                                       // 0x0029(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FMercunaUsageSpec                      UsageSpec;                                         // 0x002C(0x0008)(ConstParm, Parm, NoDestructor, AdvancedDisplay, NativeAccessSpecifierPublic)
	bool                                          bIgnoreStationaryObstacles;                        // 0x0034(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_35[0x3];                                       // 0x0035(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(MercunaNavGroundGrid_IsNavigable) == 0x000008, "Wrong alignment on MercunaNavGroundGrid_IsNavigable");
static_assert(sizeof(MercunaNavGroundGrid_IsNavigable) == 0x000038, "Wrong size on MercunaNavGroundGrid_IsNavigable");
static_assert(offsetof(MercunaNavGroundGrid_IsNavigable, AgentType) == 0x000000, "Member 'MercunaNavGroundGrid_IsNavigable::AgentType' has a wrong offset!");
static_assert(offsetof(MercunaNavGroundGrid_IsNavigable, Position) == 0x000010, "Member 'MercunaNavGroundGrid_IsNavigable::Position' has a wrong offset!");
static_assert(offsetof(MercunaNavGroundGrid_IsNavigable, bResult) == 0x000028, "Member 'MercunaNavGroundGrid_IsNavigable::bResult' has a wrong offset!");
static_assert(offsetof(MercunaNavGroundGrid_IsNavigable, UsageSpec) == 0x00002C, "Member 'MercunaNavGroundGrid_IsNavigable::UsageSpec' has a wrong offset!");
static_assert(offsetof(MercunaNavGroundGrid_IsNavigable, bIgnoreStationaryObstacles) == 0x000034, "Member 'MercunaNavGroundGrid_IsNavigable::bIgnoreStationaryObstacles' has a wrong offset!");

// Function Mercuna.MercunaNavGroundGrid.IsNavigableMulti
// 0x0040 (0x0040 - 0x0000)
struct MercunaNavGroundGrid_IsNavigableMulti final
{
public:
	struct FMercunaGroundAgentType                AgentType;                                         // 0x0000(0x000C)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FVector>                        Positions;                                         // 0x0010(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	TArray<bool>                                  Results;                                           // 0x0020(0x0010)(Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
	struct FMercunaUsageSpec                      UsageSpec;                                         // 0x0030(0x0008)(ConstParm, Parm, NoDestructor, AdvancedDisplay, NativeAccessSpecifierPublic)
	bool                                          bIgnoreStationaryObstacles;                        // 0x0038(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_39[0x7];                                       // 0x0039(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(MercunaNavGroundGrid_IsNavigableMulti) == 0x000008, "Wrong alignment on MercunaNavGroundGrid_IsNavigableMulti");
static_assert(sizeof(MercunaNavGroundGrid_IsNavigableMulti) == 0x000040, "Wrong size on MercunaNavGroundGrid_IsNavigableMulti");
static_assert(offsetof(MercunaNavGroundGrid_IsNavigableMulti, AgentType) == 0x000000, "Member 'MercunaNavGroundGrid_IsNavigableMulti::AgentType' has a wrong offset!");
static_assert(offsetof(MercunaNavGroundGrid_IsNavigableMulti, Positions) == 0x000010, "Member 'MercunaNavGroundGrid_IsNavigableMulti::Positions' has a wrong offset!");
static_assert(offsetof(MercunaNavGroundGrid_IsNavigableMulti, Results) == 0x000020, "Member 'MercunaNavGroundGrid_IsNavigableMulti::Results' has a wrong offset!");
static_assert(offsetof(MercunaNavGroundGrid_IsNavigableMulti, UsageSpec) == 0x000030, "Member 'MercunaNavGroundGrid_IsNavigableMulti::UsageSpec' has a wrong offset!");
static_assert(offsetof(MercunaNavGroundGrid_IsNavigableMulti, bIgnoreStationaryObstacles) == 0x000038, "Member 'MercunaNavGroundGrid_IsNavigableMulti::bIgnoreStationaryObstacles' has a wrong offset!");

// Function Mercuna.MercunaNavGroundGrid.IsReachable
// 0x0058 (0x0058 - 0x0000)
struct MercunaNavGroundGrid_IsReachable final
{
public:
	struct FMercunaGroundAgentType                AgentType;                                         // 0x0000(0x000C)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                From;                                              // 0x0010(0x0018)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                To;                                                // 0x0028(0x0018)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxPathLength;                                     // 0x0040(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EMercunaNavLinkQueryMode                      FollowNavLinks;                                    // 0x0044(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_45[0x3];                                       // 0x0045(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FMercunaUsageSpec                      UsageSpec;                                         // 0x0048(0x0008)(ConstParm, Parm, NoDestructor, AdvancedDisplay, NativeAccessSpecifierPublic)
	bool                                          bIgnoreStationaryObstacles;                        // 0x0050(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0051(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_52[0x6];                                       // 0x0052(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(MercunaNavGroundGrid_IsReachable) == 0x000008, "Wrong alignment on MercunaNavGroundGrid_IsReachable");
static_assert(sizeof(MercunaNavGroundGrid_IsReachable) == 0x000058, "Wrong size on MercunaNavGroundGrid_IsReachable");
static_assert(offsetof(MercunaNavGroundGrid_IsReachable, AgentType) == 0x000000, "Member 'MercunaNavGroundGrid_IsReachable::AgentType' has a wrong offset!");
static_assert(offsetof(MercunaNavGroundGrid_IsReachable, From) == 0x000010, "Member 'MercunaNavGroundGrid_IsReachable::From' has a wrong offset!");
static_assert(offsetof(MercunaNavGroundGrid_IsReachable, To) == 0x000028, "Member 'MercunaNavGroundGrid_IsReachable::To' has a wrong offset!");
static_assert(offsetof(MercunaNavGroundGrid_IsReachable, MaxPathLength) == 0x000040, "Member 'MercunaNavGroundGrid_IsReachable::MaxPathLength' has a wrong offset!");
static_assert(offsetof(MercunaNavGroundGrid_IsReachable, FollowNavLinks) == 0x000044, "Member 'MercunaNavGroundGrid_IsReachable::FollowNavLinks' has a wrong offset!");
static_assert(offsetof(MercunaNavGroundGrid_IsReachable, UsageSpec) == 0x000048, "Member 'MercunaNavGroundGrid_IsReachable::UsageSpec' has a wrong offset!");
static_assert(offsetof(MercunaNavGroundGrid_IsReachable, bIgnoreStationaryObstacles) == 0x000050, "Member 'MercunaNavGroundGrid_IsReachable::bIgnoreStationaryObstacles' has a wrong offset!");
static_assert(offsetof(MercunaNavGroundGrid_IsReachable, ReturnValue) == 0x000051, "Member 'MercunaNavGroundGrid_IsReachable::ReturnValue' has a wrong offset!");

// Function Mercuna.MercunaNavGroundGrid.IsReachableLatent
// 0x0098 (0x0098 - 0x0000)
struct MercunaNavGroundGrid_IsReachableLatent final
{
public:
	struct FMercunaGroundAgentType                AgentType;                                         // 0x0000(0x000C)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                From;                                              // 0x0010(0x0018)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FVector>                        To;                                                // 0x0028(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	TArray<bool>                                  Result;                                            // 0x0038(0x0010)(Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FVector>                        ClampedTo;                                         // 0x0048(0x0010)(Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
	class UObject*                                WorldContextObject;                                // 0x0058(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLatentActionInfo                      LatentInfo;                                        // 0x0060(0x0018)(Parm, NoDestructor, NativeAccessSpecifierPublic)
	float                                         MaxPathLength;                                     // 0x0078(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FromSearchRadius;                                  // 0x007C(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ToSearchRadius;                                    // 0x0080(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EMercunaNavLinkQueryMode                      FollowNavLinks;                                    // 0x0084(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_85[0x3];                                       // 0x0085(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FMercunaUsageSpec                      UsageSpec;                                         // 0x0088(0x0008)(ConstParm, Parm, NoDestructor, AdvancedDisplay, NativeAccessSpecifierPublic)
	bool                                          bIgnoreStationaryObstacles;                        // 0x0090(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_91[0x7];                                       // 0x0091(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(MercunaNavGroundGrid_IsReachableLatent) == 0x000008, "Wrong alignment on MercunaNavGroundGrid_IsReachableLatent");
static_assert(sizeof(MercunaNavGroundGrid_IsReachableLatent) == 0x000098, "Wrong size on MercunaNavGroundGrid_IsReachableLatent");
static_assert(offsetof(MercunaNavGroundGrid_IsReachableLatent, AgentType) == 0x000000, "Member 'MercunaNavGroundGrid_IsReachableLatent::AgentType' has a wrong offset!");
static_assert(offsetof(MercunaNavGroundGrid_IsReachableLatent, From) == 0x000010, "Member 'MercunaNavGroundGrid_IsReachableLatent::From' has a wrong offset!");
static_assert(offsetof(MercunaNavGroundGrid_IsReachableLatent, To) == 0x000028, "Member 'MercunaNavGroundGrid_IsReachableLatent::To' has a wrong offset!");
static_assert(offsetof(MercunaNavGroundGrid_IsReachableLatent, Result) == 0x000038, "Member 'MercunaNavGroundGrid_IsReachableLatent::Result' has a wrong offset!");
static_assert(offsetof(MercunaNavGroundGrid_IsReachableLatent, ClampedTo) == 0x000048, "Member 'MercunaNavGroundGrid_IsReachableLatent::ClampedTo' has a wrong offset!");
static_assert(offsetof(MercunaNavGroundGrid_IsReachableLatent, WorldContextObject) == 0x000058, "Member 'MercunaNavGroundGrid_IsReachableLatent::WorldContextObject' has a wrong offset!");
static_assert(offsetof(MercunaNavGroundGrid_IsReachableLatent, LatentInfo) == 0x000060, "Member 'MercunaNavGroundGrid_IsReachableLatent::LatentInfo' has a wrong offset!");
static_assert(offsetof(MercunaNavGroundGrid_IsReachableLatent, MaxPathLength) == 0x000078, "Member 'MercunaNavGroundGrid_IsReachableLatent::MaxPathLength' has a wrong offset!");
static_assert(offsetof(MercunaNavGroundGrid_IsReachableLatent, FromSearchRadius) == 0x00007C, "Member 'MercunaNavGroundGrid_IsReachableLatent::FromSearchRadius' has a wrong offset!");
static_assert(offsetof(MercunaNavGroundGrid_IsReachableLatent, ToSearchRadius) == 0x000080, "Member 'MercunaNavGroundGrid_IsReachableLatent::ToSearchRadius' has a wrong offset!");
static_assert(offsetof(MercunaNavGroundGrid_IsReachableLatent, FollowNavLinks) == 0x000084, "Member 'MercunaNavGroundGrid_IsReachableLatent::FollowNavLinks' has a wrong offset!");
static_assert(offsetof(MercunaNavGroundGrid_IsReachableLatent, UsageSpec) == 0x000088, "Member 'MercunaNavGroundGrid_IsReachableLatent::UsageSpec' has a wrong offset!");
static_assert(offsetof(MercunaNavGroundGrid_IsReachableLatent, bIgnoreStationaryObstacles) == 0x000090, "Member 'MercunaNavGroundGrid_IsReachableLatent::bIgnoreStationaryObstacles' has a wrong offset!");

// Function Mercuna.MercunaNavGroundGrid.ProjectToNavigable
// 0x0058 (0x0058 - 0x0000)
struct MercunaNavGroundGrid_ProjectToNavigable final
{
public:
	struct FMercunaGroundAgentType                AgentType;                                         // 0x0000(0x000C)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                Position;                                          // 0x0010(0x0018)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EMercunaProjectionDirection                   Direction;                                         // 0x0028(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bResult;                                           // 0x0029(0x0001)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2A[0x6];                                       // 0x002A(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                ProjectedPosition;                                 // 0x0030(0x0018)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SearchHeight;                                      // 0x0048(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FMercunaUsageSpec                      UsageSpec;                                         // 0x004C(0x0008)(ConstParm, Parm, NoDestructor, AdvancedDisplay, NativeAccessSpecifierPublic)
	bool                                          bIgnoreStationaryObstacles;                        // 0x0054(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_55[0x3];                                       // 0x0055(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(MercunaNavGroundGrid_ProjectToNavigable) == 0x000008, "Wrong alignment on MercunaNavGroundGrid_ProjectToNavigable");
static_assert(sizeof(MercunaNavGroundGrid_ProjectToNavigable) == 0x000058, "Wrong size on MercunaNavGroundGrid_ProjectToNavigable");
static_assert(offsetof(MercunaNavGroundGrid_ProjectToNavigable, AgentType) == 0x000000, "Member 'MercunaNavGroundGrid_ProjectToNavigable::AgentType' has a wrong offset!");
static_assert(offsetof(MercunaNavGroundGrid_ProjectToNavigable, Position) == 0x000010, "Member 'MercunaNavGroundGrid_ProjectToNavigable::Position' has a wrong offset!");
static_assert(offsetof(MercunaNavGroundGrid_ProjectToNavigable, Direction) == 0x000028, "Member 'MercunaNavGroundGrid_ProjectToNavigable::Direction' has a wrong offset!");
static_assert(offsetof(MercunaNavGroundGrid_ProjectToNavigable, bResult) == 0x000029, "Member 'MercunaNavGroundGrid_ProjectToNavigable::bResult' has a wrong offset!");
static_assert(offsetof(MercunaNavGroundGrid_ProjectToNavigable, ProjectedPosition) == 0x000030, "Member 'MercunaNavGroundGrid_ProjectToNavigable::ProjectedPosition' has a wrong offset!");
static_assert(offsetof(MercunaNavGroundGrid_ProjectToNavigable, SearchHeight) == 0x000048, "Member 'MercunaNavGroundGrid_ProjectToNavigable::SearchHeight' has a wrong offset!");
static_assert(offsetof(MercunaNavGroundGrid_ProjectToNavigable, UsageSpec) == 0x00004C, "Member 'MercunaNavGroundGrid_ProjectToNavigable::UsageSpec' has a wrong offset!");
static_assert(offsetof(MercunaNavGroundGrid_ProjectToNavigable, bIgnoreStationaryObstacles) == 0x000054, "Member 'MercunaNavGroundGrid_ProjectToNavigable::bIgnoreStationaryObstacles' has a wrong offset!");

// Function Mercuna.MercunaNavGroundGrid.Raycast
// 0x0070 (0x0070 - 0x0000)
struct MercunaNavGroundGrid_Raycast final
{
public:
	struct FMercunaGroundAgentType                AgentType;                                         // 0x0000(0x000C)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                From;                                              // 0x0010(0x0018)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                To;                                                // 0x0028(0x0018)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bRayHit;                                           // 0x0040(0x0001)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_41[0x7];                                       // 0x0041(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                HitPosition;                                       // 0x0048(0x0018)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FMercunaUsageSpec                      UsageSpec;                                         // 0x0060(0x0008)(ConstParm, Parm, NoDestructor, AdvancedDisplay, NativeAccessSpecifierPublic)
	bool                                          bIgnoreStationaryObstacles;                        // 0x0068(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_69[0x7];                                       // 0x0069(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(MercunaNavGroundGrid_Raycast) == 0x000008, "Wrong alignment on MercunaNavGroundGrid_Raycast");
static_assert(sizeof(MercunaNavGroundGrid_Raycast) == 0x000070, "Wrong size on MercunaNavGroundGrid_Raycast");
static_assert(offsetof(MercunaNavGroundGrid_Raycast, AgentType) == 0x000000, "Member 'MercunaNavGroundGrid_Raycast::AgentType' has a wrong offset!");
static_assert(offsetof(MercunaNavGroundGrid_Raycast, From) == 0x000010, "Member 'MercunaNavGroundGrid_Raycast::From' has a wrong offset!");
static_assert(offsetof(MercunaNavGroundGrid_Raycast, To) == 0x000028, "Member 'MercunaNavGroundGrid_Raycast::To' has a wrong offset!");
static_assert(offsetof(MercunaNavGroundGrid_Raycast, bRayHit) == 0x000040, "Member 'MercunaNavGroundGrid_Raycast::bRayHit' has a wrong offset!");
static_assert(offsetof(MercunaNavGroundGrid_Raycast, HitPosition) == 0x000048, "Member 'MercunaNavGroundGrid_Raycast::HitPosition' has a wrong offset!");
static_assert(offsetof(MercunaNavGroundGrid_Raycast, UsageSpec) == 0x000060, "Member 'MercunaNavGroundGrid_Raycast::UsageSpec' has a wrong offset!");
static_assert(offsetof(MercunaNavGroundGrid_Raycast, bIgnoreStationaryObstacles) == 0x000068, "Member 'MercunaNavGroundGrid_Raycast::bIgnoreStationaryObstacles' has a wrong offset!");

// Function Mercuna.MercunaNavGroundGrid.SaveToObjFile
// 0x0010 (0x0010 - 0x0000)
struct MercunaNavGroundGrid_SaveToObjFile final
{
public:
	struct FMercunaGroundAgentType                AgentType;                                         // 0x0000(0x000C)(Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDrawPolyMesh;                                     // 0x000C(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D[0x3];                                        // 0x000D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(MercunaNavGroundGrid_SaveToObjFile) == 0x000004, "Wrong alignment on MercunaNavGroundGrid_SaveToObjFile");
static_assert(sizeof(MercunaNavGroundGrid_SaveToObjFile) == 0x000010, "Wrong size on MercunaNavGroundGrid_SaveToObjFile");
static_assert(offsetof(MercunaNavGroundGrid_SaveToObjFile, AgentType) == 0x000000, "Member 'MercunaNavGroundGrid_SaveToObjFile::AgentType' has a wrong offset!");
static_assert(offsetof(MercunaNavGroundGrid_SaveToObjFile, bDrawPolyMesh) == 0x00000C, "Member 'MercunaNavGroundGrid_SaveToObjFile::bDrawPolyMesh' has a wrong offset!");

// Function Mercuna.MercunaObstacleComponent.OnCharacterMovementModeChanged
// 0x0010 (0x0010 - 0x0000)
struct MercunaObstacleComponent_OnCharacterMovementModeChanged final
{
public:
	class ACharacter*                             Character;                                         // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EMovementMode                                 PrevMovementMode;                                  // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         PreviousCustomMode;                                // 0x0009(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A[0x6];                                        // 0x000A(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(MercunaObstacleComponent_OnCharacterMovementModeChanged) == 0x000008, "Wrong alignment on MercunaObstacleComponent_OnCharacterMovementModeChanged");
static_assert(sizeof(MercunaObstacleComponent_OnCharacterMovementModeChanged) == 0x000010, "Wrong size on MercunaObstacleComponent_OnCharacterMovementModeChanged");
static_assert(offsetof(MercunaObstacleComponent_OnCharacterMovementModeChanged, Character) == 0x000000, "Member 'MercunaObstacleComponent_OnCharacterMovementModeChanged::Character' has a wrong offset!");
static_assert(offsetof(MercunaObstacleComponent_OnCharacterMovementModeChanged, PrevMovementMode) == 0x000008, "Member 'MercunaObstacleComponent_OnCharacterMovementModeChanged::PrevMovementMode' has a wrong offset!");
static_assert(offsetof(MercunaObstacleComponent_OnCharacterMovementModeChanged, PreviousCustomMode) == 0x000009, "Member 'MercunaObstacleComponent_OnCharacterMovementModeChanged::PreviousCustomMode' has a wrong offset!");

// Function Mercuna.MercunaObstacleComponent.UpdateMovementType
// 0x0001 (0x0001 - 0x0000)
struct MercunaObstacleComponent_UpdateMovementType final
{
public:
	EMercunaObstacleMovementType                  NewMovementType;                                   // 0x0000(0x0001)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MercunaObstacleComponent_UpdateMovementType) == 0x000001, "Wrong alignment on MercunaObstacleComponent_UpdateMovementType");
static_assert(sizeof(MercunaObstacleComponent_UpdateMovementType) == 0x000001, "Wrong size on MercunaObstacleComponent_UpdateMovementType");
static_assert(offsetof(MercunaObstacleComponent_UpdateMovementType, NewMovementType) == 0x000000, "Member 'MercunaObstacleComponent_UpdateMovementType::NewMovementType' has a wrong offset!");

// Function Mercuna.MercunaNavVolume.SetNavigationRotation
// 0x0018 (0x0018 - 0x0000)
struct MercunaNavVolume_SetNavigationRotation final
{
public:
	struct FRotator                               Rotation;                                          // 0x0000(0x0018)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(MercunaNavVolume_SetNavigationRotation) == 0x000008, "Wrong alignment on MercunaNavVolume_SetNavigationRotation");
static_assert(sizeof(MercunaNavVolume_SetNavigationRotation) == 0x000018, "Wrong size on MercunaNavVolume_SetNavigationRotation");
static_assert(offsetof(MercunaNavVolume_SetNavigationRotation, Rotation) == 0x000000, "Member 'MercunaNavVolume_SetNavigationRotation::Rotation' has a wrong offset!");

// Function Mercuna.MercunaNavVolume.SetSize
// 0x0018 (0x0018 - 0x0000)
struct MercunaNavVolume_SetSize final
{
public:
	struct FVector                                Size;                                              // 0x0000(0x0018)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MercunaNavVolume_SetSize) == 0x000008, "Wrong alignment on MercunaNavVolume_SetSize");
static_assert(sizeof(MercunaNavVolume_SetSize) == 0x000018, "Wrong size on MercunaNavVolume_SetSize");
static_assert(offsetof(MercunaNavVolume_SetSize, Size) == 0x000000, "Member 'MercunaNavVolume_SetSize::Size' has a wrong offset!");

// Function Mercuna.MercunaNavVolume.GetSize
// 0x0018 (0x0018 - 0x0000)
struct MercunaNavVolume_GetSize final
{
public:
	struct FVector                                ReturnValue;                                       // 0x0000(0x0018)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MercunaNavVolume_GetSize) == 0x000008, "Wrong alignment on MercunaNavVolume_GetSize");
static_assert(sizeof(MercunaNavVolume_GetSize) == 0x000018, "Wrong size on MercunaNavVolume_GetSize");
static_assert(offsetof(MercunaNavVolume_GetSize, ReturnValue) == 0x000000, "Member 'MercunaNavVolume_GetSize::ReturnValue' has a wrong offset!");

// Function Mercuna.MercunaNavModifierComponent.SetCostMultiplier
// 0x0004 (0x0004 - 0x0000)
struct MercunaNavModifierComponent_SetCostMultiplier final
{
public:
	float                                         NewCostMultiplier;                                 // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MercunaNavModifierComponent_SetCostMultiplier) == 0x000004, "Wrong alignment on MercunaNavModifierComponent_SetCostMultiplier");
static_assert(sizeof(MercunaNavModifierComponent_SetCostMultiplier) == 0x000004, "Wrong size on MercunaNavModifierComponent_SetCostMultiplier");
static_assert(offsetof(MercunaNavModifierComponent_SetCostMultiplier, NewCostMultiplier) == 0x000000, "Member 'MercunaNavModifierComponent_SetCostMultiplier::NewCostMultiplier' has a wrong offset!");

// Function Mercuna.MercunaNavModifierComponent.SetEnabled
// 0x0001 (0x0001 - 0x0000)
struct MercunaNavModifierComponent_SetEnabled final
{
public:
	bool                                          Enabled;                                           // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MercunaNavModifierComponent_SetEnabled) == 0x000001, "Wrong alignment on MercunaNavModifierComponent_SetEnabled");
static_assert(sizeof(MercunaNavModifierComponent_SetEnabled) == 0x000001, "Wrong size on MercunaNavModifierComponent_SetEnabled");
static_assert(offsetof(MercunaNavModifierComponent_SetEnabled, Enabled) == 0x000000, "Member 'MercunaNavModifierComponent_SetEnabled::Enabled' has a wrong offset!");

// Function Mercuna.MercunaNavModifierComponent.SetSize
// 0x0018 (0x0018 - 0x0000)
struct MercunaNavModifierComponent_SetSize final
{
public:
	struct FVector                                NewSize;                                           // 0x0000(0x0018)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MercunaNavModifierComponent_SetSize) == 0x000008, "Wrong alignment on MercunaNavModifierComponent_SetSize");
static_assert(sizeof(MercunaNavModifierComponent_SetSize) == 0x000018, "Wrong size on MercunaNavModifierComponent_SetSize");
static_assert(offsetof(MercunaNavModifierComponent_SetSize, NewSize) == 0x000000, "Member 'MercunaNavModifierComponent_SetSize::NewSize' has a wrong offset!");

// Function Mercuna.MercunaNavModifierComponent.SetUsageTypes
// 0x0004 (0x0004 - 0x0000)
struct MercunaNavModifierComponent_SetUsageTypes final
{
public:
	struct FMercunaUsageTypes                     NewUsageTypes;                                     // 0x0000(0x0004)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(MercunaNavModifierComponent_SetUsageTypes) == 0x000004, "Wrong alignment on MercunaNavModifierComponent_SetUsageTypes");
static_assert(sizeof(MercunaNavModifierComponent_SetUsageTypes) == 0x000004, "Wrong size on MercunaNavModifierComponent_SetUsageTypes");
static_assert(offsetof(MercunaNavModifierComponent_SetUsageTypes, NewUsageTypes) == 0x000000, "Member 'MercunaNavModifierComponent_SetUsageTypes::NewUsageTypes' has a wrong offset!");

// Function Mercuna.MercunaNavModifierComponent.GetSize
// 0x0018 (0x0018 - 0x0000)
struct MercunaNavModifierComponent_GetSize final
{
public:
	struct FVector                                ReturnValue;                                       // 0x0000(0x0018)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MercunaNavModifierComponent_GetSize) == 0x000008, "Wrong alignment on MercunaNavModifierComponent_GetSize");
static_assert(sizeof(MercunaNavModifierComponent_GetSize) == 0x000018, "Wrong size on MercunaNavModifierComponent_GetSize");
static_assert(offsetof(MercunaNavModifierComponent_GetSize, ReturnValue) == 0x000000, "Member 'MercunaNavModifierComponent_GetSize::ReturnValue' has a wrong offset!");

// Function Mercuna.MercunaNavGridModifierComponent.AddToGrid
// 0x0010 (0x0010 - 0x0000)
struct MercunaNavGridModifierComponent_AddToGrid final
{
public:
	class AMercunaNavGraph2D*                     NewNavGrid;                                        // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bRebuildGraph;                                     // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(MercunaNavGridModifierComponent_AddToGrid) == 0x000008, "Wrong alignment on MercunaNavGridModifierComponent_AddToGrid");
static_assert(sizeof(MercunaNavGridModifierComponent_AddToGrid) == 0x000010, "Wrong size on MercunaNavGridModifierComponent_AddToGrid");
static_assert(offsetof(MercunaNavGridModifierComponent_AddToGrid, NewNavGrid) == 0x000000, "Member 'MercunaNavGridModifierComponent_AddToGrid::NewNavGrid' has a wrong offset!");
static_assert(offsetof(MercunaNavGridModifierComponent_AddToGrid, bRebuildGraph) == 0x000008, "Member 'MercunaNavGridModifierComponent_AddToGrid::bRebuildGraph' has a wrong offset!");

// Function Mercuna.MercunaNavGridModifierComponent.OverrideCostMultiplier
// 0x0010 (0x0010 - 0x0000)
struct MercunaNavGridModifierComponent_OverrideCostMultiplier final
{
public:
	struct FMercunaAgentType                      AgentType;                                         // 0x0000(0x000C)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         NewCostMultiplier;                                 // 0x000C(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MercunaNavGridModifierComponent_OverrideCostMultiplier) == 0x000004, "Wrong alignment on MercunaNavGridModifierComponent_OverrideCostMultiplier");
static_assert(sizeof(MercunaNavGridModifierComponent_OverrideCostMultiplier) == 0x000010, "Wrong size on MercunaNavGridModifierComponent_OverrideCostMultiplier");
static_assert(offsetof(MercunaNavGridModifierComponent_OverrideCostMultiplier, AgentType) == 0x000000, "Member 'MercunaNavGridModifierComponent_OverrideCostMultiplier::AgentType' has a wrong offset!");
static_assert(offsetof(MercunaNavGridModifierComponent_OverrideCostMultiplier, NewCostMultiplier) == 0x00000C, "Member 'MercunaNavGridModifierComponent_OverrideCostMultiplier::NewCostMultiplier' has a wrong offset!");

// Function Mercuna.MercunaNavGridModifierComponent.OverrideUsageTypes
// 0x0010 (0x0010 - 0x0000)
struct MercunaNavGridModifierComponent_OverrideUsageTypes final
{
public:
	struct FMercunaAgentType                      AgentType;                                         // 0x0000(0x000C)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FMercunaUsageTypes                     NewUsageTypes;                                     // 0x000C(0x0004)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(MercunaNavGridModifierComponent_OverrideUsageTypes) == 0x000004, "Wrong alignment on MercunaNavGridModifierComponent_OverrideUsageTypes");
static_assert(sizeof(MercunaNavGridModifierComponent_OverrideUsageTypes) == 0x000010, "Wrong size on MercunaNavGridModifierComponent_OverrideUsageTypes");
static_assert(offsetof(MercunaNavGridModifierComponent_OverrideUsageTypes, AgentType) == 0x000000, "Member 'MercunaNavGridModifierComponent_OverrideUsageTypes::AgentType' has a wrong offset!");
static_assert(offsetof(MercunaNavGridModifierComponent_OverrideUsageTypes, NewUsageTypes) == 0x00000C, "Member 'MercunaNavGridModifierComponent_OverrideUsageTypes::NewUsageTypes' has a wrong offset!");

// Function Mercuna.MercunaNavGridModifierComponent.RemoveFromGrid
// 0x0001 (0x0001 - 0x0000)
struct MercunaNavGridModifierComponent_RemoveFromGrid final
{
public:
	bool                                          bRebuildGraph;                                     // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MercunaNavGridModifierComponent_RemoveFromGrid) == 0x000001, "Wrong alignment on MercunaNavGridModifierComponent_RemoveFromGrid");
static_assert(sizeof(MercunaNavGridModifierComponent_RemoveFromGrid) == 0x000001, "Wrong size on MercunaNavGridModifierComponent_RemoveFromGrid");
static_assert(offsetof(MercunaNavGridModifierComponent_RemoveFromGrid, bRebuildGraph) == 0x000000, "Member 'MercunaNavGridModifierComponent_RemoveFromGrid::bRebuildGraph' has a wrong offset!");

// Function Mercuna.MercunaNavGridModifierComponent.SetPrismVertices
// 0x0010 (0x0010 - 0x0000)
struct MercunaNavGridModifierComponent_SetPrismVertices final
{
public:
	TArray<struct FVector2D>                      NewVertices;                                       // 0x0000(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(MercunaNavGridModifierComponent_SetPrismVertices) == 0x000008, "Wrong alignment on MercunaNavGridModifierComponent_SetPrismVertices");
static_assert(sizeof(MercunaNavGridModifierComponent_SetPrismVertices) == 0x000010, "Wrong size on MercunaNavGridModifierComponent_SetPrismVertices");
static_assert(offsetof(MercunaNavGridModifierComponent_SetPrismVertices, NewVertices) == 0x000000, "Member 'MercunaNavGridModifierComponent_SetPrismVertices::NewVertices' has a wrong offset!");

// Function Mercuna.MercunaNavGridModifierComponent.SetShape
// 0x0001 (0x0001 - 0x0000)
struct MercunaNavGridModifierComponent_SetShape final
{
public:
	EMercunaModifierVolumeShape                   NewShape;                                          // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MercunaNavGridModifierComponent_SetShape) == 0x000001, "Wrong alignment on MercunaNavGridModifierComponent_SetShape");
static_assert(sizeof(MercunaNavGridModifierComponent_SetShape) == 0x000001, "Wrong size on MercunaNavGridModifierComponent_SetShape");
static_assert(offsetof(MercunaNavGridModifierComponent_SetShape, NewShape) == 0x000000, "Member 'MercunaNavGridModifierComponent_SetShape::NewShape' has a wrong offset!");

// Function Mercuna.MercunaNavGridModifierComponent.GetShape
// 0x0001 (0x0001 - 0x0000)
struct MercunaNavGridModifierComponent_GetShape final
{
public:
	EMercunaModifierVolumeShape                   ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MercunaNavGridModifierComponent_GetShape) == 0x000001, "Wrong alignment on MercunaNavGridModifierComponent_GetShape");
static_assert(sizeof(MercunaNavGridModifierComponent_GetShape) == 0x000001, "Wrong size on MercunaNavGridModifierComponent_GetShape");
static_assert(offsetof(MercunaNavGridModifierComponent_GetShape, ReturnValue) == 0x000000, "Member 'MercunaNavGridModifierComponent_GetShape::ReturnValue' has a wrong offset!");

// Function Mercuna.Mercuna3DTrackActorProxy.TrackActor
// 0x0040 (0x0040 - 0x0000)
struct Mercuna3DTrackActorProxy_TrackActor final
{
public:
	class UObject*                                WorldContextObject;                                // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class APawn*                                  Pawn_0;                                            // 0x0008(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 Actor;                                             // 0x0010(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Distance;                                          // 0x0018(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Speed;                                             // 0x001C(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Offset;                                            // 0x0020(0x0018)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMercuna3DTrackActorProxy*              ReturnValue;                                       // 0x0038(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(Mercuna3DTrackActorProxy_TrackActor) == 0x000008, "Wrong alignment on Mercuna3DTrackActorProxy_TrackActor");
static_assert(sizeof(Mercuna3DTrackActorProxy_TrackActor) == 0x000040, "Wrong size on Mercuna3DTrackActorProxy_TrackActor");
static_assert(offsetof(Mercuna3DTrackActorProxy_TrackActor, WorldContextObject) == 0x000000, "Member 'Mercuna3DTrackActorProxy_TrackActor::WorldContextObject' has a wrong offset!");
static_assert(offsetof(Mercuna3DTrackActorProxy_TrackActor, Pawn_0) == 0x000008, "Member 'Mercuna3DTrackActorProxy_TrackActor::Pawn_0' has a wrong offset!");
static_assert(offsetof(Mercuna3DTrackActorProxy_TrackActor, Actor) == 0x000010, "Member 'Mercuna3DTrackActorProxy_TrackActor::Actor' has a wrong offset!");
static_assert(offsetof(Mercuna3DTrackActorProxy_TrackActor, Distance) == 0x000018, "Member 'Mercuna3DTrackActorProxy_TrackActor::Distance' has a wrong offset!");
static_assert(offsetof(Mercuna3DTrackActorProxy_TrackActor, Speed) == 0x00001C, "Member 'Mercuna3DTrackActorProxy_TrackActor::Speed' has a wrong offset!");
static_assert(offsetof(Mercuna3DTrackActorProxy_TrackActor, Offset) == 0x000020, "Member 'Mercuna3DTrackActorProxy_TrackActor::Offset' has a wrong offset!");
static_assert(offsetof(Mercuna3DTrackActorProxy_TrackActor, ReturnValue) == 0x000038, "Member 'Mercuna3DTrackActorProxy_TrackActor::ReturnValue' has a wrong offset!");

// Function Mercuna.Mercuna3DTrackActorProxy.OnMoveComplete
// 0x0008 (0x0008 - 0x0000)
struct Mercuna3DTrackActorProxy_OnMoveComplete final
{
public:
	struct FAIRequestID                           RequestID;                                         // 0x0000(0x0004)(Parm, NoDestructor, NativeAccessSpecifierPublic)
	EMercunaMoveResult                            Result;                                            // 0x0004(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5[0x3];                                        // 0x0005(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(Mercuna3DTrackActorProxy_OnMoveComplete) == 0x000004, "Wrong alignment on Mercuna3DTrackActorProxy_OnMoveComplete");
static_assert(sizeof(Mercuna3DTrackActorProxy_OnMoveComplete) == 0x000008, "Wrong size on Mercuna3DTrackActorProxy_OnMoveComplete");
static_assert(offsetof(Mercuna3DTrackActorProxy_OnMoveComplete, RequestID) == 0x000000, "Member 'Mercuna3DTrackActorProxy_OnMoveComplete::RequestID' has a wrong offset!");
static_assert(offsetof(Mercuna3DTrackActorProxy_OnMoveComplete, Result) == 0x000004, "Member 'Mercuna3DTrackActorProxy_OnMoveComplete::Result' has a wrong offset!");

// Function Mercuna.Mercuna3DTask_MoveTo.MoveTo
// 0x0038 (0x0038 - 0x0000)
struct Mercuna3DTask_MoveTo_MoveTo final
{
public:
	class AAIController*                          Controller;                                        // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                GoalLocation;                                      // 0x0008(0x0018)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 GoalActor;                                         // 0x0020(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         EndDistance;                                       // 0x0028(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          AcceptPartialPath;                                 // 0x002C(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bLockAILogic;                                      // 0x002D(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2E[0x2];                                       // 0x002E(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	class UMercuna3DTask_MoveTo*                  ReturnValue;                                       // 0x0030(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(Mercuna3DTask_MoveTo_MoveTo) == 0x000008, "Wrong alignment on Mercuna3DTask_MoveTo_MoveTo");
static_assert(sizeof(Mercuna3DTask_MoveTo_MoveTo) == 0x000038, "Wrong size on Mercuna3DTask_MoveTo_MoveTo");
static_assert(offsetof(Mercuna3DTask_MoveTo_MoveTo, Controller) == 0x000000, "Member 'Mercuna3DTask_MoveTo_MoveTo::Controller' has a wrong offset!");
static_assert(offsetof(Mercuna3DTask_MoveTo_MoveTo, GoalLocation) == 0x000008, "Member 'Mercuna3DTask_MoveTo_MoveTo::GoalLocation' has a wrong offset!");
static_assert(offsetof(Mercuna3DTask_MoveTo_MoveTo, GoalActor) == 0x000020, "Member 'Mercuna3DTask_MoveTo_MoveTo::GoalActor' has a wrong offset!");
static_assert(offsetof(Mercuna3DTask_MoveTo_MoveTo, EndDistance) == 0x000028, "Member 'Mercuna3DTask_MoveTo_MoveTo::EndDistance' has a wrong offset!");
static_assert(offsetof(Mercuna3DTask_MoveTo_MoveTo, AcceptPartialPath) == 0x00002C, "Member 'Mercuna3DTask_MoveTo_MoveTo::AcceptPartialPath' has a wrong offset!");
static_assert(offsetof(Mercuna3DTask_MoveTo_MoveTo, bLockAILogic) == 0x00002D, "Member 'Mercuna3DTask_MoveTo_MoveTo::bLockAILogic' has a wrong offset!");
static_assert(offsetof(Mercuna3DTask_MoveTo_MoveTo, ReturnValue) == 0x000030, "Member 'Mercuna3DTask_MoveTo_MoveTo::ReturnValue' has a wrong offset!");

// Function Mercuna.Mercuna3DTask_MoveTo.OnMoveComplete
// 0x0008 (0x0008 - 0x0000)
struct Mercuna3DTask_MoveTo_OnMoveComplete final
{
public:
	struct FAIRequestID                           RequestID;                                         // 0x0000(0x0004)(Parm, NoDestructor, NativeAccessSpecifierPublic)
	EMercunaMoveResult                            Result;                                            // 0x0004(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5[0x3];                                        // 0x0005(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(Mercuna3DTask_MoveTo_OnMoveComplete) == 0x000004, "Wrong alignment on Mercuna3DTask_MoveTo_OnMoveComplete");
static_assert(sizeof(Mercuna3DTask_MoveTo_OnMoveComplete) == 0x000008, "Wrong size on Mercuna3DTask_MoveTo_OnMoveComplete");
static_assert(offsetof(Mercuna3DTask_MoveTo_OnMoveComplete, RequestID) == 0x000000, "Member 'Mercuna3DTask_MoveTo_OnMoveComplete::RequestID' has a wrong offset!");
static_assert(offsetof(Mercuna3DTask_MoveTo_OnMoveComplete, Result) == 0x000004, "Member 'Mercuna3DTask_MoveTo_OnMoveComplete::Result' has a wrong offset!");

// Function Mercuna.MercunaBlueprintLibrary.HasUsageType
// 0x0010 (0x0010 - 0x0000)
struct MercunaBlueprintLibrary_HasUsageType final
{
public:
	struct FMercunaUsageTypes                     UsageTypes;                                        // 0x0000(0x0004)(Parm, NoDestructor, NativeAccessSpecifierPublic)
	class FName                                   UsageTypeName;                                     // 0x0004(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x000C(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D[0x3];                                        // 0x000D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(MercunaBlueprintLibrary_HasUsageType) == 0x000004, "Wrong alignment on MercunaBlueprintLibrary_HasUsageType");
static_assert(sizeof(MercunaBlueprintLibrary_HasUsageType) == 0x000010, "Wrong size on MercunaBlueprintLibrary_HasUsageType");
static_assert(offsetof(MercunaBlueprintLibrary_HasUsageType, UsageTypes) == 0x000000, "Member 'MercunaBlueprintLibrary_HasUsageType::UsageTypes' has a wrong offset!");
static_assert(offsetof(MercunaBlueprintLibrary_HasUsageType, UsageTypeName) == 0x000004, "Member 'MercunaBlueprintLibrary_HasUsageType::UsageTypeName' has a wrong offset!");
static_assert(offsetof(MercunaBlueprintLibrary_HasUsageType, ReturnValue) == 0x00000C, "Member 'MercunaBlueprintLibrary_HasUsageType::ReturnValue' has a wrong offset!");

// Function Mercuna.MercunaBlueprintLibrary.MercunaLog
// 0x0010 (0x0010 - 0x0000)
struct MercunaBlueprintLibrary_MercunaLog final
{
public:
	class FString                                 Message;                                           // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MercunaBlueprintLibrary_MercunaLog) == 0x000008, "Wrong alignment on MercunaBlueprintLibrary_MercunaLog");
static_assert(sizeof(MercunaBlueprintLibrary_MercunaLog) == 0x000010, "Wrong size on MercunaBlueprintLibrary_MercunaLog");
static_assert(offsetof(MercunaBlueprintLibrary_MercunaLog, Message) == 0x000000, "Member 'MercunaBlueprintLibrary_MercunaLog::Message' has a wrong offset!");

// Function Mercuna.MercunaBlueprintLibrary.SetDebugActor
// 0x0008 (0x0008 - 0x0000)
struct MercunaBlueprintLibrary_SetDebugActor final
{
public:
	class AActor*                                 Actor;                                             // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MercunaBlueprintLibrary_SetDebugActor) == 0x000008, "Wrong alignment on MercunaBlueprintLibrary_SetDebugActor");
static_assert(sizeof(MercunaBlueprintLibrary_SetDebugActor) == 0x000008, "Wrong size on MercunaBlueprintLibrary_SetDebugActor");
static_assert(offsetof(MercunaBlueprintLibrary_SetDebugActor, Actor) == 0x000000, "Member 'MercunaBlueprintLibrary_SetDebugActor::Actor' has a wrong offset!");

// Function Mercuna.MercunaGroundMoveToProxy.MoveToActor
// 0x0030 (0x0030 - 0x0000)
struct MercunaGroundMoveToProxy_MoveToActor final
{
public:
	class UObject*                                WorldContextObject;                                // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class APawn*                                  Pawn_0;                                            // 0x0008(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 Actor;                                             // 0x0010(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         EndDistance;                                       // 0x0018(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Speed;                                             // 0x001C(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          UsePartialPath;                                    // 0x0020(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_21[0x7];                                       // 0x0021(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UMercunaGroundMoveToProxy*              ReturnValue;                                       // 0x0028(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MercunaGroundMoveToProxy_MoveToActor) == 0x000008, "Wrong alignment on MercunaGroundMoveToProxy_MoveToActor");
static_assert(sizeof(MercunaGroundMoveToProxy_MoveToActor) == 0x000030, "Wrong size on MercunaGroundMoveToProxy_MoveToActor");
static_assert(offsetof(MercunaGroundMoveToProxy_MoveToActor, WorldContextObject) == 0x000000, "Member 'MercunaGroundMoveToProxy_MoveToActor::WorldContextObject' has a wrong offset!");
static_assert(offsetof(MercunaGroundMoveToProxy_MoveToActor, Pawn_0) == 0x000008, "Member 'MercunaGroundMoveToProxy_MoveToActor::Pawn_0' has a wrong offset!");
static_assert(offsetof(MercunaGroundMoveToProxy_MoveToActor, Actor) == 0x000010, "Member 'MercunaGroundMoveToProxy_MoveToActor::Actor' has a wrong offset!");
static_assert(offsetof(MercunaGroundMoveToProxy_MoveToActor, EndDistance) == 0x000018, "Member 'MercunaGroundMoveToProxy_MoveToActor::EndDistance' has a wrong offset!");
static_assert(offsetof(MercunaGroundMoveToProxy_MoveToActor, Speed) == 0x00001C, "Member 'MercunaGroundMoveToProxy_MoveToActor::Speed' has a wrong offset!");
static_assert(offsetof(MercunaGroundMoveToProxy_MoveToActor, UsePartialPath) == 0x000020, "Member 'MercunaGroundMoveToProxy_MoveToActor::UsePartialPath' has a wrong offset!");
static_assert(offsetof(MercunaGroundMoveToProxy_MoveToActor, ReturnValue) == 0x000028, "Member 'MercunaGroundMoveToProxy_MoveToActor::ReturnValue' has a wrong offset!");

// Function Mercuna.MercunaGroundMoveToProxy.MoveToLocation
// 0x0058 (0x0058 - 0x0000)
struct MercunaGroundMoveToProxy_MoveToLocation final
{
public:
	class UObject*                                WorldContextObject;                                // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class APawn*                                  Pawn_0;                                            // 0x0008(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Destination;                                       // 0x0010(0x0018)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         EndDistance;                                       // 0x0028(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Speed;                                             // 0x002C(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          UsePartialPath;                                    // 0x0030(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_31[0x7];                                       // 0x0031(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                EndDirection;                                      // 0x0038(0x0018)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMercunaGroundMoveToProxy*              ReturnValue;                                       // 0x0050(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MercunaGroundMoveToProxy_MoveToLocation) == 0x000008, "Wrong alignment on MercunaGroundMoveToProxy_MoveToLocation");
static_assert(sizeof(MercunaGroundMoveToProxy_MoveToLocation) == 0x000058, "Wrong size on MercunaGroundMoveToProxy_MoveToLocation");
static_assert(offsetof(MercunaGroundMoveToProxy_MoveToLocation, WorldContextObject) == 0x000000, "Member 'MercunaGroundMoveToProxy_MoveToLocation::WorldContextObject' has a wrong offset!");
static_assert(offsetof(MercunaGroundMoveToProxy_MoveToLocation, Pawn_0) == 0x000008, "Member 'MercunaGroundMoveToProxy_MoveToLocation::Pawn_0' has a wrong offset!");
static_assert(offsetof(MercunaGroundMoveToProxy_MoveToLocation, Destination) == 0x000010, "Member 'MercunaGroundMoveToProxy_MoveToLocation::Destination' has a wrong offset!");
static_assert(offsetof(MercunaGroundMoveToProxy_MoveToLocation, EndDistance) == 0x000028, "Member 'MercunaGroundMoveToProxy_MoveToLocation::EndDistance' has a wrong offset!");
static_assert(offsetof(MercunaGroundMoveToProxy_MoveToLocation, Speed) == 0x00002C, "Member 'MercunaGroundMoveToProxy_MoveToLocation::Speed' has a wrong offset!");
static_assert(offsetof(MercunaGroundMoveToProxy_MoveToLocation, UsePartialPath) == 0x000030, "Member 'MercunaGroundMoveToProxy_MoveToLocation::UsePartialPath' has a wrong offset!");
static_assert(offsetof(MercunaGroundMoveToProxy_MoveToLocation, EndDirection) == 0x000038, "Member 'MercunaGroundMoveToProxy_MoveToLocation::EndDirection' has a wrong offset!");
static_assert(offsetof(MercunaGroundMoveToProxy_MoveToLocation, ReturnValue) == 0x000050, "Member 'MercunaGroundMoveToProxy_MoveToLocation::ReturnValue' has a wrong offset!");

// Function Mercuna.MercunaGroundMoveToProxy.MoveToLocations
// 0x0050 (0x0050 - 0x0000)
struct MercunaGroundMoveToProxy_MoveToLocations final
{
public:
	class UObject*                                WorldContextObject;                                // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class APawn*                                  Pawn_0;                                            // 0x0008(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FVector>                        Destinations;                                      // 0x0010(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	float                                         EndDistance;                                       // 0x0020(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Speed;                                             // 0x0024(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          UsePartialPath;                                    // 0x0028(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_29[0x7];                                       // 0x0029(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                EndDirection;                                      // 0x0030(0x0018)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMercunaGroundMoveToProxy*              ReturnValue;                                       // 0x0048(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MercunaGroundMoveToProxy_MoveToLocations) == 0x000008, "Wrong alignment on MercunaGroundMoveToProxy_MoveToLocations");
static_assert(sizeof(MercunaGroundMoveToProxy_MoveToLocations) == 0x000050, "Wrong size on MercunaGroundMoveToProxy_MoveToLocations");
static_assert(offsetof(MercunaGroundMoveToProxy_MoveToLocations, WorldContextObject) == 0x000000, "Member 'MercunaGroundMoveToProxy_MoveToLocations::WorldContextObject' has a wrong offset!");
static_assert(offsetof(MercunaGroundMoveToProxy_MoveToLocations, Pawn_0) == 0x000008, "Member 'MercunaGroundMoveToProxy_MoveToLocations::Pawn_0' has a wrong offset!");
static_assert(offsetof(MercunaGroundMoveToProxy_MoveToLocations, Destinations) == 0x000010, "Member 'MercunaGroundMoveToProxy_MoveToLocations::Destinations' has a wrong offset!");
static_assert(offsetof(MercunaGroundMoveToProxy_MoveToLocations, EndDistance) == 0x000020, "Member 'MercunaGroundMoveToProxy_MoveToLocations::EndDistance' has a wrong offset!");
static_assert(offsetof(MercunaGroundMoveToProxy_MoveToLocations, Speed) == 0x000024, "Member 'MercunaGroundMoveToProxy_MoveToLocations::Speed' has a wrong offset!");
static_assert(offsetof(MercunaGroundMoveToProxy_MoveToLocations, UsePartialPath) == 0x000028, "Member 'MercunaGroundMoveToProxy_MoveToLocations::UsePartialPath' has a wrong offset!");
static_assert(offsetof(MercunaGroundMoveToProxy_MoveToLocations, EndDirection) == 0x000030, "Member 'MercunaGroundMoveToProxy_MoveToLocations::EndDirection' has a wrong offset!");
static_assert(offsetof(MercunaGroundMoveToProxy_MoveToLocations, ReturnValue) == 0x000048, "Member 'MercunaGroundMoveToProxy_MoveToLocations::ReturnValue' has a wrong offset!");

// Function Mercuna.MercunaGroundMoveToProxy.OnMoveComplete
// 0x0008 (0x0008 - 0x0000)
struct MercunaGroundMoveToProxy_OnMoveComplete final
{
public:
	struct FAIRequestID                           RequestID;                                         // 0x0000(0x0004)(Parm, NoDestructor, NativeAccessSpecifierPublic)
	EMercunaMoveResult                            Result;                                            // 0x0004(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5[0x3];                                        // 0x0005(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(MercunaGroundMoveToProxy_OnMoveComplete) == 0x000004, "Wrong alignment on MercunaGroundMoveToProxy_OnMoveComplete");
static_assert(sizeof(MercunaGroundMoveToProxy_OnMoveComplete) == 0x000008, "Wrong size on MercunaGroundMoveToProxy_OnMoveComplete");
static_assert(offsetof(MercunaGroundMoveToProxy_OnMoveComplete, RequestID) == 0x000000, "Member 'MercunaGroundMoveToProxy_OnMoveComplete::RequestID' has a wrong offset!");
static_assert(offsetof(MercunaGroundMoveToProxy_OnMoveComplete, Result) == 0x000004, "Member 'MercunaGroundMoveToProxy_OnMoveComplete::Result' has a wrong offset!");

// Function Mercuna.MercunaGroundTrackActorProxy.TrackActor
// 0x0048 (0x0048 - 0x0000)
struct MercunaGroundTrackActorProxy_TrackActor final
{
public:
	class UObject*                                WorldContextObject;                                // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class APawn*                                  Pawn_0;                                            // 0x0008(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 Actor;                                             // 0x0010(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Distance;                                          // 0x0018(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Speed;                                             // 0x001C(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Offset;                                            // 0x0020(0x0018)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          UsePartialPath;                                    // 0x0038(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_39[0x7];                                       // 0x0039(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UMercunaGroundTrackActorProxy*          ReturnValue;                                       // 0x0040(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MercunaGroundTrackActorProxy_TrackActor) == 0x000008, "Wrong alignment on MercunaGroundTrackActorProxy_TrackActor");
static_assert(sizeof(MercunaGroundTrackActorProxy_TrackActor) == 0x000048, "Wrong size on MercunaGroundTrackActorProxy_TrackActor");
static_assert(offsetof(MercunaGroundTrackActorProxy_TrackActor, WorldContextObject) == 0x000000, "Member 'MercunaGroundTrackActorProxy_TrackActor::WorldContextObject' has a wrong offset!");
static_assert(offsetof(MercunaGroundTrackActorProxy_TrackActor, Pawn_0) == 0x000008, "Member 'MercunaGroundTrackActorProxy_TrackActor::Pawn_0' has a wrong offset!");
static_assert(offsetof(MercunaGroundTrackActorProxy_TrackActor, Actor) == 0x000010, "Member 'MercunaGroundTrackActorProxy_TrackActor::Actor' has a wrong offset!");
static_assert(offsetof(MercunaGroundTrackActorProxy_TrackActor, Distance) == 0x000018, "Member 'MercunaGroundTrackActorProxy_TrackActor::Distance' has a wrong offset!");
static_assert(offsetof(MercunaGroundTrackActorProxy_TrackActor, Speed) == 0x00001C, "Member 'MercunaGroundTrackActorProxy_TrackActor::Speed' has a wrong offset!");
static_assert(offsetof(MercunaGroundTrackActorProxy_TrackActor, Offset) == 0x000020, "Member 'MercunaGroundTrackActorProxy_TrackActor::Offset' has a wrong offset!");
static_assert(offsetof(MercunaGroundTrackActorProxy_TrackActor, UsePartialPath) == 0x000038, "Member 'MercunaGroundTrackActorProxy_TrackActor::UsePartialPath' has a wrong offset!");
static_assert(offsetof(MercunaGroundTrackActorProxy_TrackActor, ReturnValue) == 0x000040, "Member 'MercunaGroundTrackActorProxy_TrackActor::ReturnValue' has a wrong offset!");

// Function Mercuna.MercunaGroundTrackActorProxy.OnMoveComplete
// 0x0008 (0x0008 - 0x0000)
struct MercunaGroundTrackActorProxy_OnMoveComplete final
{
public:
	struct FAIRequestID                           RequestID;                                         // 0x0000(0x0004)(Parm, NoDestructor, NativeAccessSpecifierPublic)
	EMercunaMoveResult                            Result;                                            // 0x0004(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5[0x3];                                        // 0x0005(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(MercunaGroundTrackActorProxy_OnMoveComplete) == 0x000004, "Wrong alignment on MercunaGroundTrackActorProxy_OnMoveComplete");
static_assert(sizeof(MercunaGroundTrackActorProxy_OnMoveComplete) == 0x000008, "Wrong size on MercunaGroundTrackActorProxy_OnMoveComplete");
static_assert(offsetof(MercunaGroundTrackActorProxy_OnMoveComplete, RequestID) == 0x000000, "Member 'MercunaGroundTrackActorProxy_OnMoveComplete::RequestID' has a wrong offset!");
static_assert(offsetof(MercunaGroundTrackActorProxy_OnMoveComplete, Result) == 0x000004, "Member 'MercunaGroundTrackActorProxy_OnMoveComplete::Result' has a wrong offset!");

// Function Mercuna.MercunaNavExclusionVolume.AddToGraph
// 0x0008 (0x0008 - 0x0000)
struct MercunaNavExclusionVolume_AddToGraph final
{
public:
	class AMercunaNavGraph*                       NavGraph_0;                                        // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MercunaNavExclusionVolume_AddToGraph) == 0x000008, "Wrong alignment on MercunaNavExclusionVolume_AddToGraph");
static_assert(sizeof(MercunaNavExclusionVolume_AddToGraph) == 0x000008, "Wrong size on MercunaNavExclusionVolume_AddToGraph");
static_assert(offsetof(MercunaNavExclusionVolume_AddToGraph, NavGraph_0) == 0x000000, "Member 'MercunaNavExclusionVolume_AddToGraph::NavGraph_0' has a wrong offset!");

// Function Mercuna.MercunaNavExclusionVolume.SetSize
// 0x0018 (0x0018 - 0x0000)
struct MercunaNavExclusionVolume_SetSize final
{
public:
	struct FVector                                Size;                                              // 0x0000(0x0018)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MercunaNavExclusionVolume_SetSize) == 0x000008, "Wrong alignment on MercunaNavExclusionVolume_SetSize");
static_assert(sizeof(MercunaNavExclusionVolume_SetSize) == 0x000018, "Wrong size on MercunaNavExclusionVolume_SetSize");
static_assert(offsetof(MercunaNavExclusionVolume_SetSize, Size) == 0x000000, "Member 'MercunaNavExclusionVolume_SetSize::Size' has a wrong offset!");

// Function Mercuna.MercunaNavExclusionVolume.GetSize
// 0x0018 (0x0018 - 0x0000)
struct MercunaNavExclusionVolume_GetSize final
{
public:
	struct FVector                                ReturnValue;                                       // 0x0000(0x0018)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MercunaNavExclusionVolume_GetSize) == 0x000008, "Wrong alignment on MercunaNavExclusionVolume_GetSize");
static_assert(sizeof(MercunaNavExclusionVolume_GetSize) == 0x000018, "Wrong size on MercunaNavExclusionVolume_GetSize");
static_assert(offsetof(MercunaNavExclusionVolume_GetSize, ReturnValue) == 0x000000, "Member 'MercunaNavExclusionVolume_GetSize::ReturnValue' has a wrong offset!");

// Function Mercuna.MercunaNavGridModifierVolume.AddToGrid
// 0x0008 (0x0008 - 0x0000)
struct MercunaNavGridModifierVolume_AddToGrid final
{
public:
	class AMercunaNavGraph2D*                     NavGrid;                                           // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MercunaNavGridModifierVolume_AddToGrid) == 0x000008, "Wrong alignment on MercunaNavGridModifierVolume_AddToGrid");
static_assert(sizeof(MercunaNavGridModifierVolume_AddToGrid) == 0x000008, "Wrong size on MercunaNavGridModifierVolume_AddToGrid");
static_assert(offsetof(MercunaNavGridModifierVolume_AddToGrid, NavGrid) == 0x000000, "Member 'MercunaNavGridModifierVolume_AddToGrid::NavGrid' has a wrong offset!");

// Function Mercuna.MercunaNavGridModifierVolume.OverrideCostMultiplier
// 0x0010 (0x0010 - 0x0000)
struct MercunaNavGridModifierVolume_OverrideCostMultiplier final
{
public:
	struct FMercunaAgentType                      AgentType;                                         // 0x0000(0x000C)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         NewCostMultiplier;                                 // 0x000C(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MercunaNavGridModifierVolume_OverrideCostMultiplier) == 0x000004, "Wrong alignment on MercunaNavGridModifierVolume_OverrideCostMultiplier");
static_assert(sizeof(MercunaNavGridModifierVolume_OverrideCostMultiplier) == 0x000010, "Wrong size on MercunaNavGridModifierVolume_OverrideCostMultiplier");
static_assert(offsetof(MercunaNavGridModifierVolume_OverrideCostMultiplier, AgentType) == 0x000000, "Member 'MercunaNavGridModifierVolume_OverrideCostMultiplier::AgentType' has a wrong offset!");
static_assert(offsetof(MercunaNavGridModifierVolume_OverrideCostMultiplier, NewCostMultiplier) == 0x00000C, "Member 'MercunaNavGridModifierVolume_OverrideCostMultiplier::NewCostMultiplier' has a wrong offset!");

// Function Mercuna.MercunaNavGridModifierVolume.OverrideUsageTypes
// 0x0010 (0x0010 - 0x0000)
struct MercunaNavGridModifierVolume_OverrideUsageTypes final
{
public:
	struct FMercunaAgentType                      AgentType;                                         // 0x0000(0x000C)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FMercunaUsageTypes                     NewUsageTypes;                                     // 0x000C(0x0004)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(MercunaNavGridModifierVolume_OverrideUsageTypes) == 0x000004, "Wrong alignment on MercunaNavGridModifierVolume_OverrideUsageTypes");
static_assert(sizeof(MercunaNavGridModifierVolume_OverrideUsageTypes) == 0x000010, "Wrong size on MercunaNavGridModifierVolume_OverrideUsageTypes");
static_assert(offsetof(MercunaNavGridModifierVolume_OverrideUsageTypes, AgentType) == 0x000000, "Member 'MercunaNavGridModifierVolume_OverrideUsageTypes::AgentType' has a wrong offset!");
static_assert(offsetof(MercunaNavGridModifierVolume_OverrideUsageTypes, NewUsageTypes) == 0x00000C, "Member 'MercunaNavGridModifierVolume_OverrideUsageTypes::NewUsageTypes' has a wrong offset!");

// Function Mercuna.MercunaNavGridModifierVolume.SetCostMultiplier
// 0x0004 (0x0004 - 0x0000)
struct MercunaNavGridModifierVolume_SetCostMultiplier final
{
public:
	float                                         NewCostMultiplier;                                 // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MercunaNavGridModifierVolume_SetCostMultiplier) == 0x000004, "Wrong alignment on MercunaNavGridModifierVolume_SetCostMultiplier");
static_assert(sizeof(MercunaNavGridModifierVolume_SetCostMultiplier) == 0x000004, "Wrong size on MercunaNavGridModifierVolume_SetCostMultiplier");
static_assert(offsetof(MercunaNavGridModifierVolume_SetCostMultiplier, NewCostMultiplier) == 0x000000, "Member 'MercunaNavGridModifierVolume_SetCostMultiplier::NewCostMultiplier' has a wrong offset!");

// Function Mercuna.MercunaNavGridModifierVolume.SetEnabled
// 0x0001 (0x0001 - 0x0000)
struct MercunaNavGridModifierVolume_SetEnabled final
{
public:
	bool                                          Enabled;                                           // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MercunaNavGridModifierVolume_SetEnabled) == 0x000001, "Wrong alignment on MercunaNavGridModifierVolume_SetEnabled");
static_assert(sizeof(MercunaNavGridModifierVolume_SetEnabled) == 0x000001, "Wrong size on MercunaNavGridModifierVolume_SetEnabled");
static_assert(offsetof(MercunaNavGridModifierVolume_SetEnabled, Enabled) == 0x000000, "Member 'MercunaNavGridModifierVolume_SetEnabled::Enabled' has a wrong offset!");

// Function Mercuna.MercunaNavGridModifierVolume.SetPrismVertices
// 0x0010 (0x0010 - 0x0000)
struct MercunaNavGridModifierVolume_SetPrismVertices final
{
public:
	TArray<struct FVector2D>                      NewVertices;                                       // 0x0000(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(MercunaNavGridModifierVolume_SetPrismVertices) == 0x000008, "Wrong alignment on MercunaNavGridModifierVolume_SetPrismVertices");
static_assert(sizeof(MercunaNavGridModifierVolume_SetPrismVertices) == 0x000010, "Wrong size on MercunaNavGridModifierVolume_SetPrismVertices");
static_assert(offsetof(MercunaNavGridModifierVolume_SetPrismVertices, NewVertices) == 0x000000, "Member 'MercunaNavGridModifierVolume_SetPrismVertices::NewVertices' has a wrong offset!");

// Function Mercuna.MercunaNavGridModifierVolume.SetShape
// 0x0001 (0x0001 - 0x0000)
struct MercunaNavGridModifierVolume_SetShape final
{
public:
	EMercunaModifierVolumeShape                   NewShape;                                          // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MercunaNavGridModifierVolume_SetShape) == 0x000001, "Wrong alignment on MercunaNavGridModifierVolume_SetShape");
static_assert(sizeof(MercunaNavGridModifierVolume_SetShape) == 0x000001, "Wrong size on MercunaNavGridModifierVolume_SetShape");
static_assert(offsetof(MercunaNavGridModifierVolume_SetShape, NewShape) == 0x000000, "Member 'MercunaNavGridModifierVolume_SetShape::NewShape' has a wrong offset!");

// Function Mercuna.MercunaNavGridModifierVolume.SetSize
// 0x0018 (0x0018 - 0x0000)
struct MercunaNavGridModifierVolume_SetSize final
{
public:
	struct FVector                                Size;                                              // 0x0000(0x0018)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MercunaNavGridModifierVolume_SetSize) == 0x000008, "Wrong alignment on MercunaNavGridModifierVolume_SetSize");
static_assert(sizeof(MercunaNavGridModifierVolume_SetSize) == 0x000018, "Wrong size on MercunaNavGridModifierVolume_SetSize");
static_assert(offsetof(MercunaNavGridModifierVolume_SetSize, Size) == 0x000000, "Member 'MercunaNavGridModifierVolume_SetSize::Size' has a wrong offset!");

// Function Mercuna.MercunaNavGridModifierVolume.SetUsageTypes
// 0x0004 (0x0004 - 0x0000)
struct MercunaNavGridModifierVolume_SetUsageTypes final
{
public:
	struct FMercunaUsageTypes                     NewUsageTypes;                                     // 0x0000(0x0004)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(MercunaNavGridModifierVolume_SetUsageTypes) == 0x000004, "Wrong alignment on MercunaNavGridModifierVolume_SetUsageTypes");
static_assert(sizeof(MercunaNavGridModifierVolume_SetUsageTypes) == 0x000004, "Wrong size on MercunaNavGridModifierVolume_SetUsageTypes");
static_assert(offsetof(MercunaNavGridModifierVolume_SetUsageTypes, NewUsageTypes) == 0x000000, "Member 'MercunaNavGridModifierVolume_SetUsageTypes::NewUsageTypes' has a wrong offset!");

// Function Mercuna.MercunaNavGridModifierVolume.GetShape
// 0x0001 (0x0001 - 0x0000)
struct MercunaNavGridModifierVolume_GetShape final
{
public:
	EMercunaModifierVolumeShape                   ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MercunaNavGridModifierVolume_GetShape) == 0x000001, "Wrong alignment on MercunaNavGridModifierVolume_GetShape");
static_assert(sizeof(MercunaNavGridModifierVolume_GetShape) == 0x000001, "Wrong size on MercunaNavGridModifierVolume_GetShape");
static_assert(offsetof(MercunaNavGridModifierVolume_GetShape, ReturnValue) == 0x000000, "Member 'MercunaNavGridModifierVolume_GetShape::ReturnValue' has a wrong offset!");

// Function Mercuna.MercunaNavGridModifierVolume.GetSize
// 0x0018 (0x0018 - 0x0000)
struct MercunaNavGridModifierVolume_GetSize final
{
public:
	struct FVector                                ReturnValue;                                       // 0x0000(0x0018)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MercunaNavGridModifierVolume_GetSize) == 0x000008, "Wrong alignment on MercunaNavGridModifierVolume_GetSize");
static_assert(sizeof(MercunaNavGridModifierVolume_GetSize) == 0x000018, "Wrong size on MercunaNavGridModifierVolume_GetSize");
static_assert(offsetof(MercunaNavGridModifierVolume_GetSize, ReturnValue) == 0x000000, "Member 'MercunaNavGridModifierVolume_GetSize::ReturnValue' has a wrong offset!");

// Function Mercuna.MercunaNavTestingActor.OnNavGraphBuildComplete
// 0x0001 (0x0001 - 0x0000)
struct MercunaNavTestingActor_OnNavGraphBuildComplete final
{
public:
	bool                                          Success;                                           // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MercunaNavTestingActor_OnNavGraphBuildComplete) == 0x000001, "Wrong alignment on MercunaNavTestingActor_OnNavGraphBuildComplete");
static_assert(sizeof(MercunaNavTestingActor_OnNavGraphBuildComplete) == 0x000001, "Wrong size on MercunaNavTestingActor_OnNavGraphBuildComplete");
static_assert(offsetof(MercunaNavTestingActor_OnNavGraphBuildComplete, Success) == 0x000000, "Member 'MercunaNavTestingActor_OnNavGraphBuildComplete::Success' has a wrong offset!");

// Function Mercuna.MercunaNavTestingActor.OnPathUpdate
// 0x0001 (0x0001 - 0x0000)
struct MercunaNavTestingActor_OnPathUpdate final
{
public:
	EMercunaPathEvent                             PathEvent;                                         // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MercunaNavTestingActor_OnPathUpdate) == 0x000001, "Wrong alignment on MercunaNavTestingActor_OnPathUpdate");
static_assert(sizeof(MercunaNavTestingActor_OnPathUpdate) == 0x000001, "Wrong size on MercunaNavTestingActor_OnPathUpdate");
static_assert(offsetof(MercunaNavTestingActor_OnPathUpdate, PathEvent) == 0x000000, "Member 'MercunaNavTestingActor_OnPathUpdate::PathEvent' has a wrong offset!");

// Function Mercuna.MercunaNavTestingActor.PathfindLatent
// 0x0030 (0x0030 - 0x0000)
struct MercunaNavTestingActor_PathfindLatent final
{
public:
	bool                                          Result;                                            // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UObject*                                WorldContextObject;                                // 0x0008(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLatentActionInfo                      LatentInfo;                                        // 0x0010(0x0018)(Parm, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          bAllowPartial;                                     // 0x0028(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_29[0x7];                                       // 0x0029(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(MercunaNavTestingActor_PathfindLatent) == 0x000008, "Wrong alignment on MercunaNavTestingActor_PathfindLatent");
static_assert(sizeof(MercunaNavTestingActor_PathfindLatent) == 0x000030, "Wrong size on MercunaNavTestingActor_PathfindLatent");
static_assert(offsetof(MercunaNavTestingActor_PathfindLatent, Result) == 0x000000, "Member 'MercunaNavTestingActor_PathfindLatent::Result' has a wrong offset!");
static_assert(offsetof(MercunaNavTestingActor_PathfindLatent, WorldContextObject) == 0x000008, "Member 'MercunaNavTestingActor_PathfindLatent::WorldContextObject' has a wrong offset!");
static_assert(offsetof(MercunaNavTestingActor_PathfindLatent, LatentInfo) == 0x000010, "Member 'MercunaNavTestingActor_PathfindLatent::LatentInfo' has a wrong offset!");
static_assert(offsetof(MercunaNavTestingActor_PathfindLatent, bAllowPartial) == 0x000028, "Member 'MercunaNavTestingActor_PathfindLatent::bAllowPartial' has a wrong offset!");

// Function Mercuna.MercunaNavGridVolume.AddToGrid
// 0x0008 (0x0008 - 0x0000)
struct MercunaNavGridVolume_AddToGrid final
{
public:
	class AMercunaNavGraph2D*                     NavGrid_0;                                         // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MercunaNavGridVolume_AddToGrid) == 0x000008, "Wrong alignment on MercunaNavGridVolume_AddToGrid");
static_assert(sizeof(MercunaNavGridVolume_AddToGrid) == 0x000008, "Wrong size on MercunaNavGridVolume_AddToGrid");
static_assert(offsetof(MercunaNavGridVolume_AddToGrid, NavGrid_0) == 0x000000, "Member 'MercunaNavGridVolume_AddToGrid::NavGrid_0' has a wrong offset!");

// Function Mercuna.MercunaNavInvokerVolume.AddToGrid
// 0x0008 (0x0008 - 0x0000)
struct MercunaNavInvokerVolume_AddToGrid final
{
public:
	class AMercunaNavGroundGrid*                  NavGrid_0;                                         // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MercunaNavInvokerVolume_AddToGrid) == 0x000008, "Wrong alignment on MercunaNavInvokerVolume_AddToGrid");
static_assert(sizeof(MercunaNavInvokerVolume_AddToGrid) == 0x000008, "Wrong size on MercunaNavInvokerVolume_AddToGrid");
static_assert(offsetof(MercunaNavInvokerVolume_AddToGrid, NavGrid_0) == 0x000000, "Member 'MercunaNavInvokerVolume_AddToGrid::NavGrid_0' has a wrong offset!");

// Function Mercuna.MercunaNavInvokerVolume.SetSize
// 0x0018 (0x0018 - 0x0000)
struct MercunaNavInvokerVolume_SetSize final
{
public:
	struct FVector                                Size;                                              // 0x0000(0x0018)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MercunaNavInvokerVolume_SetSize) == 0x000008, "Wrong alignment on MercunaNavInvokerVolume_SetSize");
static_assert(sizeof(MercunaNavInvokerVolume_SetSize) == 0x000018, "Wrong size on MercunaNavInvokerVolume_SetSize");
static_assert(offsetof(MercunaNavInvokerVolume_SetSize, Size) == 0x000000, "Member 'MercunaNavInvokerVolume_SetSize::Size' has a wrong offset!");

// Function Mercuna.MercunaNavInvokerVolume.SetType
// 0x0001 (0x0001 - 0x0000)
struct MercunaNavInvokerVolume_SetType final
{
public:
	EMercunaInvokerVolumeType                     Type_0;                                            // 0x0000(0x0001)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MercunaNavInvokerVolume_SetType) == 0x000001, "Wrong alignment on MercunaNavInvokerVolume_SetType");
static_assert(sizeof(MercunaNavInvokerVolume_SetType) == 0x000001, "Wrong size on MercunaNavInvokerVolume_SetType");
static_assert(offsetof(MercunaNavInvokerVolume_SetType, Type_0) == 0x000000, "Member 'MercunaNavInvokerVolume_SetType::Type_0' has a wrong offset!");

// Function Mercuna.MercunaNavInvokerVolume.GetSize
// 0x0018 (0x0018 - 0x0000)
struct MercunaNavInvokerVolume_GetSize final
{
public:
	struct FVector                                ReturnValue;                                       // 0x0000(0x0018)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MercunaNavInvokerVolume_GetSize) == 0x000008, "Wrong alignment on MercunaNavInvokerVolume_GetSize");
static_assert(sizeof(MercunaNavInvokerVolume_GetSize) == 0x000018, "Wrong size on MercunaNavInvokerVolume_GetSize");
static_assert(offsetof(MercunaNavInvokerVolume_GetSize, ReturnValue) == 0x000000, "Member 'MercunaNavInvokerVolume_GetSize::ReturnValue' has a wrong offset!");

// Function Mercuna.MercunaNavModifierVolume.AddToGraph
// 0x0008 (0x0008 - 0x0000)
struct MercunaNavModifierVolume_AddToGraph final
{
public:
	class AMercunaNavGraph*                       NavGraph_0;                                        // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MercunaNavModifierVolume_AddToGraph) == 0x000008, "Wrong alignment on MercunaNavModifierVolume_AddToGraph");
static_assert(sizeof(MercunaNavModifierVolume_AddToGraph) == 0x000008, "Wrong size on MercunaNavModifierVolume_AddToGraph");
static_assert(offsetof(MercunaNavModifierVolume_AddToGraph, NavGraph_0) == 0x000000, "Member 'MercunaNavModifierVolume_AddToGraph::NavGraph_0' has a wrong offset!");

// Function Mercuna.MercunaNavModifierVolume.SetCostMultiplier
// 0x0004 (0x0004 - 0x0000)
struct MercunaNavModifierVolume_SetCostMultiplier final
{
public:
	float                                         NewCostMultiplier;                                 // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MercunaNavModifierVolume_SetCostMultiplier) == 0x000004, "Wrong alignment on MercunaNavModifierVolume_SetCostMultiplier");
static_assert(sizeof(MercunaNavModifierVolume_SetCostMultiplier) == 0x000004, "Wrong size on MercunaNavModifierVolume_SetCostMultiplier");
static_assert(offsetof(MercunaNavModifierVolume_SetCostMultiplier, NewCostMultiplier) == 0x000000, "Member 'MercunaNavModifierVolume_SetCostMultiplier::NewCostMultiplier' has a wrong offset!");

// Function Mercuna.MercunaNavModifierVolume.SetEnabled
// 0x0001 (0x0001 - 0x0000)
struct MercunaNavModifierVolume_SetEnabled final
{
public:
	bool                                          Enabled;                                           // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MercunaNavModifierVolume_SetEnabled) == 0x000001, "Wrong alignment on MercunaNavModifierVolume_SetEnabled");
static_assert(sizeof(MercunaNavModifierVolume_SetEnabled) == 0x000001, "Wrong size on MercunaNavModifierVolume_SetEnabled");
static_assert(offsetof(MercunaNavModifierVolume_SetEnabled, Enabled) == 0x000000, "Member 'MercunaNavModifierVolume_SetEnabled::Enabled' has a wrong offset!");

// Function Mercuna.MercunaNavModifierVolume.SetSize
// 0x0018 (0x0018 - 0x0000)
struct MercunaNavModifierVolume_SetSize final
{
public:
	struct FVector                                Size;                                              // 0x0000(0x0018)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MercunaNavModifierVolume_SetSize) == 0x000008, "Wrong alignment on MercunaNavModifierVolume_SetSize");
static_assert(sizeof(MercunaNavModifierVolume_SetSize) == 0x000018, "Wrong size on MercunaNavModifierVolume_SetSize");
static_assert(offsetof(MercunaNavModifierVolume_SetSize, Size) == 0x000000, "Member 'MercunaNavModifierVolume_SetSize::Size' has a wrong offset!");

// Function Mercuna.MercunaNavModifierVolume.SetUsageTypes
// 0x0004 (0x0004 - 0x0000)
struct MercunaNavModifierVolume_SetUsageTypes final
{
public:
	struct FMercunaUsageTypes                     NewUsageTypes;                                     // 0x0000(0x0004)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(MercunaNavModifierVolume_SetUsageTypes) == 0x000004, "Wrong alignment on MercunaNavModifierVolume_SetUsageTypes");
static_assert(sizeof(MercunaNavModifierVolume_SetUsageTypes) == 0x000004, "Wrong size on MercunaNavModifierVolume_SetUsageTypes");
static_assert(offsetof(MercunaNavModifierVolume_SetUsageTypes, NewUsageTypes) == 0x000000, "Member 'MercunaNavModifierVolume_SetUsageTypes::NewUsageTypes' has a wrong offset!");

// Function Mercuna.MercunaNavModifierVolume.GetSize
// 0x0018 (0x0018 - 0x0000)
struct MercunaNavModifierVolume_GetSize final
{
public:
	struct FVector                                ReturnValue;                                       // 0x0000(0x0018)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MercunaNavModifierVolume_GetSize) == 0x000008, "Wrong alignment on MercunaNavModifierVolume_GetSize");
static_assert(sizeof(MercunaNavModifierVolume_GetSize) == 0x000018, "Wrong size on MercunaNavModifierVolume_GetSize");
static_assert(offsetof(MercunaNavModifierVolume_GetSize, ReturnValue) == 0x000000, "Member 'MercunaNavModifierVolume_GetSize::ReturnValue' has a wrong offset!");

// Function Mercuna.MercunaNavOctree.Build
// 0x0010 (0x0010 - 0x0000)
struct MercunaNavOctree_Build final
{
public:
	TArray<struct FVector>                        PriorityPositions;                                 // 0x0000(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(MercunaNavOctree_Build) == 0x000008, "Wrong alignment on MercunaNavOctree_Build");
static_assert(sizeof(MercunaNavOctree_Build) == 0x000010, "Wrong size on MercunaNavOctree_Build");
static_assert(offsetof(MercunaNavOctree_Build, PriorityPositions) == 0x000000, "Member 'MercunaNavOctree_Build::PriorityPositions' has a wrong offset!");

// Function Mercuna.MercunaNavOctree.ClampToNavigable
// 0x0040 (0x0040 - 0x0000)
struct MercunaNavOctree_ClampToNavigable final
{
public:
	struct FVector                                Position;                                          // 0x0000(0x0018)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         NavigationRadius;                                  // 0x0018(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SearchRadius;                                      // 0x001C(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                ClampedPosition;                                   // 0x0020(0x0018)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          Result;                                            // 0x0038(0x0001)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_39[0x7];                                       // 0x0039(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(MercunaNavOctree_ClampToNavigable) == 0x000008, "Wrong alignment on MercunaNavOctree_ClampToNavigable");
static_assert(sizeof(MercunaNavOctree_ClampToNavigable) == 0x000040, "Wrong size on MercunaNavOctree_ClampToNavigable");
static_assert(offsetof(MercunaNavOctree_ClampToNavigable, Position) == 0x000000, "Member 'MercunaNavOctree_ClampToNavigable::Position' has a wrong offset!");
static_assert(offsetof(MercunaNavOctree_ClampToNavigable, NavigationRadius) == 0x000018, "Member 'MercunaNavOctree_ClampToNavigable::NavigationRadius' has a wrong offset!");
static_assert(offsetof(MercunaNavOctree_ClampToNavigable, SearchRadius) == 0x00001C, "Member 'MercunaNavOctree_ClampToNavigable::SearchRadius' has a wrong offset!");
static_assert(offsetof(MercunaNavOctree_ClampToNavigable, ClampedPosition) == 0x000020, "Member 'MercunaNavOctree_ClampToNavigable::ClampedPosition' has a wrong offset!");
static_assert(offsetof(MercunaNavOctree_ClampToNavigable, Result) == 0x000038, "Member 'MercunaNavOctree_ClampToNavigable::Result' has a wrong offset!");

// Function Mercuna.MercunaNavOctree.FindPathToActor
// 0x0048 (0x0048 - 0x0000)
struct MercunaNavOctree_FindPathToActor final
{
public:
	TDelegate<void(EMercunaPathEvent PathEvent)>  OnPathUpdated;                                     // 0x0000(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Start;                                             // 0x0010(0x0018)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 GoalActor;                                         // 0x0028(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         NavigationRadius;                                  // 0x0030(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          AllowPartial;                                      // 0x0034(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_35[0x3];                                       // 0x0035(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MaxPathLength;                                     // 0x0038(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HeightChangePenalty;                               // 0x003C(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMercunaPath*                           ReturnValue;                                       // 0x0040(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MercunaNavOctree_FindPathToActor) == 0x000008, "Wrong alignment on MercunaNavOctree_FindPathToActor");
static_assert(sizeof(MercunaNavOctree_FindPathToActor) == 0x000048, "Wrong size on MercunaNavOctree_FindPathToActor");
static_assert(offsetof(MercunaNavOctree_FindPathToActor, OnPathUpdated) == 0x000000, "Member 'MercunaNavOctree_FindPathToActor::OnPathUpdated' has a wrong offset!");
static_assert(offsetof(MercunaNavOctree_FindPathToActor, Start) == 0x000010, "Member 'MercunaNavOctree_FindPathToActor::Start' has a wrong offset!");
static_assert(offsetof(MercunaNavOctree_FindPathToActor, GoalActor) == 0x000028, "Member 'MercunaNavOctree_FindPathToActor::GoalActor' has a wrong offset!");
static_assert(offsetof(MercunaNavOctree_FindPathToActor, NavigationRadius) == 0x000030, "Member 'MercunaNavOctree_FindPathToActor::NavigationRadius' has a wrong offset!");
static_assert(offsetof(MercunaNavOctree_FindPathToActor, AllowPartial) == 0x000034, "Member 'MercunaNavOctree_FindPathToActor::AllowPartial' has a wrong offset!");
static_assert(offsetof(MercunaNavOctree_FindPathToActor, MaxPathLength) == 0x000038, "Member 'MercunaNavOctree_FindPathToActor::MaxPathLength' has a wrong offset!");
static_assert(offsetof(MercunaNavOctree_FindPathToActor, HeightChangePenalty) == 0x00003C, "Member 'MercunaNavOctree_FindPathToActor::HeightChangePenalty' has a wrong offset!");
static_assert(offsetof(MercunaNavOctree_FindPathToActor, ReturnValue) == 0x000040, "Member 'MercunaNavOctree_FindPathToActor::ReturnValue' has a wrong offset!");

// Function Mercuna.MercunaNavOctree.FindPathToLocation
// 0x0058 (0x0058 - 0x0000)
struct MercunaNavOctree_FindPathToLocation final
{
public:
	TDelegate<void(EMercunaPathEvent PathEvent)>  OnPathUpdated;                                     // 0x0000(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Start;                                             // 0x0010(0x0018)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                End;                                               // 0x0028(0x0018)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         NavigationRadius;                                  // 0x0040(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          AllowPartial;                                      // 0x0044(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_45[0x3];                                       // 0x0045(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MaxPathLength;                                     // 0x0048(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HeightChangePenalty;                               // 0x004C(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMercunaPath*                           ReturnValue;                                       // 0x0050(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MercunaNavOctree_FindPathToLocation) == 0x000008, "Wrong alignment on MercunaNavOctree_FindPathToLocation");
static_assert(sizeof(MercunaNavOctree_FindPathToLocation) == 0x000058, "Wrong size on MercunaNavOctree_FindPathToLocation");
static_assert(offsetof(MercunaNavOctree_FindPathToLocation, OnPathUpdated) == 0x000000, "Member 'MercunaNavOctree_FindPathToLocation::OnPathUpdated' has a wrong offset!");
static_assert(offsetof(MercunaNavOctree_FindPathToLocation, Start) == 0x000010, "Member 'MercunaNavOctree_FindPathToLocation::Start' has a wrong offset!");
static_assert(offsetof(MercunaNavOctree_FindPathToLocation, End) == 0x000028, "Member 'MercunaNavOctree_FindPathToLocation::End' has a wrong offset!");
static_assert(offsetof(MercunaNavOctree_FindPathToLocation, NavigationRadius) == 0x000040, "Member 'MercunaNavOctree_FindPathToLocation::NavigationRadius' has a wrong offset!");
static_assert(offsetof(MercunaNavOctree_FindPathToLocation, AllowPartial) == 0x000044, "Member 'MercunaNavOctree_FindPathToLocation::AllowPartial' has a wrong offset!");
static_assert(offsetof(MercunaNavOctree_FindPathToLocation, MaxPathLength) == 0x000048, "Member 'MercunaNavOctree_FindPathToLocation::MaxPathLength' has a wrong offset!");
static_assert(offsetof(MercunaNavOctree_FindPathToLocation, HeightChangePenalty) == 0x00004C, "Member 'MercunaNavOctree_FindPathToLocation::HeightChangePenalty' has a wrong offset!");
static_assert(offsetof(MercunaNavOctree_FindPathToLocation, ReturnValue) == 0x000050, "Member 'MercunaNavOctree_FindPathToLocation::ReturnValue' has a wrong offset!");

// Function Mercuna.MercunaNavOctree.FindPathToLocations
// 0x0050 (0x0050 - 0x0000)
struct MercunaNavOctree_FindPathToLocations final
{
public:
	TDelegate<void(EMercunaPathEvent PathEvent)>  OnPathUpdated;                                     // 0x0000(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Start;                                             // 0x0010(0x0018)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FVector>                        Destinations;                                      // 0x0028(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	float                                         NavigationRadius;                                  // 0x0038(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          AllowPartial;                                      // 0x003C(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3D[0x3];                                       // 0x003D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MaxPathLength;                                     // 0x0040(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HeightChangePenalty;                               // 0x0044(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMercunaPath*                           ReturnValue;                                       // 0x0048(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MercunaNavOctree_FindPathToLocations) == 0x000008, "Wrong alignment on MercunaNavOctree_FindPathToLocations");
static_assert(sizeof(MercunaNavOctree_FindPathToLocations) == 0x000050, "Wrong size on MercunaNavOctree_FindPathToLocations");
static_assert(offsetof(MercunaNavOctree_FindPathToLocations, OnPathUpdated) == 0x000000, "Member 'MercunaNavOctree_FindPathToLocations::OnPathUpdated' has a wrong offset!");
static_assert(offsetof(MercunaNavOctree_FindPathToLocations, Start) == 0x000010, "Member 'MercunaNavOctree_FindPathToLocations::Start' has a wrong offset!");
static_assert(offsetof(MercunaNavOctree_FindPathToLocations, Destinations) == 0x000028, "Member 'MercunaNavOctree_FindPathToLocations::Destinations' has a wrong offset!");
static_assert(offsetof(MercunaNavOctree_FindPathToLocations, NavigationRadius) == 0x000038, "Member 'MercunaNavOctree_FindPathToLocations::NavigationRadius' has a wrong offset!");
static_assert(offsetof(MercunaNavOctree_FindPathToLocations, AllowPartial) == 0x00003C, "Member 'MercunaNavOctree_FindPathToLocations::AllowPartial' has a wrong offset!");
static_assert(offsetof(MercunaNavOctree_FindPathToLocations, MaxPathLength) == 0x000040, "Member 'MercunaNavOctree_FindPathToLocations::MaxPathLength' has a wrong offset!");
static_assert(offsetof(MercunaNavOctree_FindPathToLocations, HeightChangePenalty) == 0x000044, "Member 'MercunaNavOctree_FindPathToLocations::HeightChangePenalty' has a wrong offset!");
static_assert(offsetof(MercunaNavOctree_FindPathToLocations, ReturnValue) == 0x000048, "Member 'MercunaNavOctree_FindPathToLocations::ReturnValue' has a wrong offset!");

// Function Mercuna.MercunaNavOctree.FindSmoothPathToLocation
// 0x0060 (0x0060 - 0x0000)
struct MercunaNavOctree_FindSmoothPathToLocation final
{
public:
	TDelegate<void(EMercunaPathEvent PathEvent)>  OnPathUpdated;                                     // 0x0000(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Start;                                             // 0x0010(0x0018)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                End;                                               // 0x0028(0x0018)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         NavigationRadius;                                  // 0x0040(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxSpeed;                                          // 0x0044(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxAcceleration;                                   // 0x0048(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          AllowPartial;                                      // 0x004C(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4D[0x3];                                       // 0x004D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MaxPathLength;                                     // 0x0050(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_54[0x4];                                       // 0x0054(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UMercunaSmoothPath*                     ReturnValue;                                       // 0x0058(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MercunaNavOctree_FindSmoothPathToLocation) == 0x000008, "Wrong alignment on MercunaNavOctree_FindSmoothPathToLocation");
static_assert(sizeof(MercunaNavOctree_FindSmoothPathToLocation) == 0x000060, "Wrong size on MercunaNavOctree_FindSmoothPathToLocation");
static_assert(offsetof(MercunaNavOctree_FindSmoothPathToLocation, OnPathUpdated) == 0x000000, "Member 'MercunaNavOctree_FindSmoothPathToLocation::OnPathUpdated' has a wrong offset!");
static_assert(offsetof(MercunaNavOctree_FindSmoothPathToLocation, Start) == 0x000010, "Member 'MercunaNavOctree_FindSmoothPathToLocation::Start' has a wrong offset!");
static_assert(offsetof(MercunaNavOctree_FindSmoothPathToLocation, End) == 0x000028, "Member 'MercunaNavOctree_FindSmoothPathToLocation::End' has a wrong offset!");
static_assert(offsetof(MercunaNavOctree_FindSmoothPathToLocation, NavigationRadius) == 0x000040, "Member 'MercunaNavOctree_FindSmoothPathToLocation::NavigationRadius' has a wrong offset!");
static_assert(offsetof(MercunaNavOctree_FindSmoothPathToLocation, MaxSpeed) == 0x000044, "Member 'MercunaNavOctree_FindSmoothPathToLocation::MaxSpeed' has a wrong offset!");
static_assert(offsetof(MercunaNavOctree_FindSmoothPathToLocation, MaxAcceleration) == 0x000048, "Member 'MercunaNavOctree_FindSmoothPathToLocation::MaxAcceleration' has a wrong offset!");
static_assert(offsetof(MercunaNavOctree_FindSmoothPathToLocation, AllowPartial) == 0x00004C, "Member 'MercunaNavOctree_FindSmoothPathToLocation::AllowPartial' has a wrong offset!");
static_assert(offsetof(MercunaNavOctree_FindSmoothPathToLocation, MaxPathLength) == 0x000050, "Member 'MercunaNavOctree_FindSmoothPathToLocation::MaxPathLength' has a wrong offset!");
static_assert(offsetof(MercunaNavOctree_FindSmoothPathToLocation, ReturnValue) == 0x000058, "Member 'MercunaNavOctree_FindSmoothPathToLocation::ReturnValue' has a wrong offset!");

// Function Mercuna.MercunaNavOctree.FindSmoothPathToLocations
// 0x0058 (0x0058 - 0x0000)
struct MercunaNavOctree_FindSmoothPathToLocations final
{
public:
	TDelegate<void(EMercunaPathEvent PathEvent)>  OnPathUpdated;                                     // 0x0000(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Start;                                             // 0x0010(0x0018)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FVector>                        Destinations;                                      // 0x0028(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	float                                         NavigationRadius;                                  // 0x0038(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxSpeed;                                          // 0x003C(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxAcceleration;                                   // 0x0040(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          AllowPartial;                                      // 0x0044(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_45[0x3];                                       // 0x0045(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MaxPathLength;                                     // 0x0048(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4C[0x4];                                       // 0x004C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UMercunaSmoothPath*                     ReturnValue;                                       // 0x0050(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MercunaNavOctree_FindSmoothPathToLocations) == 0x000008, "Wrong alignment on MercunaNavOctree_FindSmoothPathToLocations");
static_assert(sizeof(MercunaNavOctree_FindSmoothPathToLocations) == 0x000058, "Wrong size on MercunaNavOctree_FindSmoothPathToLocations");
static_assert(offsetof(MercunaNavOctree_FindSmoothPathToLocations, OnPathUpdated) == 0x000000, "Member 'MercunaNavOctree_FindSmoothPathToLocations::OnPathUpdated' has a wrong offset!");
static_assert(offsetof(MercunaNavOctree_FindSmoothPathToLocations, Start) == 0x000010, "Member 'MercunaNavOctree_FindSmoothPathToLocations::Start' has a wrong offset!");
static_assert(offsetof(MercunaNavOctree_FindSmoothPathToLocations, Destinations) == 0x000028, "Member 'MercunaNavOctree_FindSmoothPathToLocations::Destinations' has a wrong offset!");
static_assert(offsetof(MercunaNavOctree_FindSmoothPathToLocations, NavigationRadius) == 0x000038, "Member 'MercunaNavOctree_FindSmoothPathToLocations::NavigationRadius' has a wrong offset!");
static_assert(offsetof(MercunaNavOctree_FindSmoothPathToLocations, MaxSpeed) == 0x00003C, "Member 'MercunaNavOctree_FindSmoothPathToLocations::MaxSpeed' has a wrong offset!");
static_assert(offsetof(MercunaNavOctree_FindSmoothPathToLocations, MaxAcceleration) == 0x000040, "Member 'MercunaNavOctree_FindSmoothPathToLocations::MaxAcceleration' has a wrong offset!");
static_assert(offsetof(MercunaNavOctree_FindSmoothPathToLocations, AllowPartial) == 0x000044, "Member 'MercunaNavOctree_FindSmoothPathToLocations::AllowPartial' has a wrong offset!");
static_assert(offsetof(MercunaNavOctree_FindSmoothPathToLocations, MaxPathLength) == 0x000048, "Member 'MercunaNavOctree_FindSmoothPathToLocations::MaxPathLength' has a wrong offset!");
static_assert(offsetof(MercunaNavOctree_FindSmoothPathToLocations, ReturnValue) == 0x000050, "Member 'MercunaNavOctree_FindSmoothPathToLocations::ReturnValue' has a wrong offset!");

// Function Mercuna.MercunaNavOctree.IsNavigable
// 0x0020 (0x0020 - 0x0000)
struct MercunaNavOctree_IsNavigable final
{
public:
	struct FVector                                Position;                                          // 0x0000(0x0018)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         NavigationRadius;                                  // 0x0018(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          Result;                                            // 0x001C(0x0001)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1D[0x3];                                       // 0x001D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(MercunaNavOctree_IsNavigable) == 0x000008, "Wrong alignment on MercunaNavOctree_IsNavigable");
static_assert(sizeof(MercunaNavOctree_IsNavigable) == 0x000020, "Wrong size on MercunaNavOctree_IsNavigable");
static_assert(offsetof(MercunaNavOctree_IsNavigable, Position) == 0x000000, "Member 'MercunaNavOctree_IsNavigable::Position' has a wrong offset!");
static_assert(offsetof(MercunaNavOctree_IsNavigable, NavigationRadius) == 0x000018, "Member 'MercunaNavOctree_IsNavigable::NavigationRadius' has a wrong offset!");
static_assert(offsetof(MercunaNavOctree_IsNavigable, Result) == 0x00001C, "Member 'MercunaNavOctree_IsNavigable::Result' has a wrong offset!");

// Function Mercuna.MercunaNavOctree.IsNavigableMulti
// 0x0028 (0x0028 - 0x0000)
struct MercunaNavOctree_IsNavigableMulti final
{
public:
	TArray<struct FVector>                        Positions;                                         // 0x0000(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	float                                         NavigationRadius;                                  // 0x0010(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<bool>                                  Results;                                           // 0x0018(0x0010)(Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(MercunaNavOctree_IsNavigableMulti) == 0x000008, "Wrong alignment on MercunaNavOctree_IsNavigableMulti");
static_assert(sizeof(MercunaNavOctree_IsNavigableMulti) == 0x000028, "Wrong size on MercunaNavOctree_IsNavigableMulti");
static_assert(offsetof(MercunaNavOctree_IsNavigableMulti, Positions) == 0x000000, "Member 'MercunaNavOctree_IsNavigableMulti::Positions' has a wrong offset!");
static_assert(offsetof(MercunaNavOctree_IsNavigableMulti, NavigationRadius) == 0x000010, "Member 'MercunaNavOctree_IsNavigableMulti::NavigationRadius' has a wrong offset!");
static_assert(offsetof(MercunaNavOctree_IsNavigableMulti, Results) == 0x000018, "Member 'MercunaNavOctree_IsNavigableMulti::Results' has a wrong offset!");

// Function Mercuna.MercunaNavOctree.IsReachable
// 0x0040 (0x0040 - 0x0000)
struct MercunaNavOctree_IsReachable final
{
public:
	struct FVector                                Start;                                             // 0x0000(0x0018)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                End;                                               // 0x0018(0x0018)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         NavigationRadius;                                  // 0x0030(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxPathLength;                                     // 0x0034(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0038(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_39[0x7];                                       // 0x0039(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(MercunaNavOctree_IsReachable) == 0x000008, "Wrong alignment on MercunaNavOctree_IsReachable");
static_assert(sizeof(MercunaNavOctree_IsReachable) == 0x000040, "Wrong size on MercunaNavOctree_IsReachable");
static_assert(offsetof(MercunaNavOctree_IsReachable, Start) == 0x000000, "Member 'MercunaNavOctree_IsReachable::Start' has a wrong offset!");
static_assert(offsetof(MercunaNavOctree_IsReachable, End) == 0x000018, "Member 'MercunaNavOctree_IsReachable::End' has a wrong offset!");
static_assert(offsetof(MercunaNavOctree_IsReachable, NavigationRadius) == 0x000030, "Member 'MercunaNavOctree_IsReachable::NavigationRadius' has a wrong offset!");
static_assert(offsetof(MercunaNavOctree_IsReachable, MaxPathLength) == 0x000034, "Member 'MercunaNavOctree_IsReachable::MaxPathLength' has a wrong offset!");
static_assert(offsetof(MercunaNavOctree_IsReachable, ReturnValue) == 0x000038, "Member 'MercunaNavOctree_IsReachable::ReturnValue' has a wrong offset!");

// Function Mercuna.MercunaNavOctree.IsReachableLatent
// 0x0080 (0x0080 - 0x0000)
struct MercunaNavOctree_IsReachableLatent final
{
public:
	struct FVector                                Start;                                             // 0x0000(0x0018)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FVector>                        EndPos;                                            // 0x0018(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	float                                         NavigationRadius;                                  // 0x0028(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C[0x4];                                       // 0x002C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<bool>                                  Result;                                            // 0x0030(0x0010)(Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FVector>                        ClampedPos;                                        // 0x0040(0x0010)(Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
	class UObject*                                WorldContextObject;                                // 0x0050(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLatentActionInfo                      LatentInfo;                                        // 0x0058(0x0018)(Parm, NoDestructor, NativeAccessSpecifierPublic)
	float                                         MaxPathLength;                                     // 0x0070(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          AccuratePathLength;                                // 0x0074(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_75[0x3];                                       // 0x0075(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         StartSearchRadius;                                 // 0x0078(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         EndSearchRadius;                                   // 0x007C(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MercunaNavOctree_IsReachableLatent) == 0x000008, "Wrong alignment on MercunaNavOctree_IsReachableLatent");
static_assert(sizeof(MercunaNavOctree_IsReachableLatent) == 0x000080, "Wrong size on MercunaNavOctree_IsReachableLatent");
static_assert(offsetof(MercunaNavOctree_IsReachableLatent, Start) == 0x000000, "Member 'MercunaNavOctree_IsReachableLatent::Start' has a wrong offset!");
static_assert(offsetof(MercunaNavOctree_IsReachableLatent, EndPos) == 0x000018, "Member 'MercunaNavOctree_IsReachableLatent::EndPos' has a wrong offset!");
static_assert(offsetof(MercunaNavOctree_IsReachableLatent, NavigationRadius) == 0x000028, "Member 'MercunaNavOctree_IsReachableLatent::NavigationRadius' has a wrong offset!");
static_assert(offsetof(MercunaNavOctree_IsReachableLatent, Result) == 0x000030, "Member 'MercunaNavOctree_IsReachableLatent::Result' has a wrong offset!");
static_assert(offsetof(MercunaNavOctree_IsReachableLatent, ClampedPos) == 0x000040, "Member 'MercunaNavOctree_IsReachableLatent::ClampedPos' has a wrong offset!");
static_assert(offsetof(MercunaNavOctree_IsReachableLatent, WorldContextObject) == 0x000050, "Member 'MercunaNavOctree_IsReachableLatent::WorldContextObject' has a wrong offset!");
static_assert(offsetof(MercunaNavOctree_IsReachableLatent, LatentInfo) == 0x000058, "Member 'MercunaNavOctree_IsReachableLatent::LatentInfo' has a wrong offset!");
static_assert(offsetof(MercunaNavOctree_IsReachableLatent, MaxPathLength) == 0x000070, "Member 'MercunaNavOctree_IsReachableLatent::MaxPathLength' has a wrong offset!");
static_assert(offsetof(MercunaNavOctree_IsReachableLatent, AccuratePathLength) == 0x000074, "Member 'MercunaNavOctree_IsReachableLatent::AccuratePathLength' has a wrong offset!");
static_assert(offsetof(MercunaNavOctree_IsReachableLatent, StartSearchRadius) == 0x000078, "Member 'MercunaNavOctree_IsReachableLatent::StartSearchRadius' has a wrong offset!");
static_assert(offsetof(MercunaNavOctree_IsReachableLatent, EndSearchRadius) == 0x00007C, "Member 'MercunaNavOctree_IsReachableLatent::EndSearchRadius' has a wrong offset!");

// Function Mercuna.MercunaNavOctree.Raycast
// 0x0058 (0x0058 - 0x0000)
struct MercunaNavOctree_Raycast final
{
public:
	struct FVector                                Start;                                             // 0x0000(0x0018)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                End;                                               // 0x0018(0x0018)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         NavigationRadius;                                  // 0x0030(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_34[0x4];                                       // 0x0034(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                HitPosition;                                       // 0x0038(0x0018)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          RayHit;                                            // 0x0050(0x0001)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_51[0x7];                                       // 0x0051(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(MercunaNavOctree_Raycast) == 0x000008, "Wrong alignment on MercunaNavOctree_Raycast");
static_assert(sizeof(MercunaNavOctree_Raycast) == 0x000058, "Wrong size on MercunaNavOctree_Raycast");
static_assert(offsetof(MercunaNavOctree_Raycast, Start) == 0x000000, "Member 'MercunaNavOctree_Raycast::Start' has a wrong offset!");
static_assert(offsetof(MercunaNavOctree_Raycast, End) == 0x000018, "Member 'MercunaNavOctree_Raycast::End' has a wrong offset!");
static_assert(offsetof(MercunaNavOctree_Raycast, NavigationRadius) == 0x000030, "Member 'MercunaNavOctree_Raycast::NavigationRadius' has a wrong offset!");
static_assert(offsetof(MercunaNavOctree_Raycast, HitPosition) == 0x000038, "Member 'MercunaNavOctree_Raycast::HitPosition' has a wrong offset!");
static_assert(offsetof(MercunaNavOctree_Raycast, RayHit) == 0x000050, "Member 'MercunaNavOctree_Raycast::RayHit' has a wrong offset!");

// Function Mercuna.MercunaNavOctree.RebuildChanges
// 0x0002 (0x0002 - 0x0000)
struct MercunaNavOctree_RebuildChanges final
{
public:
	bool                                          StagedBuild;                                       // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          RemoveUnseeded;                                    // 0x0001(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MercunaNavOctree_RebuildChanges) == 0x000001, "Wrong alignment on MercunaNavOctree_RebuildChanges");
static_assert(sizeof(MercunaNavOctree_RebuildChanges) == 0x000002, "Wrong size on MercunaNavOctree_RebuildChanges");
static_assert(offsetof(MercunaNavOctree_RebuildChanges, StagedBuild) == 0x000000, "Member 'MercunaNavOctree_RebuildChanges::StagedBuild' has a wrong offset!");
static_assert(offsetof(MercunaNavOctree_RebuildChanges, RemoveUnseeded) == 0x000001, "Member 'MercunaNavOctree_RebuildChanges::RemoveUnseeded' has a wrong offset!");

// Function Mercuna.MercunaNavOctree.RebuildVolume
// 0x0010 (0x0010 - 0x0000)
struct MercunaNavOctree_RebuildVolume final
{
public:
	const class AActor*                           Volume;                                            // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          StagedBuild;                                       // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          RemoveUnseeded;                                    // 0x0009(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A[0x6];                                        // 0x000A(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(MercunaNavOctree_RebuildVolume) == 0x000008, "Wrong alignment on MercunaNavOctree_RebuildVolume");
static_assert(sizeof(MercunaNavOctree_RebuildVolume) == 0x000010, "Wrong size on MercunaNavOctree_RebuildVolume");
static_assert(offsetof(MercunaNavOctree_RebuildVolume, Volume) == 0x000000, "Member 'MercunaNavOctree_RebuildVolume::Volume' has a wrong offset!");
static_assert(offsetof(MercunaNavOctree_RebuildVolume, StagedBuild) == 0x000008, "Member 'MercunaNavOctree_RebuildVolume::StagedBuild' has a wrong offset!");
static_assert(offsetof(MercunaNavOctree_RebuildVolume, RemoveUnseeded) == 0x000009, "Member 'MercunaNavOctree_RebuildVolume::RemoveUnseeded' has a wrong offset!");

// Function Mercuna.MercunaNavOctree.RebuildVolumes
// 0x0018 (0x0018 - 0x0000)
struct MercunaNavOctree_RebuildVolumes final
{
public:
	TArray<struct FBox>                           Volumes;                                           // 0x0000(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	bool                                          bStagedBuild;                                      // 0x0010(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bRemoveUnseeded;                                   // 0x0011(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bMergeVolumes;                                     // 0x0012(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_13[0x5];                                       // 0x0013(0x0005)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(MercunaNavOctree_RebuildVolumes) == 0x000008, "Wrong alignment on MercunaNavOctree_RebuildVolumes");
static_assert(sizeof(MercunaNavOctree_RebuildVolumes) == 0x000018, "Wrong size on MercunaNavOctree_RebuildVolumes");
static_assert(offsetof(MercunaNavOctree_RebuildVolumes, Volumes) == 0x000000, "Member 'MercunaNavOctree_RebuildVolumes::Volumes' has a wrong offset!");
static_assert(offsetof(MercunaNavOctree_RebuildVolumes, bStagedBuild) == 0x000010, "Member 'MercunaNavOctree_RebuildVolumes::bStagedBuild' has a wrong offset!");
static_assert(offsetof(MercunaNavOctree_RebuildVolumes, bRemoveUnseeded) == 0x000011, "Member 'MercunaNavOctree_RebuildVolumes::bRemoveUnseeded' has a wrong offset!");
static_assert(offsetof(MercunaNavOctree_RebuildVolumes, bMergeVolumes) == 0x000012, "Member 'MercunaNavOctree_RebuildVolumes::bMergeVolumes' has a wrong offset!");

// Function Mercuna.MercunaNavOctree.SetNavigationRotation
// 0x0018 (0x0018 - 0x0000)
struct MercunaNavOctree_SetNavigationRotation final
{
public:
	struct FRotator                               Rotation;                                          // 0x0000(0x0018)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(MercunaNavOctree_SetNavigationRotation) == 0x000008, "Wrong alignment on MercunaNavOctree_SetNavigationRotation");
static_assert(sizeof(MercunaNavOctree_SetNavigationRotation) == 0x000018, "Wrong size on MercunaNavOctree_SetNavigationRotation");
static_assert(offsetof(MercunaNavOctree_SetNavigationRotation, Rotation) == 0x000000, "Member 'MercunaNavOctree_SetNavigationRotation::Rotation' has a wrong offset!");

// Function Mercuna.MercunaNavOctree.IsBuilding
// 0x0001 (0x0001 - 0x0000)
struct MercunaNavOctree_IsBuilding final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MercunaNavOctree_IsBuilding) == 0x000001, "Wrong alignment on MercunaNavOctree_IsBuilding");
static_assert(sizeof(MercunaNavOctree_IsBuilding) == 0x000001, "Wrong size on MercunaNavOctree_IsBuilding");
static_assert(offsetof(MercunaNavOctree_IsBuilding, ReturnValue) == 0x000000, "Member 'MercunaNavOctree_IsBuilding::ReturnValue' has a wrong offset!");

// Function Mercuna.MercunaNavOctreeModifierComponent.AddToOctree
// 0x0008 (0x0008 - 0x0000)
struct MercunaNavOctreeModifierComponent_AddToOctree final
{
public:
	class AMercunaNavOctree*                      NewNavOctree;                                      // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MercunaNavOctreeModifierComponent_AddToOctree) == 0x000008, "Wrong alignment on MercunaNavOctreeModifierComponent_AddToOctree");
static_assert(sizeof(MercunaNavOctreeModifierComponent_AddToOctree) == 0x000008, "Wrong size on MercunaNavOctreeModifierComponent_AddToOctree");
static_assert(offsetof(MercunaNavOctreeModifierComponent_AddToOctree, NewNavOctree) == 0x000000, "Member 'MercunaNavOctreeModifierComponent_AddToOctree::NewNavOctree' has a wrong offset!");

// Function Mercuna.MercunaNavOctreeModifierVolume.AddToOctree
// 0x0008 (0x0008 - 0x0000)
struct MercunaNavOctreeModifierVolume_AddToOctree final
{
public:
	class AMercunaNavOctree*                      NavOctree;                                         // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MercunaNavOctreeModifierVolume_AddToOctree) == 0x000008, "Wrong alignment on MercunaNavOctreeModifierVolume_AddToOctree");
static_assert(sizeof(MercunaNavOctreeModifierVolume_AddToOctree) == 0x000008, "Wrong size on MercunaNavOctreeModifierVolume_AddToOctree");
static_assert(offsetof(MercunaNavOctreeModifierVolume_AddToOctree, NavOctree) == 0x000000, "Member 'MercunaNavOctreeModifierVolume_AddToOctree::NavOctree' has a wrong offset!");

// Function Mercuna.MercunaNavOctreeModifierVolume.SetCostMultiplier
// 0x0004 (0x0004 - 0x0000)
struct MercunaNavOctreeModifierVolume_SetCostMultiplier final
{
public:
	float                                         NewCostMultiplier;                                 // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MercunaNavOctreeModifierVolume_SetCostMultiplier) == 0x000004, "Wrong alignment on MercunaNavOctreeModifierVolume_SetCostMultiplier");
static_assert(sizeof(MercunaNavOctreeModifierVolume_SetCostMultiplier) == 0x000004, "Wrong size on MercunaNavOctreeModifierVolume_SetCostMultiplier");
static_assert(offsetof(MercunaNavOctreeModifierVolume_SetCostMultiplier, NewCostMultiplier) == 0x000000, "Member 'MercunaNavOctreeModifierVolume_SetCostMultiplier::NewCostMultiplier' has a wrong offset!");

// Function Mercuna.MercunaNavOctreeModifierVolume.SetEnabled
// 0x0001 (0x0001 - 0x0000)
struct MercunaNavOctreeModifierVolume_SetEnabled final
{
public:
	bool                                          Enabled;                                           // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MercunaNavOctreeModifierVolume_SetEnabled) == 0x000001, "Wrong alignment on MercunaNavOctreeModifierVolume_SetEnabled");
static_assert(sizeof(MercunaNavOctreeModifierVolume_SetEnabled) == 0x000001, "Wrong size on MercunaNavOctreeModifierVolume_SetEnabled");
static_assert(offsetof(MercunaNavOctreeModifierVolume_SetEnabled, Enabled) == 0x000000, "Member 'MercunaNavOctreeModifierVolume_SetEnabled::Enabled' has a wrong offset!");

// Function Mercuna.MercunaNavOctreeModifierVolume.SetSize
// 0x0018 (0x0018 - 0x0000)
struct MercunaNavOctreeModifierVolume_SetSize final
{
public:
	struct FVector                                Size;                                              // 0x0000(0x0018)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MercunaNavOctreeModifierVolume_SetSize) == 0x000008, "Wrong alignment on MercunaNavOctreeModifierVolume_SetSize");
static_assert(sizeof(MercunaNavOctreeModifierVolume_SetSize) == 0x000018, "Wrong size on MercunaNavOctreeModifierVolume_SetSize");
static_assert(offsetof(MercunaNavOctreeModifierVolume_SetSize, Size) == 0x000000, "Member 'MercunaNavOctreeModifierVolume_SetSize::Size' has a wrong offset!");

// Function Mercuna.MercunaNavOctreeModifierVolume.SetUsageTypes
// 0x0004 (0x0004 - 0x0000)
struct MercunaNavOctreeModifierVolume_SetUsageTypes final
{
public:
	struct FMercunaUsageTypes                     NewUsageTypes;                                     // 0x0000(0x0004)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(MercunaNavOctreeModifierVolume_SetUsageTypes) == 0x000004, "Wrong alignment on MercunaNavOctreeModifierVolume_SetUsageTypes");
static_assert(sizeof(MercunaNavOctreeModifierVolume_SetUsageTypes) == 0x000004, "Wrong size on MercunaNavOctreeModifierVolume_SetUsageTypes");
static_assert(offsetof(MercunaNavOctreeModifierVolume_SetUsageTypes, NewUsageTypes) == 0x000000, "Member 'MercunaNavOctreeModifierVolume_SetUsageTypes::NewUsageTypes' has a wrong offset!");

// Function Mercuna.MercunaNavOctreeModifierVolume.GetSize
// 0x0018 (0x0018 - 0x0000)
struct MercunaNavOctreeModifierVolume_GetSize final
{
public:
	struct FVector                                ReturnValue;                                       // 0x0000(0x0018)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MercunaNavOctreeModifierVolume_GetSize) == 0x000008, "Wrong alignment on MercunaNavOctreeModifierVolume_GetSize");
static_assert(sizeof(MercunaNavOctreeModifierVolume_GetSize) == 0x000018, "Wrong size on MercunaNavOctreeModifierVolume_GetSize");
static_assert(offsetof(MercunaNavOctreeModifierVolume_GetSize, ReturnValue) == 0x000000, "Member 'MercunaNavOctreeModifierVolume_GetSize::ReturnValue' has a wrong offset!");

// Function Mercuna.MercunaNavOctreeVolume.AddToOctree
// 0x0008 (0x0008 - 0x0000)
struct MercunaNavOctreeVolume_AddToOctree final
{
public:
	class AMercunaNavOctree*                      NavOctree_0;                                       // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MercunaNavOctreeVolume_AddToOctree) == 0x000008, "Wrong alignment on MercunaNavOctreeVolume_AddToOctree");
static_assert(sizeof(MercunaNavOctreeVolume_AddToOctree) == 0x000008, "Wrong size on MercunaNavOctreeVolume_AddToOctree");
static_assert(offsetof(MercunaNavOctreeVolume_AddToOctree, NavOctree_0) == 0x000000, "Member 'MercunaNavOctreeVolume_AddToOctree::NavOctree_0' has a wrong offset!");

// Function Mercuna.MercunaNavSurfaceGrid.Build
// 0x0010 (0x0010 - 0x0000)
struct MercunaNavSurfaceGrid_Build final
{
public:
	TArray<struct FVector>                        PriorityPositions;                                 // 0x0000(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(MercunaNavSurfaceGrid_Build) == 0x000008, "Wrong alignment on MercunaNavSurfaceGrid_Build");
static_assert(sizeof(MercunaNavSurfaceGrid_Build) == 0x000010, "Wrong size on MercunaNavSurfaceGrid_Build");
static_assert(offsetof(MercunaNavSurfaceGrid_Build, PriorityPositions) == 0x000000, "Member 'MercunaNavSurfaceGrid_Build::PriorityPositions' has a wrong offset!");

// Function Mercuna.MercunaNavSurfaceGrid.FindPathToLocation
// 0x0088 (0x0088 - 0x0000)
struct MercunaNavSurfaceGrid_FindPathToLocation final
{
public:
	struct FMercunaSurfaceAgentType               AgentType;                                         // 0x0000(0x000C)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TDelegate<void(EMercunaPathEvent PathEvent)>  OnPathUpdated;                                     // 0x000C(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C[0x4];                                       // 0x001C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                Start;                                             // 0x0020(0x0018)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                StartUp;                                           // 0x0038(0x0018)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                End;                                               // 0x0050(0x0018)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         IdealTurnRadius;                                   // 0x0068(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxSpeed;                                          // 0x006C(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          AllowPartial;                                      // 0x0070(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_71[0x3];                                       // 0x0071(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MaxPathLength;                                     // 0x0074(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FMercunaUsageSpec                      UsageSpec;                                         // 0x0078(0x0008)(ConstParm, Parm, NoDestructor, NativeAccessSpecifierPublic)
	class UMercunaPath*                           ReturnValue;                                       // 0x0080(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MercunaNavSurfaceGrid_FindPathToLocation) == 0x000008, "Wrong alignment on MercunaNavSurfaceGrid_FindPathToLocation");
static_assert(sizeof(MercunaNavSurfaceGrid_FindPathToLocation) == 0x000088, "Wrong size on MercunaNavSurfaceGrid_FindPathToLocation");
static_assert(offsetof(MercunaNavSurfaceGrid_FindPathToLocation, AgentType) == 0x000000, "Member 'MercunaNavSurfaceGrid_FindPathToLocation::AgentType' has a wrong offset!");
static_assert(offsetof(MercunaNavSurfaceGrid_FindPathToLocation, OnPathUpdated) == 0x00000C, "Member 'MercunaNavSurfaceGrid_FindPathToLocation::OnPathUpdated' has a wrong offset!");
static_assert(offsetof(MercunaNavSurfaceGrid_FindPathToLocation, Start) == 0x000020, "Member 'MercunaNavSurfaceGrid_FindPathToLocation::Start' has a wrong offset!");
static_assert(offsetof(MercunaNavSurfaceGrid_FindPathToLocation, StartUp) == 0x000038, "Member 'MercunaNavSurfaceGrid_FindPathToLocation::StartUp' has a wrong offset!");
static_assert(offsetof(MercunaNavSurfaceGrid_FindPathToLocation, End) == 0x000050, "Member 'MercunaNavSurfaceGrid_FindPathToLocation::End' has a wrong offset!");
static_assert(offsetof(MercunaNavSurfaceGrid_FindPathToLocation, IdealTurnRadius) == 0x000068, "Member 'MercunaNavSurfaceGrid_FindPathToLocation::IdealTurnRadius' has a wrong offset!");
static_assert(offsetof(MercunaNavSurfaceGrid_FindPathToLocation, MaxSpeed) == 0x00006C, "Member 'MercunaNavSurfaceGrid_FindPathToLocation::MaxSpeed' has a wrong offset!");
static_assert(offsetof(MercunaNavSurfaceGrid_FindPathToLocation, AllowPartial) == 0x000070, "Member 'MercunaNavSurfaceGrid_FindPathToLocation::AllowPartial' has a wrong offset!");
static_assert(offsetof(MercunaNavSurfaceGrid_FindPathToLocation, MaxPathLength) == 0x000074, "Member 'MercunaNavSurfaceGrid_FindPathToLocation::MaxPathLength' has a wrong offset!");
static_assert(offsetof(MercunaNavSurfaceGrid_FindPathToLocation, UsageSpec) == 0x000078, "Member 'MercunaNavSurfaceGrid_FindPathToLocation::UsageSpec' has a wrong offset!");
static_assert(offsetof(MercunaNavSurfaceGrid_FindPathToLocation, ReturnValue) == 0x000080, "Member 'MercunaNavSurfaceGrid_FindPathToLocation::ReturnValue' has a wrong offset!");

// Function Mercuna.MercunaNavSurfaceGrid.FindPathToLocations
// 0x0080 (0x0080 - 0x0000)
struct MercunaNavSurfaceGrid_FindPathToLocations final
{
public:
	struct FMercunaSurfaceAgentType               AgentType;                                         // 0x0000(0x000C)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TDelegate<void(EMercunaPathEvent PathEvent)>  OnPathUpdated;                                     // 0x000C(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C[0x4];                                       // 0x001C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                Start;                                             // 0x0020(0x0018)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                StartUp;                                           // 0x0038(0x0018)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FVector>                        Destinations;                                      // 0x0050(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	float                                         IdealTurnRadius;                                   // 0x0060(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxSpeed;                                          // 0x0064(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          AllowPartial;                                      // 0x0068(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_69[0x3];                                       // 0x0069(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MaxPathLength;                                     // 0x006C(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FMercunaUsageSpec                      UsageSpec;                                         // 0x0070(0x0008)(ConstParm, Parm, NoDestructor, NativeAccessSpecifierPublic)
	class UMercunaPath*                           ReturnValue;                                       // 0x0078(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MercunaNavSurfaceGrid_FindPathToLocations) == 0x000008, "Wrong alignment on MercunaNavSurfaceGrid_FindPathToLocations");
static_assert(sizeof(MercunaNavSurfaceGrid_FindPathToLocations) == 0x000080, "Wrong size on MercunaNavSurfaceGrid_FindPathToLocations");
static_assert(offsetof(MercunaNavSurfaceGrid_FindPathToLocations, AgentType) == 0x000000, "Member 'MercunaNavSurfaceGrid_FindPathToLocations::AgentType' has a wrong offset!");
static_assert(offsetof(MercunaNavSurfaceGrid_FindPathToLocations, OnPathUpdated) == 0x00000C, "Member 'MercunaNavSurfaceGrid_FindPathToLocations::OnPathUpdated' has a wrong offset!");
static_assert(offsetof(MercunaNavSurfaceGrid_FindPathToLocations, Start) == 0x000020, "Member 'MercunaNavSurfaceGrid_FindPathToLocations::Start' has a wrong offset!");
static_assert(offsetof(MercunaNavSurfaceGrid_FindPathToLocations, StartUp) == 0x000038, "Member 'MercunaNavSurfaceGrid_FindPathToLocations::StartUp' has a wrong offset!");
static_assert(offsetof(MercunaNavSurfaceGrid_FindPathToLocations, Destinations) == 0x000050, "Member 'MercunaNavSurfaceGrid_FindPathToLocations::Destinations' has a wrong offset!");
static_assert(offsetof(MercunaNavSurfaceGrid_FindPathToLocations, IdealTurnRadius) == 0x000060, "Member 'MercunaNavSurfaceGrid_FindPathToLocations::IdealTurnRadius' has a wrong offset!");
static_assert(offsetof(MercunaNavSurfaceGrid_FindPathToLocations, MaxSpeed) == 0x000064, "Member 'MercunaNavSurfaceGrid_FindPathToLocations::MaxSpeed' has a wrong offset!");
static_assert(offsetof(MercunaNavSurfaceGrid_FindPathToLocations, AllowPartial) == 0x000068, "Member 'MercunaNavSurfaceGrid_FindPathToLocations::AllowPartial' has a wrong offset!");
static_assert(offsetof(MercunaNavSurfaceGrid_FindPathToLocations, MaxPathLength) == 0x00006C, "Member 'MercunaNavSurfaceGrid_FindPathToLocations::MaxPathLength' has a wrong offset!");
static_assert(offsetof(MercunaNavSurfaceGrid_FindPathToLocations, UsageSpec) == 0x000070, "Member 'MercunaNavSurfaceGrid_FindPathToLocations::UsageSpec' has a wrong offset!");
static_assert(offsetof(MercunaNavSurfaceGrid_FindPathToLocations, ReturnValue) == 0x000078, "Member 'MercunaNavSurfaceGrid_FindPathToLocations::ReturnValue' has a wrong offset!");

// Function Mercuna.MercunaNavSurfaceGrid.FindSmoothPathToLocation
// 0x0088 (0x0088 - 0x0000)
struct MercunaNavSurfaceGrid_FindSmoothPathToLocation final
{
public:
	struct FMercunaSurfaceAgentType               AgentType;                                         // 0x0000(0x000C)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TDelegate<void(EMercunaPathEvent PathEvent)>  OnPathUpdated;                                     // 0x000C(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C[0x4];                                       // 0x001C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                Start;                                             // 0x0020(0x0018)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                StartUp;                                           // 0x0038(0x0018)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                End;                                               // 0x0050(0x0018)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         IdealTurnRadius;                                   // 0x0068(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxSpeed;                                          // 0x006C(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          AllowPartial;                                      // 0x0070(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_71[0x3];                                       // 0x0071(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MaxPathLength;                                     // 0x0074(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FMercunaUsageSpec                      UsageSpec;                                         // 0x0078(0x0008)(ConstParm, Parm, NoDestructor, NativeAccessSpecifierPublic)
	class UMercunaSmoothPath*                     ReturnValue;                                       // 0x0080(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MercunaNavSurfaceGrid_FindSmoothPathToLocation) == 0x000008, "Wrong alignment on MercunaNavSurfaceGrid_FindSmoothPathToLocation");
static_assert(sizeof(MercunaNavSurfaceGrid_FindSmoothPathToLocation) == 0x000088, "Wrong size on MercunaNavSurfaceGrid_FindSmoothPathToLocation");
static_assert(offsetof(MercunaNavSurfaceGrid_FindSmoothPathToLocation, AgentType) == 0x000000, "Member 'MercunaNavSurfaceGrid_FindSmoothPathToLocation::AgentType' has a wrong offset!");
static_assert(offsetof(MercunaNavSurfaceGrid_FindSmoothPathToLocation, OnPathUpdated) == 0x00000C, "Member 'MercunaNavSurfaceGrid_FindSmoothPathToLocation::OnPathUpdated' has a wrong offset!");
static_assert(offsetof(MercunaNavSurfaceGrid_FindSmoothPathToLocation, Start) == 0x000020, "Member 'MercunaNavSurfaceGrid_FindSmoothPathToLocation::Start' has a wrong offset!");
static_assert(offsetof(MercunaNavSurfaceGrid_FindSmoothPathToLocation, StartUp) == 0x000038, "Member 'MercunaNavSurfaceGrid_FindSmoothPathToLocation::StartUp' has a wrong offset!");
static_assert(offsetof(MercunaNavSurfaceGrid_FindSmoothPathToLocation, End) == 0x000050, "Member 'MercunaNavSurfaceGrid_FindSmoothPathToLocation::End' has a wrong offset!");
static_assert(offsetof(MercunaNavSurfaceGrid_FindSmoothPathToLocation, IdealTurnRadius) == 0x000068, "Member 'MercunaNavSurfaceGrid_FindSmoothPathToLocation::IdealTurnRadius' has a wrong offset!");
static_assert(offsetof(MercunaNavSurfaceGrid_FindSmoothPathToLocation, MaxSpeed) == 0x00006C, "Member 'MercunaNavSurfaceGrid_FindSmoothPathToLocation::MaxSpeed' has a wrong offset!");
static_assert(offsetof(MercunaNavSurfaceGrid_FindSmoothPathToLocation, AllowPartial) == 0x000070, "Member 'MercunaNavSurfaceGrid_FindSmoothPathToLocation::AllowPartial' has a wrong offset!");
static_assert(offsetof(MercunaNavSurfaceGrid_FindSmoothPathToLocation, MaxPathLength) == 0x000074, "Member 'MercunaNavSurfaceGrid_FindSmoothPathToLocation::MaxPathLength' has a wrong offset!");
static_assert(offsetof(MercunaNavSurfaceGrid_FindSmoothPathToLocation, UsageSpec) == 0x000078, "Member 'MercunaNavSurfaceGrid_FindSmoothPathToLocation::UsageSpec' has a wrong offset!");
static_assert(offsetof(MercunaNavSurfaceGrid_FindSmoothPathToLocation, ReturnValue) == 0x000080, "Member 'MercunaNavSurfaceGrid_FindSmoothPathToLocation::ReturnValue' has a wrong offset!");

// Function Mercuna.MercunaNavSurfaceGrid.FindSmoothPathToLocations
// 0x0080 (0x0080 - 0x0000)
struct MercunaNavSurfaceGrid_FindSmoothPathToLocations final
{
public:
	struct FMercunaSurfaceAgentType               AgentType;                                         // 0x0000(0x000C)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TDelegate<void(EMercunaPathEvent PathEvent)>  OnPathUpdated;                                     // 0x000C(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C[0x4];                                       // 0x001C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                Start;                                             // 0x0020(0x0018)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                StartUp;                                           // 0x0038(0x0018)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FVector>                        Destinations;                                      // 0x0050(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	float                                         IdealTurnRadius;                                   // 0x0060(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxSpeed;                                          // 0x0064(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          AllowPartial;                                      // 0x0068(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_69[0x3];                                       // 0x0069(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MaxPathLength;                                     // 0x006C(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FMercunaUsageSpec                      UsageSpec;                                         // 0x0070(0x0008)(ConstParm, Parm, NoDestructor, NativeAccessSpecifierPublic)
	class UMercunaSmoothPath*                     ReturnValue;                                       // 0x0078(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MercunaNavSurfaceGrid_FindSmoothPathToLocations) == 0x000008, "Wrong alignment on MercunaNavSurfaceGrid_FindSmoothPathToLocations");
static_assert(sizeof(MercunaNavSurfaceGrid_FindSmoothPathToLocations) == 0x000080, "Wrong size on MercunaNavSurfaceGrid_FindSmoothPathToLocations");
static_assert(offsetof(MercunaNavSurfaceGrid_FindSmoothPathToLocations, AgentType) == 0x000000, "Member 'MercunaNavSurfaceGrid_FindSmoothPathToLocations::AgentType' has a wrong offset!");
static_assert(offsetof(MercunaNavSurfaceGrid_FindSmoothPathToLocations, OnPathUpdated) == 0x00000C, "Member 'MercunaNavSurfaceGrid_FindSmoothPathToLocations::OnPathUpdated' has a wrong offset!");
static_assert(offsetof(MercunaNavSurfaceGrid_FindSmoothPathToLocations, Start) == 0x000020, "Member 'MercunaNavSurfaceGrid_FindSmoothPathToLocations::Start' has a wrong offset!");
static_assert(offsetof(MercunaNavSurfaceGrid_FindSmoothPathToLocations, StartUp) == 0x000038, "Member 'MercunaNavSurfaceGrid_FindSmoothPathToLocations::StartUp' has a wrong offset!");
static_assert(offsetof(MercunaNavSurfaceGrid_FindSmoothPathToLocations, Destinations) == 0x000050, "Member 'MercunaNavSurfaceGrid_FindSmoothPathToLocations::Destinations' has a wrong offset!");
static_assert(offsetof(MercunaNavSurfaceGrid_FindSmoothPathToLocations, IdealTurnRadius) == 0x000060, "Member 'MercunaNavSurfaceGrid_FindSmoothPathToLocations::IdealTurnRadius' has a wrong offset!");
static_assert(offsetof(MercunaNavSurfaceGrid_FindSmoothPathToLocations, MaxSpeed) == 0x000064, "Member 'MercunaNavSurfaceGrid_FindSmoothPathToLocations::MaxSpeed' has a wrong offset!");
static_assert(offsetof(MercunaNavSurfaceGrid_FindSmoothPathToLocations, AllowPartial) == 0x000068, "Member 'MercunaNavSurfaceGrid_FindSmoothPathToLocations::AllowPartial' has a wrong offset!");
static_assert(offsetof(MercunaNavSurfaceGrid_FindSmoothPathToLocations, MaxPathLength) == 0x00006C, "Member 'MercunaNavSurfaceGrid_FindSmoothPathToLocations::MaxPathLength' has a wrong offset!");
static_assert(offsetof(MercunaNavSurfaceGrid_FindSmoothPathToLocations, UsageSpec) == 0x000070, "Member 'MercunaNavSurfaceGrid_FindSmoothPathToLocations::UsageSpec' has a wrong offset!");
static_assert(offsetof(MercunaNavSurfaceGrid_FindSmoothPathToLocations, ReturnValue) == 0x000078, "Member 'MercunaNavSurfaceGrid_FindSmoothPathToLocations::ReturnValue' has a wrong offset!");

// Function Mercuna.MercunaNavSurfaceGrid.RebuildVolume
// 0x0010 (0x0010 - 0x0000)
struct MercunaNavSurfaceGrid_RebuildVolume final
{
public:
	const class AActor*                           Volume;                                            // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bApplyNavSeeds;                                    // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(MercunaNavSurfaceGrid_RebuildVolume) == 0x000008, "Wrong alignment on MercunaNavSurfaceGrid_RebuildVolume");
static_assert(sizeof(MercunaNavSurfaceGrid_RebuildVolume) == 0x000010, "Wrong size on MercunaNavSurfaceGrid_RebuildVolume");
static_assert(offsetof(MercunaNavSurfaceGrid_RebuildVolume, Volume) == 0x000000, "Member 'MercunaNavSurfaceGrid_RebuildVolume::Volume' has a wrong offset!");
static_assert(offsetof(MercunaNavSurfaceGrid_RebuildVolume, bApplyNavSeeds) == 0x000008, "Member 'MercunaNavSurfaceGrid_RebuildVolume::bApplyNavSeeds' has a wrong offset!");

// Function Mercuna.MercunaNavSurfaceGrid.RebuildVolumes
// 0x0018 (0x0018 - 0x0000)
struct MercunaNavSurfaceGrid_RebuildVolumes final
{
public:
	TArray<struct FBox>                           Volumes;                                           // 0x0000(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	bool                                          bMergeVolumes;                                     // 0x0010(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bOnlyUnbuilt;                                      // 0x0011(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bApplyNavSeeds;                                    // 0x0012(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_13[0x5];                                       // 0x0013(0x0005)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(MercunaNavSurfaceGrid_RebuildVolumes) == 0x000008, "Wrong alignment on MercunaNavSurfaceGrid_RebuildVolumes");
static_assert(sizeof(MercunaNavSurfaceGrid_RebuildVolumes) == 0x000018, "Wrong size on MercunaNavSurfaceGrid_RebuildVolumes");
static_assert(offsetof(MercunaNavSurfaceGrid_RebuildVolumes, Volumes) == 0x000000, "Member 'MercunaNavSurfaceGrid_RebuildVolumes::Volumes' has a wrong offset!");
static_assert(offsetof(MercunaNavSurfaceGrid_RebuildVolumes, bMergeVolumes) == 0x000010, "Member 'MercunaNavSurfaceGrid_RebuildVolumes::bMergeVolumes' has a wrong offset!");
static_assert(offsetof(MercunaNavSurfaceGrid_RebuildVolumes, bOnlyUnbuilt) == 0x000011, "Member 'MercunaNavSurfaceGrid_RebuildVolumes::bOnlyUnbuilt' has a wrong offset!");
static_assert(offsetof(MercunaNavSurfaceGrid_RebuildVolumes, bApplyNavSeeds) == 0x000012, "Member 'MercunaNavSurfaceGrid_RebuildVolumes::bApplyNavSeeds' has a wrong offset!");

// Function Mercuna.MercunaNavSurfaceGrid.ClampToNavigable
// 0x0090 (0x0090 - 0x0000)
struct MercunaNavSurfaceGrid_ClampToNavigable final
{
public:
	struct FMercunaSurfaceAgentType               AgentType;                                         // 0x0000(0x000C)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                Position;                                          // 0x0010(0x0018)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Up;                                                // 0x0028(0x0018)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SearchRadius;                                      // 0x0040(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HeightRange;                                       // 0x0044(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bResult;                                           // 0x0048(0x0001)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_49[0x7];                                       // 0x0049(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                ClampedPosition;                                   // 0x0050(0x0018)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                ClampedUp;                                         // 0x0068(0x0018)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FMercunaUsageTypes                     ClampedUsageTypes;                                 // 0x0080(0x0004)(Parm, OutParm, NoDestructor, NativeAccessSpecifierPublic)
	struct FMercunaUsageSpec                      UsageSpec;                                         // 0x0084(0x0008)(ConstParm, Parm, NoDestructor, AdvancedDisplay, NativeAccessSpecifierPublic)
	uint8                                         Pad_8C[0x4];                                       // 0x008C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(MercunaNavSurfaceGrid_ClampToNavigable) == 0x000008, "Wrong alignment on MercunaNavSurfaceGrid_ClampToNavigable");
static_assert(sizeof(MercunaNavSurfaceGrid_ClampToNavigable) == 0x000090, "Wrong size on MercunaNavSurfaceGrid_ClampToNavigable");
static_assert(offsetof(MercunaNavSurfaceGrid_ClampToNavigable, AgentType) == 0x000000, "Member 'MercunaNavSurfaceGrid_ClampToNavigable::AgentType' has a wrong offset!");
static_assert(offsetof(MercunaNavSurfaceGrid_ClampToNavigable, Position) == 0x000010, "Member 'MercunaNavSurfaceGrid_ClampToNavigable::Position' has a wrong offset!");
static_assert(offsetof(MercunaNavSurfaceGrid_ClampToNavigable, Up) == 0x000028, "Member 'MercunaNavSurfaceGrid_ClampToNavigable::Up' has a wrong offset!");
static_assert(offsetof(MercunaNavSurfaceGrid_ClampToNavigable, SearchRadius) == 0x000040, "Member 'MercunaNavSurfaceGrid_ClampToNavigable::SearchRadius' has a wrong offset!");
static_assert(offsetof(MercunaNavSurfaceGrid_ClampToNavigable, HeightRange) == 0x000044, "Member 'MercunaNavSurfaceGrid_ClampToNavigable::HeightRange' has a wrong offset!");
static_assert(offsetof(MercunaNavSurfaceGrid_ClampToNavigable, bResult) == 0x000048, "Member 'MercunaNavSurfaceGrid_ClampToNavigable::bResult' has a wrong offset!");
static_assert(offsetof(MercunaNavSurfaceGrid_ClampToNavigable, ClampedPosition) == 0x000050, "Member 'MercunaNavSurfaceGrid_ClampToNavigable::ClampedPosition' has a wrong offset!");
static_assert(offsetof(MercunaNavSurfaceGrid_ClampToNavigable, ClampedUp) == 0x000068, "Member 'MercunaNavSurfaceGrid_ClampToNavigable::ClampedUp' has a wrong offset!");
static_assert(offsetof(MercunaNavSurfaceGrid_ClampToNavigable, ClampedUsageTypes) == 0x000080, "Member 'MercunaNavSurfaceGrid_ClampToNavigable::ClampedUsageTypes' has a wrong offset!");
static_assert(offsetof(MercunaNavSurfaceGrid_ClampToNavigable, UsageSpec) == 0x000084, "Member 'MercunaNavSurfaceGrid_ClampToNavigable::UsageSpec' has a wrong offset!");

// Function Mercuna.MercunaNavSurfaceGrid.GetNumBoxesBuilding
// 0x0004 (0x0004 - 0x0000)
struct MercunaNavSurfaceGrid_GetNumBoxesBuilding final
{
public:
	int32                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MercunaNavSurfaceGrid_GetNumBoxesBuilding) == 0x000004, "Wrong alignment on MercunaNavSurfaceGrid_GetNumBoxesBuilding");
static_assert(sizeof(MercunaNavSurfaceGrid_GetNumBoxesBuilding) == 0x000004, "Wrong size on MercunaNavSurfaceGrid_GetNumBoxesBuilding");
static_assert(offsetof(MercunaNavSurfaceGrid_GetNumBoxesBuilding, ReturnValue) == 0x000000, "Member 'MercunaNavSurfaceGrid_GetNumBoxesBuilding::ReturnValue' has a wrong offset!");

// Function Mercuna.MercunaNavSurfaceGrid.IsAnyWorkInProgress
// 0x0001 (0x0001 - 0x0000)
struct MercunaNavSurfaceGrid_IsAnyWorkInProgress final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MercunaNavSurfaceGrid_IsAnyWorkInProgress) == 0x000001, "Wrong alignment on MercunaNavSurfaceGrid_IsAnyWorkInProgress");
static_assert(sizeof(MercunaNavSurfaceGrid_IsAnyWorkInProgress) == 0x000001, "Wrong size on MercunaNavSurfaceGrid_IsAnyWorkInProgress");
static_assert(offsetof(MercunaNavSurfaceGrid_IsAnyWorkInProgress, ReturnValue) == 0x000000, "Member 'MercunaNavSurfaceGrid_IsAnyWorkInProgress::ReturnValue' has a wrong offset!");

// Function Mercuna.MercunaNavSurfaceGrid.IsBuilding
// 0x0001 (0x0001 - 0x0000)
struct MercunaNavSurfaceGrid_IsBuilding final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MercunaNavSurfaceGrid_IsBuilding) == 0x000001, "Wrong alignment on MercunaNavSurfaceGrid_IsBuilding");
static_assert(sizeof(MercunaNavSurfaceGrid_IsBuilding) == 0x000001, "Wrong size on MercunaNavSurfaceGrid_IsBuilding");
static_assert(offsetof(MercunaNavSurfaceGrid_IsBuilding, ReturnValue) == 0x000000, "Member 'MercunaNavSurfaceGrid_IsBuilding::ReturnValue' has a wrong offset!");

// Function Mercuna.MercunaNavSurfaceGrid.IsBuilt
// 0x0030 (0x0030 - 0x0000)
struct MercunaNavSurfaceGrid_IsBuilt final
{
public:
	struct FMercunaSurfaceAgentType               AgentType;                                         // 0x0000(0x000C)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                Pos;                                               // 0x0010(0x0018)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0028(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_29[0x7];                                       // 0x0029(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(MercunaNavSurfaceGrid_IsBuilt) == 0x000008, "Wrong alignment on MercunaNavSurfaceGrid_IsBuilt");
static_assert(sizeof(MercunaNavSurfaceGrid_IsBuilt) == 0x000030, "Wrong size on MercunaNavSurfaceGrid_IsBuilt");
static_assert(offsetof(MercunaNavSurfaceGrid_IsBuilt, AgentType) == 0x000000, "Member 'MercunaNavSurfaceGrid_IsBuilt::AgentType' has a wrong offset!");
static_assert(offsetof(MercunaNavSurfaceGrid_IsBuilt, Pos) == 0x000010, "Member 'MercunaNavSurfaceGrid_IsBuilt::Pos' has a wrong offset!");
static_assert(offsetof(MercunaNavSurfaceGrid_IsBuilt, ReturnValue) == 0x000028, "Member 'MercunaNavSurfaceGrid_IsBuilt::ReturnValue' has a wrong offset!");

// Function Mercuna.MercunaNavSurfaceGrid.IsBuiltWithinBox
// 0x0050 (0x0050 - 0x0000)
struct MercunaNavSurfaceGrid_IsBuiltWithinBox final
{
public:
	struct FMercunaSurfaceAgentType               AgentType;                                         // 0x0000(0x000C)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FBox                                   Box;                                               // 0x0010(0x0038)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0048(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_49[0x7];                                       // 0x0049(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(MercunaNavSurfaceGrid_IsBuiltWithinBox) == 0x000008, "Wrong alignment on MercunaNavSurfaceGrid_IsBuiltWithinBox");
static_assert(sizeof(MercunaNavSurfaceGrid_IsBuiltWithinBox) == 0x000050, "Wrong size on MercunaNavSurfaceGrid_IsBuiltWithinBox");
static_assert(offsetof(MercunaNavSurfaceGrid_IsBuiltWithinBox, AgentType) == 0x000000, "Member 'MercunaNavSurfaceGrid_IsBuiltWithinBox::AgentType' has a wrong offset!");
static_assert(offsetof(MercunaNavSurfaceGrid_IsBuiltWithinBox, Box) == 0x000010, "Member 'MercunaNavSurfaceGrid_IsBuiltWithinBox::Box' has a wrong offset!");
static_assert(offsetof(MercunaNavSurfaceGrid_IsBuiltWithinBox, ReturnValue) == 0x000048, "Member 'MercunaNavSurfaceGrid_IsBuiltWithinBox::ReturnValue' has a wrong offset!");

// Function Mercuna.MercunaNavSurfaceGrid.IsNavigable
// 0x0050 (0x0050 - 0x0000)
struct MercunaNavSurfaceGrid_IsNavigable final
{
public:
	struct FMercunaSurfaceAgentType               AgentType;                                         // 0x0000(0x000C)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                Position;                                          // 0x0010(0x0018)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Up;                                                // 0x0028(0x0018)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bResult;                                           // 0x0040(0x0001)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_41[0x3];                                       // 0x0041(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FMercunaUsageSpec                      UsageSpec;                                         // 0x0044(0x0008)(ConstParm, Parm, NoDestructor, AdvancedDisplay, NativeAccessSpecifierPublic)
	uint8                                         Pad_4C[0x4];                                       // 0x004C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(MercunaNavSurfaceGrid_IsNavigable) == 0x000008, "Wrong alignment on MercunaNavSurfaceGrid_IsNavigable");
static_assert(sizeof(MercunaNavSurfaceGrid_IsNavigable) == 0x000050, "Wrong size on MercunaNavSurfaceGrid_IsNavigable");
static_assert(offsetof(MercunaNavSurfaceGrid_IsNavigable, AgentType) == 0x000000, "Member 'MercunaNavSurfaceGrid_IsNavigable::AgentType' has a wrong offset!");
static_assert(offsetof(MercunaNavSurfaceGrid_IsNavigable, Position) == 0x000010, "Member 'MercunaNavSurfaceGrid_IsNavigable::Position' has a wrong offset!");
static_assert(offsetof(MercunaNavSurfaceGrid_IsNavigable, Up) == 0x000028, "Member 'MercunaNavSurfaceGrid_IsNavigable::Up' has a wrong offset!");
static_assert(offsetof(MercunaNavSurfaceGrid_IsNavigable, bResult) == 0x000040, "Member 'MercunaNavSurfaceGrid_IsNavigable::bResult' has a wrong offset!");
static_assert(offsetof(MercunaNavSurfaceGrid_IsNavigable, UsageSpec) == 0x000044, "Member 'MercunaNavSurfaceGrid_IsNavigable::UsageSpec' has a wrong offset!");

// Function Mercuna.MercunaNavSurfaceGrid.IsReachable
// 0x0070 (0x0070 - 0x0000)
struct MercunaNavSurfaceGrid_IsReachable final
{
public:
	struct FMercunaSurfaceAgentType               AgentType;                                         // 0x0000(0x000C)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                From;                                              // 0x0010(0x0018)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                FromUp;                                            // 0x0028(0x0018)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                To;                                                // 0x0040(0x0018)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxPathLength;                                     // 0x0058(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EMercunaNavLinkQueryMode                      FollowNavLinks;                                    // 0x005C(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5D[0x3];                                       // 0x005D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FMercunaUsageSpec                      UsageSpec;                                         // 0x0060(0x0008)(ConstParm, Parm, NoDestructor, AdvancedDisplay, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0068(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_69[0x7];                                       // 0x0069(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(MercunaNavSurfaceGrid_IsReachable) == 0x000008, "Wrong alignment on MercunaNavSurfaceGrid_IsReachable");
static_assert(sizeof(MercunaNavSurfaceGrid_IsReachable) == 0x000070, "Wrong size on MercunaNavSurfaceGrid_IsReachable");
static_assert(offsetof(MercunaNavSurfaceGrid_IsReachable, AgentType) == 0x000000, "Member 'MercunaNavSurfaceGrid_IsReachable::AgentType' has a wrong offset!");
static_assert(offsetof(MercunaNavSurfaceGrid_IsReachable, From) == 0x000010, "Member 'MercunaNavSurfaceGrid_IsReachable::From' has a wrong offset!");
static_assert(offsetof(MercunaNavSurfaceGrid_IsReachable, FromUp) == 0x000028, "Member 'MercunaNavSurfaceGrid_IsReachable::FromUp' has a wrong offset!");
static_assert(offsetof(MercunaNavSurfaceGrid_IsReachable, To) == 0x000040, "Member 'MercunaNavSurfaceGrid_IsReachable::To' has a wrong offset!");
static_assert(offsetof(MercunaNavSurfaceGrid_IsReachable, MaxPathLength) == 0x000058, "Member 'MercunaNavSurfaceGrid_IsReachable::MaxPathLength' has a wrong offset!");
static_assert(offsetof(MercunaNavSurfaceGrid_IsReachable, FollowNavLinks) == 0x00005C, "Member 'MercunaNavSurfaceGrid_IsReachable::FollowNavLinks' has a wrong offset!");
static_assert(offsetof(MercunaNavSurfaceGrid_IsReachable, UsageSpec) == 0x000060, "Member 'MercunaNavSurfaceGrid_IsReachable::UsageSpec' has a wrong offset!");
static_assert(offsetof(MercunaNavSurfaceGrid_IsReachable, ReturnValue) == 0x000068, "Member 'MercunaNavSurfaceGrid_IsReachable::ReturnValue' has a wrong offset!");

// Function Mercuna.MercunaNavSurfaceGrid.IsReachableLatent
// 0x00A8 (0x00A8 - 0x0000)
struct MercunaNavSurfaceGrid_IsReachableLatent final
{
public:
	struct FMercunaSurfaceAgentType               AgentType;                                         // 0x0000(0x000C)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                From;                                              // 0x0010(0x0018)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                FromUp;                                            // 0x0028(0x0018)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FVector>                        To;                                                // 0x0040(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	TArray<bool>                                  Result;                                            // 0x0050(0x0010)(Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FVector>                        ClampedTo;                                         // 0x0060(0x0010)(Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
	class UObject*                                WorldContextObject;                                // 0x0070(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLatentActionInfo                      LatentInfo;                                        // 0x0078(0x0018)(Parm, NoDestructor, NativeAccessSpecifierPublic)
	float                                         MaxPathLength;                                     // 0x0090(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FromSearchRadius;                                  // 0x0094(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ToSearchRadius;                                    // 0x0098(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EMercunaNavLinkQueryMode                      FollowNavLinks;                                    // 0x009C(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9D[0x3];                                       // 0x009D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FMercunaUsageSpec                      UsageSpec;                                         // 0x00A0(0x0008)(ConstParm, Parm, NoDestructor, AdvancedDisplay, NativeAccessSpecifierPublic)
};
static_assert(alignof(MercunaNavSurfaceGrid_IsReachableLatent) == 0x000008, "Wrong alignment on MercunaNavSurfaceGrid_IsReachableLatent");
static_assert(sizeof(MercunaNavSurfaceGrid_IsReachableLatent) == 0x0000A8, "Wrong size on MercunaNavSurfaceGrid_IsReachableLatent");
static_assert(offsetof(MercunaNavSurfaceGrid_IsReachableLatent, AgentType) == 0x000000, "Member 'MercunaNavSurfaceGrid_IsReachableLatent::AgentType' has a wrong offset!");
static_assert(offsetof(MercunaNavSurfaceGrid_IsReachableLatent, From) == 0x000010, "Member 'MercunaNavSurfaceGrid_IsReachableLatent::From' has a wrong offset!");
static_assert(offsetof(MercunaNavSurfaceGrid_IsReachableLatent, FromUp) == 0x000028, "Member 'MercunaNavSurfaceGrid_IsReachableLatent::FromUp' has a wrong offset!");
static_assert(offsetof(MercunaNavSurfaceGrid_IsReachableLatent, To) == 0x000040, "Member 'MercunaNavSurfaceGrid_IsReachableLatent::To' has a wrong offset!");
static_assert(offsetof(MercunaNavSurfaceGrid_IsReachableLatent, Result) == 0x000050, "Member 'MercunaNavSurfaceGrid_IsReachableLatent::Result' has a wrong offset!");
static_assert(offsetof(MercunaNavSurfaceGrid_IsReachableLatent, ClampedTo) == 0x000060, "Member 'MercunaNavSurfaceGrid_IsReachableLatent::ClampedTo' has a wrong offset!");
static_assert(offsetof(MercunaNavSurfaceGrid_IsReachableLatent, WorldContextObject) == 0x000070, "Member 'MercunaNavSurfaceGrid_IsReachableLatent::WorldContextObject' has a wrong offset!");
static_assert(offsetof(MercunaNavSurfaceGrid_IsReachableLatent, LatentInfo) == 0x000078, "Member 'MercunaNavSurfaceGrid_IsReachableLatent::LatentInfo' has a wrong offset!");
static_assert(offsetof(MercunaNavSurfaceGrid_IsReachableLatent, MaxPathLength) == 0x000090, "Member 'MercunaNavSurfaceGrid_IsReachableLatent::MaxPathLength' has a wrong offset!");
static_assert(offsetof(MercunaNavSurfaceGrid_IsReachableLatent, FromSearchRadius) == 0x000094, "Member 'MercunaNavSurfaceGrid_IsReachableLatent::FromSearchRadius' has a wrong offset!");
static_assert(offsetof(MercunaNavSurfaceGrid_IsReachableLatent, ToSearchRadius) == 0x000098, "Member 'MercunaNavSurfaceGrid_IsReachableLatent::ToSearchRadius' has a wrong offset!");
static_assert(offsetof(MercunaNavSurfaceGrid_IsReachableLatent, FollowNavLinks) == 0x00009C, "Member 'MercunaNavSurfaceGrid_IsReachableLatent::FollowNavLinks' has a wrong offset!");
static_assert(offsetof(MercunaNavSurfaceGrid_IsReachableLatent, UsageSpec) == 0x0000A0, "Member 'MercunaNavSurfaceGrid_IsReachableLatent::UsageSpec' has a wrong offset!");

// Function Mercuna.MercunaNavSurfaceGrid.ProjectToNavigable
// 0x0070 (0x0070 - 0x0000)
struct MercunaNavSurfaceGrid_ProjectToNavigable final
{
public:
	struct FMercunaSurfaceAgentType               AgentType;                                         // 0x0000(0x000C)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                Position;                                          // 0x0010(0x0018)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Up;                                                // 0x0028(0x0018)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EMercunaProjectionDirection                   Direction;                                         // 0x0040(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bResult;                                           // 0x0041(0x0001)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_42[0x6];                                       // 0x0042(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                ProjectedPosition;                                 // 0x0048(0x0018)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SearchDistance;                                    // 0x0060(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FMercunaUsageSpec                      UsageSpec;                                         // 0x0064(0x0008)(ConstParm, Parm, NoDestructor, AdvancedDisplay, NativeAccessSpecifierPublic)
	uint8                                         Pad_6C[0x4];                                       // 0x006C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(MercunaNavSurfaceGrid_ProjectToNavigable) == 0x000008, "Wrong alignment on MercunaNavSurfaceGrid_ProjectToNavigable");
static_assert(sizeof(MercunaNavSurfaceGrid_ProjectToNavigable) == 0x000070, "Wrong size on MercunaNavSurfaceGrid_ProjectToNavigable");
static_assert(offsetof(MercunaNavSurfaceGrid_ProjectToNavigable, AgentType) == 0x000000, "Member 'MercunaNavSurfaceGrid_ProjectToNavigable::AgentType' has a wrong offset!");
static_assert(offsetof(MercunaNavSurfaceGrid_ProjectToNavigable, Position) == 0x000010, "Member 'MercunaNavSurfaceGrid_ProjectToNavigable::Position' has a wrong offset!");
static_assert(offsetof(MercunaNavSurfaceGrid_ProjectToNavigable, Up) == 0x000028, "Member 'MercunaNavSurfaceGrid_ProjectToNavigable::Up' has a wrong offset!");
static_assert(offsetof(MercunaNavSurfaceGrid_ProjectToNavigable, Direction) == 0x000040, "Member 'MercunaNavSurfaceGrid_ProjectToNavigable::Direction' has a wrong offset!");
static_assert(offsetof(MercunaNavSurfaceGrid_ProjectToNavigable, bResult) == 0x000041, "Member 'MercunaNavSurfaceGrid_ProjectToNavigable::bResult' has a wrong offset!");
static_assert(offsetof(MercunaNavSurfaceGrid_ProjectToNavigable, ProjectedPosition) == 0x000048, "Member 'MercunaNavSurfaceGrid_ProjectToNavigable::ProjectedPosition' has a wrong offset!");
static_assert(offsetof(MercunaNavSurfaceGrid_ProjectToNavigable, SearchDistance) == 0x000060, "Member 'MercunaNavSurfaceGrid_ProjectToNavigable::SearchDistance' has a wrong offset!");
static_assert(offsetof(MercunaNavSurfaceGrid_ProjectToNavigable, UsageSpec) == 0x000064, "Member 'MercunaNavSurfaceGrid_ProjectToNavigable::UsageSpec' has a wrong offset!");

// Function Mercuna.MercunaNavSurfaceGrid.Raycast
// 0x0080 (0x0080 - 0x0000)
struct MercunaNavSurfaceGrid_Raycast final
{
public:
	struct FMercunaSurfaceAgentType               AgentType;                                         // 0x0000(0x000C)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                From;                                              // 0x0010(0x0018)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                FromUp;                                            // 0x0028(0x0018)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                To;                                                // 0x0040(0x0018)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bRayHit;                                           // 0x0058(0x0001)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_59[0x7];                                       // 0x0059(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                HitPosition;                                       // 0x0060(0x0018)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FMercunaUsageSpec                      UsageSpec;                                         // 0x0078(0x0008)(ConstParm, Parm, NoDestructor, AdvancedDisplay, NativeAccessSpecifierPublic)
};
static_assert(alignof(MercunaNavSurfaceGrid_Raycast) == 0x000008, "Wrong alignment on MercunaNavSurfaceGrid_Raycast");
static_assert(sizeof(MercunaNavSurfaceGrid_Raycast) == 0x000080, "Wrong size on MercunaNavSurfaceGrid_Raycast");
static_assert(offsetof(MercunaNavSurfaceGrid_Raycast, AgentType) == 0x000000, "Member 'MercunaNavSurfaceGrid_Raycast::AgentType' has a wrong offset!");
static_assert(offsetof(MercunaNavSurfaceGrid_Raycast, From) == 0x000010, "Member 'MercunaNavSurfaceGrid_Raycast::From' has a wrong offset!");
static_assert(offsetof(MercunaNavSurfaceGrid_Raycast, FromUp) == 0x000028, "Member 'MercunaNavSurfaceGrid_Raycast::FromUp' has a wrong offset!");
static_assert(offsetof(MercunaNavSurfaceGrid_Raycast, To) == 0x000040, "Member 'MercunaNavSurfaceGrid_Raycast::To' has a wrong offset!");
static_assert(offsetof(MercunaNavSurfaceGrid_Raycast, bRayHit) == 0x000058, "Member 'MercunaNavSurfaceGrid_Raycast::bRayHit' has a wrong offset!");
static_assert(offsetof(MercunaNavSurfaceGrid_Raycast, HitPosition) == 0x000060, "Member 'MercunaNavSurfaceGrid_Raycast::HitPosition' has a wrong offset!");
static_assert(offsetof(MercunaNavSurfaceGrid_Raycast, UsageSpec) == 0x000078, "Member 'MercunaNavSurfaceGrid_Raycast::UsageSpec' has a wrong offset!");

// Function Mercuna.MercunaNavSurfaceGrid.SaveToObjFile
// 0x0010 (0x0010 - 0x0000)
struct MercunaNavSurfaceGrid_SaveToObjFile final
{
public:
	struct FMercunaSurfaceAgentType               AgentType;                                         // 0x0000(0x000C)(Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDrawPolyMesh;                                     // 0x000C(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D[0x3];                                        // 0x000D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(MercunaNavSurfaceGrid_SaveToObjFile) == 0x000004, "Wrong alignment on MercunaNavSurfaceGrid_SaveToObjFile");
static_assert(sizeof(MercunaNavSurfaceGrid_SaveToObjFile) == 0x000010, "Wrong size on MercunaNavSurfaceGrid_SaveToObjFile");
static_assert(offsetof(MercunaNavSurfaceGrid_SaveToObjFile, AgentType) == 0x000000, "Member 'MercunaNavSurfaceGrid_SaveToObjFile::AgentType' has a wrong offset!");
static_assert(offsetof(MercunaNavSurfaceGrid_SaveToObjFile, bDrawPolyMesh) == 0x00000C, "Member 'MercunaNavSurfaceGrid_SaveToObjFile::bDrawPolyMesh' has a wrong offset!");

// Function Mercuna.MercunaOctreeClampToNavigableProxy.ClampToNavigable
// 0x0030 (0x0030 - 0x0000)
struct MercunaOctreeClampToNavigableProxy_ClampToNavigable final
{
public:
	class UObject*                                WorldContextObject_0;                              // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Position;                                          // 0x0008(0x0018)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         NavigationRadius;                                  // 0x0020(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SearchRadius;                                      // 0x0024(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMercunaOctreeClampToNavigableProxy*    ReturnValue;                                       // 0x0028(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MercunaOctreeClampToNavigableProxy_ClampToNavigable) == 0x000008, "Wrong alignment on MercunaOctreeClampToNavigableProxy_ClampToNavigable");
static_assert(sizeof(MercunaOctreeClampToNavigableProxy_ClampToNavigable) == 0x000030, "Wrong size on MercunaOctreeClampToNavigableProxy_ClampToNavigable");
static_assert(offsetof(MercunaOctreeClampToNavigableProxy_ClampToNavigable, WorldContextObject_0) == 0x000000, "Member 'MercunaOctreeClampToNavigableProxy_ClampToNavigable::WorldContextObject_0' has a wrong offset!");
static_assert(offsetof(MercunaOctreeClampToNavigableProxy_ClampToNavigable, Position) == 0x000008, "Member 'MercunaOctreeClampToNavigableProxy_ClampToNavigable::Position' has a wrong offset!");
static_assert(offsetof(MercunaOctreeClampToNavigableProxy_ClampToNavigable, NavigationRadius) == 0x000020, "Member 'MercunaOctreeClampToNavigableProxy_ClampToNavigable::NavigationRadius' has a wrong offset!");
static_assert(offsetof(MercunaOctreeClampToNavigableProxy_ClampToNavigable, SearchRadius) == 0x000024, "Member 'MercunaOctreeClampToNavigableProxy_ClampToNavigable::SearchRadius' has a wrong offset!");
static_assert(offsetof(MercunaOctreeClampToNavigableProxy_ClampToNavigable, ReturnValue) == 0x000028, "Member 'MercunaOctreeClampToNavigableProxy_ClampToNavigable::ReturnValue' has a wrong offset!");

// Function Mercuna.MercunaOctreeRaycastProxy.NavigationRaycast
// 0x0048 (0x0048 - 0x0000)
struct MercunaOctreeRaycastProxy_NavigationRaycast final
{
public:
	class UObject*                                WorldContextObject_0;                              // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Start;                                             // 0x0008(0x0018)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                End;                                               // 0x0020(0x0018)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         NavigationRadius;                                  // 0x0038(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3C[0x4];                                       // 0x003C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UMercunaOctreeRaycastProxy*             ReturnValue;                                       // 0x0040(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MercunaOctreeRaycastProxy_NavigationRaycast) == 0x000008, "Wrong alignment on MercunaOctreeRaycastProxy_NavigationRaycast");
static_assert(sizeof(MercunaOctreeRaycastProxy_NavigationRaycast) == 0x000048, "Wrong size on MercunaOctreeRaycastProxy_NavigationRaycast");
static_assert(offsetof(MercunaOctreeRaycastProxy_NavigationRaycast, WorldContextObject_0) == 0x000000, "Member 'MercunaOctreeRaycastProxy_NavigationRaycast::WorldContextObject_0' has a wrong offset!");
static_assert(offsetof(MercunaOctreeRaycastProxy_NavigationRaycast, Start) == 0x000008, "Member 'MercunaOctreeRaycastProxy_NavigationRaycast::Start' has a wrong offset!");
static_assert(offsetof(MercunaOctreeRaycastProxy_NavigationRaycast, End) == 0x000020, "Member 'MercunaOctreeRaycastProxy_NavigationRaycast::End' has a wrong offset!");
static_assert(offsetof(MercunaOctreeRaycastProxy_NavigationRaycast, NavigationRadius) == 0x000038, "Member 'MercunaOctreeRaycastProxy_NavigationRaycast::NavigationRadius' has a wrong offset!");
static_assert(offsetof(MercunaOctreeRaycastProxy_NavigationRaycast, ReturnValue) == 0x000040, "Member 'MercunaOctreeRaycastProxy_NavigationRaycast::ReturnValue' has a wrong offset!");

// Function Mercuna.MercunaPath.GetDebugInfo
// 0x000C (0x000C - 0x0000)
struct MercunaPath_GetDebugInfo final
{
public:
	int32                                         nodesUsed;                                         // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bOutOfNodes;                                       // 0x0004(0x0001)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5[0x3];                                        // 0x0005(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         queryTime;                                         // 0x0008(0x0004)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MercunaPath_GetDebugInfo) == 0x000004, "Wrong alignment on MercunaPath_GetDebugInfo");
static_assert(sizeof(MercunaPath_GetDebugInfo) == 0x00000C, "Wrong size on MercunaPath_GetDebugInfo");
static_assert(offsetof(MercunaPath_GetDebugInfo, nodesUsed) == 0x000000, "Member 'MercunaPath_GetDebugInfo::nodesUsed' has a wrong offset!");
static_assert(offsetof(MercunaPath_GetDebugInfo, bOutOfNodes) == 0x000004, "Member 'MercunaPath_GetDebugInfo::bOutOfNodes' has a wrong offset!");
static_assert(offsetof(MercunaPath_GetDebugInfo, queryTime) == 0x000008, "Member 'MercunaPath_GetDebugInfo::queryTime' has a wrong offset!");

// Function Mercuna.MercunaPath.GetNumPoints
// 0x0004 (0x0004 - 0x0000)
struct MercunaPath_GetNumPoints final
{
public:
	int32                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MercunaPath_GetNumPoints) == 0x000004, "Wrong alignment on MercunaPath_GetNumPoints");
static_assert(sizeof(MercunaPath_GetNumPoints) == 0x000004, "Wrong size on MercunaPath_GetNumPoints");
static_assert(offsetof(MercunaPath_GetNumPoints, ReturnValue) == 0x000000, "Member 'MercunaPath_GetNumPoints::ReturnValue' has a wrong offset!");

// Function Mercuna.MercunaPath.GetPathLength
// 0x0004 (0x0004 - 0x0000)
struct MercunaPath_GetPathLength final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MercunaPath_GetPathLength) == 0x000004, "Wrong alignment on MercunaPath_GetPathLength");
static_assert(sizeof(MercunaPath_GetPathLength) == 0x000004, "Wrong size on MercunaPath_GetPathLength");
static_assert(offsetof(MercunaPath_GetPathLength, ReturnValue) == 0x000000, "Member 'MercunaPath_GetPathLength::ReturnValue' has a wrong offset!");

// Function Mercuna.MercunaPath.GetPoint
// 0x0020 (0x0020 - 0x0000)
struct MercunaPath_GetPoint final
{
public:
	int32                                         I;                                                 // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                ReturnValue;                                       // 0x0008(0x0018)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MercunaPath_GetPoint) == 0x000008, "Wrong alignment on MercunaPath_GetPoint");
static_assert(sizeof(MercunaPath_GetPoint) == 0x000020, "Wrong size on MercunaPath_GetPoint");
static_assert(offsetof(MercunaPath_GetPoint, I) == 0x000000, "Member 'MercunaPath_GetPoint::I' has a wrong offset!");
static_assert(offsetof(MercunaPath_GetPoint, ReturnValue) == 0x000008, "Member 'MercunaPath_GetPoint::ReturnValue' has a wrong offset!");

// Function Mercuna.MercunaPath.GetStatus
// 0x0010 (0x0010 - 0x0000)
struct MercunaPath_GetStatus final
{
public:
	class FString                                 ReturnValue;                                       // 0x0000(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MercunaPath_GetStatus) == 0x000008, "Wrong alignment on MercunaPath_GetStatus");
static_assert(sizeof(MercunaPath_GetStatus) == 0x000010, "Wrong size on MercunaPath_GetStatus");
static_assert(offsetof(MercunaPath_GetStatus, ReturnValue) == 0x000000, "Member 'MercunaPath_GetStatus::ReturnValue' has a wrong offset!");

// Function Mercuna.MercunaPath.IsPartial
// 0x0001 (0x0001 - 0x0000)
struct MercunaPath_IsPartial final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MercunaPath_IsPartial) == 0x000001, "Wrong alignment on MercunaPath_IsPartial");
static_assert(sizeof(MercunaPath_IsPartial) == 0x000001, "Wrong size on MercunaPath_IsPartial");
static_assert(offsetof(MercunaPath_IsPartial, ReturnValue) == 0x000000, "Member 'MercunaPath_IsPartial::ReturnValue' has a wrong offset!");

// Function Mercuna.MercunaPath.IsReady
// 0x0001 (0x0001 - 0x0000)
struct MercunaPath_IsReady final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MercunaPath_IsReady) == 0x000001, "Wrong alignment on MercunaPath_IsReady");
static_assert(sizeof(MercunaPath_IsReady) == 0x000001, "Wrong size on MercunaPath_IsReady");
static_assert(offsetof(MercunaPath_IsReady, ReturnValue) == 0x000000, "Member 'MercunaPath_IsReady::ReturnValue' has a wrong offset!");

// Function Mercuna.MercunaPath.IsValid
// 0x0001 (0x0001 - 0x0000)
struct MercunaPath_IsValid final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MercunaPath_IsValid) == 0x000001, "Wrong alignment on MercunaPath_IsValid");
static_assert(sizeof(MercunaPath_IsValid) == 0x000001, "Wrong size on MercunaPath_IsValid");
static_assert(offsetof(MercunaPath_IsValid, ReturnValue) == 0x000000, "Member 'MercunaPath_IsValid::ReturnValue' has a wrong offset!");

// Function Mercuna.MercunaSmoothPath.GetPosition
// 0x0020 (0x0020 - 0x0000)
struct MercunaSmoothPath_GetPosition final
{
public:
	float                                         Length;                                            // 0x0000(0x0004)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                ReturnValue;                                       // 0x0008(0x0018)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MercunaSmoothPath_GetPosition) == 0x000008, "Wrong alignment on MercunaSmoothPath_GetPosition");
static_assert(sizeof(MercunaSmoothPath_GetPosition) == 0x000020, "Wrong size on MercunaSmoothPath_GetPosition");
static_assert(offsetof(MercunaSmoothPath_GetPosition, Length) == 0x000000, "Member 'MercunaSmoothPath_GetPosition::Length' has a wrong offset!");
static_assert(offsetof(MercunaSmoothPath_GetPosition, ReturnValue) == 0x000008, "Member 'MercunaSmoothPath_GetPosition::ReturnValue' has a wrong offset!");

// Function Mercuna.MercunaSmoothPath.GetSplinePoints
// 0x0070 (0x0070 - 0x0000)
struct MercunaSmoothPath_GetSplinePoints final
{
public:
	struct FTransform                             RelativeTo;                                        // 0x0000(0x0060)(ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FSplinePoint>                   ReturnValue;                                       // 0x0060(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(MercunaSmoothPath_GetSplinePoints) == 0x000010, "Wrong alignment on MercunaSmoothPath_GetSplinePoints");
static_assert(sizeof(MercunaSmoothPath_GetSplinePoints) == 0x000070, "Wrong size on MercunaSmoothPath_GetSplinePoints");
static_assert(offsetof(MercunaSmoothPath_GetSplinePoints, RelativeTo) == 0x000000, "Member 'MercunaSmoothPath_GetSplinePoints::RelativeTo' has a wrong offset!");
static_assert(offsetof(MercunaSmoothPath_GetSplinePoints, ReturnValue) == 0x000060, "Member 'MercunaSmoothPath_GetSplinePoints::ReturnValue' has a wrong offset!");

// Function Mercuna.MercunaSmoothPath.GetTangent
// 0x0020 (0x0020 - 0x0000)
struct MercunaSmoothPath_GetTangent final
{
public:
	float                                         Length;                                            // 0x0000(0x0004)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                ReturnValue;                                       // 0x0008(0x0018)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MercunaSmoothPath_GetTangent) == 0x000008, "Wrong alignment on MercunaSmoothPath_GetTangent");
static_assert(sizeof(MercunaSmoothPath_GetTangent) == 0x000020, "Wrong size on MercunaSmoothPath_GetTangent");
static_assert(offsetof(MercunaSmoothPath_GetTangent, Length) == 0x000000, "Member 'MercunaSmoothPath_GetTangent::Length' has a wrong offset!");
static_assert(offsetof(MercunaSmoothPath_GetTangent, ReturnValue) == 0x000008, "Member 'MercunaSmoothPath_GetTangent::ReturnValue' has a wrong offset!");

// Function Mercuna.MercunaSurfaceMoveToProxy.MoveToActor
// 0x0030 (0x0030 - 0x0000)
struct MercunaSurfaceMoveToProxy_MoveToActor final
{
public:
	class UObject*                                WorldContextObject;                                // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class APawn*                                  Pawn_0;                                            // 0x0008(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 Actor;                                             // 0x0010(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         EndDistance;                                       // 0x0018(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Speed;                                             // 0x001C(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          UsePartialPath;                                    // 0x0020(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          UseEndActorOrientation;                            // 0x0021(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_22[0x6];                                       // 0x0022(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	class UMercunaSurfaceMoveToProxy*             ReturnValue;                                       // 0x0028(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MercunaSurfaceMoveToProxy_MoveToActor) == 0x000008, "Wrong alignment on MercunaSurfaceMoveToProxy_MoveToActor");
static_assert(sizeof(MercunaSurfaceMoveToProxy_MoveToActor) == 0x000030, "Wrong size on MercunaSurfaceMoveToProxy_MoveToActor");
static_assert(offsetof(MercunaSurfaceMoveToProxy_MoveToActor, WorldContextObject) == 0x000000, "Member 'MercunaSurfaceMoveToProxy_MoveToActor::WorldContextObject' has a wrong offset!");
static_assert(offsetof(MercunaSurfaceMoveToProxy_MoveToActor, Pawn_0) == 0x000008, "Member 'MercunaSurfaceMoveToProxy_MoveToActor::Pawn_0' has a wrong offset!");
static_assert(offsetof(MercunaSurfaceMoveToProxy_MoveToActor, Actor) == 0x000010, "Member 'MercunaSurfaceMoveToProxy_MoveToActor::Actor' has a wrong offset!");
static_assert(offsetof(MercunaSurfaceMoveToProxy_MoveToActor, EndDistance) == 0x000018, "Member 'MercunaSurfaceMoveToProxy_MoveToActor::EndDistance' has a wrong offset!");
static_assert(offsetof(MercunaSurfaceMoveToProxy_MoveToActor, Speed) == 0x00001C, "Member 'MercunaSurfaceMoveToProxy_MoveToActor::Speed' has a wrong offset!");
static_assert(offsetof(MercunaSurfaceMoveToProxy_MoveToActor, UsePartialPath) == 0x000020, "Member 'MercunaSurfaceMoveToProxy_MoveToActor::UsePartialPath' has a wrong offset!");
static_assert(offsetof(MercunaSurfaceMoveToProxy_MoveToActor, UseEndActorOrientation) == 0x000021, "Member 'MercunaSurfaceMoveToProxy_MoveToActor::UseEndActorOrientation' has a wrong offset!");
static_assert(offsetof(MercunaSurfaceMoveToProxy_MoveToActor, ReturnValue) == 0x000028, "Member 'MercunaSurfaceMoveToProxy_MoveToActor::ReturnValue' has a wrong offset!");

// Function Mercuna.MercunaSurfaceMoveToProxy.MoveToLocation
// 0x0058 (0x0058 - 0x0000)
struct MercunaSurfaceMoveToProxy_MoveToLocation final
{
public:
	class UObject*                                WorldContextObject;                                // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class APawn*                                  Pawn_0;                                            // 0x0008(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Destination;                                       // 0x0010(0x0018)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         EndDistance;                                       // 0x0028(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Speed;                                             // 0x002C(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          UsePartialPath;                                    // 0x0030(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_31[0x7];                                       // 0x0031(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                EndDirection;                                      // 0x0038(0x0018)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMercunaSurfaceMoveToProxy*             ReturnValue;                                       // 0x0050(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MercunaSurfaceMoveToProxy_MoveToLocation) == 0x000008, "Wrong alignment on MercunaSurfaceMoveToProxy_MoveToLocation");
static_assert(sizeof(MercunaSurfaceMoveToProxy_MoveToLocation) == 0x000058, "Wrong size on MercunaSurfaceMoveToProxy_MoveToLocation");
static_assert(offsetof(MercunaSurfaceMoveToProxy_MoveToLocation, WorldContextObject) == 0x000000, "Member 'MercunaSurfaceMoveToProxy_MoveToLocation::WorldContextObject' has a wrong offset!");
static_assert(offsetof(MercunaSurfaceMoveToProxy_MoveToLocation, Pawn_0) == 0x000008, "Member 'MercunaSurfaceMoveToProxy_MoveToLocation::Pawn_0' has a wrong offset!");
static_assert(offsetof(MercunaSurfaceMoveToProxy_MoveToLocation, Destination) == 0x000010, "Member 'MercunaSurfaceMoveToProxy_MoveToLocation::Destination' has a wrong offset!");
static_assert(offsetof(MercunaSurfaceMoveToProxy_MoveToLocation, EndDistance) == 0x000028, "Member 'MercunaSurfaceMoveToProxy_MoveToLocation::EndDistance' has a wrong offset!");
static_assert(offsetof(MercunaSurfaceMoveToProxy_MoveToLocation, Speed) == 0x00002C, "Member 'MercunaSurfaceMoveToProxy_MoveToLocation::Speed' has a wrong offset!");
static_assert(offsetof(MercunaSurfaceMoveToProxy_MoveToLocation, UsePartialPath) == 0x000030, "Member 'MercunaSurfaceMoveToProxy_MoveToLocation::UsePartialPath' has a wrong offset!");
static_assert(offsetof(MercunaSurfaceMoveToProxy_MoveToLocation, EndDirection) == 0x000038, "Member 'MercunaSurfaceMoveToProxy_MoveToLocation::EndDirection' has a wrong offset!");
static_assert(offsetof(MercunaSurfaceMoveToProxy_MoveToLocation, ReturnValue) == 0x000050, "Member 'MercunaSurfaceMoveToProxy_MoveToLocation::ReturnValue' has a wrong offset!");

// Function Mercuna.MercunaSurfaceMoveToProxy.MoveToLocations
// 0x0050 (0x0050 - 0x0000)
struct MercunaSurfaceMoveToProxy_MoveToLocations final
{
public:
	class UObject*                                WorldContextObject;                                // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class APawn*                                  Pawn_0;                                            // 0x0008(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FVector>                        Destinations;                                      // 0x0010(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	float                                         EndDistance;                                       // 0x0020(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Speed;                                             // 0x0024(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          UsePartialPath;                                    // 0x0028(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_29[0x7];                                       // 0x0029(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                EndDirection;                                      // 0x0030(0x0018)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMercunaSurfaceMoveToProxy*             ReturnValue;                                       // 0x0048(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MercunaSurfaceMoveToProxy_MoveToLocations) == 0x000008, "Wrong alignment on MercunaSurfaceMoveToProxy_MoveToLocations");
static_assert(sizeof(MercunaSurfaceMoveToProxy_MoveToLocations) == 0x000050, "Wrong size on MercunaSurfaceMoveToProxy_MoveToLocations");
static_assert(offsetof(MercunaSurfaceMoveToProxy_MoveToLocations, WorldContextObject) == 0x000000, "Member 'MercunaSurfaceMoveToProxy_MoveToLocations::WorldContextObject' has a wrong offset!");
static_assert(offsetof(MercunaSurfaceMoveToProxy_MoveToLocations, Pawn_0) == 0x000008, "Member 'MercunaSurfaceMoveToProxy_MoveToLocations::Pawn_0' has a wrong offset!");
static_assert(offsetof(MercunaSurfaceMoveToProxy_MoveToLocations, Destinations) == 0x000010, "Member 'MercunaSurfaceMoveToProxy_MoveToLocations::Destinations' has a wrong offset!");
static_assert(offsetof(MercunaSurfaceMoveToProxy_MoveToLocations, EndDistance) == 0x000020, "Member 'MercunaSurfaceMoveToProxy_MoveToLocations::EndDistance' has a wrong offset!");
static_assert(offsetof(MercunaSurfaceMoveToProxy_MoveToLocations, Speed) == 0x000024, "Member 'MercunaSurfaceMoveToProxy_MoveToLocations::Speed' has a wrong offset!");
static_assert(offsetof(MercunaSurfaceMoveToProxy_MoveToLocations, UsePartialPath) == 0x000028, "Member 'MercunaSurfaceMoveToProxy_MoveToLocations::UsePartialPath' has a wrong offset!");
static_assert(offsetof(MercunaSurfaceMoveToProxy_MoveToLocations, EndDirection) == 0x000030, "Member 'MercunaSurfaceMoveToProxy_MoveToLocations::EndDirection' has a wrong offset!");
static_assert(offsetof(MercunaSurfaceMoveToProxy_MoveToLocations, ReturnValue) == 0x000048, "Member 'MercunaSurfaceMoveToProxy_MoveToLocations::ReturnValue' has a wrong offset!");

// Function Mercuna.MercunaSurfaceMoveToProxy.OnMoveComplete
// 0x0008 (0x0008 - 0x0000)
struct MercunaSurfaceMoveToProxy_OnMoveComplete final
{
public:
	struct FAIRequestID                           RequestID;                                         // 0x0000(0x0004)(Parm, NoDestructor, NativeAccessSpecifierPublic)
	EMercunaMoveResult                            Result;                                            // 0x0004(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5[0x3];                                        // 0x0005(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(MercunaSurfaceMoveToProxy_OnMoveComplete) == 0x000004, "Wrong alignment on MercunaSurfaceMoveToProxy_OnMoveComplete");
static_assert(sizeof(MercunaSurfaceMoveToProxy_OnMoveComplete) == 0x000008, "Wrong size on MercunaSurfaceMoveToProxy_OnMoveComplete");
static_assert(offsetof(MercunaSurfaceMoveToProxy_OnMoveComplete, RequestID) == 0x000000, "Member 'MercunaSurfaceMoveToProxy_OnMoveComplete::RequestID' has a wrong offset!");
static_assert(offsetof(MercunaSurfaceMoveToProxy_OnMoveComplete, Result) == 0x000004, "Member 'MercunaSurfaceMoveToProxy_OnMoveComplete::Result' has a wrong offset!");

// Function Mercuna.MercunaSurfaceTrackActorProxy.TrackActor
// 0x0048 (0x0048 - 0x0000)
struct MercunaSurfaceTrackActorProxy_TrackActor final
{
public:
	class UObject*                                WorldContextObject;                                // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class APawn*                                  Pawn_0;                                            // 0x0008(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 Actor;                                             // 0x0010(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Distance;                                          // 0x0018(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Speed;                                             // 0x001C(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Offset;                                            // 0x0020(0x0018)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          UsePartialPath;                                    // 0x0038(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          UseEndActorOrientation;                            // 0x0039(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3A[0x6];                                       // 0x003A(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	class UMercunaSurfaceTrackActorProxy*         ReturnValue;                                       // 0x0040(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MercunaSurfaceTrackActorProxy_TrackActor) == 0x000008, "Wrong alignment on MercunaSurfaceTrackActorProxy_TrackActor");
static_assert(sizeof(MercunaSurfaceTrackActorProxy_TrackActor) == 0x000048, "Wrong size on MercunaSurfaceTrackActorProxy_TrackActor");
static_assert(offsetof(MercunaSurfaceTrackActorProxy_TrackActor, WorldContextObject) == 0x000000, "Member 'MercunaSurfaceTrackActorProxy_TrackActor::WorldContextObject' has a wrong offset!");
static_assert(offsetof(MercunaSurfaceTrackActorProxy_TrackActor, Pawn_0) == 0x000008, "Member 'MercunaSurfaceTrackActorProxy_TrackActor::Pawn_0' has a wrong offset!");
static_assert(offsetof(MercunaSurfaceTrackActorProxy_TrackActor, Actor) == 0x000010, "Member 'MercunaSurfaceTrackActorProxy_TrackActor::Actor' has a wrong offset!");
static_assert(offsetof(MercunaSurfaceTrackActorProxy_TrackActor, Distance) == 0x000018, "Member 'MercunaSurfaceTrackActorProxy_TrackActor::Distance' has a wrong offset!");
static_assert(offsetof(MercunaSurfaceTrackActorProxy_TrackActor, Speed) == 0x00001C, "Member 'MercunaSurfaceTrackActorProxy_TrackActor::Speed' has a wrong offset!");
static_assert(offsetof(MercunaSurfaceTrackActorProxy_TrackActor, Offset) == 0x000020, "Member 'MercunaSurfaceTrackActorProxy_TrackActor::Offset' has a wrong offset!");
static_assert(offsetof(MercunaSurfaceTrackActorProxy_TrackActor, UsePartialPath) == 0x000038, "Member 'MercunaSurfaceTrackActorProxy_TrackActor::UsePartialPath' has a wrong offset!");
static_assert(offsetof(MercunaSurfaceTrackActorProxy_TrackActor, UseEndActorOrientation) == 0x000039, "Member 'MercunaSurfaceTrackActorProxy_TrackActor::UseEndActorOrientation' has a wrong offset!");
static_assert(offsetof(MercunaSurfaceTrackActorProxy_TrackActor, ReturnValue) == 0x000040, "Member 'MercunaSurfaceTrackActorProxy_TrackActor::ReturnValue' has a wrong offset!");

// Function Mercuna.MercunaSurfaceTrackActorProxy.OnMoveComplete
// 0x0008 (0x0008 - 0x0000)
struct MercunaSurfaceTrackActorProxy_OnMoveComplete final
{
public:
	struct FAIRequestID                           RequestID;                                         // 0x0000(0x0004)(Parm, NoDestructor, NativeAccessSpecifierPublic)
	EMercunaMoveResult                            Result;                                            // 0x0004(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5[0x3];                                        // 0x0005(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(MercunaSurfaceTrackActorProxy_OnMoveComplete) == 0x000004, "Wrong alignment on MercunaSurfaceTrackActorProxy_OnMoveComplete");
static_assert(sizeof(MercunaSurfaceTrackActorProxy_OnMoveComplete) == 0x000008, "Wrong size on MercunaSurfaceTrackActorProxy_OnMoveComplete");
static_assert(offsetof(MercunaSurfaceTrackActorProxy_OnMoveComplete, RequestID) == 0x000000, "Member 'MercunaSurfaceTrackActorProxy_OnMoveComplete::RequestID' has a wrong offset!");
static_assert(offsetof(MercunaSurfaceTrackActorProxy_OnMoveComplete, Result) == 0x000004, "Member 'MercunaSurfaceTrackActorProxy_OnMoveComplete::Result' has a wrong offset!");

// Function Mercuna.MercunaSurfaceNavigationComponent.AddDestinationLocation
// 0x0020 (0x0020 - 0x0000)
struct MercunaSurfaceNavigationComponent_AddDestinationLocation final
{
public:
	struct FVector                                NextDestination;                                   // 0x0000(0x0018)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bSmoothTransition;                                 // 0x0018(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19[0x7];                                       // 0x0019(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(MercunaSurfaceNavigationComponent_AddDestinationLocation) == 0x000008, "Wrong alignment on MercunaSurfaceNavigationComponent_AddDestinationLocation");
static_assert(sizeof(MercunaSurfaceNavigationComponent_AddDestinationLocation) == 0x000020, "Wrong size on MercunaSurfaceNavigationComponent_AddDestinationLocation");
static_assert(offsetof(MercunaSurfaceNavigationComponent_AddDestinationLocation, NextDestination) == 0x000000, "Member 'MercunaSurfaceNavigationComponent_AddDestinationLocation::NextDestination' has a wrong offset!");
static_assert(offsetof(MercunaSurfaceNavigationComponent_AddDestinationLocation, bSmoothTransition) == 0x000018, "Member 'MercunaSurfaceNavigationComponent_AddDestinationLocation::bSmoothTransition' has a wrong offset!");

// Function Mercuna.MercunaSurfaceNavigationComponent.Configure
// 0x0010 (0x0010 - 0x0000)
struct MercunaSurfaceNavigationComponent_Configure final
{
public:
	struct FMercunaSurfaceNavigationConfiguration NewConfiguration;                                  // 0x0000(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(MercunaSurfaceNavigationComponent_Configure) == 0x000004, "Wrong alignment on MercunaSurfaceNavigationComponent_Configure");
static_assert(sizeof(MercunaSurfaceNavigationComponent_Configure) == 0x000010, "Wrong size on MercunaSurfaceNavigationComponent_Configure");
static_assert(offsetof(MercunaSurfaceNavigationComponent_Configure, NewConfiguration) == 0x000000, "Member 'MercunaSurfaceNavigationComponent_Configure::NewConfiguration' has a wrong offset!");

// Function Mercuna.MercunaSurfaceNavigationComponent.ConfigureMovement
// 0x0001 (0x0001 - 0x0000)
struct MercunaSurfaceNavigationComponent_ConfigureMovement final
{
public:
	EMercunaAvoidanceMode                         NewAvoidanceMode;                                  // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MercunaSurfaceNavigationComponent_ConfigureMovement) == 0x000001, "Wrong alignment on MercunaSurfaceNavigationComponent_ConfigureMovement");
static_assert(sizeof(MercunaSurfaceNavigationComponent_ConfigureMovement) == 0x000001, "Wrong size on MercunaSurfaceNavigationComponent_ConfigureMovement");
static_assert(offsetof(MercunaSurfaceNavigationComponent_ConfigureMovement, NewAvoidanceMode) == 0x000000, "Member 'MercunaSurfaceNavigationComponent_ConfigureMovement::NewAvoidanceMode' has a wrong offset!");

// Function Mercuna.MercunaSurfaceNavigationComponent.ConfigureSteering
// 0x0014 (0x0014 - 0x0000)
struct MercunaSurfaceNavigationComponent_ConfigureSteering final
{
public:
	struct FMercunaSurfaceNavigationSteeringParameters NewSteering;                                  // 0x0000(0x0014)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(MercunaSurfaceNavigationComponent_ConfigureSteering) == 0x000004, "Wrong alignment on MercunaSurfaceNavigationComponent_ConfigureSteering");
static_assert(sizeof(MercunaSurfaceNavigationComponent_ConfigureSteering) == 0x000014, "Wrong size on MercunaSurfaceNavigationComponent_ConfigureSteering");
static_assert(offsetof(MercunaSurfaceNavigationComponent_ConfigureSteering, NewSteering) == 0x000000, "Member 'MercunaSurfaceNavigationComponent_ConfigureSteering::NewSteering' has a wrong offset!");

// Function Mercuna.MercunaSurfaceNavigationComponent.GetLookDirection
// 0x0018 (0x0018 - 0x0000)
struct MercunaSurfaceNavigationComponent_GetLookDirection final
{
public:
	struct FVector                                ReturnValue;                                       // 0x0000(0x0018)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MercunaSurfaceNavigationComponent_GetLookDirection) == 0x000008, "Wrong alignment on MercunaSurfaceNavigationComponent_GetLookDirection");
static_assert(sizeof(MercunaSurfaceNavigationComponent_GetLookDirection) == 0x000018, "Wrong size on MercunaSurfaceNavigationComponent_GetLookDirection");
static_assert(offsetof(MercunaSurfaceNavigationComponent_GetLookDirection, ReturnValue) == 0x000000, "Member 'MercunaSurfaceNavigationComponent_GetLookDirection::ReturnValue' has a wrong offset!");

// Function Mercuna.MercunaSurfaceNavigationComponent.GetPathInfo
// 0x0008 (0x0008 - 0x0000)
struct MercunaSurfaceNavigationComponent_GetPathInfo final
{
public:
	bool                                          Valid;                                             // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         DistanceToEnd;                                     // 0x0004(0x0004)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MercunaSurfaceNavigationComponent_GetPathInfo) == 0x000004, "Wrong alignment on MercunaSurfaceNavigationComponent_GetPathInfo");
static_assert(sizeof(MercunaSurfaceNavigationComponent_GetPathInfo) == 0x000008, "Wrong size on MercunaSurfaceNavigationComponent_GetPathInfo");
static_assert(offsetof(MercunaSurfaceNavigationComponent_GetPathInfo, Valid) == 0x000000, "Member 'MercunaSurfaceNavigationComponent_GetPathInfo::Valid' has a wrong offset!");
static_assert(offsetof(MercunaSurfaceNavigationComponent_GetPathInfo, DistanceToEnd) == 0x000004, "Member 'MercunaSurfaceNavigationComponent_GetPathInfo::DistanceToEnd' has a wrong offset!");

// Function Mercuna.MercunaSurfaceNavigationComponent.GetRemainingPathLength
// 0x0004 (0x0004 - 0x0000)
struct MercunaSurfaceNavigationComponent_GetRemainingPathLength final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MercunaSurfaceNavigationComponent_GetRemainingPathLength) == 0x000004, "Wrong alignment on MercunaSurfaceNavigationComponent_GetRemainingPathLength");
static_assert(sizeof(MercunaSurfaceNavigationComponent_GetRemainingPathLength) == 0x000004, "Wrong size on MercunaSurfaceNavigationComponent_GetRemainingPathLength");
static_assert(offsetof(MercunaSurfaceNavigationComponent_GetRemainingPathLength, ReturnValue) == 0x000000, "Member 'MercunaSurfaceNavigationComponent_GetRemainingPathLength::ReturnValue' has a wrong offset!");

// Function Mercuna.MercunaSurfaceNavigationComponent.InvalidateContextualSteeringParamsAgainstActor
// 0x0008 (0x0008 - 0x0000)
struct MercunaSurfaceNavigationComponent_InvalidateContextualSteeringParamsAgainstActor final
{
public:
	class AActor*                                 Actor;                                             // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MercunaSurfaceNavigationComponent_InvalidateContextualSteeringParamsAgainstActor) == 0x000008, "Wrong alignment on MercunaSurfaceNavigationComponent_InvalidateContextualSteeringParamsAgainstActor");
static_assert(sizeof(MercunaSurfaceNavigationComponent_InvalidateContextualSteeringParamsAgainstActor) == 0x000008, "Wrong size on MercunaSurfaceNavigationComponent_InvalidateContextualSteeringParamsAgainstActor");
static_assert(offsetof(MercunaSurfaceNavigationComponent_InvalidateContextualSteeringParamsAgainstActor, Actor) == 0x000000, "Member 'MercunaSurfaceNavigationComponent_InvalidateContextualSteeringParamsAgainstActor::Actor' has a wrong offset!");

// Function Mercuna.MercunaSurfaceNavigationComponent.MoveToActor
// 0x0018 (0x0018 - 0x0000)
struct MercunaSurfaceNavigationComponent_MoveToActor final
{
public:
	class AActor*                                 Actor;                                             // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         EndDistance;                                       // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Speed;                                             // 0x000C(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          UsePartialPath;                                    // 0x0010(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUseEndActorOrientation;                           // 0x0011(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_12[0x6];                                       // 0x0012(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(MercunaSurfaceNavigationComponent_MoveToActor) == 0x000008, "Wrong alignment on MercunaSurfaceNavigationComponent_MoveToActor");
static_assert(sizeof(MercunaSurfaceNavigationComponent_MoveToActor) == 0x000018, "Wrong size on MercunaSurfaceNavigationComponent_MoveToActor");
static_assert(offsetof(MercunaSurfaceNavigationComponent_MoveToActor, Actor) == 0x000000, "Member 'MercunaSurfaceNavigationComponent_MoveToActor::Actor' has a wrong offset!");
static_assert(offsetof(MercunaSurfaceNavigationComponent_MoveToActor, EndDistance) == 0x000008, "Member 'MercunaSurfaceNavigationComponent_MoveToActor::EndDistance' has a wrong offset!");
static_assert(offsetof(MercunaSurfaceNavigationComponent_MoveToActor, Speed) == 0x00000C, "Member 'MercunaSurfaceNavigationComponent_MoveToActor::Speed' has a wrong offset!");
static_assert(offsetof(MercunaSurfaceNavigationComponent_MoveToActor, UsePartialPath) == 0x000010, "Member 'MercunaSurfaceNavigationComponent_MoveToActor::UsePartialPath' has a wrong offset!");
static_assert(offsetof(MercunaSurfaceNavigationComponent_MoveToActor, bUseEndActorOrientation) == 0x000011, "Member 'MercunaSurfaceNavigationComponent_MoveToActor::bUseEndActorOrientation' has a wrong offset!");

// Function Mercuna.MercunaSurfaceNavigationComponent.MoveToLocation
// 0x0040 (0x0040 - 0x0000)
struct MercunaSurfaceNavigationComponent_MoveToLocation final
{
public:
	struct FVector                                Destination;                                       // 0x0000(0x0018)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                EndDirection;                                      // 0x0018(0x0018)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         EndDistance;                                       // 0x0030(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Speed;                                             // 0x0034(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          UsePartialPath;                                    // 0x0038(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_39[0x7];                                       // 0x0039(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(MercunaSurfaceNavigationComponent_MoveToLocation) == 0x000008, "Wrong alignment on MercunaSurfaceNavigationComponent_MoveToLocation");
static_assert(sizeof(MercunaSurfaceNavigationComponent_MoveToLocation) == 0x000040, "Wrong size on MercunaSurfaceNavigationComponent_MoveToLocation");
static_assert(offsetof(MercunaSurfaceNavigationComponent_MoveToLocation, Destination) == 0x000000, "Member 'MercunaSurfaceNavigationComponent_MoveToLocation::Destination' has a wrong offset!");
static_assert(offsetof(MercunaSurfaceNavigationComponent_MoveToLocation, EndDirection) == 0x000018, "Member 'MercunaSurfaceNavigationComponent_MoveToLocation::EndDirection' has a wrong offset!");
static_assert(offsetof(MercunaSurfaceNavigationComponent_MoveToLocation, EndDistance) == 0x000030, "Member 'MercunaSurfaceNavigationComponent_MoveToLocation::EndDistance' has a wrong offset!");
static_assert(offsetof(MercunaSurfaceNavigationComponent_MoveToLocation, Speed) == 0x000034, "Member 'MercunaSurfaceNavigationComponent_MoveToLocation::Speed' has a wrong offset!");
static_assert(offsetof(MercunaSurfaceNavigationComponent_MoveToLocation, UsePartialPath) == 0x000038, "Member 'MercunaSurfaceNavigationComponent_MoveToLocation::UsePartialPath' has a wrong offset!");

// Function Mercuna.MercunaSurfaceNavigationComponent.MoveToLocations
// 0x0038 (0x0038 - 0x0000)
struct MercunaSurfaceNavigationComponent_MoveToLocations final
{
public:
	TArray<struct FVector>                        Destinations;                                      // 0x0000(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	struct FVector                                EndDirection;                                      // 0x0010(0x0018)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         EndDistance;                                       // 0x0028(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Speed;                                             // 0x002C(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          UsePartialPath;                                    // 0x0030(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_31[0x7];                                       // 0x0031(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(MercunaSurfaceNavigationComponent_MoveToLocations) == 0x000008, "Wrong alignment on MercunaSurfaceNavigationComponent_MoveToLocations");
static_assert(sizeof(MercunaSurfaceNavigationComponent_MoveToLocations) == 0x000038, "Wrong size on MercunaSurfaceNavigationComponent_MoveToLocations");
static_assert(offsetof(MercunaSurfaceNavigationComponent_MoveToLocations, Destinations) == 0x000000, "Member 'MercunaSurfaceNavigationComponent_MoveToLocations::Destinations' has a wrong offset!");
static_assert(offsetof(MercunaSurfaceNavigationComponent_MoveToLocations, EndDirection) == 0x000010, "Member 'MercunaSurfaceNavigationComponent_MoveToLocations::EndDirection' has a wrong offset!");
static_assert(offsetof(MercunaSurfaceNavigationComponent_MoveToLocations, EndDistance) == 0x000028, "Member 'MercunaSurfaceNavigationComponent_MoveToLocations::EndDistance' has a wrong offset!");
static_assert(offsetof(MercunaSurfaceNavigationComponent_MoveToLocations, Speed) == 0x00002C, "Member 'MercunaSurfaceNavigationComponent_MoveToLocations::Speed' has a wrong offset!");
static_assert(offsetof(MercunaSurfaceNavigationComponent_MoveToLocations, UsePartialPath) == 0x000030, "Member 'MercunaSurfaceNavigationComponent_MoveToLocations::UsePartialPath' has a wrong offset!");

// Function Mercuna.MercunaSurfaceNavigationComponent.OverrideSpeedMultiplier
// 0x0008 (0x0008 - 0x0000)
struct MercunaSurfaceNavigationComponent_OverrideSpeedMultiplier final
{
public:
	float                                         NewSpeedMultiplier;                                // 0x0000(0x0004)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0004(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5[0x3];                                        // 0x0005(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(MercunaSurfaceNavigationComponent_OverrideSpeedMultiplier) == 0x000004, "Wrong alignment on MercunaSurfaceNavigationComponent_OverrideSpeedMultiplier");
static_assert(sizeof(MercunaSurfaceNavigationComponent_OverrideSpeedMultiplier) == 0x000008, "Wrong size on MercunaSurfaceNavigationComponent_OverrideSpeedMultiplier");
static_assert(offsetof(MercunaSurfaceNavigationComponent_OverrideSpeedMultiplier, NewSpeedMultiplier) == 0x000000, "Member 'MercunaSurfaceNavigationComponent_OverrideSpeedMultiplier::NewSpeedMultiplier' has a wrong offset!");
static_assert(offsetof(MercunaSurfaceNavigationComponent_OverrideSpeedMultiplier, ReturnValue) == 0x000004, "Member 'MercunaSurfaceNavigationComponent_OverrideSpeedMultiplier::ReturnValue' has a wrong offset!");

// Function Mercuna.MercunaSurfaceNavigationComponent.SetAgentType
// 0x000C (0x000C - 0x0000)
struct MercunaSurfaceNavigationComponent_SetAgentType final
{
public:
	struct FMercunaSurfaceAgentType               NewAgentType;                                      // 0x0000(0x000C)(Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MercunaSurfaceNavigationComponent_SetAgentType) == 0x000004, "Wrong alignment on MercunaSurfaceNavigationComponent_SetAgentType");
static_assert(sizeof(MercunaSurfaceNavigationComponent_SetAgentType) == 0x00000C, "Wrong size on MercunaSurfaceNavigationComponent_SetAgentType");
static_assert(offsetof(MercunaSurfaceNavigationComponent_SetAgentType, NewAgentType) == 0x000000, "Member 'MercunaSurfaceNavigationComponent_SetAgentType::NewAgentType' has a wrong offset!");

// Function Mercuna.MercunaSurfaceNavigationComponent.SetAvoidanceAgainst
// 0x0010 (0x0010 - 0x0000)
struct MercunaSurfaceNavigationComponent_SetAvoidanceAgainst final
{
public:
	class AActor*                                 Actor;                                             // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          Enable;                                            // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(MercunaSurfaceNavigationComponent_SetAvoidanceAgainst) == 0x000008, "Wrong alignment on MercunaSurfaceNavigationComponent_SetAvoidanceAgainst");
static_assert(sizeof(MercunaSurfaceNavigationComponent_SetAvoidanceAgainst) == 0x000010, "Wrong size on MercunaSurfaceNavigationComponent_SetAvoidanceAgainst");
static_assert(offsetof(MercunaSurfaceNavigationComponent_SetAvoidanceAgainst, Actor) == 0x000000, "Member 'MercunaSurfaceNavigationComponent_SetAvoidanceAgainst::Actor' has a wrong offset!");
static_assert(offsetof(MercunaSurfaceNavigationComponent_SetAvoidanceAgainst, Enable) == 0x000008, "Member 'MercunaSurfaceNavigationComponent_SetAvoidanceAgainst::Enable' has a wrong offset!");

// Function Mercuna.MercunaSurfaceNavigationComponent.SetNavGrid
// 0x0008 (0x0008 - 0x0000)
struct MercunaSurfaceNavigationComponent_SetNavGrid final
{
public:
	class AMercunaNavSurfaceGrid*                 NavSurfaceGrid_0;                                  // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MercunaSurfaceNavigationComponent_SetNavGrid) == 0x000008, "Wrong alignment on MercunaSurfaceNavigationComponent_SetNavGrid");
static_assert(sizeof(MercunaSurfaceNavigationComponent_SetNavGrid) == 0x000008, "Wrong size on MercunaSurfaceNavigationComponent_SetNavGrid");
static_assert(offsetof(MercunaSurfaceNavigationComponent_SetNavGrid, NavSurfaceGrid_0) == 0x000000, "Member 'MercunaSurfaceNavigationComponent_SetNavGrid::NavSurfaceGrid_0' has a wrong offset!");

// Function Mercuna.MercunaSurfaceNavigationComponent.SetUsageSpec
// 0x0008 (0x0008 - 0x0000)
struct MercunaSurfaceNavigationComponent_SetUsageSpec final
{
public:
	struct FMercunaUsageSpec                      NewUsageSpec;                                      // 0x0000(0x0008)(Parm, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(MercunaSurfaceNavigationComponent_SetUsageSpec) == 0x000004, "Wrong alignment on MercunaSurfaceNavigationComponent_SetUsageSpec");
static_assert(sizeof(MercunaSurfaceNavigationComponent_SetUsageSpec) == 0x000008, "Wrong size on MercunaSurfaceNavigationComponent_SetUsageSpec");
static_assert(offsetof(MercunaSurfaceNavigationComponent_SetUsageSpec, NewUsageSpec) == 0x000000, "Member 'MercunaSurfaceNavigationComponent_SetUsageSpec::NewUsageSpec' has a wrong offset!");

// Function Mercuna.MercunaSurfaceNavigationComponent.TrackActor
// 0x0030 (0x0030 - 0x0000)
struct MercunaSurfaceNavigationComponent_TrackActor final
{
public:
	class AActor*                                 Actor;                                             // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Distance;                                          // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Speed;                                             // 0x000C(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Offset;                                            // 0x0010(0x0018)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          UsePartialPath;                                    // 0x0028(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUseEndActorOrientation;                           // 0x0029(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2A[0x6];                                       // 0x002A(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(MercunaSurfaceNavigationComponent_TrackActor) == 0x000008, "Wrong alignment on MercunaSurfaceNavigationComponent_TrackActor");
static_assert(sizeof(MercunaSurfaceNavigationComponent_TrackActor) == 0x000030, "Wrong size on MercunaSurfaceNavigationComponent_TrackActor");
static_assert(offsetof(MercunaSurfaceNavigationComponent_TrackActor, Actor) == 0x000000, "Member 'MercunaSurfaceNavigationComponent_TrackActor::Actor' has a wrong offset!");
static_assert(offsetof(MercunaSurfaceNavigationComponent_TrackActor, Distance) == 0x000008, "Member 'MercunaSurfaceNavigationComponent_TrackActor::Distance' has a wrong offset!");
static_assert(offsetof(MercunaSurfaceNavigationComponent_TrackActor, Speed) == 0x00000C, "Member 'MercunaSurfaceNavigationComponent_TrackActor::Speed' has a wrong offset!");
static_assert(offsetof(MercunaSurfaceNavigationComponent_TrackActor, Offset) == 0x000010, "Member 'MercunaSurfaceNavigationComponent_TrackActor::Offset' has a wrong offset!");
static_assert(offsetof(MercunaSurfaceNavigationComponent_TrackActor, UsePartialPath) == 0x000028, "Member 'MercunaSurfaceNavigationComponent_TrackActor::UsePartialPath' has a wrong offset!");
static_assert(offsetof(MercunaSurfaceNavigationComponent_TrackActor, bUseEndActorOrientation) == 0x000029, "Member 'MercunaSurfaceNavigationComponent_TrackActor::bUseEndActorOrientation' has a wrong offset!");

// Function Mercuna.MercunaSurfaceNavigationComponent.UpdateDynamicSteeringParams
// 0x000C (0x000C - 0x0000)
struct MercunaSurfaceNavigationComponent_UpdateDynamicSteeringParams final
{
public:
	struct FMercunaSurfaceNavigationDynamicSteeringParameters NewDynamicSteeringParams;              // 0x0000(0x000C)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(MercunaSurfaceNavigationComponent_UpdateDynamicSteeringParams) == 0x000004, "Wrong alignment on MercunaSurfaceNavigationComponent_UpdateDynamicSteeringParams");
static_assert(sizeof(MercunaSurfaceNavigationComponent_UpdateDynamicSteeringParams) == 0x00000C, "Wrong size on MercunaSurfaceNavigationComponent_UpdateDynamicSteeringParams");
static_assert(offsetof(MercunaSurfaceNavigationComponent_UpdateDynamicSteeringParams, NewDynamicSteeringParams) == 0x000000, "Member 'MercunaSurfaceNavigationComponent_UpdateDynamicSteeringParams::NewDynamicSteeringParams' has a wrong offset!");

// Function Mercuna.MercunaSurfaceNavigationComponent.GetConfiguration
// 0x0010 (0x0010 - 0x0000)
struct MercunaSurfaceNavigationComponent_GetConfiguration final
{
public:
	struct FMercunaSurfaceNavigationConfiguration ReturnValue;                                       // 0x0000(0x0010)(Parm, OutParm, ReturnParm, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(MercunaSurfaceNavigationComponent_GetConfiguration) == 0x000004, "Wrong alignment on MercunaSurfaceNavigationComponent_GetConfiguration");
static_assert(sizeof(MercunaSurfaceNavigationComponent_GetConfiguration) == 0x000010, "Wrong size on MercunaSurfaceNavigationComponent_GetConfiguration");
static_assert(offsetof(MercunaSurfaceNavigationComponent_GetConfiguration, ReturnValue) == 0x000000, "Member 'MercunaSurfaceNavigationComponent_GetConfiguration::ReturnValue' has a wrong offset!");

// Function Mercuna.MercunaSurfaceNavigationComponent.GetDynamicSteeringParameters
// 0x000C (0x000C - 0x0000)
struct MercunaSurfaceNavigationComponent_GetDynamicSteeringParameters final
{
public:
	struct FMercunaSurfaceNavigationDynamicSteeringParameters ReturnValue;                           // 0x0000(0x000C)(Parm, OutParm, ReturnParm, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(MercunaSurfaceNavigationComponent_GetDynamicSteeringParameters) == 0x000004, "Wrong alignment on MercunaSurfaceNavigationComponent_GetDynamicSteeringParameters");
static_assert(sizeof(MercunaSurfaceNavigationComponent_GetDynamicSteeringParameters) == 0x00000C, "Wrong size on MercunaSurfaceNavigationComponent_GetDynamicSteeringParameters");
static_assert(offsetof(MercunaSurfaceNavigationComponent_GetDynamicSteeringParameters, ReturnValue) == 0x000000, "Member 'MercunaSurfaceNavigationComponent_GetDynamicSteeringParameters::ReturnValue' has a wrong offset!");

// Function Mercuna.MercunaSurfaceNavigationComponent.GetLastRequestedMoveVelocity
// 0x0018 (0x0018 - 0x0000)
struct MercunaSurfaceNavigationComponent_GetLastRequestedMoveVelocity final
{
public:
	struct FVector                                ReturnValue;                                       // 0x0000(0x0018)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MercunaSurfaceNavigationComponent_GetLastRequestedMoveVelocity) == 0x000008, "Wrong alignment on MercunaSurfaceNavigationComponent_GetLastRequestedMoveVelocity");
static_assert(sizeof(MercunaSurfaceNavigationComponent_GetLastRequestedMoveVelocity) == 0x000018, "Wrong size on MercunaSurfaceNavigationComponent_GetLastRequestedMoveVelocity");
static_assert(offsetof(MercunaSurfaceNavigationComponent_GetLastRequestedMoveVelocity, ReturnValue) == 0x000000, "Member 'MercunaSurfaceNavigationComponent_GetLastRequestedMoveVelocity::ReturnValue' has a wrong offset!");

// Function Mercuna.MercunaSurfaceNavigationComponent.GetNavGrid
// 0x0008 (0x0008 - 0x0000)
struct MercunaSurfaceNavigationComponent_GetNavGrid final
{
public:
	class AMercunaNavSurfaceGrid*                 ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MercunaSurfaceNavigationComponent_GetNavGrid) == 0x000008, "Wrong alignment on MercunaSurfaceNavigationComponent_GetNavGrid");
static_assert(sizeof(MercunaSurfaceNavigationComponent_GetNavGrid) == 0x000008, "Wrong size on MercunaSurfaceNavigationComponent_GetNavGrid");
static_assert(offsetof(MercunaSurfaceNavigationComponent_GetNavGrid, ReturnValue) == 0x000000, "Member 'MercunaSurfaceNavigationComponent_GetNavGrid::ReturnValue' has a wrong offset!");

// Function Mercuna.MercunaSurfaceNavigationComponent.GetNextNavLink
// 0x0050 (0x0050 - 0x0000)
struct MercunaSurfaceNavigationComponent_GetNextNavLink final
{
public:
	bool                                          bNextNavLinkFound;                                 // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         DistanceToNextNavLink;                             // 0x0004(0x0004)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TimeToNextNavLink;                                 // 0x0008(0x0004)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                TraversalStart;                                    // 0x0010(0x0018)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                TraversalEnd;                                      // 0x0028(0x0018)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AMercunaNavLink*                        NavLink;                                           // 0x0040(0x0008)(Parm, OutParm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxLookAhead;                                      // 0x0048(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4C[0x4];                                       // 0x004C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(MercunaSurfaceNavigationComponent_GetNextNavLink) == 0x000008, "Wrong alignment on MercunaSurfaceNavigationComponent_GetNextNavLink");
static_assert(sizeof(MercunaSurfaceNavigationComponent_GetNextNavLink) == 0x000050, "Wrong size on MercunaSurfaceNavigationComponent_GetNextNavLink");
static_assert(offsetof(MercunaSurfaceNavigationComponent_GetNextNavLink, bNextNavLinkFound) == 0x000000, "Member 'MercunaSurfaceNavigationComponent_GetNextNavLink::bNextNavLinkFound' has a wrong offset!");
static_assert(offsetof(MercunaSurfaceNavigationComponent_GetNextNavLink, DistanceToNextNavLink) == 0x000004, "Member 'MercunaSurfaceNavigationComponent_GetNextNavLink::DistanceToNextNavLink' has a wrong offset!");
static_assert(offsetof(MercunaSurfaceNavigationComponent_GetNextNavLink, TimeToNextNavLink) == 0x000008, "Member 'MercunaSurfaceNavigationComponent_GetNextNavLink::TimeToNextNavLink' has a wrong offset!");
static_assert(offsetof(MercunaSurfaceNavigationComponent_GetNextNavLink, TraversalStart) == 0x000010, "Member 'MercunaSurfaceNavigationComponent_GetNextNavLink::TraversalStart' has a wrong offset!");
static_assert(offsetof(MercunaSurfaceNavigationComponent_GetNextNavLink, TraversalEnd) == 0x000028, "Member 'MercunaSurfaceNavigationComponent_GetNextNavLink::TraversalEnd' has a wrong offset!");
static_assert(offsetof(MercunaSurfaceNavigationComponent_GetNextNavLink, NavLink) == 0x000040, "Member 'MercunaSurfaceNavigationComponent_GetNextNavLink::NavLink' has a wrong offset!");
static_assert(offsetof(MercunaSurfaceNavigationComponent_GetNextNavLink, MaxLookAhead) == 0x000048, "Member 'MercunaSurfaceNavigationComponent_GetNextNavLink::MaxLookAhead' has a wrong offset!");

// Function Mercuna.MercunaSurfaceNavigationComponent.GetSteeringParameters
// 0x0014 (0x0014 - 0x0000)
struct MercunaSurfaceNavigationComponent_GetSteeringParameters final
{
public:
	struct FMercunaSurfaceNavigationSteeringParameters ReturnValue;                                  // 0x0000(0x0014)(Parm, OutParm, ReturnParm, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(MercunaSurfaceNavigationComponent_GetSteeringParameters) == 0x000004, "Wrong alignment on MercunaSurfaceNavigationComponent_GetSteeringParameters");
static_assert(sizeof(MercunaSurfaceNavigationComponent_GetSteeringParameters) == 0x000014, "Wrong size on MercunaSurfaceNavigationComponent_GetSteeringParameters");
static_assert(offsetof(MercunaSurfaceNavigationComponent_GetSteeringParameters, ReturnValue) == 0x000000, "Member 'MercunaSurfaceNavigationComponent_GetSteeringParameters::ReturnValue' has a wrong offset!");

// Function Mercuna.MercunaSurfaceNavigationComponent.GetUsageSpec
// 0x0008 (0x0008 - 0x0000)
struct MercunaSurfaceNavigationComponent_GetUsageSpec final
{
public:
	struct FMercunaUsageSpec                      ReturnValue;                                       // 0x0000(0x0008)(ConstParm, Parm, OutParm, ReturnParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(MercunaSurfaceNavigationComponent_GetUsageSpec) == 0x000004, "Wrong alignment on MercunaSurfaceNavigationComponent_GetUsageSpec");
static_assert(sizeof(MercunaSurfaceNavigationComponent_GetUsageSpec) == 0x000008, "Wrong size on MercunaSurfaceNavigationComponent_GetUsageSpec");
static_assert(offsetof(MercunaSurfaceNavigationComponent_GetUsageSpec, ReturnValue) == 0x000000, "Member 'MercunaSurfaceNavigationComponent_GetUsageSpec::ReturnValue' has a wrong offset!");

// Function Mercuna.MercunaSurfaceTask_MoveTo.MoveTo
// 0x0038 (0x0038 - 0x0000)
struct MercunaSurfaceTask_MoveTo_MoveTo final
{
public:
	class AAIController*                          Controller;                                        // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                GoalLocation;                                      // 0x0008(0x0018)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 GoalActor;                                         // 0x0020(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         EndDistance;                                       // 0x0028(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          AcceptPartialPath;                                 // 0x002C(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bLockAILogic;                                      // 0x002D(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2E[0x2];                                       // 0x002E(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	class UMercunaSurfaceTask_MoveTo*             ReturnValue;                                       // 0x0030(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MercunaSurfaceTask_MoveTo_MoveTo) == 0x000008, "Wrong alignment on MercunaSurfaceTask_MoveTo_MoveTo");
static_assert(sizeof(MercunaSurfaceTask_MoveTo_MoveTo) == 0x000038, "Wrong size on MercunaSurfaceTask_MoveTo_MoveTo");
static_assert(offsetof(MercunaSurfaceTask_MoveTo_MoveTo, Controller) == 0x000000, "Member 'MercunaSurfaceTask_MoveTo_MoveTo::Controller' has a wrong offset!");
static_assert(offsetof(MercunaSurfaceTask_MoveTo_MoveTo, GoalLocation) == 0x000008, "Member 'MercunaSurfaceTask_MoveTo_MoveTo::GoalLocation' has a wrong offset!");
static_assert(offsetof(MercunaSurfaceTask_MoveTo_MoveTo, GoalActor) == 0x000020, "Member 'MercunaSurfaceTask_MoveTo_MoveTo::GoalActor' has a wrong offset!");
static_assert(offsetof(MercunaSurfaceTask_MoveTo_MoveTo, EndDistance) == 0x000028, "Member 'MercunaSurfaceTask_MoveTo_MoveTo::EndDistance' has a wrong offset!");
static_assert(offsetof(MercunaSurfaceTask_MoveTo_MoveTo, AcceptPartialPath) == 0x00002C, "Member 'MercunaSurfaceTask_MoveTo_MoveTo::AcceptPartialPath' has a wrong offset!");
static_assert(offsetof(MercunaSurfaceTask_MoveTo_MoveTo, bLockAILogic) == 0x00002D, "Member 'MercunaSurfaceTask_MoveTo_MoveTo::bLockAILogic' has a wrong offset!");
static_assert(offsetof(MercunaSurfaceTask_MoveTo_MoveTo, ReturnValue) == 0x000030, "Member 'MercunaSurfaceTask_MoveTo_MoveTo::ReturnValue' has a wrong offset!");

// Function Mercuna.MercunaSurfaceTask_MoveTo.OnMoveComplete
// 0x0008 (0x0008 - 0x0000)
struct MercunaSurfaceTask_MoveTo_OnMoveComplete final
{
public:
	struct FAIRequestID                           RequestID;                                         // 0x0000(0x0004)(Parm, NoDestructor, NativeAccessSpecifierPublic)
	EMercunaMoveResult                            Result;                                            // 0x0004(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5[0x3];                                        // 0x0005(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(MercunaSurfaceTask_MoveTo_OnMoveComplete) == 0x000004, "Wrong alignment on MercunaSurfaceTask_MoveTo_OnMoveComplete");
static_assert(sizeof(MercunaSurfaceTask_MoveTo_OnMoveComplete) == 0x000008, "Wrong size on MercunaSurfaceTask_MoveTo_OnMoveComplete");
static_assert(offsetof(MercunaSurfaceTask_MoveTo_OnMoveComplete, RequestID) == 0x000000, "Member 'MercunaSurfaceTask_MoveTo_OnMoveComplete::RequestID' has a wrong offset!");
static_assert(offsetof(MercunaSurfaceTask_MoveTo_OnMoveComplete, Result) == 0x000004, "Member 'MercunaSurfaceTask_MoveTo_OnMoveComplete::Result' has a wrong offset!");

}

