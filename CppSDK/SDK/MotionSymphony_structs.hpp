#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: MotionSymphony

#include "Basic.hpp"

#include "AnimGraphRuntime_structs.hpp"
#include "CoreUObject_structs.hpp"
#include "GameplayTags_structs.hpp"
#include "Engine_structs.hpp"


namespace SDK
{

// Enum MotionSymphony.EMSHyperExtensionFixMethod
// NumValues: 0x0004
enum class EMSHyperExtensionFixMethod : uint8
{
	None                                     = 0,
	MoveFootTowardsThigh                     = 1,
	MoveFootUnderThigh                       = 2,
	EMSHyperExtensionFixMethod_MAX           = 3,
};

// Enum MotionSymphony.EDecouplerClampMode
// NumValues: 0x0003
enum class EDecouplerClampMode : uint8
{
	None                                     = 0,
	Hard                                     = 1,
	EDecouplerClampMode_MAX                  = 2,
};

// Enum MotionSymphony.ETransitionDirectionMethod
// NumValues: 0x0003
enum class ETransitionDirectionMethod : uint8
{
	Manual                                   = 0,
	RootMotion                               = 1,
	ETransitionDirectionMethod_MAX           = 2,
};

// Enum MotionSymphony.ETransitionMatchingOrder
// NumValues: 0x0003
enum class ETransitionMatchingOrder : uint8
{
	TransitionPriority                       = 0,
	PoseAndTransitionCombined                = 1,
	ETransitionMatchingOrder_MAX             = 2,
};

// Enum MotionSymphony.EDistanceMatchingUseCase
// NumValues: 0x0003
enum class EDistanceMatchingUseCase : uint8
{
	None                                     = 0,
	Strict                                   = 1,
	EDistanceMatchingUseCase_MAX             = 2,
};

// Enum MotionSymphony.EDistanceMatchType
// NumValues: 0x0005
enum class EDistanceMatchType : uint8
{
	None                                     = 0,
	Backward                                 = 1,
	Forward                                  = 2,
	Both                                     = 3,
	EDistanceMatchType_MAX                   = 4,
};

// Enum MotionSymphony.EDistanceMatchBasis
// NumValues: 0x0003
enum class EDistanceMatchBasis : uint8
{
	Positional                               = 0,
	Rotational                               = 1,
	EDistanceMatchBasis_MAX                  = 2,
};

// Enum MotionSymphony.EDistanceMatchTrigger
// NumValues: 0x0008
enum class EDistanceMatchTrigger : uint8
{
	None                                     = 0,
	Start                                    = 1,
	Stop                                     = 2,
	Plant                                    = 3,
	Jump                                     = 4,
	TurnInPlace                              = 5,
	Pivot                                    = 6,
	EDistanceMatchTrigger_MAX                = 7,
};

// Enum MotionSymphony.ETrajectoryPreProcessMethod
// NumValues: 0x0005
enum class ETrajectoryPreProcessMethod : uint8
{
	None                                     = 0,
	IgnoreEdges                              = 1,
	Extrapolate                              = 2,
	Animation                                = 3,
	ETrajectoryPreProcessMethod_MAX          = 4,
};

// Enum MotionSymphony.EJointVelocityCalculationMethod
// NumValues: 0x0003
enum class EJointVelocityCalculationMethod : uint8
{
	BodyIndependent                          = 0,
	BodyDependent                            = 1,
	EJointVelocityCalculationMethod_MAX      = 2,
};

// Enum MotionSymphony.EAllAxis
// NumValues: 0x0007
enum class EAllAxis : uint8
{
	X                                        = 0,
	Y                                        = 1,
	Z                                        = 2,
	NegX                                     = 3,
	NegY                                     = 4,
	NegZ                                     = 5,
	EAllAxis_MAX                             = 6,
};

// Enum MotionSymphony.EMotionMatchingMode
// NumValues: 0x0004
enum class EMotionMatchingMode : uint8
{
	MotionMatching                           = 0,
	DistanceMatching                         = 1,
	Action                                   = 2,
	EMotionMatchingMode_MAX                  = 3,
};

// Enum MotionSymphony.EPoseSearchFlag
// NumValues: 0x0005
enum class EPoseSearchFlag : uint8
{
	Searchable                               = 0,
	NextNatural                              = 1,
	EdgePose                                 = 2,
	DoNotUse                                 = 3,
	EPoseSearchFlag_MAX                      = 4,
};

// Enum MotionSymphony.EBlendStatus
// NumValues: 0x0005
enum class EBlendStatus : uint8
{
	Inactive                                 = 0,
	Chosen                                   = 1,
	Dominant                                 = 2,
	Decay                                    = 3,
	EBlendStatus_MAX                         = 4,
};

// Enum MotionSymphony.ETransitionMethod
// NumValues: 0x0003
enum class ETransitionMethod : uint8
{
	None                                     = 0,
	Inertialization                          = 1,
	ETransitionMethod_MAX                    = 2,
};

// Enum MotionSymphony.EPastTrajectoryMode
// NumValues: 0x0003
enum class EPastTrajectoryMode : uint8
{
	ActualHistory                            = 0,
	CopyFromCurrentPose                      = 1,
	EPastTrajectoryMode_MAX                  = 2,
};

// Enum MotionSymphony.EMotionAnimAssetType
// NumValues: 0x0005
enum class EMotionAnimAssetType : uint8
{
	None                                     = 0,
	Sequence                                 = 1,
	BlendSpace                               = 2,
	Composite                                = 3,
	EMotionAnimAssetType_MAX                 = 4,
};

// Enum MotionSymphony.EMotionMatchingSearchQuality
// NumValues: 0x0003
enum class EMotionMatchingSearchQuality : uint8
{
	Performance                              = 0,
	Quality                                  = 1,
	EMotionMatchingSearchQuality_MAX         = 2,
};

// Enum MotionSymphony.ETrajectoryMoveMode
// NumValues: 0x0003
enum class ETrajectoryMoveMode : uint8
{
	Standard                                 = 0,
	Strafe                                   = 1,
	ETrajectoryMoveMode_MAX                  = 2,
};

// Enum MotionSymphony.ETrajectoryModel
// NumValues: 0x0003
enum class ETrajectoryModel : uint8
{
	Spring                                   = 0,
	UECharacterMovement                      = 1,
	ETrajectoryModel_MAX                     = 2,
};

// Enum MotionSymphony.ETrajectoryControlMode
// NumValues: 0x0003
enum class ETrajectoryControlMode : uint8
{
	PlayerControlled                         = 0,
	AIControlled                             = 1,
	ETrajectoryControlMode_MAX               = 2,
};

// Enum MotionSymphony.EPoseCategory
// NumValues: 0x0003
enum class EPoseCategory : uint8
{
	Quality                                  = 0,
	Responsiveness                           = 1,
	EPoseCategory_MAX                        = 2,
};

// Enum MotionSymphony.EMSFootLockId
// NumValues: 0x0009
enum class EMSFootLockId : uint8
{
	LeftFoot                                 = 0,
	RightFoot                                = 1,
	Foot3                                    = 2,
	Foot4                                    = 3,
	Foot5                                    = 4,
	Foot6                                    = 5,
	Foot7                                    = 6,
	Foot8                                    = 7,
	EMSFootLockId_MAX                        = 8,
};

// Enum MotionSymphony.EMotionCalibrationType
// NumValues: 0x0003
enum class EMotionCalibrationType : uint8
{
	Multiplier                               = 0,
	Override                                 = 1,
	EMotionCalibrationType_MAX               = 2,
};

// Enum MotionSymphony.EMSStrideVectorMethod
// NumValues: 0x0003
enum class EMSStrideVectorMethod : uint8
{
	ManualVelocity                           = 0,
	ActorVelocity                            = 1,
	EMSStrideVectorMethod_MAX                = 2,
};

// Enum MotionSymphony.EMSFootLockState
// NumValues: 0x0004
enum class EMSFootLockState : uint8
{
	Unlocked                                 = 0,
	Locked                                   = 1,
	TimeLocked                               = 2,
	EMSFootLockState_MAX                     = 3,
};

// Enum MotionSymphony.ETrajectoryErrorWarpMode
// NumValues: 0x0004
enum class ETrajectoryErrorWarpMode : uint8
{
	Disabled                                 = 0,
	Standard                                 = 1,
	Strafe                                   = 2,
	ETrajectoryErrorWarpMode_MAX             = 3,
};

// ScriptStruct MotionSymphony.AnimNode_MSDistanceMatching
// 0x0050 (0x0098 - 0x0048)
struct FAnimNode_MSDistanceMatching final : public FAnimNode_SequencePlayer
{
public:
	float                                         DesiredDistance;                                   // 0x0048(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   DistanceCurveName;                                 // 0x004C(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bNegateDistanceCurve;                              // 0x0054(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EDistanceMatchType                            MovementType;                                      // 0x0055(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_56[0x2];                                       // 0x0056(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         DistanceLimit;                                     // 0x0058(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DestinationReachedThreshold;                       // 0x005C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SmoothRate;                                        // 0x0060(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SmoothTimeThreshold;                               // 0x0064(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_68[0x28];                                      // 0x0068(0x0028)(Fixing Size After Last Property [ Dumper-7 ])
	class UAnimSequenceBase*                      LastAnimSequenceUsed;                              // 0x0090(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
};
static_assert(alignof(FAnimNode_MSDistanceMatching) == 0x000008, "Wrong alignment on FAnimNode_MSDistanceMatching");
static_assert(sizeof(FAnimNode_MSDistanceMatching) == 0x000098, "Wrong size on FAnimNode_MSDistanceMatching");
static_assert(offsetof(FAnimNode_MSDistanceMatching, DesiredDistance) == 0x000048, "Member 'FAnimNode_MSDistanceMatching::DesiredDistance' has a wrong offset!");
static_assert(offsetof(FAnimNode_MSDistanceMatching, DistanceCurveName) == 0x00004C, "Member 'FAnimNode_MSDistanceMatching::DistanceCurveName' has a wrong offset!");
static_assert(offsetof(FAnimNode_MSDistanceMatching, bNegateDistanceCurve) == 0x000054, "Member 'FAnimNode_MSDistanceMatching::bNegateDistanceCurve' has a wrong offset!");
static_assert(offsetof(FAnimNode_MSDistanceMatching, MovementType) == 0x000055, "Member 'FAnimNode_MSDistanceMatching::MovementType' has a wrong offset!");
static_assert(offsetof(FAnimNode_MSDistanceMatching, DistanceLimit) == 0x000058, "Member 'FAnimNode_MSDistanceMatching::DistanceLimit' has a wrong offset!");
static_assert(offsetof(FAnimNode_MSDistanceMatching, DestinationReachedThreshold) == 0x00005C, "Member 'FAnimNode_MSDistanceMatching::DestinationReachedThreshold' has a wrong offset!");
static_assert(offsetof(FAnimNode_MSDistanceMatching, SmoothRate) == 0x000060, "Member 'FAnimNode_MSDistanceMatching::SmoothRate' has a wrong offset!");
static_assert(offsetof(FAnimNode_MSDistanceMatching, SmoothTimeThreshold) == 0x000064, "Member 'FAnimNode_MSDistanceMatching::SmoothTimeThreshold' has a wrong offset!");
static_assert(offsetof(FAnimNode_MSDistanceMatching, LastAnimSequenceUsed) == 0x000090, "Member 'FAnimNode_MSDistanceMatching::LastAnimSequenceUsed' has a wrong offset!");

// ScriptStruct MotionSymphony.AnimChannelState
// 0x0050 (0x0050 - 0x0000)
struct FAnimChannelState final
{
public:
	int32                                         AnimId;                                            // 0x0000(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EMotionAnimAssetType                          AnimType;                                          // 0x0004(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5[0x3];                                        // 0x0005(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         StartPoseId;                                       // 0x0008(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         StartTime;                                         // 0x000C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              BlendSpacePosition;                                // 0x0010(0x0010)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AnimTime;                                          // 0x0020(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bLoop;                                             // 0x0024(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_25[0x3];                                       // 0x0025(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         PlayRate;                                          // 0x0028(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bMirrored;                                         // 0x002C(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2D[0x3];                                       // 0x002D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         AnimLength;                                        // 0x0030(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_34[0x14];                                      // 0x0034(0x0014)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         CachedTriangulationIndex;                          // 0x0048(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4C[0x4];                                       // 0x004C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FAnimChannelState) == 0x000008, "Wrong alignment on FAnimChannelState");
static_assert(sizeof(FAnimChannelState) == 0x000050, "Wrong size on FAnimChannelState");
static_assert(offsetof(FAnimChannelState, AnimId) == 0x000000, "Member 'FAnimChannelState::AnimId' has a wrong offset!");
static_assert(offsetof(FAnimChannelState, AnimType) == 0x000004, "Member 'FAnimChannelState::AnimType' has a wrong offset!");
static_assert(offsetof(FAnimChannelState, StartPoseId) == 0x000008, "Member 'FAnimChannelState::StartPoseId' has a wrong offset!");
static_assert(offsetof(FAnimChannelState, StartTime) == 0x00000C, "Member 'FAnimChannelState::StartTime' has a wrong offset!");
static_assert(offsetof(FAnimChannelState, BlendSpacePosition) == 0x000010, "Member 'FAnimChannelState::BlendSpacePosition' has a wrong offset!");
static_assert(offsetof(FAnimChannelState, AnimTime) == 0x000020, "Member 'FAnimChannelState::AnimTime' has a wrong offset!");
static_assert(offsetof(FAnimChannelState, bLoop) == 0x000024, "Member 'FAnimChannelState::bLoop' has a wrong offset!");
static_assert(offsetof(FAnimChannelState, PlayRate) == 0x000028, "Member 'FAnimChannelState::PlayRate' has a wrong offset!");
static_assert(offsetof(FAnimChannelState, bMirrored) == 0x00002C, "Member 'FAnimChannelState::bMirrored' has a wrong offset!");
static_assert(offsetof(FAnimChannelState, AnimLength) == 0x000030, "Member 'FAnimChannelState::AnimLength' has a wrong offset!");
static_assert(offsetof(FAnimChannelState, CachedTriangulationIndex) == 0x000048, "Member 'FAnimChannelState::CachedTriangulationIndex' has a wrong offset!");

// ScriptStruct MotionSymphony.MSFootLockLimbDefinition
// 0x0100 (0x0100 - 0x0000)
struct alignas(0x10) FMSFootLockLimbDefinition final
{
public:
	struct FBoneReference                         FootBone;                                          // 0x0000(0x0010)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FBoneReference                         ToeBone;                                           // 0x0010(0x0010)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FBoneReference                         IkTarget;                                          // 0x0020(0x0010)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	int32                                         LimbBoneCount;                                     // 0x0030(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_34[0xCC];                                      // 0x0034(0x00CC)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FMSFootLockLimbDefinition) == 0x000010, "Wrong alignment on FMSFootLockLimbDefinition");
static_assert(sizeof(FMSFootLockLimbDefinition) == 0x000100, "Wrong size on FMSFootLockLimbDefinition");
static_assert(offsetof(FMSFootLockLimbDefinition, FootBone) == 0x000000, "Member 'FMSFootLockLimbDefinition::FootBone' has a wrong offset!");
static_assert(offsetof(FMSFootLockLimbDefinition, ToeBone) == 0x000010, "Member 'FMSFootLockLimbDefinition::ToeBone' has a wrong offset!");
static_assert(offsetof(FMSFootLockLimbDefinition, IkTarget) == 0x000020, "Member 'FMSFootLockLimbDefinition::IkTarget' has a wrong offset!");
static_assert(offsetof(FMSFootLockLimbDefinition, LimbBoneCount) == 0x000030, "Member 'FMSFootLockLimbDefinition::LimbBoneCount' has a wrong offset!");

// ScriptStruct MotionSymphony.AnimNode_MSFootLocker
// 0x0268 (0x0330 - 0x00C8)
struct FAnimNode_MSFootLocker final : public FAnimNode_SkeletalControlBase
{
public:
	bool                                          bLeftFootLock;                                     // 0x00C8(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bRightFootLock;                                    // 0x00C9(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EMSHyperExtensionFixMethod                    LegHyperExtensionFixMethod;                        // 0x00CA(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_CB[0x1];                                       // 0x00CB(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         AllowLegExtensionRatio;                            // 0x00CC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LockReleaseSmoothTime;                             // 0x00D0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D4[0xC];                                       // 0x00D4(0x000C)(Fixing Size After Last Property [ Dumper-7 ])
	struct FMSFootLockLimbDefinition              LeftFootDefinition;                                // 0x00E0(0x0100)(Edit, NativeAccessSpecifierPublic)
	struct FMSFootLockLimbDefinition              RightFootDefinition;                               // 0x01E0(0x0100)(Edit, NativeAccessSpecifierPublic)
	uint8                                         Pad_2E0[0x50];                                     // 0x02E0(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FAnimNode_MSFootLocker) == 0x000010, "Wrong alignment on FAnimNode_MSFootLocker");
static_assert(sizeof(FAnimNode_MSFootLocker) == 0x000330, "Wrong size on FAnimNode_MSFootLocker");
static_assert(offsetof(FAnimNode_MSFootLocker, bLeftFootLock) == 0x0000C8, "Member 'FAnimNode_MSFootLocker::bLeftFootLock' has a wrong offset!");
static_assert(offsetof(FAnimNode_MSFootLocker, bRightFootLock) == 0x0000C9, "Member 'FAnimNode_MSFootLocker::bRightFootLock' has a wrong offset!");
static_assert(offsetof(FAnimNode_MSFootLocker, LegHyperExtensionFixMethod) == 0x0000CA, "Member 'FAnimNode_MSFootLocker::LegHyperExtensionFixMethod' has a wrong offset!");
static_assert(offsetof(FAnimNode_MSFootLocker, AllowLegExtensionRatio) == 0x0000CC, "Member 'FAnimNode_MSFootLocker::AllowLegExtensionRatio' has a wrong offset!");
static_assert(offsetof(FAnimNode_MSFootLocker, LockReleaseSmoothTime) == 0x0000D0, "Member 'FAnimNode_MSFootLocker::LockReleaseSmoothTime' has a wrong offset!");
static_assert(offsetof(FAnimNode_MSFootLocker, LeftFootDefinition) == 0x0000E0, "Member 'FAnimNode_MSFootLocker::LeftFootDefinition' has a wrong offset!");
static_assert(offsetof(FAnimNode_MSFootLocker, RightFootDefinition) == 0x0001E0, "Member 'FAnimNode_MSFootLocker::RightFootDefinition' has a wrong offset!");

// ScriptStruct MotionSymphony.MotionRecordData
// 0x0028 (0x0028 - 0x0000)
struct FMotionRecordData final
{
public:
	class UMotionMatchConfig*                     MotionMatchConfig;                                 // 0x0000(0x0008)(ZeroConstructor, Transient, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<float>                                 RecordedPoseArray;                                 // 0x0008(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPublic)
	TArray<float>                                 FeatureCacheData;                                  // 0x0018(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMotionRecordData) == 0x000008, "Wrong alignment on FMotionRecordData");
static_assert(sizeof(FMotionRecordData) == 0x000028, "Wrong size on FMotionRecordData");
static_assert(offsetof(FMotionRecordData, MotionMatchConfig) == 0x000000, "Member 'FMotionRecordData::MotionMatchConfig' has a wrong offset!");
static_assert(offsetof(FMotionRecordData, RecordedPoseArray) == 0x000008, "Member 'FMotionRecordData::RecordedPoseArray' has a wrong offset!");
static_assert(offsetof(FMotionRecordData, FeatureCacheData) == 0x000018, "Member 'FMotionRecordData::FeatureCacheData' has a wrong offset!");

// ScriptStruct MotionSymphony.AnimNode_MotionRecorder
// 0x0048 (0x0058 - 0x0010)
struct FAnimNode_MotionRecorder final : public FAnimNode_Base
{
public:
	struct FPoseLink                              Source;                                            // 0x0010(0x0010)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          bRetargetPose;                                     // 0x0020(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_21[0x7];                                       // 0x0021(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UMotionMatchConfig*>             MotionConfigs;                                     // 0x0028(0x0010)(Edit, ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
	uint8                                         Pad_38[0x20];                                      // 0x0038(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FAnimNode_MotionRecorder) == 0x000008, "Wrong alignment on FAnimNode_MotionRecorder");
static_assert(sizeof(FAnimNode_MotionRecorder) == 0x000058, "Wrong size on FAnimNode_MotionRecorder");
static_assert(offsetof(FAnimNode_MotionRecorder, Source) == 0x000010, "Member 'FAnimNode_MotionRecorder::Source' has a wrong offset!");
static_assert(offsetof(FAnimNode_MotionRecorder, bRetargetPose) == 0x000020, "Member 'FAnimNode_MotionRecorder::bRetargetPose' has a wrong offset!");
static_assert(offsetof(FAnimNode_MotionRecorder, MotionConfigs) == 0x000028, "Member 'FAnimNode_MotionRecorder::MotionConfigs' has a wrong offset!");

// ScriptStruct MotionSymphony.MotionMatchingInputData
// 0x0010 (0x0010 - 0x0000)
struct FMotionMatchingInputData final
{
public:
	TArray<float>                                 DesiredInputArray;                                 // 0x0000(0x0010)(BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMotionMatchingInputData) == 0x000008, "Wrong alignment on FMotionMatchingInputData");
static_assert(sizeof(FMotionMatchingInputData) == 0x000010, "Wrong size on FMotionMatchingInputData");
static_assert(offsetof(FMotionMatchingInputData, DesiredInputArray) == 0x000000, "Member 'FMotionMatchingInputData::DesiredInputArray' has a wrong offset!");

// ScriptStruct MotionSymphony.CalibrationData
// 0x0010 (0x0010 - 0x0000)
struct FCalibrationData final
{
public:
	TArray<float>                                 Weights;                                           // 0x0000(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCalibrationData) == 0x000008, "Wrong alignment on FCalibrationData");
static_assert(sizeof(FCalibrationData) == 0x000010, "Wrong size on FCalibrationData");
static_assert(offsetof(FCalibrationData, Weights) == 0x000000, "Member 'FCalibrationData::Weights' has a wrong offset!");

// ScriptStruct MotionSymphony.AnimNode_MSMotionMatching
// 0x01A8 (0x01E0 - 0x0038)
struct FAnimNode_MSMotionMatching final : public FAnimNode_AssetPlayerBase
{
public:
	struct FMotionMatchingInputData               InputData;                                         // 0x0038(0x0010)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	bool                                          bUserForcePoseSearch;                              // 0x0048(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_49[0x3];                                       // 0x0049(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         UpdateInterval;                                    // 0x004C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SamePoseTolerance;                                 // 0x0050(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PlaybackRate;                                      // 0x0054(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BlendTime;                                         // 0x0058(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         OverrideQualityVsResponsivenessRatio;              // 0x005C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMotionDataAsset*                       MotionData;                                        // 0x0060(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMotionCalibration*                     UserCalibration;                                   // 0x0068(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FCalibrationData>               FinalCalibrationSets;                              // 0x0070(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	EMotionMatchingSearchQuality                  SearchQuality;                                     // 0x0080(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETransitionMethod                             TransitionMethod;                                  // 0x0081(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EPastTrajectoryMode                           PastTrajectoryMode;                                // 0x0082(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bBlendInputResponse;                               // 0x0083(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         InputResponseBlendMagnitude;                       // 0x0084(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bFavourCurrentPose;                                // 0x0088(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_89[0x3];                                       // 0x0089(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         CurrentPoseFavour;                                 // 0x008C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         NextNaturalRange;                                  // 0x0090(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bNextNaturalToleranceTest;                         // 0x0094(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bFavourNextNatural;                                // 0x0095(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_96[0x2];                                       // 0x0096(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         NextNaturalFavour;                                 // 0x0098(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bEnableToleranceTest;                              // 0x009C(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9D[0x3];                                       // 0x009D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         PositionTolerance;                                 // 0x00A0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RotationTolerance;                                 // 0x00A4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTagContainer                  RequiredMotionTags;                                // 0x00A8(0x0020)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	uint8                                         Pad_C8[0x118];                                     // 0x00C8(0x0118)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FAnimNode_MSMotionMatching) == 0x000008, "Wrong alignment on FAnimNode_MSMotionMatching");
static_assert(sizeof(FAnimNode_MSMotionMatching) == 0x0001E0, "Wrong size on FAnimNode_MSMotionMatching");
static_assert(offsetof(FAnimNode_MSMotionMatching, InputData) == 0x000038, "Member 'FAnimNode_MSMotionMatching::InputData' has a wrong offset!");
static_assert(offsetof(FAnimNode_MSMotionMatching, bUserForcePoseSearch) == 0x000048, "Member 'FAnimNode_MSMotionMatching::bUserForcePoseSearch' has a wrong offset!");
static_assert(offsetof(FAnimNode_MSMotionMatching, UpdateInterval) == 0x00004C, "Member 'FAnimNode_MSMotionMatching::UpdateInterval' has a wrong offset!");
static_assert(offsetof(FAnimNode_MSMotionMatching, SamePoseTolerance) == 0x000050, "Member 'FAnimNode_MSMotionMatching::SamePoseTolerance' has a wrong offset!");
static_assert(offsetof(FAnimNode_MSMotionMatching, PlaybackRate) == 0x000054, "Member 'FAnimNode_MSMotionMatching::PlaybackRate' has a wrong offset!");
static_assert(offsetof(FAnimNode_MSMotionMatching, BlendTime) == 0x000058, "Member 'FAnimNode_MSMotionMatching::BlendTime' has a wrong offset!");
static_assert(offsetof(FAnimNode_MSMotionMatching, OverrideQualityVsResponsivenessRatio) == 0x00005C, "Member 'FAnimNode_MSMotionMatching::OverrideQualityVsResponsivenessRatio' has a wrong offset!");
static_assert(offsetof(FAnimNode_MSMotionMatching, MotionData) == 0x000060, "Member 'FAnimNode_MSMotionMatching::MotionData' has a wrong offset!");
static_assert(offsetof(FAnimNode_MSMotionMatching, UserCalibration) == 0x000068, "Member 'FAnimNode_MSMotionMatching::UserCalibration' has a wrong offset!");
static_assert(offsetof(FAnimNode_MSMotionMatching, FinalCalibrationSets) == 0x000070, "Member 'FAnimNode_MSMotionMatching::FinalCalibrationSets' has a wrong offset!");
static_assert(offsetof(FAnimNode_MSMotionMatching, SearchQuality) == 0x000080, "Member 'FAnimNode_MSMotionMatching::SearchQuality' has a wrong offset!");
static_assert(offsetof(FAnimNode_MSMotionMatching, TransitionMethod) == 0x000081, "Member 'FAnimNode_MSMotionMatching::TransitionMethod' has a wrong offset!");
static_assert(offsetof(FAnimNode_MSMotionMatching, PastTrajectoryMode) == 0x000082, "Member 'FAnimNode_MSMotionMatching::PastTrajectoryMode' has a wrong offset!");
static_assert(offsetof(FAnimNode_MSMotionMatching, bBlendInputResponse) == 0x000083, "Member 'FAnimNode_MSMotionMatching::bBlendInputResponse' has a wrong offset!");
static_assert(offsetof(FAnimNode_MSMotionMatching, InputResponseBlendMagnitude) == 0x000084, "Member 'FAnimNode_MSMotionMatching::InputResponseBlendMagnitude' has a wrong offset!");
static_assert(offsetof(FAnimNode_MSMotionMatching, bFavourCurrentPose) == 0x000088, "Member 'FAnimNode_MSMotionMatching::bFavourCurrentPose' has a wrong offset!");
static_assert(offsetof(FAnimNode_MSMotionMatching, CurrentPoseFavour) == 0x00008C, "Member 'FAnimNode_MSMotionMatching::CurrentPoseFavour' has a wrong offset!");
static_assert(offsetof(FAnimNode_MSMotionMatching, NextNaturalRange) == 0x000090, "Member 'FAnimNode_MSMotionMatching::NextNaturalRange' has a wrong offset!");
static_assert(offsetof(FAnimNode_MSMotionMatching, bNextNaturalToleranceTest) == 0x000094, "Member 'FAnimNode_MSMotionMatching::bNextNaturalToleranceTest' has a wrong offset!");
static_assert(offsetof(FAnimNode_MSMotionMatching, bFavourNextNatural) == 0x000095, "Member 'FAnimNode_MSMotionMatching::bFavourNextNatural' has a wrong offset!");
static_assert(offsetof(FAnimNode_MSMotionMatching, NextNaturalFavour) == 0x000098, "Member 'FAnimNode_MSMotionMatching::NextNaturalFavour' has a wrong offset!");
static_assert(offsetof(FAnimNode_MSMotionMatching, bEnableToleranceTest) == 0x00009C, "Member 'FAnimNode_MSMotionMatching::bEnableToleranceTest' has a wrong offset!");
static_assert(offsetof(FAnimNode_MSMotionMatching, PositionTolerance) == 0x0000A0, "Member 'FAnimNode_MSMotionMatching::PositionTolerance' has a wrong offset!");
static_assert(offsetof(FAnimNode_MSMotionMatching, RotationTolerance) == 0x0000A4, "Member 'FAnimNode_MSMotionMatching::RotationTolerance' has a wrong offset!");
static_assert(offsetof(FAnimNode_MSMotionMatching, RequiredMotionTags) == 0x0000A8, "Member 'FAnimNode_MSMotionMatching::RequiredMotionTags' has a wrong offset!");

// ScriptStruct MotionSymphony.PoseMatchData
// 0x0010 (0x0010 - 0x0000)
struct FPoseMatchData final
{
public:
	int32                                         PoseId;                                            // 0x0000(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         AnimId;                                            // 0x0004(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bMirror;                                           // 0x0008(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x3];                                        // 0x0009(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Time;                                              // 0x000C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FPoseMatchData) == 0x000004, "Wrong alignment on FPoseMatchData");
static_assert(sizeof(FPoseMatchData) == 0x000010, "Wrong size on FPoseMatchData");
static_assert(offsetof(FPoseMatchData, PoseId) == 0x000000, "Member 'FPoseMatchData::PoseId' has a wrong offset!");
static_assert(offsetof(FPoseMatchData, AnimId) == 0x000004, "Member 'FPoseMatchData::AnimId' has a wrong offset!");
static_assert(offsetof(FPoseMatchData, bMirror) == 0x000008, "Member 'FPoseMatchData::bMirror' has a wrong offset!");
static_assert(offsetof(FPoseMatchData, Time) == 0x00000C, "Member 'FPoseMatchData::Time' has a wrong offset!");

// ScriptStruct MotionSymphony.AnimNode_PoseMatchBase
// 0x00B0 (0x00F8 - 0x0048)
struct FAnimNode_PoseMatchBase : public FAnimNode_SequencePlayer
{
public:
	float                                         PoseInterval;                                      // 0x0048(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PosesEndTime;                                      // 0x004C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMotionMatchConfig*                     PoseConfig;                                        // 0x0050(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMotionCalibration*                     Calibration;                                       // 0x0058(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bEnableMirroring;                                  // 0x0060(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_61[0x7];                                       // 0x0061(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UMirrorDataTable*                       MirrorDataTable;                                   // 0x0068(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_70[0x8];                                       // 0x0070(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FPoseMatchData>                 Poses;                                             // 0x0078(0x0010)(ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	struct FCalibrationData                       FinalCalibration;                                  // 0x0088(0x0010)(Protected, NativeAccessSpecifierProtected)
	TArray<float>                                 PoseMatrix;                                        // 0x0098(0x0010)(ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	struct FCalibrationData                       StandardDeviation;                                 // 0x00A8(0x0010)(Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_B8[0x40];                                      // 0x00B8(0x0040)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FAnimNode_PoseMatchBase) == 0x000008, "Wrong alignment on FAnimNode_PoseMatchBase");
static_assert(sizeof(FAnimNode_PoseMatchBase) == 0x0000F8, "Wrong size on FAnimNode_PoseMatchBase");
static_assert(offsetof(FAnimNode_PoseMatchBase, PoseInterval) == 0x000048, "Member 'FAnimNode_PoseMatchBase::PoseInterval' has a wrong offset!");
static_assert(offsetof(FAnimNode_PoseMatchBase, PosesEndTime) == 0x00004C, "Member 'FAnimNode_PoseMatchBase::PosesEndTime' has a wrong offset!");
static_assert(offsetof(FAnimNode_PoseMatchBase, PoseConfig) == 0x000050, "Member 'FAnimNode_PoseMatchBase::PoseConfig' has a wrong offset!");
static_assert(offsetof(FAnimNode_PoseMatchBase, Calibration) == 0x000058, "Member 'FAnimNode_PoseMatchBase::Calibration' has a wrong offset!");
static_assert(offsetof(FAnimNode_PoseMatchBase, bEnableMirroring) == 0x000060, "Member 'FAnimNode_PoseMatchBase::bEnableMirroring' has a wrong offset!");
static_assert(offsetof(FAnimNode_PoseMatchBase, MirrorDataTable) == 0x000068, "Member 'FAnimNode_PoseMatchBase::MirrorDataTable' has a wrong offset!");
static_assert(offsetof(FAnimNode_PoseMatchBase, Poses) == 0x000078, "Member 'FAnimNode_PoseMatchBase::Poses' has a wrong offset!");
static_assert(offsetof(FAnimNode_PoseMatchBase, FinalCalibration) == 0x000088, "Member 'FAnimNode_PoseMatchBase::FinalCalibration' has a wrong offset!");
static_assert(offsetof(FAnimNode_PoseMatchBase, PoseMatrix) == 0x000098, "Member 'FAnimNode_PoseMatchBase::PoseMatrix' has a wrong offset!");
static_assert(offsetof(FAnimNode_PoseMatchBase, StandardDeviation) == 0x0000A8, "Member 'FAnimNode_PoseMatchBase::StandardDeviation' has a wrong offset!");

// ScriptStruct MotionSymphony.DistanceMatchingNodeData
// 0x001C (0x001C - 0x0000)
struct FDistanceMatchingNodeData final
{
public:
	class FName                                   DistanceCurveName;                                 // 0x0000(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bNegateDistanceCurve;                              // 0x0008(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EDistanceMatchType                            MovementType;                                      // 0x0009(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A[0x2];                                        // 0x000A(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         DistanceLimit;                                     // 0x000C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DestinationReachedThreshold;                       // 0x0010(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SmoothRate;                                        // 0x0014(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SmoothTimeThreshold;                               // 0x0018(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FDistanceMatchingNodeData) == 0x000004, "Wrong alignment on FDistanceMatchingNodeData");
static_assert(sizeof(FDistanceMatchingNodeData) == 0x00001C, "Wrong size on FDistanceMatchingNodeData");
static_assert(offsetof(FDistanceMatchingNodeData, DistanceCurveName) == 0x000000, "Member 'FDistanceMatchingNodeData::DistanceCurveName' has a wrong offset!");
static_assert(offsetof(FDistanceMatchingNodeData, bNegateDistanceCurve) == 0x000008, "Member 'FDistanceMatchingNodeData::bNegateDistanceCurve' has a wrong offset!");
static_assert(offsetof(FDistanceMatchingNodeData, MovementType) == 0x000009, "Member 'FDistanceMatchingNodeData::MovementType' has a wrong offset!");
static_assert(offsetof(FDistanceMatchingNodeData, DistanceLimit) == 0x00000C, "Member 'FDistanceMatchingNodeData::DistanceLimit' has a wrong offset!");
static_assert(offsetof(FDistanceMatchingNodeData, DestinationReachedThreshold) == 0x000010, "Member 'FDistanceMatchingNodeData::DestinationReachedThreshold' has a wrong offset!");
static_assert(offsetof(FDistanceMatchingNodeData, SmoothRate) == 0x000014, "Member 'FDistanceMatchingNodeData::SmoothRate' has a wrong offset!");
static_assert(offsetof(FDistanceMatchingNodeData, SmoothTimeThreshold) == 0x000018, "Member 'FDistanceMatchingNodeData::SmoothTimeThreshold' has a wrong offset!");

// ScriptStruct MotionSymphony.AnimNode_MultiPoseMatching
// 0x0050 (0x0148 - 0x00F8)
struct FAnimNode_MultiPoseMatching final : public FAnimNode_PoseMatchBase
{
public:
	TArray<class UAnimSequence*>                  Animations;                                        // 0x00F8(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	EDistanceMatchingUseCase                      DistanceMatchingUseCase;                           // 0x0108(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_109[0x3];                                      // 0x0109(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         DesiredDistance;                                   // 0x010C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FDistanceMatchingNodeData              DistanceMatchData;                                 // 0x0110(0x001C)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_12C[0x1C];                                     // 0x012C(0x001C)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FAnimNode_MultiPoseMatching) == 0x000008, "Wrong alignment on FAnimNode_MultiPoseMatching");
static_assert(sizeof(FAnimNode_MultiPoseMatching) == 0x000148, "Wrong size on FAnimNode_MultiPoseMatching");
static_assert(offsetof(FAnimNode_MultiPoseMatching, Animations) == 0x0000F8, "Member 'FAnimNode_MultiPoseMatching::Animations' has a wrong offset!");
static_assert(offsetof(FAnimNode_MultiPoseMatching, DistanceMatchingUseCase) == 0x000108, "Member 'FAnimNode_MultiPoseMatching::DistanceMatchingUseCase' has a wrong offset!");
static_assert(offsetof(FAnimNode_MultiPoseMatching, DesiredDistance) == 0x00010C, "Member 'FAnimNode_MultiPoseMatching::DesiredDistance' has a wrong offset!");
static_assert(offsetof(FAnimNode_MultiPoseMatching, DistanceMatchData) == 0x000110, "Member 'FAnimNode_MultiPoseMatching::DistanceMatchData' has a wrong offset!");

// ScriptStruct MotionSymphony.AnimNode_PoseMatching
// 0x0000 (0x00F8 - 0x00F8)
struct FAnimNode_PoseMatching final : public FAnimNode_PoseMatchBase
{
};
static_assert(alignof(FAnimNode_PoseMatching) == 0x000008, "Wrong alignment on FAnimNode_PoseMatching");
static_assert(sizeof(FAnimNode_PoseMatching) == 0x0000F8, "Wrong size on FAnimNode_PoseMatching");

// ScriptStruct MotionSymphony.AnimNode_RootMotionDecoupler
// 0x0108 (0x01D0 - 0x00C8)
struct alignas(0x10) FAnimNode_RootMotionDecoupler final : public FAnimNode_SkeletalControlBase
{
public:
	bool                                          bDecoupleLocation;                                 // 0x00C8(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EDecouplerClampMode                           TranslationClampMode;                              // 0x00C9(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_CA[0x2];                                       // 0x00CA(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         TranslationClampDistance;                          // 0x00CC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDecoupleRotation;                                 // 0x00D0(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EDecouplerClampMode                           RotationClampMode;                                 // 0x00D1(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D2[0x2];                                       // 0x00D2(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         RotationClampDegrees;                              // 0x00D4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D8[0xF8];                                      // 0x00D8(0x00F8)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FAnimNode_RootMotionDecoupler) == 0x000010, "Wrong alignment on FAnimNode_RootMotionDecoupler");
static_assert(sizeof(FAnimNode_RootMotionDecoupler) == 0x0001D0, "Wrong size on FAnimNode_RootMotionDecoupler");
static_assert(offsetof(FAnimNode_RootMotionDecoupler, bDecoupleLocation) == 0x0000C8, "Member 'FAnimNode_RootMotionDecoupler::bDecoupleLocation' has a wrong offset!");
static_assert(offsetof(FAnimNode_RootMotionDecoupler, TranslationClampMode) == 0x0000C9, "Member 'FAnimNode_RootMotionDecoupler::TranslationClampMode' has a wrong offset!");
static_assert(offsetof(FAnimNode_RootMotionDecoupler, TranslationClampDistance) == 0x0000CC, "Member 'FAnimNode_RootMotionDecoupler::TranslationClampDistance' has a wrong offset!");
static_assert(offsetof(FAnimNode_RootMotionDecoupler, bDecoupleRotation) == 0x0000D0, "Member 'FAnimNode_RootMotionDecoupler::bDecoupleRotation' has a wrong offset!");
static_assert(offsetof(FAnimNode_RootMotionDecoupler, RotationClampMode) == 0x0000D1, "Member 'FAnimNode_RootMotionDecoupler::RotationClampMode' has a wrong offset!");
static_assert(offsetof(FAnimNode_RootMotionDecoupler, RotationClampDegrees) == 0x0000D4, "Member 'FAnimNode_RootMotionDecoupler::RotationClampDegrees' has a wrong offset!");

// ScriptStruct MotionSymphony.AnimNode_TimeMatching
// 0x0020 (0x0068 - 0x0048)
struct FAnimNode_TimeMatching final : public FAnimNode_SequencePlayer
{
public:
	float                                         DesiredTime;                                       // 0x0048(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MarkerTime;                                        // 0x004C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_50[0x18];                                      // 0x0050(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FAnimNode_TimeMatching) == 0x000008, "Wrong alignment on FAnimNode_TimeMatching");
static_assert(sizeof(FAnimNode_TimeMatching) == 0x000068, "Wrong size on FAnimNode_TimeMatching");
static_assert(offsetof(FAnimNode_TimeMatching, DesiredTime) == 0x000048, "Member 'FAnimNode_TimeMatching::DesiredTime' has a wrong offset!");
static_assert(offsetof(FAnimNode_TimeMatching, MarkerTime) == 0x00004C, "Member 'FAnimNode_TimeMatching::MarkerTime' has a wrong offset!");

// ScriptStruct MotionSymphony.DistanceMatchingModule
// 0x0020 (0x0020 - 0x0000)
struct FDistanceMatchingModule final
{
public:
	class UAnimSequenceBase*                      AnimSequence;                                      // 0x0000(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_8[0x18];                                       // 0x0008(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FDistanceMatchingModule) == 0x000008, "Wrong alignment on FDistanceMatchingModule");
static_assert(sizeof(FDistanceMatchingModule) == 0x000020, "Wrong size on FDistanceMatchingModule");
static_assert(offsetof(FDistanceMatchingModule, AnimSequence) == 0x000000, "Member 'FDistanceMatchingModule::AnimSequence' has a wrong offset!");

// ScriptStruct MotionSymphony.TransitionAnimData
// 0x0070 (0x0070 - 0x0000)
struct FTransitionAnimData final
{
public:
	class UAnimSequence*                          AnimSequence;                                      // 0x0000(0x0008)(Edit, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                CurrentMove;                                       // 0x0008(0x0018)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                DesiredMove;                                       // 0x0020(0x0018)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETransitionDirectionMethod                    TransitionDirectionMethod;                         // 0x0038(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_39[0x3];                                       // 0x0039(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         CostMultiplier;                                    // 0x003C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bMirror;                                           // 0x0040(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_41[0x3];                                       // 0x0041(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         StartPose;                                         // 0x0044(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         EndPose;                                           // 0x0048(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4C[0x4];                                       // 0x004C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FDistanceMatchingModule                DistanceMatchModule;                               // 0x0050(0x0020)(Transient, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTransitionAnimData) == 0x000008, "Wrong alignment on FTransitionAnimData");
static_assert(sizeof(FTransitionAnimData) == 0x000070, "Wrong size on FTransitionAnimData");
static_assert(offsetof(FTransitionAnimData, AnimSequence) == 0x000000, "Member 'FTransitionAnimData::AnimSequence' has a wrong offset!");
static_assert(offsetof(FTransitionAnimData, CurrentMove) == 0x000008, "Member 'FTransitionAnimData::CurrentMove' has a wrong offset!");
static_assert(offsetof(FTransitionAnimData, DesiredMove) == 0x000020, "Member 'FTransitionAnimData::DesiredMove' has a wrong offset!");
static_assert(offsetof(FTransitionAnimData, TransitionDirectionMethod) == 0x000038, "Member 'FTransitionAnimData::TransitionDirectionMethod' has a wrong offset!");
static_assert(offsetof(FTransitionAnimData, CostMultiplier) == 0x00003C, "Member 'FTransitionAnimData::CostMultiplier' has a wrong offset!");
static_assert(offsetof(FTransitionAnimData, bMirror) == 0x000040, "Member 'FTransitionAnimData::bMirror' has a wrong offset!");
static_assert(offsetof(FTransitionAnimData, StartPose) == 0x000044, "Member 'FTransitionAnimData::StartPose' has a wrong offset!");
static_assert(offsetof(FTransitionAnimData, EndPose) == 0x000048, "Member 'FTransitionAnimData::EndPose' has a wrong offset!");
static_assert(offsetof(FTransitionAnimData, DistanceMatchModule) == 0x000050, "Member 'FTransitionAnimData::DistanceMatchModule' has a wrong offset!");

// ScriptStruct MotionSymphony.AnimNode_TransitionMatching
// 0x0090 (0x0188 - 0x00F8)
struct FAnimNode_TransitionMatching final : public FAnimNode_PoseMatchBase
{
public:
	struct FVector                                CurrentMoveVector;                                 // 0x00F8(0x0018)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                DesiredMoveVector;                                 // 0x0110(0x0018)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETransitionMatchingOrder                      TransitionMatchingOrder;                           // 0x0128(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_129[0x3];                                      // 0x0129(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         StartDirectionWeight;                              // 0x012C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         EndDirectionWeight;                                // 0x0130(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_134[0x4];                                      // 0x0134(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FTransitionAnimData>            TransitionAnimData;                                // 0x0138(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	EDistanceMatchingUseCase                      DistanceMatchingUseCase;                           // 0x0148(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_149[0x3];                                      // 0x0149(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         DesiredDistance;                                   // 0x014C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FDistanceMatchingNodeData              DistanceMatchData;                                 // 0x0150(0x001C)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_16C[0x4];                                      // 0x016C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FTransitionAnimData>            MirroredTransitionAnimData;                        // 0x0170(0x0010)(ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_180[0x8];                                      // 0x0180(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FAnimNode_TransitionMatching) == 0x000008, "Wrong alignment on FAnimNode_TransitionMatching");
static_assert(sizeof(FAnimNode_TransitionMatching) == 0x000188, "Wrong size on FAnimNode_TransitionMatching");
static_assert(offsetof(FAnimNode_TransitionMatching, CurrentMoveVector) == 0x0000F8, "Member 'FAnimNode_TransitionMatching::CurrentMoveVector' has a wrong offset!");
static_assert(offsetof(FAnimNode_TransitionMatching, DesiredMoveVector) == 0x000110, "Member 'FAnimNode_TransitionMatching::DesiredMoveVector' has a wrong offset!");
static_assert(offsetof(FAnimNode_TransitionMatching, TransitionMatchingOrder) == 0x000128, "Member 'FAnimNode_TransitionMatching::TransitionMatchingOrder' has a wrong offset!");
static_assert(offsetof(FAnimNode_TransitionMatching, StartDirectionWeight) == 0x00012C, "Member 'FAnimNode_TransitionMatching::StartDirectionWeight' has a wrong offset!");
static_assert(offsetof(FAnimNode_TransitionMatching, EndDirectionWeight) == 0x000130, "Member 'FAnimNode_TransitionMatching::EndDirectionWeight' has a wrong offset!");
static_assert(offsetof(FAnimNode_TransitionMatching, TransitionAnimData) == 0x000138, "Member 'FAnimNode_TransitionMatching::TransitionAnimData' has a wrong offset!");
static_assert(offsetof(FAnimNode_TransitionMatching, DistanceMatchingUseCase) == 0x000148, "Member 'FAnimNode_TransitionMatching::DistanceMatchingUseCase' has a wrong offset!");
static_assert(offsetof(FAnimNode_TransitionMatching, DesiredDistance) == 0x00014C, "Member 'FAnimNode_TransitionMatching::DesiredDistance' has a wrong offset!");
static_assert(offsetof(FAnimNode_TransitionMatching, DistanceMatchData) == 0x000150, "Member 'FAnimNode_TransitionMatching::DistanceMatchData' has a wrong offset!");
static_assert(offsetof(FAnimNode_TransitionMatching, MirroredTransitionAnimData) == 0x000170, "Member 'FAnimNode_TransitionMatching::MirroredTransitionAnimData' has a wrong offset!");

// ScriptStruct MotionSymphony.InputSet
// 0x0020 (0x0020 - 0x0000)
struct FInputSet final
{
public:
	struct FVector2D                              InputRemapRange;                                   // 0x0000(0x0010)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SpeedMultiplier;                                   // 0x0010(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MoveResponseMultiplier;                            // 0x0014(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TurnResponseMultiplier;                            // 0x0018(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C[0x4];                                       // 0x001C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FInputSet) == 0x000008, "Wrong alignment on FInputSet");
static_assert(sizeof(FInputSet) == 0x000020, "Wrong size on FInputSet");
static_assert(offsetof(FInputSet, InputRemapRange) == 0x000000, "Member 'FInputSet::InputRemapRange' has a wrong offset!");
static_assert(offsetof(FInputSet, SpeedMultiplier) == 0x000010, "Member 'FInputSet::SpeedMultiplier' has a wrong offset!");
static_assert(offsetof(FInputSet, MoveResponseMultiplier) == 0x000014, "Member 'FInputSet::MoveResponseMultiplier' has a wrong offset!");
static_assert(offsetof(FInputSet, TurnResponseMultiplier) == 0x000018, "Member 'FInputSet::TurnResponseMultiplier' has a wrong offset!");

// ScriptStruct MotionSymphony.InputProfile
// 0x0010 (0x0010 - 0x0000)
struct FInputProfile final
{
public:
	TArray<struct FInputSet>                      InputSets;                                         // 0x0000(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FInputProfile) == 0x000008, "Wrong alignment on FInputProfile");
static_assert(sizeof(FInputProfile) == 0x000010, "Wrong size on FInputProfile");
static_assert(offsetof(FInputProfile, InputSets) == 0x000000, "Member 'FInputProfile::InputSets' has a wrong offset!");

// ScriptStruct MotionSymphony.JointData
// 0x0030 (0x0030 - 0x0000)
struct FJointData final
{
public:
	struct FVector                                Position;                                          // 0x0000(0x0018)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Velocity;                                          // 0x0018(0x0018)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FJointData) == 0x000008, "Wrong alignment on FJointData");
static_assert(sizeof(FJointData) == 0x000030, "Wrong size on FJointData");
static_assert(offsetof(FJointData, Position) == 0x000000, "Member 'FJointData::Position' has a wrong offset!");
static_assert(offsetof(FJointData, Velocity) == 0x000018, "Member 'FJointData::Velocity' has a wrong offset!");

// ScriptStruct MotionSymphony.MotionAnimAsset
// 0x0070 (0x0070 - 0x0000)
struct FMotionAnimAsset
{
public:
	uint8                                         Pad_0[0x8];                                        // 0x0000(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         AnimId;                                            // 0x0008(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EMotionAnimAssetType                          MotionAnimAssetType;                               // 0x000C(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bLoop;                                             // 0x000D(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_E[0x2];                                        // 0x000E(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         PlayRate;                                          // 0x0010(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bEnableMirroring;                                  // 0x0014(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bFlattenTrajectory;                                // 0x0015(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETrajectoryPreProcessMethod                   PastTrajectory;                                    // 0x0016(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETrajectoryPreProcessMethod                   FutureTrajectory;                                  // 0x0017(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimationAsset*                        AnimAsset;                                         // 0x0018(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          PrecedingMotion;                                   // 0x0020(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          FollowingMotion;                                   // 0x0028(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CostMultiplier;                                    // 0x0030(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_34[0x4];                                       // 0x0034(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTagContainer                  MotionTags;                                        // 0x0038(0x0020)(NativeAccessSpecifierPublic)
	TArray<struct FAnimNotifyEvent>               Tags;                                              // 0x0058(0x0010)(ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	class UMotionDataAsset*                       ParentMotionDataAsset;                             // 0x0068(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMotionAnimAsset) == 0x000008, "Wrong alignment on FMotionAnimAsset");
static_assert(sizeof(FMotionAnimAsset) == 0x000070, "Wrong size on FMotionAnimAsset");
static_assert(offsetof(FMotionAnimAsset, AnimId) == 0x000008, "Member 'FMotionAnimAsset::AnimId' has a wrong offset!");
static_assert(offsetof(FMotionAnimAsset, MotionAnimAssetType) == 0x00000C, "Member 'FMotionAnimAsset::MotionAnimAssetType' has a wrong offset!");
static_assert(offsetof(FMotionAnimAsset, bLoop) == 0x00000D, "Member 'FMotionAnimAsset::bLoop' has a wrong offset!");
static_assert(offsetof(FMotionAnimAsset, PlayRate) == 0x000010, "Member 'FMotionAnimAsset::PlayRate' has a wrong offset!");
static_assert(offsetof(FMotionAnimAsset, bEnableMirroring) == 0x000014, "Member 'FMotionAnimAsset::bEnableMirroring' has a wrong offset!");
static_assert(offsetof(FMotionAnimAsset, bFlattenTrajectory) == 0x000015, "Member 'FMotionAnimAsset::bFlattenTrajectory' has a wrong offset!");
static_assert(offsetof(FMotionAnimAsset, PastTrajectory) == 0x000016, "Member 'FMotionAnimAsset::PastTrajectory' has a wrong offset!");
static_assert(offsetof(FMotionAnimAsset, FutureTrajectory) == 0x000017, "Member 'FMotionAnimAsset::FutureTrajectory' has a wrong offset!");
static_assert(offsetof(FMotionAnimAsset, AnimAsset) == 0x000018, "Member 'FMotionAnimAsset::AnimAsset' has a wrong offset!");
static_assert(offsetof(FMotionAnimAsset, PrecedingMotion) == 0x000020, "Member 'FMotionAnimAsset::PrecedingMotion' has a wrong offset!");
static_assert(offsetof(FMotionAnimAsset, FollowingMotion) == 0x000028, "Member 'FMotionAnimAsset::FollowingMotion' has a wrong offset!");
static_assert(offsetof(FMotionAnimAsset, CostMultiplier) == 0x000030, "Member 'FMotionAnimAsset::CostMultiplier' has a wrong offset!");
static_assert(offsetof(FMotionAnimAsset, MotionTags) == 0x000038, "Member 'FMotionAnimAsset::MotionTags' has a wrong offset!");
static_assert(offsetof(FMotionAnimAsset, Tags) == 0x000058, "Member 'FMotionAnimAsset::Tags' has a wrong offset!");
static_assert(offsetof(FMotionAnimAsset, ParentMotionDataAsset) == 0x000068, "Member 'FMotionAnimAsset::ParentMotionDataAsset' has a wrong offset!");

// ScriptStruct MotionSymphony.MotionAnimSequence
// 0x0008 (0x0078 - 0x0070)
struct FMotionAnimSequence final : public FMotionAnimAsset
{
public:
	class UAnimSequence*                          Sequence;                                          // 0x0070(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMotionAnimSequence) == 0x000008, "Wrong alignment on FMotionAnimSequence");
static_assert(sizeof(FMotionAnimSequence) == 0x000078, "Wrong size on FMotionAnimSequence");
static_assert(offsetof(FMotionAnimSequence, Sequence) == 0x000070, "Member 'FMotionAnimSequence::Sequence' has a wrong offset!");

// ScriptStruct MotionSymphony.MotionBlendSpace
// 0x0018 (0x0088 - 0x0070)
struct FMotionBlendSpace final : public FMotionAnimAsset
{
public:
	class UBlendSpace*                            BlendSpace;                                        // 0x0070(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              SampleSpacing;                                     // 0x0078(0x0010)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMotionBlendSpace) == 0x000008, "Wrong alignment on FMotionBlendSpace");
static_assert(sizeof(FMotionBlendSpace) == 0x000088, "Wrong size on FMotionBlendSpace");
static_assert(offsetof(FMotionBlendSpace, BlendSpace) == 0x000070, "Member 'FMotionBlendSpace::BlendSpace' has a wrong offset!");
static_assert(offsetof(FMotionBlendSpace, SampleSpacing) == 0x000078, "Member 'FMotionBlendSpace::SampleSpacing' has a wrong offset!");

// ScriptStruct MotionSymphony.MotionComposite
// 0x0008 (0x0078 - 0x0070)
struct FMotionComposite final : public FMotionAnimAsset
{
public:
	class UAnimComposite*                         AnimComposite;                                     // 0x0070(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMotionComposite) == 0x000008, "Wrong alignment on FMotionComposite");
static_assert(sizeof(FMotionComposite) == 0x000078, "Wrong size on FMotionComposite");
static_assert(offsetof(FMotionComposite, AnimComposite) == 0x000070, "Member 'FMotionComposite::AnimComposite' has a wrong offset!");

// ScriptStruct MotionSymphony.MotionTagEvent
// 0x0060 (0x0090 - 0x0030)
struct FMotionTagEvent final : public FAnimLinkableElement
{
public:
	class FName                                   TagName;                                           // 0x0030(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMotionTag*                             Tag;                                               // 0x0038(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, PersistentInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Duration;                                          // 0x0040(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_44[0x4];                                       // 0x0044(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FAnimLinkableElement                   EndLink;                                           // 0x0048(0x0030)(NativeAccessSpecifierPublic)
	int32                                         TrackIndex;                                        // 0x0078(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_7C[0x14];                                      // 0x007C(0x0014)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FMotionTagEvent) == 0x000008, "Wrong alignment on FMotionTagEvent");
static_assert(sizeof(FMotionTagEvent) == 0x000090, "Wrong size on FMotionTagEvent");
static_assert(offsetof(FMotionTagEvent, TagName) == 0x000030, "Member 'FMotionTagEvent::TagName' has a wrong offset!");
static_assert(offsetof(FMotionTagEvent, Tag) == 0x000038, "Member 'FMotionTagEvent::Tag' has a wrong offset!");
static_assert(offsetof(FMotionTagEvent, Duration) == 0x000040, "Member 'FMotionTagEvent::Duration' has a wrong offset!");
static_assert(offsetof(FMotionTagEvent, EndLink) == 0x000048, "Member 'FMotionTagEvent::EndLink' has a wrong offset!");
static_assert(offsetof(FMotionTagEvent, TrackIndex) == 0x000078, "Member 'FMotionTagEvent::TrackIndex' has a wrong offset!");

// ScriptStruct MotionSymphony.MSFootLockData
// 0x0008 (0x0008 - 0x0000)
struct FMSFootLockData final
{
public:
	EMSFootLockState                              LockState;                                         // 0x0000(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         RemainingLockTime;                                 // 0x0004(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMSFootLockData) == 0x000004, "Wrong alignment on FMSFootLockData");
static_assert(sizeof(FMSFootLockData) == 0x000008, "Wrong size on FMSFootLockData");
static_assert(offsetof(FMSFootLockData, LockState) == 0x000000, "Member 'FMSFootLockData::LockState' has a wrong offset!");
static_assert(offsetof(FMSFootLockData, RemainingLockTime) == 0x000004, "Member 'FMSFootLockData::RemainingLockTime' has a wrong offset!");

// ScriptStruct MotionSymphony.PoseMatrix
// 0x0018 (0x0018 - 0x0000)
struct FPoseMatrix final
{
public:
	int32                                         PoseCount;                                         // 0x0000(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         AtomCount;                                         // 0x0004(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<float>                                 PoseArray;                                         // 0x0008(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FPoseMatrix) == 0x000008, "Wrong alignment on FPoseMatrix");
static_assert(sizeof(FPoseMatrix) == 0x000018, "Wrong size on FPoseMatrix");
static_assert(offsetof(FPoseMatrix, PoseCount) == 0x000000, "Member 'FPoseMatrix::PoseCount' has a wrong offset!");
static_assert(offsetof(FPoseMatrix, AtomCount) == 0x000004, "Member 'FPoseMatrix::AtomCount' has a wrong offset!");
static_assert(offsetof(FPoseMatrix, PoseArray) == 0x000008, "Member 'FPoseMatrix::PoseArray' has a wrong offset!");

// ScriptStruct MotionSymphony.PoseMatrixSection
// 0x0008 (0x0008 - 0x0000)
struct FPoseMatrixSection final
{
public:
	int32                                         StartIndex;                                        // 0x0000(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         EndIndex;                                          // 0x0004(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FPoseMatrixSection) == 0x000004, "Wrong alignment on FPoseMatrixSection");
static_assert(sizeof(FPoseMatrixSection) == 0x000008, "Wrong size on FPoseMatrixSection");
static_assert(offsetof(FPoseMatrixSection, StartIndex) == 0x000000, "Member 'FPoseMatrixSection::StartIndex' has a wrong offset!");
static_assert(offsetof(FPoseMatrixSection, EndIndex) == 0x000004, "Member 'FPoseMatrixSection::EndIndex' has a wrong offset!");

// ScriptStruct MotionSymphony.PoseAABBMatrix
// 0x0018 (0x0018 - 0x0000)
struct FPoseAABBMatrix final
{
public:
	float                                         DimCount;                                          // 0x0000(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AABBCount;                                         // 0x0004(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<float>                                 ExtentsArray;                                      // 0x0008(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FPoseAABBMatrix) == 0x000008, "Wrong alignment on FPoseAABBMatrix");
static_assert(sizeof(FPoseAABBMatrix) == 0x000018, "Wrong size on FPoseAABBMatrix");
static_assert(offsetof(FPoseAABBMatrix, DimCount) == 0x000000, "Member 'FPoseAABBMatrix::DimCount' has a wrong offset!");
static_assert(offsetof(FPoseAABBMatrix, AABBCount) == 0x000004, "Member 'FPoseAABBMatrix::AABBCount' has a wrong offset!");
static_assert(offsetof(FPoseAABBMatrix, ExtentsArray) == 0x000008, "Member 'FPoseAABBMatrix::ExtentsArray' has a wrong offset!");

// ScriptStruct MotionSymphony.PoseMotionData
// 0x0050 (0x0050 - 0x0000)
struct FPoseMotionData final
{
public:
	int32                                         PoseId;                                            // 0x0000(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EMotionAnimAssetType                          AnimType;                                          // 0x0004(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5[0x3];                                        // 0x0005(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         AnimId;                                            // 0x0008(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Time;                                              // 0x000C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              BlendSpacePosition;                                // 0x0010(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         NextPoseId;                                        // 0x0020(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         LastPoseId;                                        // 0x0024(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bMirrored;                                         // 0x0028(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EPoseSearchFlag                               SearchFlag;                                        // 0x0029(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2A[0x6];                                       // 0x002A(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTagContainer                  MotionTags;                                        // 0x0030(0x0020)(BlueprintVisible, NativeAccessSpecifierPublic)
};
static_assert(alignof(FPoseMotionData) == 0x000008, "Wrong alignment on FPoseMotionData");
static_assert(sizeof(FPoseMotionData) == 0x000050, "Wrong size on FPoseMotionData");
static_assert(offsetof(FPoseMotionData, PoseId) == 0x000000, "Member 'FPoseMotionData::PoseId' has a wrong offset!");
static_assert(offsetof(FPoseMotionData, AnimType) == 0x000004, "Member 'FPoseMotionData::AnimType' has a wrong offset!");
static_assert(offsetof(FPoseMotionData, AnimId) == 0x000008, "Member 'FPoseMotionData::AnimId' has a wrong offset!");
static_assert(offsetof(FPoseMotionData, Time) == 0x00000C, "Member 'FPoseMotionData::Time' has a wrong offset!");
static_assert(offsetof(FPoseMotionData, BlendSpacePosition) == 0x000010, "Member 'FPoseMotionData::BlendSpacePosition' has a wrong offset!");
static_assert(offsetof(FPoseMotionData, NextPoseId) == 0x000020, "Member 'FPoseMotionData::NextPoseId' has a wrong offset!");
static_assert(offsetof(FPoseMotionData, LastPoseId) == 0x000024, "Member 'FPoseMotionData::LastPoseId' has a wrong offset!");
static_assert(offsetof(FPoseMotionData, bMirrored) == 0x000028, "Member 'FPoseMotionData::bMirrored' has a wrong offset!");
static_assert(offsetof(FPoseMotionData, SearchFlag) == 0x000029, "Member 'FPoseMotionData::SearchFlag' has a wrong offset!");
static_assert(offsetof(FPoseMotionData, MotionTags) == 0x000030, "Member 'FPoseMotionData::MotionTags' has a wrong offset!");

// ScriptStruct MotionSymphony.TrajectoryPoint
// 0x0020 (0x0020 - 0x0000)
struct FTrajectoryPoint final
{
public:
	struct FVector                                Position;                                          // 0x0000(0x0018)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RotationZ;                                         // 0x0018(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C[0x4];                                       // 0x001C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FTrajectoryPoint) == 0x000008, "Wrong alignment on FTrajectoryPoint");
static_assert(sizeof(FTrajectoryPoint) == 0x000020, "Wrong size on FTrajectoryPoint");
static_assert(offsetof(FTrajectoryPoint, Position) == 0x000000, "Member 'FTrajectoryPoint::Position' has a wrong offset!");
static_assert(offsetof(FTrajectoryPoint, RotationZ) == 0x000018, "Member 'FTrajectoryPoint::RotationZ' has a wrong offset!");

// ScriptStruct MotionSymphony.Trajectory
// 0x0010 (0x0010 - 0x0000)
struct FTrajectory final
{
public:
	TArray<struct FTrajectoryPoint>               TrajectoryPoints;                                  // 0x0000(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTrajectory) == 0x000008, "Wrong alignment on FTrajectory");
static_assert(sizeof(FTrajectory) == 0x000010, "Wrong size on FTrajectory");
static_assert(offsetof(FTrajectory, TrajectoryPoints) == 0x000000, "Member 'FTrajectory::TrajectoryPoints' has a wrong offset!");

}

