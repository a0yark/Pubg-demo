#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: CharacterSkinSystem

#include "Basic.hpp"

#include "CoreUObject_structs.hpp"


namespace SDK
{

// Enum CharacterSkinSystem.EPrimitiveGizmoType
// NumValues: 0x0005
enum class EPrimitiveGizmoType : uint8
{
	EPGT_None                                = 0,
	EPGT_Box                                 = 1,
	EPGT_Cylinder                            = 2,
	EPGT_Sphere                              = 3,
	EPGT_MAX                                 = 4,
};

// Enum CharacterSkinSystem.EGizmoSceneDepthPriorityGroup
// NumValues: 0x0003
enum class EGizmoSceneDepthPriorityGroup : uint8
{
	GSDPG_World                              = 0,
	GSDPG_Foreground                         = 1,
	GSDPG_MAX                                = 2,
};

// Enum CharacterSkinSystem.ECutMeshCommandType
// NumValues: 0x0003
enum class ECutMeshCommandType : uint8
{
	Boolean                                  = 0,
	Jacket                                   = 1,
	MAX                                      = 2,
};

// Enum CharacterSkinSystem.EPipelineCachingPriority
// NumValues: 0x0005
enum class EPipelineCachingPriority : uint8
{
	Normal                                   = 0,
	High                                     = 1,
	Low                                      = 2,
	None                                     = 3,
	MAX                                      = 4,
};

// Enum CharacterSkinSystem.EDebugMeshFlags
// NumValues: 0x0003
enum class EDebugMeshFlags : uint8
{
	None                                     = 0,
	ShowWireframe                            = 1,
	EDebugMeshFlags_MAX                      = 2,
};

// Enum CharacterSkinSystem.ESkinMeshLODDataType
// NumValues: 0x0003
enum class ESkinMeshLODDataType : uint8
{
	ImportedModel                            = 0,
	RenderData                               = 1,
	ESkinMeshLODDataType_MAX                 = 2,
};

// Enum CharacterSkinSystem.EWrapOperationType
// NumValues: 0x0004
enum class EWrapOperationType : uint8
{
	WrapInside                               = 0,
	WrapOutside                              = 1,
	WrapBoth                                 = 2,
	EWrapOperationType_MAX                   = 3,
};

// Enum CharacterSkinSystem.EBooleanOperationType
// NumValues: 0x0005
enum class EBooleanOperationType : uint8
{
	Union                                    = 0,
	Intersection                             = 1,
	Subtract                                 = 2,
	Trim                                     = 3,
	EBooleanOperationType_MAX                = 4,
};

// ScriptStruct CharacterSkinSystem.SkinCommandMirrorSettings
// 0x0030 (0x0030 - 0x0000)
struct FSkinCommandMirrorSettings final
{
public:
	EAxis                                         MirrorAxis;                                        // 0x0000(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EAxis                                         AxisToFlip;                                        // 0x0001(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2[0x6];                                        // 0x0002(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 SearchString;                                      // 0x0008(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 ReplaceString;                                     // 0x0018(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUseMirroredDeformer;                              // 0x0028(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_29[0x7];                                       // 0x0029(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FSkinCommandMirrorSettings) == 0x000008, "Wrong alignment on FSkinCommandMirrorSettings");
static_assert(sizeof(FSkinCommandMirrorSettings) == 0x000030, "Wrong size on FSkinCommandMirrorSettings");
static_assert(offsetof(FSkinCommandMirrorSettings, MirrorAxis) == 0x000000, "Member 'FSkinCommandMirrorSettings::MirrorAxis' has a wrong offset!");
static_assert(offsetof(FSkinCommandMirrorSettings, AxisToFlip) == 0x000001, "Member 'FSkinCommandMirrorSettings::AxisToFlip' has a wrong offset!");
static_assert(offsetof(FSkinCommandMirrorSettings, SearchString) == 0x000008, "Member 'FSkinCommandMirrorSettings::SearchString' has a wrong offset!");
static_assert(offsetof(FSkinCommandMirrorSettings, ReplaceString) == 0x000018, "Member 'FSkinCommandMirrorSettings::ReplaceString' has a wrong offset!");
static_assert(offsetof(FSkinCommandMirrorSettings, bUseMirroredDeformer) == 0x000028, "Member 'FSkinCommandMirrorSettings::bUseMirroredDeformer' has a wrong offset!");

// ScriptStruct CharacterSkinSystem.PrimitiveGizmo
// 0x00B0 (0x00B0 - 0x0000)
struct FPrimitiveGizmo final
{
public:
	class FString                                 PropertyName;                                      // 0x0000(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FTransform                             Transform;                                         // 0x0010(0x0060)(Edit, BlueprintVisible, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Height;                                            // 0x0070(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Radius;                                            // 0x0074(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Min;                                               // 0x0078(0x0018)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Max;                                               // 0x0090(0x0018)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EPrimitiveGizmoType                           GizmoType;                                         // 0x00A8(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A9[0x7];                                       // 0x00A9(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FPrimitiveGizmo) == 0x000010, "Wrong alignment on FPrimitiveGizmo");
static_assert(sizeof(FPrimitiveGizmo) == 0x0000B0, "Wrong size on FPrimitiveGizmo");
static_assert(offsetof(FPrimitiveGizmo, PropertyName) == 0x000000, "Member 'FPrimitiveGizmo::PropertyName' has a wrong offset!");
static_assert(offsetof(FPrimitiveGizmo, Transform) == 0x000010, "Member 'FPrimitiveGizmo::Transform' has a wrong offset!");
static_assert(offsetof(FPrimitiveGizmo, Height) == 0x000070, "Member 'FPrimitiveGizmo::Height' has a wrong offset!");
static_assert(offsetof(FPrimitiveGizmo, Radius) == 0x000074, "Member 'FPrimitiveGizmo::Radius' has a wrong offset!");
static_assert(offsetof(FPrimitiveGizmo, Min) == 0x000078, "Member 'FPrimitiveGizmo::Min' has a wrong offset!");
static_assert(offsetof(FPrimitiveGizmo, Max) == 0x000090, "Member 'FPrimitiveGizmo::Max' has a wrong offset!");
static_assert(offsetof(FPrimitiveGizmo, GizmoType) == 0x0000A8, "Member 'FPrimitiveGizmo::GizmoType' has a wrong offset!");

// ScriptStruct CharacterSkinSystem.PrimitiveGizmoInfo
// 0x0120 (0x0120 - 0x0000)
struct FPrimitiveGizmoInfo final
{
public:
	struct FTransform                             LocalToWorld;                                      // 0x0000(0x0060)(Edit, BlueprintVisible, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FPrimitiveGizmo                        Gizmo;                                             // 0x0060(0x00B0)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	bool                                          bClickable;                                        // 0x0110(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EGizmoSceneDepthPriorityGroup                 GizmoDepthPriorityGroup;                           // 0x0111(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_112[0xE];                                      // 0x0112(0x000E)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FPrimitiveGizmoInfo) == 0x000010, "Wrong alignment on FPrimitiveGizmoInfo");
static_assert(sizeof(FPrimitiveGizmoInfo) == 0x000120, "Wrong size on FPrimitiveGizmoInfo");
static_assert(offsetof(FPrimitiveGizmoInfo, LocalToWorld) == 0x000000, "Member 'FPrimitiveGizmoInfo::LocalToWorld' has a wrong offset!");
static_assert(offsetof(FPrimitiveGizmoInfo, Gizmo) == 0x000060, "Member 'FPrimitiveGizmoInfo::Gizmo' has a wrong offset!");
static_assert(offsetof(FPrimitiveGizmoInfo, bClickable) == 0x000110, "Member 'FPrimitiveGizmoInfo::bClickable' has a wrong offset!");
static_assert(offsetof(FPrimitiveGizmoInfo, GizmoDepthPriorityGroup) == 0x000111, "Member 'FPrimitiveGizmoInfo::GizmoDepthPriorityGroup' has a wrong offset!");

// ScriptStruct CharacterSkinSystem.CharacterSkinDebugData
// 0x0020 (0x0020 - 0x0000)
struct FCharacterSkinDebugData final
{
public:
	int32                                         LODIndex;                                          // 0x0000(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Name;                                              // 0x0004(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UDynamicMesh*                           DebugMesh;                                         // 0x0010(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FColor                                 Color;                                             // 0x0018(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EDebugMeshFlags                               Flag;                                              // 0x001C(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1D[0x3];                                       // 0x001D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FCharacterSkinDebugData) == 0x000008, "Wrong alignment on FCharacterSkinDebugData");
static_assert(sizeof(FCharacterSkinDebugData) == 0x000020, "Wrong size on FCharacterSkinDebugData");
static_assert(offsetof(FCharacterSkinDebugData, LODIndex) == 0x000000, "Member 'FCharacterSkinDebugData::LODIndex' has a wrong offset!");
static_assert(offsetof(FCharacterSkinDebugData, Name) == 0x000004, "Member 'FCharacterSkinDebugData::Name' has a wrong offset!");
static_assert(offsetof(FCharacterSkinDebugData, DebugMesh) == 0x000010, "Member 'FCharacterSkinDebugData::DebugMesh' has a wrong offset!");
static_assert(offsetof(FCharacterSkinDebugData, Color) == 0x000018, "Member 'FCharacterSkinDebugData::Color' has a wrong offset!");
static_assert(offsetof(FCharacterSkinDebugData, Flag) == 0x00001C, "Member 'FCharacterSkinDebugData::Flag' has a wrong offset!");

// ScriptStruct CharacterSkinSystem.ImmatureSkeletalMesh
// 0x0010 (0x0010 - 0x0000)
struct FImmatureSkeletalMesh final
{
public:
	class USkeletalMesh*                          SkeletalMesh;                                      // 0x0000(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_8[0x8];                                        // 0x0008(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FImmatureSkeletalMesh) == 0x000008, "Wrong alignment on FImmatureSkeletalMesh");
static_assert(sizeof(FImmatureSkeletalMesh) == 0x000010, "Wrong size on FImmatureSkeletalMesh");
static_assert(offsetof(FImmatureSkeletalMesh, SkeletalMesh) == 0x000000, "Member 'FImmatureSkeletalMesh::SkeletalMesh' has a wrong offset!");

// ScriptStruct CharacterSkinSystem.PipelineInitParams
// 0x0018 (0x0018 - 0x0000)
struct FPipelineInitParams final
{
public:
	class USkeletalMesh*                          ReferenceMesh;                                     // 0x0000(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UObject*                                OuterObject;                                       // 0x0008(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EPipelineCachingPriority                      CachingPriority;                                   // 0x0010(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsCacheEnabled;                                   // 0x0011(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_12[0x6];                                       // 0x0012(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FPipelineInitParams) == 0x000008, "Wrong alignment on FPipelineInitParams");
static_assert(sizeof(FPipelineInitParams) == 0x000018, "Wrong size on FPipelineInitParams");
static_assert(offsetof(FPipelineInitParams, ReferenceMesh) == 0x000000, "Member 'FPipelineInitParams::ReferenceMesh' has a wrong offset!");
static_assert(offsetof(FPipelineInitParams, OuterObject) == 0x000008, "Member 'FPipelineInitParams::OuterObject' has a wrong offset!");
static_assert(offsetof(FPipelineInitParams, CachingPriority) == 0x000010, "Member 'FPipelineInitParams::CachingPriority' has a wrong offset!");
static_assert(offsetof(FPipelineInitParams, bIsCacheEnabled) == 0x000011, "Member 'FPipelineInitParams::bIsCacheEnabled' has a wrong offset!");

// ScriptStruct CharacterSkinSystem.IncrementalLODParams
// 0x0018 (0x0018 - 0x0000)
struct FIncrementalLODParams final
{
public:
	bool                                          bIsEnabled;                                        // 0x0000(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class USkeletalMesh*                          CachedChracterMesh;                                // 0x0008(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         PredictedLOD;                                      // 0x0010(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MaxGeneratingLODNum;                               // 0x0014(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FIncrementalLODParams) == 0x000008, "Wrong alignment on FIncrementalLODParams");
static_assert(sizeof(FIncrementalLODParams) == 0x000018, "Wrong size on FIncrementalLODParams");
static_assert(offsetof(FIncrementalLODParams, bIsEnabled) == 0x000000, "Member 'FIncrementalLODParams::bIsEnabled' has a wrong offset!");
static_assert(offsetof(FIncrementalLODParams, CachedChracterMesh) == 0x000008, "Member 'FIncrementalLODParams::CachedChracterMesh' has a wrong offset!");
static_assert(offsetof(FIncrementalLODParams, PredictedLOD) == 0x000010, "Member 'FIncrementalLODParams::PredictedLOD' has a wrong offset!");
static_assert(offsetof(FIncrementalLODParams, MaxGeneratingLODNum) == 0x000014, "Member 'FIncrementalLODParams::MaxGeneratingLODNum' has a wrong offset!");

// ScriptStruct CharacterSkinSystem.SkinOperationMeshMaterial
// 0x0010 (0x0010 - 0x0000)
struct FSkinOperationMeshMaterial final
{
public:
	class UMaterialInterface*                     Material;                                          // 0x0000(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   SlotName;                                          // 0x0008(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSkinOperationMeshMaterial) == 0x000008, "Wrong alignment on FSkinOperationMeshMaterial");
static_assert(sizeof(FSkinOperationMeshMaterial) == 0x000010, "Wrong size on FSkinOperationMeshMaterial");
static_assert(offsetof(FSkinOperationMeshMaterial, Material) == 0x000000, "Member 'FSkinOperationMeshMaterial::Material' has a wrong offset!");
static_assert(offsetof(FSkinOperationMeshMaterial, SlotName) == 0x000008, "Member 'FSkinOperationMeshMaterial::SlotName' has a wrong offset!");

// ScriptStruct CharacterSkinSystem.SkinOperationMeshSocket
// 0x0060 (0x0060 - 0x0000)
struct FSkinOperationMeshSocket final
{
public:
	class FName                                   SocketName;                                        // 0x0000(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                RelativeLocation;                                  // 0x0008(0x0018)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               RelativeRotation;                                  // 0x0020(0x0018)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FVector                                RelativeScale;                                     // 0x0038(0x0018)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   BoneName;                                          // 0x0050(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bForceAlwaysAnimated;                              // 0x0058(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_59[0x7];                                       // 0x0059(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FSkinOperationMeshSocket) == 0x000008, "Wrong alignment on FSkinOperationMeshSocket");
static_assert(sizeof(FSkinOperationMeshSocket) == 0x000060, "Wrong size on FSkinOperationMeshSocket");
static_assert(offsetof(FSkinOperationMeshSocket, SocketName) == 0x000000, "Member 'FSkinOperationMeshSocket::SocketName' has a wrong offset!");
static_assert(offsetof(FSkinOperationMeshSocket, RelativeLocation) == 0x000008, "Member 'FSkinOperationMeshSocket::RelativeLocation' has a wrong offset!");
static_assert(offsetof(FSkinOperationMeshSocket, RelativeRotation) == 0x000020, "Member 'FSkinOperationMeshSocket::RelativeRotation' has a wrong offset!");
static_assert(offsetof(FSkinOperationMeshSocket, RelativeScale) == 0x000038, "Member 'FSkinOperationMeshSocket::RelativeScale' has a wrong offset!");
static_assert(offsetof(FSkinOperationMeshSocket, BoneName) == 0x000050, "Member 'FSkinOperationMeshSocket::BoneName' has a wrong offset!");
static_assert(offsetof(FSkinOperationMeshSocket, bForceAlwaysAnimated) == 0x000058, "Member 'FSkinOperationMeshSocket::bForceAlwaysAnimated' has a wrong offset!");

// ScriptStruct CharacterSkinSystem.DuplicatedLODInsertInfo
// 0x0008 (0x0008 - 0x0000)
struct FDuplicatedLODInsertInfo final
{
public:
	int32                                         Index;                                             // 0x0000(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Count;                                             // 0x0004(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FDuplicatedLODInsertInfo) == 0x000004, "Wrong alignment on FDuplicatedLODInsertInfo");
static_assert(sizeof(FDuplicatedLODInsertInfo) == 0x000008, "Wrong size on FDuplicatedLODInsertInfo");
static_assert(offsetof(FDuplicatedLODInsertInfo, Index) == 0x000000, "Member 'FDuplicatedLODInsertInfo::Index' has a wrong offset!");
static_assert(offsetof(FDuplicatedLODInsertInfo, Count) == 0x000004, "Member 'FDuplicatedLODInsertInfo::Count' has a wrong offset!");

// ScriptStruct CharacterSkinSystem.MergeWrappedClothWeightData
// 0x0020 (0x0020 - 0x0000)
struct FMergeWrappedClothWeightData final
{
public:
	struct FIntVector                             Min;                                               // 0x0000(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FIntVector                             Max;                                               // 0x000C(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	double                                        Weight;                                            // 0x0018(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMergeWrappedClothWeightData) == 0x000008, "Wrong alignment on FMergeWrappedClothWeightData");
static_assert(sizeof(FMergeWrappedClothWeightData) == 0x000020, "Wrong size on FMergeWrappedClothWeightData");
static_assert(offsetof(FMergeWrappedClothWeightData, Min) == 0x000000, "Member 'FMergeWrappedClothWeightData::Min' has a wrong offset!");
static_assert(offsetof(FMergeWrappedClothWeightData, Max) == 0x00000C, "Member 'FMergeWrappedClothWeightData::Max' has a wrong offset!");
static_assert(offsetof(FMergeWrappedClothWeightData, Weight) == 0x000018, "Member 'FMergeWrappedClothWeightData::Weight' has a wrong offset!");

// ScriptStruct CharacterSkinSystem.IsolateConfig
// 0x0058 (0x0058 - 0x0000)
struct FIsolateConfig final
{
public:
	TSet<class FName>                             TargetSlotNames;                                   // 0x0000(0x0050)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	class FName                                   JoinSlotName;                                      // 0x0050(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FIsolateConfig) == 0x000008, "Wrong alignment on FIsolateConfig");
static_assert(sizeof(FIsolateConfig) == 0x000058, "Wrong size on FIsolateConfig");
static_assert(offsetof(FIsolateConfig, TargetSlotNames) == 0x000000, "Member 'FIsolateConfig::TargetSlotNames' has a wrong offset!");
static_assert(offsetof(FIsolateConfig, JoinSlotName) == 0x000050, "Member 'FIsolateConfig::JoinSlotName' has a wrong offset!");

// ScriptStruct CharacterSkinSystem.OperationBakedData
// 0x0008 (0x0008 - 0x0000)
struct alignas(0x08) FOperationBakedData
{
public:
	uint8                                         Pad_0[0x8];                                        // 0x0000(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FOperationBakedData) == 0x000008, "Wrong alignment on FOperationBakedData");
static_assert(sizeof(FOperationBakedData) == 0x000008, "Wrong size on FOperationBakedData");

// ScriptStruct CharacterSkinSystem.DynamicMeshBakedData
// 0x0048 (0x0048 - 0x0000)
struct FDynamicMeshBakedData final
{
public:
	TArray<class UDynamicMesh*>                   DynamicLODMesh;                                    // 0x0000(0x0010)(Edit, ZeroConstructor, EditConst, UObjectWrapper, NativeAccessSpecifierPublic)
	TArray<struct FSkinOperationMeshMaterial>     Materials;                                         // 0x0010(0x0010)(Edit, ZeroConstructor, EditConst, NativeAccessSpecifierPublic)
	TArray<struct FSkinOperationMeshSocket>       Sockets;                                           // 0x0020(0x0010)(Edit, ZeroConstructor, EditConst, NativeAccessSpecifierPublic)
	uint8                                         ProcessFlags;                                      // 0x0030(0x0001)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_31[0x3];                                       // 0x0031(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGuid                                  SourceMeshId;                                      // 0x0034(0x0010)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_44[0x4];                                       // 0x0044(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FDynamicMeshBakedData) == 0x000008, "Wrong alignment on FDynamicMeshBakedData");
static_assert(sizeof(FDynamicMeshBakedData) == 0x000048, "Wrong size on FDynamicMeshBakedData");
static_assert(offsetof(FDynamicMeshBakedData, DynamicLODMesh) == 0x000000, "Member 'FDynamicMeshBakedData::DynamicLODMesh' has a wrong offset!");
static_assert(offsetof(FDynamicMeshBakedData, Materials) == 0x000010, "Member 'FDynamicMeshBakedData::Materials' has a wrong offset!");
static_assert(offsetof(FDynamicMeshBakedData, Sockets) == 0x000020, "Member 'FDynamicMeshBakedData::Sockets' has a wrong offset!");
static_assert(offsetof(FDynamicMeshBakedData, ProcessFlags) == 0x000030, "Member 'FDynamicMeshBakedData::ProcessFlags' has a wrong offset!");
static_assert(offsetof(FDynamicMeshBakedData, SourceMeshId) == 0x000034, "Member 'FDynamicMeshBakedData::SourceMeshId' has a wrong offset!");

// ScriptStruct CharacterSkinSystem.MergeOperationBakedData
// 0x0010 (0x0018 - 0x0008)
struct FMergeOperationBakedData final : public FOperationBakedData
{
public:
	TArray<struct FDynamicMeshBakedData>          AppendMeshes;                                      // 0x0008(0x0010)(Edit, ZeroConstructor, EditConst, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMergeOperationBakedData) == 0x000008, "Wrong alignment on FMergeOperationBakedData");
static_assert(sizeof(FMergeOperationBakedData) == 0x000018, "Wrong size on FMergeOperationBakedData");
static_assert(offsetof(FMergeOperationBakedData, AppendMeshes) == 0x000008, "Member 'FMergeOperationBakedData::AppendMeshes' has a wrong offset!");

// ScriptStruct CharacterSkinSystem.SqueezeOperationBakedData
// 0x00A0 (0x00A8 - 0x0008)
struct FSqueezeOperationBakedData final : public FOperationBakedData
{
public:
	struct FDynamicMeshBakedData                  SqueezeMesh;                                       // 0x0008(0x0048)(Edit, EditConst, NativeAccessSpecifierPublic)
	struct FDynamicMeshBakedData                  ExtrudedInnerFace;                                 // 0x0050(0x0048)(Edit, EditConst, NativeAccessSpecifierPublic)
	struct FGuid                                  ParameterGuid;                                     // 0x0098(0x0010)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSqueezeOperationBakedData) == 0x000008, "Wrong alignment on FSqueezeOperationBakedData");
static_assert(sizeof(FSqueezeOperationBakedData) == 0x0000A8, "Wrong size on FSqueezeOperationBakedData");
static_assert(offsetof(FSqueezeOperationBakedData, SqueezeMesh) == 0x000008, "Member 'FSqueezeOperationBakedData::SqueezeMesh' has a wrong offset!");
static_assert(offsetof(FSqueezeOperationBakedData, ExtrudedInnerFace) == 0x000050, "Member 'FSqueezeOperationBakedData::ExtrudedInnerFace' has a wrong offset!");
static_assert(offsetof(FSqueezeOperationBakedData, ParameterGuid) == 0x000098, "Member 'FSqueezeOperationBakedData::ParameterGuid' has a wrong offset!");

// ScriptStruct CharacterSkinSystem.LatticeWrapOperationBakedData
// 0x0048 (0x0050 - 0x0008)
struct FLatticeWrapOperationBakedData final : public FOperationBakedData
{
public:
	struct FDynamicMeshBakedData                  LatticeWrapMesh;                                   // 0x0008(0x0048)(Edit, EditConst, NativeAccessSpecifierPublic)
};
static_assert(alignof(FLatticeWrapOperationBakedData) == 0x000008, "Wrong alignment on FLatticeWrapOperationBakedData");
static_assert(sizeof(FLatticeWrapOperationBakedData) == 0x000050, "Wrong size on FLatticeWrapOperationBakedData");
static_assert(offsetof(FLatticeWrapOperationBakedData, LatticeWrapMesh) == 0x000008, "Member 'FLatticeWrapOperationBakedData::LatticeWrapMesh' has a wrong offset!");

// ScriptStruct CharacterSkinSystem.ConvertToSkinMeshOperationBakedData
// 0x0048 (0x0050 - 0x0008)
struct FConvertToSkinMeshOperationBakedData final : public FOperationBakedData
{
public:
	struct FDynamicMeshBakedData                  ConvertMesh;                                       // 0x0008(0x0048)(Edit, EditConst, NativeAccessSpecifierPublic)
};
static_assert(alignof(FConvertToSkinMeshOperationBakedData) == 0x000008, "Wrong alignment on FConvertToSkinMeshOperationBakedData");
static_assert(sizeof(FConvertToSkinMeshOperationBakedData) == 0x000050, "Wrong size on FConvertToSkinMeshOperationBakedData");
static_assert(offsetof(FConvertToSkinMeshOperationBakedData, ConvertMesh) == 0x000008, "Member 'FConvertToSkinMeshOperationBakedData::ConvertMesh' has a wrong offset!");

// ScriptStruct CharacterSkinSystem.MaterialSlotExposeInfo
// 0x0010 (0x0010 - 0x0000)
struct FMaterialSlotExposeInfo final
{
public:
	int32                                         MeshIndex;                                         // 0x0000(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MaterialIndex;                                     // 0x0004(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   SlotName;                                          // 0x0008(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMaterialSlotExposeInfo) == 0x000004, "Wrong alignment on FMaterialSlotExposeInfo");
static_assert(sizeof(FMaterialSlotExposeInfo) == 0x000010, "Wrong size on FMaterialSlotExposeInfo");
static_assert(offsetof(FMaterialSlotExposeInfo, MeshIndex) == 0x000000, "Member 'FMaterialSlotExposeInfo::MeshIndex' has a wrong offset!");
static_assert(offsetof(FMaterialSlotExposeInfo, MaterialIndex) == 0x000004, "Member 'FMaterialSlotExposeInfo::MaterialIndex' has a wrong offset!");
static_assert(offsetof(FMaterialSlotExposeInfo, SlotName) == 0x000008, "Member 'FMaterialSlotExposeInfo::SlotName' has a wrong offset!");

// ScriptStruct CharacterSkinSystem.ConvertToSkinOperationMeshParams
// 0x0050 (0x0050 - 0x0000)
struct FConvertToSkinOperationMeshParams final
{
public:
	ESkinMeshLODDataType                          ReadData;                                          // 0x0000(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         ExtractLODNums;                                    // 0x0004(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bExtractMaterials;                                 // 0x0008(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         ProcessFlags;                                      // 0x0009(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A[0x6];                                        // 0x000A(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FMaterialSlotExposeInfo>        ExposedMaterial;                                   // 0x0010(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	bool                                          bExtractSockets;                                   // 0x0020(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_21[0x3];                                       // 0x0021(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         ProcessingMeshIndex;                               // 0x0024(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_28[0x10];                                      // 0x0028(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector3d                              MirroringDirection;                                // 0x0038(0x0018)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FConvertToSkinOperationMeshParams) == 0x000008, "Wrong alignment on FConvertToSkinOperationMeshParams");
static_assert(sizeof(FConvertToSkinOperationMeshParams) == 0x000050, "Wrong size on FConvertToSkinOperationMeshParams");
static_assert(offsetof(FConvertToSkinOperationMeshParams, ReadData) == 0x000000, "Member 'FConvertToSkinOperationMeshParams::ReadData' has a wrong offset!");
static_assert(offsetof(FConvertToSkinOperationMeshParams, ExtractLODNums) == 0x000004, "Member 'FConvertToSkinOperationMeshParams::ExtractLODNums' has a wrong offset!");
static_assert(offsetof(FConvertToSkinOperationMeshParams, bExtractMaterials) == 0x000008, "Member 'FConvertToSkinOperationMeshParams::bExtractMaterials' has a wrong offset!");
static_assert(offsetof(FConvertToSkinOperationMeshParams, ProcessFlags) == 0x000009, "Member 'FConvertToSkinOperationMeshParams::ProcessFlags' has a wrong offset!");
static_assert(offsetof(FConvertToSkinOperationMeshParams, ExposedMaterial) == 0x000010, "Member 'FConvertToSkinOperationMeshParams::ExposedMaterial' has a wrong offset!");
static_assert(offsetof(FConvertToSkinOperationMeshParams, bExtractSockets) == 0x000020, "Member 'FConvertToSkinOperationMeshParams::bExtractSockets' has a wrong offset!");
static_assert(offsetof(FConvertToSkinOperationMeshParams, ProcessingMeshIndex) == 0x000024, "Member 'FConvertToSkinOperationMeshParams::ProcessingMeshIndex' has a wrong offset!");
static_assert(offsetof(FConvertToSkinOperationMeshParams, MirroringDirection) == 0x000038, "Member 'FConvertToSkinOperationMeshParams::MirroringDirection' has a wrong offset!");

// ScriptStruct CharacterSkinSystem.CreateSkeletalMeshParams
// 0x0018 (0x0018 - 0x0000)
struct FCreateSkeletalMeshParams final
{
public:
	class USkeletalMesh*                          ReferenceMesh;                                     // 0x0000(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UObject*                                OuterObject;                                       // 0x0008(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_10[0x8];                                       // 0x0010(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FCreateSkeletalMeshParams) == 0x000008, "Wrong alignment on FCreateSkeletalMeshParams");
static_assert(sizeof(FCreateSkeletalMeshParams) == 0x000018, "Wrong size on FCreateSkeletalMeshParams");
static_assert(offsetof(FCreateSkeletalMeshParams, ReferenceMesh) == 0x000000, "Member 'FCreateSkeletalMeshParams::ReferenceMesh' has a wrong offset!");
static_assert(offsetof(FCreateSkeletalMeshParams, OuterObject) == 0x000008, "Member 'FCreateSkeletalMeshParams::OuterObject' has a wrong offset!");

// ScriptStruct CharacterSkinSystem.ConvertToSkeletalMeshParams
// 0x0010 (0x0010 - 0x0000)
struct FConvertToSkeletalMeshParams final
{
public:
	class USkeletalMesh*                          TargetMesh;                                        // 0x0000(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ESkinMeshLODDataType                          WriteData;                                         // 0x0008(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bRecomputeNormals;                                 // 0x0009(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bRecomputeTangents;                                // 0x000A(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bRemoveDegenerates;                                // 0x000B(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FConvertToSkeletalMeshParams) == 0x000008, "Wrong alignment on FConvertToSkeletalMeshParams");
static_assert(sizeof(FConvertToSkeletalMeshParams) == 0x000010, "Wrong size on FConvertToSkeletalMeshParams");
static_assert(offsetof(FConvertToSkeletalMeshParams, TargetMesh) == 0x000000, "Member 'FConvertToSkeletalMeshParams::TargetMesh' has a wrong offset!");
static_assert(offsetof(FConvertToSkeletalMeshParams, WriteData) == 0x000008, "Member 'FConvertToSkeletalMeshParams::WriteData' has a wrong offset!");
static_assert(offsetof(FConvertToSkeletalMeshParams, bRecomputeNormals) == 0x000009, "Member 'FConvertToSkeletalMeshParams::bRecomputeNormals' has a wrong offset!");
static_assert(offsetof(FConvertToSkeletalMeshParams, bRecomputeTangents) == 0x00000A, "Member 'FConvertToSkeletalMeshParams::bRecomputeTangents' has a wrong offset!");
static_assert(offsetof(FConvertToSkeletalMeshParams, bRemoveDegenerates) == 0x00000B, "Member 'FConvertToSkeletalMeshParams::bRemoveDegenerates' has a wrong offset!");

// ScriptStruct CharacterSkinSystem.SkinCommand
// 0x0010 (0x0010 - 0x0000)
struct FSkinCommand final
{
public:
	TSubclassOf<class UBaseSkinCommand>           CommandClass;                                      // 0x0000(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UBaseSkinCommand*                       CommandInstance;                                   // 0x0008(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
};
static_assert(alignof(FSkinCommand) == 0x000008, "Wrong alignment on FSkinCommand");
static_assert(sizeof(FSkinCommand) == 0x000010, "Wrong size on FSkinCommand");
static_assert(offsetof(FSkinCommand, CommandClass) == 0x000000, "Member 'FSkinCommand::CommandClass' has a wrong offset!");
static_assert(offsetof(FSkinCommand, CommandInstance) == 0x000008, "Member 'FSkinCommand::CommandInstance' has a wrong offset!");

}

