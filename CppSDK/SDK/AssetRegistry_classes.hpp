#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: AssetRegistry

#include "Basic.hpp"

#include "CoreUObject_classes.hpp"


namespace SDK
{

// Class AssetRegistry.AssetRegistryHelpers
// 0x0000 (0x0028 - 0x0028)
class UAssetRegistryHelpers final : public UObject
{
public:
	static struct FAssetData CreateAssetData(const class UObject* InAsset, bool bAllowBlueprintClass)	 // 0x6797858;
	static class UClass* FindAssetNativeClass(const struct FAssetData& AssetData)	 // 0x6797a38;
	static class UObject* GetAsset(const struct FAssetData& InAssetData)	 // 0x6797ef8;
	static TScriptInterface<class IAssetRegistry> GetAssetRegistry()	 // 0x679818c;
	static void GetBlueprintAssets(const struct FARFilter& InFilter, TArray<struct FAssetData>* OutAssetData)	 // 0x6799024;
	static class UClass* GetClass(const struct FAssetData& InAssetData)	 // 0x679917c;
	static class FString GetExportTextName(const struct FAssetData& InAssetData)	 // 0x6799450;
	static class FString GetFullName(const struct FAssetData& InAssetData)	 // 0x679955c;
	static bool GetTagValue(const struct FAssetData& InAssetData, const class FName& InTagName, class FString* OutTagValue)	 // 0x67998b0;
	static bool IsAssetLoaded(const struct FAssetData& InAssetData)	 // 0x6799ba8;
	static bool IsRedirector(const struct FAssetData& InAssetData)	 // 0x6799c90;
	static bool IsUAsset(const struct FAssetData& InAssetData)	 // 0x6799dc8;
	static bool IsValid(const struct FAssetData& InAssetData)	 // 0x6799eb0;
	static struct FARFilter SetFilterTagsAndValues(const struct FARFilter& InFilter, const TArray<struct FTagAndValue>& InTagsAndValues)	 // 0x679acb4;
	static struct FSoftObjectPath ToSoftObjectPath(const struct FAssetData& InAssetData)	 // 0x679ae04;

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"AssetRegistryHelpers">();
	}
	static class UAssetRegistryHelpers* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UAssetRegistryHelpers>();
	}
};
static_assert(alignof(UAssetRegistryHelpers) == 0x000008, "Wrong alignment on UAssetRegistryHelpers");
static_assert(sizeof(UAssetRegistryHelpers) == 0x000028, "Wrong size on UAssetRegistryHelpers");

// Class AssetRegistry.AssetRegistry
// 0x0000 (0x0000 - 0x0000)
class IAssetRegistry final
{
public:
	void PrioritizeSearchPath(const class FString& PathToPrioritize)	 // 0x679a484;
	void ScanFilesSynchronous(const TArray<class FString>& InFilePaths, bool bForceRescan)	 // 0x679a6b8;
	void ScanModifiedAssetFiles(const TArray<class FString>& InFilePaths)	 // 0x679a880;
	void ScanPathsSynchronous(const TArray<class FString>& InPaths, bool bForceRescan, bool bIgnoreDenyListScanFilters)	 // 0x679a948;
	void SearchAllAssets(bool bSynchronousSearch)	 // 0x679abec;
	void WaitForCompletion()	 // 0x679b07c;
	void WaitForPackage(const class FString& PackageName)	 // 0x679b094;

	bool GetAllAssets(TArray<struct FAssetData>* OutAssetData, bool bIncludeOnlyOnDiskAssets) const	 // 0x6797b20;
	void GetAllCachedPaths(TArray<class FString>* OutPathList) const	 // 0x6797ce8;
	bool GetAncestorClassNames(const struct FTopLevelAssetPath& ClassPathName, TArray<struct FTopLevelAssetPath>* OutAncestorClassNames) const	 // 0x6797db0;
	struct FAssetData GetAssetByObjectPath(const class FName ObjectPath, bool bIncludeOnlyOnDiskAssets) const	 // 0x6798008;
	bool GetAssets(const struct FARFilter& Filter, TArray<struct FAssetData>* OutAssetData, bool bSkipARFilteredAssets) const	 // 0x67981f4;
	bool GetAssetsByClass(const struct FTopLevelAssetPath& ClassPathName, TArray<struct FAssetData>* OutAssetData, bool bSearchSubClasses) const	 // 0x6798444;
	bool GetAssetsByPackageName(class FName PackageName, TArray<struct FAssetData>* OutAssetData, bool bIncludeOnlyOnDiskAssets, bool bSkipARFilteredAssets) const	 // 0x6798684;
	bool GetAssetsByPath(class FName PackagePath, TArray<struct FAssetData>* OutAssetData, bool bRecursive, bool bIncludeOnlyOnDiskAssets) const	 // 0x679899c;
	bool GetAssetsByPaths(const TArray<class FName>& PackagePaths, TArray<struct FAssetData>* OutAssetData, bool bRecursive, bool bIncludeOnlyOnDiskAssets) const	 // 0x6798cb4;
	void GetDerivedClassNames(const TArray<struct FTopLevelAssetPath>& ClassNames, const TSet<struct FTopLevelAssetPath>& ExcludedClassNames, TSet<struct FTopLevelAssetPath>* OutDerivedClassNames) const	 // 0x6799264;
	void GetSubPaths(const class FString& InBasePath, TArray<class FString>* OutPathList, bool bInRecurse) const	 // 0x6799668;
	bool HasAssets(const class FName PackagePath, const bool bRecursive) const	 // 0x6799a54;
	bool IsLoadingAssets() const	 // 0x1809fe8;
	bool IsSearchAllAssets() const	 // 0x6799d78;
	bool IsSearchAsync() const	 // 0x6799da0;
	struct FAssetData K2_GetAssetByObjectPath(const struct FSoftObjectPath& ObjectPath, bool bIncludeOnlyOnDiskAssets) const	 // 0x6799fa0;
	bool K2_GetDependencies(class FName PackageName, const struct FAssetRegistryDependencyOptions& DependencyOptions, TArray<class FName>* OutDependencies) const	 // 0x679a17c;
	bool K2_GetReferencers(class FName PackageName, const struct FAssetRegistryDependencyOptions& ReferenceOptions, TArray<class FName>* OutReferencers) const	 // 0x679a300;
	void RunAssetsThroughFilter(TArray<struct FAssetData>& AssetDataList, const struct FARFilter& Filter) const	 // 0x679a558;
	void UseFilterToExcludeAssets(TArray<struct FAssetData>& AssetDataList, const struct FARFilter& Filter) const	 // 0x679af1c;

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"AssetRegistry">();
	}
	static class IAssetRegistry* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<IAssetRegistry>();
	}

	class UObject* AsUObject()	 // 0x0
	{
		return reinterpret_cast<UObject*>(this);
	}
	const class UObject* AsUObject() const	 // 0x0
	{
		return reinterpret_cast<const UObject*>(this);
	}
};
static_assert(alignof(IAssetRegistry) == 0x000001, "Wrong alignment on IAssetRegistry");
static_assert(sizeof(IAssetRegistry) == 0x000001, "Wrong size on IAssetRegistry");

// Class AssetRegistry.AssetRegistryImpl
// 0x0B90 (0x0BB8 - 0x0028)
class UAssetRegistryImpl final : public UObject
{
public:
	uint8                                         Pad_28[0xB90];                                     // 0x0028(0x0B90)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"AssetRegistryImpl">();
	}
	static class UAssetRegistryImpl* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UAssetRegistryImpl>();
	}
};
static_assert(alignof(UAssetRegistryImpl) == 0x000008, "Wrong alignment on UAssetRegistryImpl");
static_assert(sizeof(UAssetRegistryImpl) == 0x000BB8, "Wrong size on UAssetRegistryImpl");

}

