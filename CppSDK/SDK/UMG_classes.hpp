#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: UMG

#include "Basic.hpp"

#include "CoreUObject_structs.hpp"
#include "CoreUObject_classes.hpp"
#include "UMG_structs.hpp"
#include "Engine_structs.hpp"
#include "Engine_classes.hpp"
#include "SlateCore_structs.hpp"
#include "InputCore_structs.hpp"
#include "MovieScene_structs.hpp"
#include "MovieScene_classes.hpp"
#include "MovieSceneTracks_classes.hpp"
#include "Slate_structs.hpp"


namespace SDK
{

// Class UMG.MovieScene2DTransformTrack
// 0x0000 (0x00C8 - 0x00C8)
class UMovieScene2DTransformTrack final : public UMovieScenePropertyTrack
{
public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"MovieScene2DTransformTrack">();
	}
	static class UMovieScene2DTransformTrack* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UMovieScene2DTransformTrack>();
	}
};
static_assert(alignof(UMovieScene2DTransformTrack) == 0x000008, "Wrong alignment on UMovieScene2DTransformTrack");
static_assert(sizeof(UMovieScene2DTransformTrack) == 0x0000C8, "Wrong size on UMovieScene2DTransformTrack");

// Class UMG.Visual
// 0x0000 (0x0028 - 0x0028)
class UVisual : public UObject
{
public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"Visual">();
	}
	static class UVisual* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UVisual>();
	}
};
static_assert(alignof(UVisual) == 0x000008, "Wrong alignment on UVisual");
static_assert(sizeof(UVisual) == 0x000028, "Wrong size on UVisual");

// Class UMG.MovieScene2DTransformSection
// 0x0780 (0x0870 - 0x00F0)
class UMovieScene2DTransformSection final : public UMovieSceneSection
{
public:
	uint8                                         Pad_F0[0x8];                                       // 0x00F0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FMovieScene2DTransformMask             TransformMask;                                     // 0x00F8(0x0004)(NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_FC[0x4];                                       // 0x00FC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FMovieSceneFloatChannel                Translation[0x2];                                  // 0x0100(0x0110)(NativeAccessSpecifierPublic)
	struct FMovieSceneFloatChannel                Rotation;                                          // 0x0320(0x0110)(NativeAccessSpecifierPublic)
	struct FMovieSceneFloatChannel                Scale[0x2];                                        // 0x0430(0x0110)(NativeAccessSpecifierPublic)
	struct FMovieSceneFloatChannel                Shear[0x2];                                        // 0x0650(0x0110)(NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"MovieScene2DTransformSection">();
	}
	static class UMovieScene2DTransformSection* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UMovieScene2DTransformSection>();
	}
};
static_assert(alignof(UMovieScene2DTransformSection) == 0x000008, "Wrong alignment on UMovieScene2DTransformSection");
static_assert(sizeof(UMovieScene2DTransformSection) == 0x000870, "Wrong size on UMovieScene2DTransformSection");
static_assert(offsetof(UMovieScene2DTransformSection, TransformMask) == 0x0000F8, "Member 'UMovieScene2DTransformSection::TransformMask' has a wrong offset!");
static_assert(offsetof(UMovieScene2DTransformSection, Translation) == 0x000100, "Member 'UMovieScene2DTransformSection::Translation' has a wrong offset!");
static_assert(offsetof(UMovieScene2DTransformSection, Rotation) == 0x000320, "Member 'UMovieScene2DTransformSection::Rotation' has a wrong offset!");
static_assert(offsetof(UMovieScene2DTransformSection, Scale) == 0x000430, "Member 'UMovieScene2DTransformSection::Scale' has a wrong offset!");
static_assert(offsetof(UMovieScene2DTransformSection, Shear) == 0x000650, "Member 'UMovieScene2DTransformSection::Shear' has a wrong offset!");

// Class UMG.Widget
// 0x0128 (0x0150 - 0x0028)
class UWidget : public UVisual
{
public:
	uint8                                         Pad_28[0x8];                                       // 0x0028(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UPanelSlot*                             Slot;                                              // 0x0030(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, TextExportTransient, PersistentInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TDelegate<void()>                             bIsEnabledDelegate;                                // 0x0038(0x0010)(ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FText                                   ToolTipText;                                       // 0x0048(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	TDelegate<void()>                             ToolTipTextDelegate;                               // 0x0060(0x0010)(ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UWidget*                                ToolTipWidget;                                     // 0x0070(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, EditConst, InstancedReference, NoDestructor, AdvancedDisplay, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TDelegate<void()>                             ToolTipWidgetDelegate;                             // 0x0078(0x0010)(ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TDelegate<void()>                             VisibilityDelegate;                                // 0x0088(0x0010)(ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FWidgetTransform                       RenderTransform;                                   // 0x0098(0x0038)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	struct FVector2D                              RenderTransformPivot;                              // 0x00D0(0x0010)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EFlowDirectionPreference                      FlowDirectionPreference;                           // 0x00E0(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bIsVariable : 1;                                   // 0x00E1(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bCreatedByConstructionScript : 1;                  // 0x00E1(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bIsEnabled : 1;                                    // 0x00E1(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bOverride_Cursor : 1;                              // 0x00E1(0x0001)(BitIndex: 0x03, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bIsVolatile : 1;                                   // 0x00E1(0x0001)(BitIndex: 0x04, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	EMouseCursor                                  Cursor;                                            // 0x00E2(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EWidgetClipping                               Clipping;                                          // 0x00E3(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ESlateVisibility                              Visibility;                                        // 0x00E4(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_E5[0x3];                                       // 0x00E5(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         RenderOpacity;                                     // 0x00E8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_EC[0x4];                                       // 0x00EC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class USlateAccessibleWidgetData*             AccessibleWidgetData;                              // 0x00F0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, PersistentInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UWidgetNavigation*                      Navigation;                                        // 0x00F8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, PersistentInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_100[0x20];                                     // 0x0100(0x0020)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UPropertyBinding*>               NativeBindings;                                    // 0x0120(0x0010)(ZeroConstructor, Transient, Protected, UObjectWrapper, NativeAccessSpecifierProtected)
	uint8                                         Pad_130[0x20];                                     // 0x0130(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ForceLayoutPrepass()	 // 0x66f36e8;
	void ForceVolatile(bool bForce)	 // 0x66f372c;
	void InvalidateLayoutAndVolatility()	 // 0x66f4e68;
	void K2_AddFieldValueChangedDelegate(const struct FFieldNotificationId& FieldId, TDelegate<void(class UObject* Object, const struct FFieldNotificationId& Field)> Delegate)	 // 0x66f4fb0;
	void K2_BroadcastFieldValueChanged(const struct FFieldNotificationId& FieldId)	 // 0x66f5104;
	void K2_RemoveFieldValueChangedDelegate(const struct FFieldNotificationId& FieldId, TDelegate<void(class UObject* Object, const struct FFieldNotificationId& Field)> Delegate)	 // 0x66f5208;
	void RemoveFromParent()	 // 0x115cedc;
	void ResetCursor()	 // 0x66f5d30;
	void SetAllNavigationRules(EUINavigationRule Rule, class FName WidgetToFocus)	 // 0x66f6128;
	void SetClipping(EWidgetClipping InClipping)	 // 0x66f71f0;
	void SetCursor(EMouseCursor InCursor)	 // 0x66f76ec;
	void SetFocus()	 // 0x66f8848;
	void SetIsEnabled(bool bInIsEnabled)	 // 0xb47de8;
	void SetKeyboardFocus()	 // 0x66fa360;
	void SetNavigationRule(EUINavigation Direction, EUINavigationRule Rule, class FName WidgetToFocus)	 // 0x66fb374;
	void SetNavigationRuleBase(EUINavigation Direction, EUINavigationRule Rule)	 // 0x66fb55c;
	void SetNavigationRuleCustom(EUINavigation Direction, TDelegate<void(EUINavigation Navigation)> InCustomDelegate)	 // 0x66fb6e0;
	void SetNavigationRuleCustomBoundary(EUINavigation Direction, TDelegate<void(EUINavigation Navigation)> InCustomDelegate)	 // 0x66fb854;
	void SetNavigationRuleExplicit(EUINavigation Direction, class UWidget* InWidget)	 // 0x66fb9c8;
	void SetRenderOpacity(float InOpacity)	 // 0x174380c;
	void SetRenderScale(const struct FVector2D& Scale)	 // 0xb14ed4;
	void SetRenderShear(const struct FVector2D& Shear)	 // 0x66fc528;
	void SetRenderTransform(const struct FWidgetTransform& InTransform)	 // 0xf806f0;
	void SetRenderTransformAngle(float Angle)	 // 0xf61968;
	void SetRenderTransformPivot(const struct FVector2D& Pivot)	 // 0x66fc5ec;
	void SetRenderTranslation(const struct FVector2D& Translation)	 // 0xd9902c;
	void SetToolTip(class UWidget* Widget)	 // 0x66fe848;
	void SetToolTipText(const class FText& InToolTipText)	 // 0x66fe908;
	void SetUserFocus(class APlayerController* PlayerController)	 // 0x66fea7c;
	void SetVisibility(ESlateVisibility InVisibility)	 // 0xe83788;

	class FText GetAccessibleSummaryText() const	 // 0x66f3840;
	class FText GetAccessibleText() const	 // 0x66f38d0;
	const struct FGeometry GetCachedGeometry() const	 // 0x66f3988;
	EWidgetClipping GetClipping() const	 // 0x66f3aa4;
	struct FVector2D GetDesiredSize() const	 // 0x66f3c68;
	class UGameInstance* GetGameInstance() const	 // 0x66f3e08;
	bool GetIsEnabled() const	 // 0x66f3fe8;
	class ULocalPlayer* GetOwningLocalPlayer() const	 // 0x66f42ac;
	class APlayerController* GetOwningPlayer() const	 // 0x1639874;
	const struct FGeometry GetPaintSpaceGeometry() const	 // 0x66f42d4;
	class UPanelWidget* GetParent() const	 // 0x66f4300;
	float GetRenderOpacity() const	 // 0x66f4354;
	float GetRenderTransformAngle() const	 // 0x66f4394;
	const struct FGeometry GetTickSpaceGeometry() const	 // 0x66f3988;
	ESlateVisibility GetVisibility() const	 // 0x1680964;
	bool HasAnyUserFocus() const	 // 0x66f47b8;
	bool HasFocusedDescendants() const	 // 0x66f4960;
	bool HasKeyboardFocus() const	 // 0x66f49b0;
	bool HasMouseCapture() const	 // 0x66f49d4;
	bool HasMouseCaptureByUser(int32 UserIndex, int32 PointerIndex) const	 // 0x66f4a24;
	bool HasUserFocus(class APlayerController* PlayerController) const	 // 0x66f4bd4;
	bool HasUserFocusedDescendants(class APlayerController* PlayerController) const	 // 0x66f4d34;
	bool IsHovered() const	 // 0x4f1e4c0;
	bool IsInViewport() const	 // 0x66f4e7c;
	bool IsRendered() const	 // 0x66f4f08;
	bool IsVisible() const	 // 0x66f4f68;

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"Widget">();
	}
	static class UWidget* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UWidget>();
	}
};
static_assert(alignof(UWidget) == 0x000008, "Wrong alignment on UWidget");
static_assert(sizeof(UWidget) == 0x000150, "Wrong size on UWidget");
static_assert(offsetof(UWidget, Slot) == 0x000030, "Member 'UWidget::Slot' has a wrong offset!");
static_assert(offsetof(UWidget, bIsEnabledDelegate) == 0x000038, "Member 'UWidget::bIsEnabledDelegate' has a wrong offset!");
static_assert(offsetof(UWidget, ToolTipText) == 0x000048, "Member 'UWidget::ToolTipText' has a wrong offset!");
static_assert(offsetof(UWidget, ToolTipTextDelegate) == 0x000060, "Member 'UWidget::ToolTipTextDelegate' has a wrong offset!");
static_assert(offsetof(UWidget, ToolTipWidget) == 0x000070, "Member 'UWidget::ToolTipWidget' has a wrong offset!");
static_assert(offsetof(UWidget, ToolTipWidgetDelegate) == 0x000078, "Member 'UWidget::ToolTipWidgetDelegate' has a wrong offset!");
static_assert(offsetof(UWidget, VisibilityDelegate) == 0x000088, "Member 'UWidget::VisibilityDelegate' has a wrong offset!");
static_assert(offsetof(UWidget, RenderTransform) == 0x000098, "Member 'UWidget::RenderTransform' has a wrong offset!");
static_assert(offsetof(UWidget, RenderTransformPivot) == 0x0000D0, "Member 'UWidget::RenderTransformPivot' has a wrong offset!");
static_assert(offsetof(UWidget, FlowDirectionPreference) == 0x0000E0, "Member 'UWidget::FlowDirectionPreference' has a wrong offset!");
static_assert(offsetof(UWidget, Cursor) == 0x0000E2, "Member 'UWidget::Cursor' has a wrong offset!");
static_assert(offsetof(UWidget, Clipping) == 0x0000E3, "Member 'UWidget::Clipping' has a wrong offset!");
static_assert(offsetof(UWidget, Visibility) == 0x0000E4, "Member 'UWidget::Visibility' has a wrong offset!");
static_assert(offsetof(UWidget, RenderOpacity) == 0x0000E8, "Member 'UWidget::RenderOpacity' has a wrong offset!");
static_assert(offsetof(UWidget, AccessibleWidgetData) == 0x0000F0, "Member 'UWidget::AccessibleWidgetData' has a wrong offset!");
static_assert(offsetof(UWidget, Navigation) == 0x0000F8, "Member 'UWidget::Navigation' has a wrong offset!");
static_assert(offsetof(UWidget, NativeBindings) == 0x000120, "Member 'UWidget::NativeBindings' has a wrong offset!");

// Class UMG.Throbber
// 0x00F0 (0x0240 - 0x0150)
class UThrobber final : public UWidget
{
public:
	int32                                         NumberOfPieces;                                    // 0x0150(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAnimateHorizontally;                              // 0x0154(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAnimateVertically;                                // 0x0155(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAnimateOpacity;                                   // 0x0156(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_157[0x9];                                      // 0x0157(0x0009)(Fixing Size After Last Property [ Dumper-7 ])
	struct FSlateBrush                            Image;                                             // 0x0160(0x00D0)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	uint8                                         Pad_230[0x10];                                     // 0x0230(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SetAnimateHorizontally(bool bInAnimateHorizontally)	 // 0x66f6638;
	void SetAnimateOpacity(bool bInAnimateOpacity)	 // 0x66f66fc;
	void SetAnimateVertically(bool bInAnimateVertically)	 // 0x66f67c0;
	void SetNumberOfPieces(int32 InNumberOfPieces)	 // 0x66fbce8;

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"Throbber">();
	}
	static class UThrobber* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UThrobber>();
	}
};
static_assert(alignof(UThrobber) == 0x000010, "Wrong alignment on UThrobber");
static_assert(sizeof(UThrobber) == 0x000240, "Wrong size on UThrobber");
static_assert(offsetof(UThrobber, NumberOfPieces) == 0x000150, "Member 'UThrobber::NumberOfPieces' has a wrong offset!");
static_assert(offsetof(UThrobber, bAnimateHorizontally) == 0x000154, "Member 'UThrobber::bAnimateHorizontally' has a wrong offset!");
static_assert(offsetof(UThrobber, bAnimateVertically) == 0x000155, "Member 'UThrobber::bAnimateVertically' has a wrong offset!");
static_assert(offsetof(UThrobber, bAnimateOpacity) == 0x000156, "Member 'UThrobber::bAnimateOpacity' has a wrong offset!");
static_assert(offsetof(UThrobber, Image) == 0x000160, "Member 'UThrobber::Image' has a wrong offset!");

// Class UMG.PanelWidget
// 0x0018 (0x0168 - 0x0150)
class UPanelWidget : public UWidget
{
public:
	TArray<class UPanelSlot*>                     Slots;                                             // 0x0150(0x0010)(ExportObject, ZeroConstructor, ContainsInstancedReference, Protected, UObjectWrapper, NativeAccessSpecifierProtected)
	uint8                                         Pad_160[0x8];                                      // 0x0160(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	class UPanelSlot* AddChild(class UWidget* Content)	 // 0x66f2228;
	void ClearChildren()	 // 0x17abc48;
	bool RemoveChild(class UWidget* Content)	 // 0x66f57c4;
	bool RemoveChildAt(int32 Index_0)	 // 0x66f5894;

	TArray<class UWidget*> GetAllChildren() const	 // 0x1226d34;
	class UWidget* GetChildAt(int32 Index_0) const	 // 0x16d5888;
	int32 GetChildIndex(const class UWidget* Content) const	 // 0x66f39d4;
	int32 GetChildrenCount() const	 // 0x62ccac4;
	bool HasAnyChildren() const	 // 0x4a8bc64;
	bool HasChild(class UWidget* Content) const	 // 0x66f4834;

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"PanelWidget">();
	}
	static class UPanelWidget* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UPanelWidget>();
	}
};
static_assert(alignof(UPanelWidget) == 0x000008, "Wrong alignment on UPanelWidget");
static_assert(sizeof(UPanelWidget) == 0x000168, "Wrong size on UPanelWidget");
static_assert(offsetof(UPanelWidget, Slots) == 0x000150, "Member 'UPanelWidget::Slots' has a wrong offset!");

// Class UMG.ContentWidget
// 0x0000 (0x0168 - 0x0168)
class UContentWidget : public UPanelWidget
{
public:
	class UPanelSlot* SetContent(class UWidget* Content)	 // 0x66cdb94;

	class UWidget* GetContent() const	 // 0x66cbca0;
	class UPanelSlot* GetContentSlot() const	 // 0x66cbccc;

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"ContentWidget">();
	}
	static class UContentWidget* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UContentWidget>();
	}
};
static_assert(alignof(UContentWidget) == 0x000008, "Wrong alignment on UContentWidget");
static_assert(sizeof(UContentWidget) == 0x000168, "Wrong size on UContentWidget");

// Class UMG.Border
// 0x01A8 (0x0310 - 0x0168)
#pragma pack(push, 0x1)
class alignas(0x10) UBorder : public UContentWidget
{
public:
	EHorizontalAlignment                          HorizontalAlignment;                               // 0x0168(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EVerticalAlignment                            VerticalAlignment;                                 // 0x0169(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bShowEffectWhenDisabled : 1;                       // 0x016A(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_16B[0x1];                                      // 0x016B(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	struct FLinearColor                           ContentColorAndOpacity;                            // 0x016C(0x0010)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TDelegate<void()>                             ContentColorAndOpacityDelegate;                    // 0x017C(0x0010)(ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FMargin                                Padding;                                           // 0x018C(0x0010)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_19C[0x4];                                      // 0x019C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FSlateBrush                            Background;                                        // 0x01A0(0x00D0)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	TDelegate<void()>                             BackgroundDelegate;                                // 0x0270(0x0010)(ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           BrushColor;                                        // 0x0280(0x0010)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TDelegate<void()>                             BrushColorDelegate;                                // 0x0290(0x0010)(ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              DesiredSizeScale;                                  // 0x02A0(0x0010)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bFlipForRightToLeftFlowDirection;                  // 0x02B0(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2B1[0x3];                                      // 0x02B1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	TDelegate<void(const struct FGeometry& MyGeometry, const struct FPointerEvent& MouseEvent)> OnMouseButtonDownEvent; // 0x02B4(0x0010)(Edit, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TDelegate<void(const struct FGeometry& MyGeometry, const struct FPointerEvent& MouseEvent)> OnMouseButtonUpEvent; // 0x02C4(0x0010)(Edit, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TDelegate<void(const struct FGeometry& MyGeometry, const struct FPointerEvent& MouseEvent)> OnMouseMoveEvent; // 0x02D4(0x0010)(Edit, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TDelegate<void(const struct FGeometry& MyGeometry, const struct FPointerEvent& MouseEvent)> OnMouseDoubleClickEvent; // 0x02E4(0x0010)(Edit, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2F4[0x14];                                     // 0x02F4(0x0014)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	class UMaterialInstanceDynamic* GetDynamicMaterial()	 // 0x66cbcec;
	void SetBrush(const struct FSlateBrush& InBrush)	 // 0xb13818;
	void SetBrushColor(const struct FLinearColor& InBrushColor)	 // 0xb15cc0;
	void SetBrushFromAsset(class USlateBrushAsset* Asset)	 // 0x66cd894;
	void SetBrushFromMaterial(class UMaterialInterface* Material)	 // 0x173c49c;
	void SetBrushFromTexture(class UTexture2D* Texture)	 // 0x17a5460;
	void SetContentColorAndOpacity(const struct FLinearColor& InContentColorAndOpacity)	 // 0xc871d4;
	void SetDesiredSizeScale(const struct FVector2D& InScale)	 // 0x66cddf0;
	void SetHorizontalAlignment(EHorizontalAlignment InHorizontalAlignment)	 // 0x66ce4a4;
	void SetPadding(const struct FMargin& InPadding)	 // 0x66cf110;
	void SetShowEffectWhenDisabled(bool bInShowEffectWhenDisabled)	 // 0x66cf914;
	void SetVerticalAlignment(EVerticalAlignment InVerticalAlignment)	 // 0x66cff38;

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"Border">();
	}
	static class UBorder* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UBorder>();
	}
};
#pragma pack(pop)
static_assert(alignof(UBorder) == 0x000010, "Wrong alignment on UBorder");
static_assert(sizeof(UBorder) == 0x000310, "Wrong size on UBorder");
static_assert(offsetof(UBorder, HorizontalAlignment) == 0x000168, "Member 'UBorder::HorizontalAlignment' has a wrong offset!");
static_assert(offsetof(UBorder, VerticalAlignment) == 0x000169, "Member 'UBorder::VerticalAlignment' has a wrong offset!");
static_assert(offsetof(UBorder, ContentColorAndOpacity) == 0x00016C, "Member 'UBorder::ContentColorAndOpacity' has a wrong offset!");
static_assert(offsetof(UBorder, ContentColorAndOpacityDelegate) == 0x00017C, "Member 'UBorder::ContentColorAndOpacityDelegate' has a wrong offset!");
static_assert(offsetof(UBorder, Padding) == 0x00018C, "Member 'UBorder::Padding' has a wrong offset!");
static_assert(offsetof(UBorder, Background) == 0x0001A0, "Member 'UBorder::Background' has a wrong offset!");
static_assert(offsetof(UBorder, BackgroundDelegate) == 0x000270, "Member 'UBorder::BackgroundDelegate' has a wrong offset!");
static_assert(offsetof(UBorder, BrushColor) == 0x000280, "Member 'UBorder::BrushColor' has a wrong offset!");
static_assert(offsetof(UBorder, BrushColorDelegate) == 0x000290, "Member 'UBorder::BrushColorDelegate' has a wrong offset!");
static_assert(offsetof(UBorder, DesiredSizeScale) == 0x0002A0, "Member 'UBorder::DesiredSizeScale' has a wrong offset!");
static_assert(offsetof(UBorder, bFlipForRightToLeftFlowDirection) == 0x0002B0, "Member 'UBorder::bFlipForRightToLeftFlowDirection' has a wrong offset!");
static_assert(offsetof(UBorder, OnMouseButtonDownEvent) == 0x0002B4, "Member 'UBorder::OnMouseButtonDownEvent' has a wrong offset!");
static_assert(offsetof(UBorder, OnMouseButtonUpEvent) == 0x0002C4, "Member 'UBorder::OnMouseButtonUpEvent' has a wrong offset!");
static_assert(offsetof(UBorder, OnMouseMoveEvent) == 0x0002D4, "Member 'UBorder::OnMouseMoveEvent' has a wrong offset!");
static_assert(offsetof(UBorder, OnMouseDoubleClickEvent) == 0x0002E4, "Member 'UBorder::OnMouseDoubleClickEvent' has a wrong offset!");

// Class UMG.ScrollBar
// 0x07B0 (0x0900 - 0x0150)
class UScrollBar final : public UWidget
{
public:
	struct FScrollBarStyle                        WidgetStyle;                                       // 0x0150(0x0770)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	bool                                          bAlwaysShowScrollbar;                              // 0x08C0(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAlwaysShowScrollbarTrack;                         // 0x08C1(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EOrientation                                  Orientation;                                       // 0x08C2(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_8C3[0x5];                                      // 0x08C3(0x0005)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector2D                              Thickness;                                         // 0x08C8(0x0010)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FMargin                                Padding;                                           // 0x08D8(0x0010)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_8E8[0x18];                                     // 0x08E8(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SetState(float InOffsetFraction, float InThumbSizeFraction)	 // 0x66fdb18;

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"ScrollBar">();
	}
	static class UScrollBar* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UScrollBar>();
	}
};
static_assert(alignof(UScrollBar) == 0x000010, "Wrong alignment on UScrollBar");
static_assert(sizeof(UScrollBar) == 0x000900, "Wrong size on UScrollBar");
static_assert(offsetof(UScrollBar, WidgetStyle) == 0x000150, "Member 'UScrollBar::WidgetStyle' has a wrong offset!");
static_assert(offsetof(UScrollBar, bAlwaysShowScrollbar) == 0x0008C0, "Member 'UScrollBar::bAlwaysShowScrollbar' has a wrong offset!");
static_assert(offsetof(UScrollBar, bAlwaysShowScrollbarTrack) == 0x0008C1, "Member 'UScrollBar::bAlwaysShowScrollbarTrack' has a wrong offset!");
static_assert(offsetof(UScrollBar, Orientation) == 0x0008C2, "Member 'UScrollBar::Orientation' has a wrong offset!");
static_assert(offsetof(UScrollBar, Thickness) == 0x0008C8, "Member 'UScrollBar::Thickness' has a wrong offset!");
static_assert(offsetof(UScrollBar, Padding) == 0x0008D8, "Member 'UScrollBar::Padding' has a wrong offset!");

// Class UMG.CheckBox
// 0x0B18 (0x0C80 - 0x0168)
#pragma pack(push, 0x1)
class alignas(0x10) UCheckBox : public UContentWidget
{
public:
	ECheckBoxState                                CheckedState;                                      // 0x0168(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_169[0x3];                                      // 0x0169(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	TDelegate<void()>                             CheckedStateDelegate;                              // 0x016C(0x0010)(ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_17C[0x4];                                      // 0x017C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FCheckBoxStyle                         WidgetStyle;                                       // 0x0180(0x0AD0)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	EHorizontalAlignment                          HorizontalAlignment;                               // 0x0C50(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EButtonClickMethod                            ClickMethod;                                       // 0x0C51(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EButtonTouchMethod                            TouchMethod;                                       // 0x0C52(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EButtonPressMethod                            PressMethod;                                       // 0x0C53(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsFocusable;                                       // 0x0C54(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C55[0x3];                                      // 0x0C55(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	TMulticastInlineDelegate<void(bool bIsChecked)> OnCheckStateChanged;                             // 0x0C58(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_C68[0x10];                                     // 0x0C68(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SetCheckedState(ECheckBoxState InCheckedState)	 // 0x66cd954;
	void SetClickMethod(EButtonClickMethod InClickMethod)	 // 0x66cdad4;
	void SetIsChecked(bool InIsChecked)	 // 0x66ce6e8;
	void SetPressMethod(EButtonPressMethod InPressMethod)	 // 0x66cf434;
	void SetTouchMethod(EButtonTouchMethod InTouchMethod)	 // 0x66cfc34;

	ECheckBoxState GetCheckedState() const	 // 0x66cbc7c;
	bool IsChecked() const	 // 0x66cc664;
	bool IsPressed() const	 // 0x66cc94c;

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"CheckBox">();
	}
	static class UCheckBox* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UCheckBox>();
	}
};
#pragma pack(pop)
static_assert(alignof(UCheckBox) == 0x000010, "Wrong alignment on UCheckBox");
static_assert(sizeof(UCheckBox) == 0x000C80, "Wrong size on UCheckBox");
static_assert(offsetof(UCheckBox, CheckedState) == 0x000168, "Member 'UCheckBox::CheckedState' has a wrong offset!");
static_assert(offsetof(UCheckBox, CheckedStateDelegate) == 0x00016C, "Member 'UCheckBox::CheckedStateDelegate' has a wrong offset!");
static_assert(offsetof(UCheckBox, WidgetStyle) == 0x000180, "Member 'UCheckBox::WidgetStyle' has a wrong offset!");
static_assert(offsetof(UCheckBox, HorizontalAlignment) == 0x000C50, "Member 'UCheckBox::HorizontalAlignment' has a wrong offset!");
static_assert(offsetof(UCheckBox, ClickMethod) == 0x000C51, "Member 'UCheckBox::ClickMethod' has a wrong offset!");
static_assert(offsetof(UCheckBox, TouchMethod) == 0x000C52, "Member 'UCheckBox::TouchMethod' has a wrong offset!");
static_assert(offsetof(UCheckBox, PressMethod) == 0x000C53, "Member 'UCheckBox::PressMethod' has a wrong offset!");
static_assert(offsetof(UCheckBox, IsFocusable) == 0x000C54, "Member 'UCheckBox::IsFocusable' has a wrong offset!");
static_assert(offsetof(UCheckBox, OnCheckStateChanged) == 0x000C58, "Member 'UCheckBox::OnCheckStateChanged' has a wrong offset!");

// Class UMG.Slider
// 0x05B0 (0x0700 - 0x0150)
class USlider : public UWidget
{
public:
	float                                         Value;                                             // 0x0150(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TDelegate<void()>                             ValueDelegate;                                     // 0x0154(0x0010)(ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MinValue;                                          // 0x0164(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxValue;                                          // 0x0168(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_16C[0x4];                                      // 0x016C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FSliderStyle                           WidgetStyle;                                       // 0x0170(0x0500)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	EOrientation                                  Orientation;                                       // 0x0670(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_671[0x3];                                      // 0x0671(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FLinearColor                           SliderBarColor;                                    // 0x0674(0x0010)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           SliderHandleColor;                                 // 0x0684(0x0010)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IndentHandle;                                      // 0x0694(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          Locked;                                            // 0x0695(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          MouseUsesStep;                                     // 0x0696(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          RequiresControllerLock;                            // 0x0697(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         StepSize;                                          // 0x0698(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsFocusable;                                       // 0x069C(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_69D[0x3];                                      // 0x069D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	TMulticastInlineDelegate<void()>              OnMouseCaptureBegin;                               // 0x06A0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void()>              OnMouseCaptureEnd;                                 // 0x06B0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void()>              OnControllerCaptureBegin;                          // 0x06C0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void()>              OnControllerCaptureEnd;                            // 0x06D0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(float Value)>   OnValueChanged;                                    // 0x06E0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_6F0[0x10];                                     // 0x06F0(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SetIndentHandle(bool InValue)	 // 0x66f9940;
	void SetLocked(bool InValue)	 // 0x66fa434;
	void SetMaxValue(float InValue)	 // 0x66fa988;
	void SetMinValue(float InValue)	 // 0x66fb12c;
	void SetSliderBarColor(const struct FLinearColor& InValue)	 // 0x66fd8b8;
	void SetSliderHandleColor(const struct FLinearColor& InValue)	 // 0x66fd980;
	void SetStepSize(float InValue)	 // 0x66fdc6c;
	void SetValue(float InValue)	 // 0x66fec04;

	float GetNormalizedValue() const	 // 0x66f4250;
	float GetValue() const	 // 0x12bd7c8;

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"Slider">();
	}
	static class USlider* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<USlider>();
	}
};
static_assert(alignof(USlider) == 0x000010, "Wrong alignment on USlider");
static_assert(sizeof(USlider) == 0x000700, "Wrong size on USlider");
static_assert(offsetof(USlider, Value) == 0x000150, "Member 'USlider::Value' has a wrong offset!");
static_assert(offsetof(USlider, ValueDelegate) == 0x000154, "Member 'USlider::ValueDelegate' has a wrong offset!");
static_assert(offsetof(USlider, MinValue) == 0x000164, "Member 'USlider::MinValue' has a wrong offset!");
static_assert(offsetof(USlider, MaxValue) == 0x000168, "Member 'USlider::MaxValue' has a wrong offset!");
static_assert(offsetof(USlider, WidgetStyle) == 0x000170, "Member 'USlider::WidgetStyle' has a wrong offset!");
static_assert(offsetof(USlider, Orientation) == 0x000670, "Member 'USlider::Orientation' has a wrong offset!");
static_assert(offsetof(USlider, SliderBarColor) == 0x000674, "Member 'USlider::SliderBarColor' has a wrong offset!");
static_assert(offsetof(USlider, SliderHandleColor) == 0x000684, "Member 'USlider::SliderHandleColor' has a wrong offset!");
static_assert(offsetof(USlider, IndentHandle) == 0x000694, "Member 'USlider::IndentHandle' has a wrong offset!");
static_assert(offsetof(USlider, Locked) == 0x000695, "Member 'USlider::Locked' has a wrong offset!");
static_assert(offsetof(USlider, MouseUsesStep) == 0x000696, "Member 'USlider::MouseUsesStep' has a wrong offset!");
static_assert(offsetof(USlider, RequiresControllerLock) == 0x000697, "Member 'USlider::RequiresControllerLock' has a wrong offset!");
static_assert(offsetof(USlider, StepSize) == 0x000698, "Member 'USlider::StepSize' has a wrong offset!");
static_assert(offsetof(USlider, IsFocusable) == 0x00069C, "Member 'USlider::IsFocusable' has a wrong offset!");
static_assert(offsetof(USlider, OnMouseCaptureBegin) == 0x0006A0, "Member 'USlider::OnMouseCaptureBegin' has a wrong offset!");
static_assert(offsetof(USlider, OnMouseCaptureEnd) == 0x0006B0, "Member 'USlider::OnMouseCaptureEnd' has a wrong offset!");
static_assert(offsetof(USlider, OnControllerCaptureBegin) == 0x0006C0, "Member 'USlider::OnControllerCaptureBegin' has a wrong offset!");
static_assert(offsetof(USlider, OnControllerCaptureEnd) == 0x0006D0, "Member 'USlider::OnControllerCaptureEnd' has a wrong offset!");
static_assert(offsetof(USlider, OnValueChanged) == 0x0006E0, "Member 'USlider::OnValueChanged' has a wrong offset!");

// Class UMG.UMGSequencePlayer
// 0x0310 (0x0338 - 0x0028)
class UUMGSequencePlayer final : public UObject
{
public:
	uint8                                         Pad_28[0x1F8];                                     // 0x0028(0x01F8)(Fixing Size After Last Property [ Dumper-7 ])
	class UWidgetAnimation*                       Animation;                                         // 0x0220(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_228[0x8];                                      // 0x0228(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FMovieSceneRootEvaluationTemplateInstance RootTemplateInstance;                           // 0x0230(0x0088)(NativeAccessSpecifierPrivate)
	uint8                                         Pad_2B8[0x80];                                     // 0x02B8(0x0080)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SetUserTag(class FName InUserTag)	 // 0x66cfcf4;

	class FName GetUserTag() const	 // 0x66cc328;

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"UMGSequencePlayer">();
	}
	static class UUMGSequencePlayer* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UUMGSequencePlayer>();
	}
};
static_assert(alignof(UUMGSequencePlayer) == 0x000008, "Wrong alignment on UUMGSequencePlayer");
static_assert(sizeof(UUMGSequencePlayer) == 0x000338, "Wrong size on UUMGSequencePlayer");
static_assert(offsetof(UUMGSequencePlayer, Animation) == 0x000220, "Member 'UUMGSequencePlayer::Animation' has a wrong offset!");
static_assert(offsetof(UUMGSequencePlayer, RootTemplateInstance) == 0x000230, "Member 'UUMGSequencePlayer::RootTemplateInstance' has a wrong offset!");

// Class UMG.NativeWidgetHost
// 0x0010 (0x0160 - 0x0150)
class UNativeWidgetHost final : public UWidget
{
public:
	uint8                                         Pad_150[0x10];                                     // 0x0150(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"NativeWidgetHost">();
	}
	static class UNativeWidgetHost* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UNativeWidgetHost>();
	}
};
static_assert(alignof(UNativeWidgetHost) == 0x000008, "Wrong alignment on UNativeWidgetHost");
static_assert(sizeof(UNativeWidgetHost) == 0x000160, "Wrong size on UNativeWidgetHost");

// Class UMG.AsyncTaskDownloadImage
// 0x0020 (0x0050 - 0x0030)
class UAsyncTaskDownloadImage final : public UBlueprintAsyncActionBase
{
public:
	TMulticastInlineDelegate<void(class UTexture2DDynamic* Texture)> OnSuccess;                      // 0x0030(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(class UTexture2DDynamic* Texture)> OnFail;                         // 0x0040(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)

public:
	static class UAsyncTaskDownloadImage* DownloadImage(const class FString& URL)	 // 0x66cb9e8;

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"AsyncTaskDownloadImage">();
	}
	static class UAsyncTaskDownloadImage* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UAsyncTaskDownloadImage>();
	}
};
static_assert(alignof(UAsyncTaskDownloadImage) == 0x000008, "Wrong alignment on UAsyncTaskDownloadImage");
static_assert(sizeof(UAsyncTaskDownloadImage) == 0x000050, "Wrong size on UAsyncTaskDownloadImage");
static_assert(offsetof(UAsyncTaskDownloadImage, OnSuccess) == 0x000030, "Member 'UAsyncTaskDownloadImage::OnSuccess' has a wrong offset!");
static_assert(offsetof(UAsyncTaskDownloadImage, OnFail) == 0x000040, "Member 'UAsyncTaskDownloadImage::OnFail' has a wrong offset!");

// Class UMG.WidgetTree
// 0x0060 (0x0088 - 0x0028)
class UWidgetTree final : public UObject
{
public:
	uint8                                         Pad_28[0x8];                                       // 0x0028(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UWidget*                                RootWidget;                                        // 0x0030(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, PersistentInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TMap<class FName, class UWidget*>             NamedSlotBindings;                                 // 0x0038(0x0050)(ExportObject, ContainsInstancedReference, UObjectWrapper, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"WidgetTree">();
	}
	static class UWidgetTree* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UWidgetTree>();
	}
};
static_assert(alignof(UWidgetTree) == 0x000008, "Wrong alignment on UWidgetTree");
static_assert(sizeof(UWidgetTree) == 0x000088, "Wrong size on UWidgetTree");
static_assert(offsetof(UWidgetTree, RootWidget) == 0x000030, "Member 'UWidgetTree::RootWidget' has a wrong offset!");
static_assert(offsetof(UWidgetTree, NamedSlotBindings) == 0x000038, "Member 'UWidgetTree::NamedSlotBindings' has a wrong offset!");

// Class UMG.MovieSceneWidgetMaterialTrack
// 0x0028 (0x00D0 - 0x00A8)
class UMovieSceneWidgetMaterialTrack final : public UMovieSceneMaterialTrack
{
public:
	uint8                                         Pad_A8[0x10];                                      // 0x00A8(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class FName>                           BrushPropertyNamePath;                             // 0x00B8(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	class FName                                   TrackName;                                         // 0x00C8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"MovieSceneWidgetMaterialTrack">();
	}
	static class UMovieSceneWidgetMaterialTrack* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UMovieSceneWidgetMaterialTrack>();
	}
};
static_assert(alignof(UMovieSceneWidgetMaterialTrack) == 0x000008, "Wrong alignment on UMovieSceneWidgetMaterialTrack");
static_assert(sizeof(UMovieSceneWidgetMaterialTrack) == 0x0000D0, "Wrong size on UMovieSceneWidgetMaterialTrack");
static_assert(offsetof(UMovieSceneWidgetMaterialTrack, BrushPropertyNamePath) == 0x0000B8, "Member 'UMovieSceneWidgetMaterialTrack::BrushPropertyNamePath' has a wrong offset!");
static_assert(offsetof(UMovieSceneWidgetMaterialTrack, TrackName) == 0x0000C8, "Member 'UMovieSceneWidgetMaterialTrack::TrackName' has a wrong offset!");

// Class UMG.DynamicEntryBoxBase
// 0x00E0 (0x0230 - 0x0150)
class UDynamicEntryBoxBase : public UWidget
{
public:
	struct FVector2D                              EntrySpacing;                                      // 0x0150(0x0010)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<struct FVector2D>                      SpacingPattern;                                    // 0x0160(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	EDynamicBoxType                               EntryBoxType;                                      // 0x0170(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_171[0x3];                                      // 0x0171(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FSlateChildSize                        EntrySizeRule;                                     // 0x0174(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, Protected, NativeAccessSpecifierProtected)
	EHorizontalAlignment                          EntryHorizontalAlignment;                          // 0x017C(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EVerticalAlignment                            EntryVerticalAlignment;                            // 0x017D(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_17E[0x2];                                      // 0x017E(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         MaxElementSize;                                    // 0x0180(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FRadialBoxSettings                     RadialBoxSettings;                                 // 0x0184(0x0010)(Edit, BlueprintVisible, NoDestructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_194[0x14];                                     // 0x0194(0x0014)(Fixing Size After Last Property [ Dumper-7 ])
	struct FUserWidgetPool                        EntryWidgetPool;                                   // 0x01A8(0x0088)(Transient, ContainsInstancedReference, NativeAccessSpecifierPrivate)

public:
	void SetEntrySpacing(const struct FVector2D& InEntrySpacing)	 // 0x66cdeb8;
	void SetRadialSettings(const struct FRadialBoxSettings& InSettings)	 // 0x66cf4f4;

	const TArray<class UUserWidget*> GetAllEntries() const	 // 0x66cbbec;
	int32 GetNumEntries() const	 // 0x66cbeec;

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"DynamicEntryBoxBase">();
	}
	static class UDynamicEntryBoxBase* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UDynamicEntryBoxBase>();
	}
};
static_assert(alignof(UDynamicEntryBoxBase) == 0x000008, "Wrong alignment on UDynamicEntryBoxBase");
static_assert(sizeof(UDynamicEntryBoxBase) == 0x000230, "Wrong size on UDynamicEntryBoxBase");
static_assert(offsetof(UDynamicEntryBoxBase, EntrySpacing) == 0x000150, "Member 'UDynamicEntryBoxBase::EntrySpacing' has a wrong offset!");
static_assert(offsetof(UDynamicEntryBoxBase, SpacingPattern) == 0x000160, "Member 'UDynamicEntryBoxBase::SpacingPattern' has a wrong offset!");
static_assert(offsetof(UDynamicEntryBoxBase, EntryBoxType) == 0x000170, "Member 'UDynamicEntryBoxBase::EntryBoxType' has a wrong offset!");
static_assert(offsetof(UDynamicEntryBoxBase, EntrySizeRule) == 0x000174, "Member 'UDynamicEntryBoxBase::EntrySizeRule' has a wrong offset!");
static_assert(offsetof(UDynamicEntryBoxBase, EntryHorizontalAlignment) == 0x00017C, "Member 'UDynamicEntryBoxBase::EntryHorizontalAlignment' has a wrong offset!");
static_assert(offsetof(UDynamicEntryBoxBase, EntryVerticalAlignment) == 0x00017D, "Member 'UDynamicEntryBoxBase::EntryVerticalAlignment' has a wrong offset!");
static_assert(offsetof(UDynamicEntryBoxBase, MaxElementSize) == 0x000180, "Member 'UDynamicEntryBoxBase::MaxElementSize' has a wrong offset!");
static_assert(offsetof(UDynamicEntryBoxBase, RadialBoxSettings) == 0x000184, "Member 'UDynamicEntryBoxBase::RadialBoxSettings' has a wrong offset!");
static_assert(offsetof(UDynamicEntryBoxBase, EntryWidgetPool) == 0x0001A8, "Member 'UDynamicEntryBoxBase::EntryWidgetPool' has a wrong offset!");

// Class UMG.MovieSceneMarginSection
// 0x0448 (0x0538 - 0x00F0)
class UMovieSceneMarginSection final : public UMovieSceneSection
{
public:
	uint8                                         Pad_F0[0x8];                                       // 0x00F0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FMovieSceneFloatChannel                TopCurve;                                          // 0x00F8(0x0110)(NativeAccessSpecifierPublic)
	struct FMovieSceneFloatChannel                LeftCurve;                                         // 0x0208(0x0110)(NativeAccessSpecifierPublic)
	struct FMovieSceneFloatChannel                RightCurve;                                        // 0x0318(0x0110)(NativeAccessSpecifierPublic)
	struct FMovieSceneFloatChannel                BottomCurve;                                       // 0x0428(0x0110)(NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"MovieSceneMarginSection">();
	}
	static class UMovieSceneMarginSection* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UMovieSceneMarginSection>();
	}
};
static_assert(alignof(UMovieSceneMarginSection) == 0x000008, "Wrong alignment on UMovieSceneMarginSection");
static_assert(sizeof(UMovieSceneMarginSection) == 0x000538, "Wrong size on UMovieSceneMarginSection");
static_assert(offsetof(UMovieSceneMarginSection, TopCurve) == 0x0000F8, "Member 'UMovieSceneMarginSection::TopCurve' has a wrong offset!");
static_assert(offsetof(UMovieSceneMarginSection, LeftCurve) == 0x000208, "Member 'UMovieSceneMarginSection::LeftCurve' has a wrong offset!");
static_assert(offsetof(UMovieSceneMarginSection, RightCurve) == 0x000318, "Member 'UMovieSceneMarginSection::RightCurve' has a wrong offset!");
static_assert(offsetof(UMovieSceneMarginSection, BottomCurve) == 0x000428, "Member 'UMovieSceneMarginSection::BottomCurve' has a wrong offset!");

// Class UMG.WidgetSwitcher
// 0x0018 (0x0180 - 0x0168)
class UWidgetSwitcher : public UPanelWidget
{
public:
	int32                                         ActiveWidgetIndex;                                 // 0x0168(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_16C[0x14];                                     // 0x016C(0x0014)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SetActiveWidget(class UWidget* Widget)	 // 0x472b054;
	void SetActiveWidgetIndex(int32 Index_0)	 // 0xe12688;

	class UWidget* GetActiveWidget() const	 // 0x6711ec0;
	int32 GetActiveWidgetIndex() const	 // 0x6711ee4;
	int32 GetNumWidgets() const	 // 0x6713698;
	class UWidget* GetWidgetAtIndex(int32 Index_0) const	 // 0x6713b74;

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"WidgetSwitcher">();
	}
	static class UWidgetSwitcher* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UWidgetSwitcher>();
	}
};
static_assert(alignof(UWidgetSwitcher) == 0x000008, "Wrong alignment on UWidgetSwitcher");
static_assert(sizeof(UWidgetSwitcher) == 0x000180, "Wrong size on UWidgetSwitcher");
static_assert(offsetof(UWidgetSwitcher, ActiveWidgetIndex) == 0x000168, "Member 'UWidgetSwitcher::ActiveWidgetIndex' has a wrong offset!");

// Class UMG.UserListEntryLibrary
// 0x0000 (0x0028 - 0x0028)
class UUserListEntryLibrary final : public UBlueprintFunctionLibrary
{
public:
	static class UListViewBase* GetOwningListView(TScriptInterface<class IUserListEntry> UserListEntry)	 // 0x66cc030;
	static bool IsListItemExpanded(TScriptInterface<class IUserListEntry> UserListEntry)	 // 0x66cc688;
	static bool IsListItemSelected(TScriptInterface<class IUserListEntry> UserListEntry)	 // 0x66cc798;

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"UserListEntryLibrary">();
	}
	static class UUserListEntryLibrary* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UUserListEntryLibrary>();
	}
};
static_assert(alignof(UUserListEntryLibrary) == 0x000008, "Wrong alignment on UUserListEntryLibrary");
static_assert(sizeof(UUserListEntryLibrary) == 0x000028, "Wrong size on UUserListEntryLibrary");

// Class UMG.UserWidget
// 0x0130 (0x0280 - 0x0150)
class UUserWidget : public UWidget
{
public:
	uint8                                         Pad_150[0x8];                                      // 0x0150(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FLinearColor                           ColorAndOpacity;                                   // 0x0158(0x0010)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TDelegate<void()>                             ColorAndOpacityDelegate;                           // 0x0168(0x0010)(ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSlateColor                            ForegroundColor;                                   // 0x0178(0x0014)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	TDelegate<void()>                             ForegroundColorDelegate;                           // 0x018C(0x0010)(ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19C[0x4];                                      // 0x019C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TMulticastInlineDelegate<void(ESlateVisibility InVisibility)> OnVisibilityChanged;               // 0x01A0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_1B0[0x18];                                     // 0x01B0(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	struct FMargin                                Padding;                                           // 0x01C8(0x0010)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	int32                                         Priority;                                          // 0x01D8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bIsFocusable : 1;                                  // 0x01DC(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bStopAction : 1;                                   // 0x01DC(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_1DD[0x3];                                      // 0x01DD(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UUMGSequencePlayer*>             ActiveSequencePlayers;                             // 0x01E0(0x0010)(ZeroConstructor, Transient, UObjectWrapper, NativeAccessSpecifierPublic)
	class UUMGSequenceTickManager*                AnimationTickManager;                              // 0x01F0(0x0008)(ZeroConstructor, Transient, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class UUMGSequencePlayer*>             StoppedSequencePlayers;                            // 0x01F8(0x0010)(ZeroConstructor, Transient, UObjectWrapper, NativeAccessSpecifierPublic)
	TArray<struct FNamedSlotBinding>              NamedSlotBindings;                                 // 0x0208(0x0010)(ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	TArray<class UUserWidgetExtension*>           Extensions;                                        // 0x0218(0x0010)(ExportObject, ZeroConstructor, ContainsInstancedReference, UObjectWrapper, NativeAccessSpecifierPrivate)
	class UWidgetTree*                            WidgetTree;                                        // 0x0228(0x0008)(ZeroConstructor, Transient, DuplicateTransient, NoDestructor, TextExportTransient, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bHasScriptImplementedTick : 1;                     // 0x0230(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bHasScriptImplementedPaint : 1;                    // 0x0230(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_231[0x17];                                     // 0x0231(0x0017)(Fixing Size After Last Property [ Dumper-7 ])
	EWidgetTickFrequency                          TickFrequency;                                     // 0x0248(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_249[0x7];                                      // 0x0249(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UInputComponent*                        InputComponent;                                    // 0x0250(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, DuplicateTransient, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<struct FAnimationEventBinding>         AnimationCallbacks;                                // 0x0258(0x0010)(ZeroConstructor, Transient, DuplicateTransient, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_268[0x18];                                     // 0x0268(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	class UUserWidgetExtension* AddExtension(TSubclassOf<class UUserWidgetExtension> InExtensionType)	 // 0x670ef0c;
	bool AddToPlayerScreen(int32 ZOrder)	 // 0x670efdc;
	void AddToViewport(int32 ZOrder)	 // 0x17dbec0;
	void BindToAnimationEvent(class UWidgetAnimation* Animation, TDelegate<void()> Delegate, EWidgetAnimationEvent AnimationEvent, class FName UserTag)	 // 0x1537ad8;
	void BindToAnimationFinished(class UWidgetAnimation* Animation, TDelegate<void()> Delegate)	 // 0x1538348;
	void BindToAnimationStarted(class UWidgetAnimation* Animation, TDelegate<void()> Delegate)	 // 0x670f0a8;
	void CancelLatentActions()	 // 0x670f218;
	void Construct()	 // 0xae1e64;
	void Destruct()	 // 0xae1e64;
	void FlushAnimations()	 // 0x6711e80;
	bool IsAnimationPlayingForward(const class UWidgetAnimation* InAnimation)	 // 0x6713c44;
	void ListenForInputAction(class FName ActionName, EInputEvent EventType, bool bConsume, TDelegate<void()> Callback)	 // 0x671404c;
	void OnAddedToFocusPath(const struct FFocusEvent& InFocusEvent)	 // 0xae1e64;
	struct FEventReply OnAnalogValueChanged(const struct FGeometry& MyGeometry, const struct FAnalogInputEvent& InAnalogInputEvent)	 // 0xae1e64;
	void OnAnimationFinished(const class UWidgetAnimation* Animation)	 // 0x166e6f4;
	void OnAnimationStarted(const class UWidgetAnimation* Animation)	 // 0x166dcf4;
	void OnDragCancelled(const struct FPointerEvent& PointerEvent, class UDragDropOperation* Operation)	 // 0xae1e64;
	void OnDragDetected(const struct FGeometry& MyGeometry, const struct FPointerEvent& PointerEvent, class UDragDropOperation** Operation)	 // 0xae1e64;
	void OnDragEnter(const struct FGeometry& MyGeometry, const struct FPointerEvent& PointerEvent, class UDragDropOperation* Operation)	 // 0xae1e64;
	void OnDragLeave(const struct FPointerEvent& PointerEvent, class UDragDropOperation* Operation)	 // 0xae1e64;
	bool OnDragOver(const struct FGeometry& MyGeometry, const struct FPointerEvent& PointerEvent, class UDragDropOperation* Operation)	 // 0xae1e64;
	bool OnDrop(const struct FGeometry& MyGeometry, const struct FPointerEvent& PointerEvent, class UDragDropOperation* Operation)	 // 0xae1e64;
	void OnFocusLost(const struct FFocusEvent& InFocusEvent)	 // 0xae1e64;
	struct FEventReply OnFocusReceived(const struct FGeometry& MyGeometry, const struct FFocusEvent& InFocusEvent)	 // 0xae1e64;
	void OnInitialized()	 // 0xae1e64;
	struct FEventReply OnKeyChar(const struct FGeometry& MyGeometry, const struct FCharacterEvent& InCharacterEvent)	 // 0xae1e64;
	struct FEventReply OnKeyDown(const struct FGeometry& MyGeometry, const struct FKeyEvent& InKeyEvent)	 // 0xae1e64;
	struct FEventReply OnKeyUp(const struct FGeometry& MyGeometry, const struct FKeyEvent& InKeyEvent)	 // 0xae1e64;
	struct FEventReply OnMotionDetected(const struct FGeometry& MyGeometry, const struct FMotionEvent& InMotionEvent)	 // 0xae1e64;
	struct FEventReply OnMouseButtonDoubleClick(const struct FGeometry& InMyGeometry, const struct FPointerEvent& InMouseEvent)	 // 0xae1e64;
	struct FEventReply OnMouseButtonDown(const struct FGeometry& MyGeometry, const struct FPointerEvent& MouseEvent)	 // 0xae1e64;
	struct FEventReply OnMouseButtonUp(const struct FGeometry& MyGeometry, const struct FPointerEvent& MouseEvent)	 // 0xae1e64;
	void OnMouseCaptureLost()	 // 0xae1e64;
	void OnMouseEnter(const struct FGeometry& MyGeometry, const struct FPointerEvent& MouseEvent)	 // 0xae1e64;
	void OnMouseLeave(const struct FPointerEvent& MouseEvent)	 // 0xae1e64;
	struct FEventReply OnMouseMove(const struct FGeometry& MyGeometry, const struct FPointerEvent& MouseEvent)	 // 0xae1e64;
	struct FEventReply OnMouseWheel(const struct FGeometry& MyGeometry, const struct FPointerEvent& MouseEvent)	 // 0xae1e64;
	struct FEventReply OnPreviewKeyDown(const struct FGeometry& MyGeometry, const struct FKeyEvent& InKeyEvent)	 // 0xae1e64;
	struct FEventReply OnPreviewMouseButtonDown(const struct FGeometry& MyGeometry, const struct FPointerEvent& MouseEvent)	 // 0xae1e64;
	void OnRemovedFromFocusPath(const struct FFocusEvent& InFocusEvent)	 // 0xae1e64;
	struct FEventReply OnTouchEnded(const struct FGeometry& MyGeometry, const struct FPointerEvent& InTouchEvent)	 // 0xae1e64;
	struct FEventReply OnTouchForceChanged(const struct FGeometry& MyGeometry, const struct FPointerEvent& InTouchEvent)	 // 0xae1e64;
	struct FEventReply OnTouchGesture(const struct FGeometry& MyGeometry, const struct FPointerEvent& GestureEvent)	 // 0xae1e64;
	struct FEventReply OnTouchMoved(const struct FGeometry& MyGeometry, const struct FPointerEvent& InTouchEvent)	 // 0xae1e64;
	struct FEventReply OnTouchStarted(const struct FGeometry& MyGeometry, const struct FPointerEvent& InTouchEvent)	 // 0xae1e64;
	float PauseAnimation(const class UWidgetAnimation* InAnimation)	 // 0x6714e94;
	class UUMGSequencePlayer* PlayAnimation(class UWidgetAnimation* InAnimation, float StartAtTime, int32 NumLoopsToPlay, EUMGSequencePlayMode PlayMode, float PlaybackSpeed, bool bRestoreState)	 // 0x1649180;
	class UUMGSequencePlayer* PlayAnimationForward(class UWidgetAnimation* InAnimation, float PlaybackSpeed, bool bRestoreState)	 // 0x6714fd0;
	class UUMGSequencePlayer* PlayAnimationReverse(class UWidgetAnimation* InAnimation, float PlaybackSpeed, bool bRestoreState)	 // 0x6715190;
	class UUMGSequencePlayer* PlayAnimationTimeRange(class UWidgetAnimation* InAnimation, float StartAtTime, float EndAtTime, int32 NumLoopsToPlay, EUMGSequencePlayMode PlayMode, float PlaybackSpeed, bool bRestoreState)	 // 0x6715350;
	void PlaySound(class USoundBase* SoundToPlay)	 // 0x6715704;
	void PreConstruct(bool IsDesignTime)	 // 0xae1e64;
	void RegisterInputComponent()	 // 0x6715f58;
	void RemoveExtension(class UUserWidgetExtension* InExtension)	 // 0x67165dc;
	void RemoveExtensions(TSubclassOf<class UUserWidgetExtension> InExtensionType)	 // 0x6716708;
	void RemoveFromViewport()	 // 0x115cedc;
	void ReverseAnimation(const class UWidgetAnimation* InAnimation)	 // 0x6716834;
	void SetAlignmentInViewport(const struct FVector2D& Alignment)	 // 0x671722c;
	void SetAnchorsInViewport(const struct FAnchors& Anchors)	 // 0x67172f4;
	void SetAnimationCurrentTime(const class UWidgetAnimation* InAnimation, float InTime)	 // 0x67173d4;
	void SetColorAndOpacity(const struct FLinearColor& InColorAndOpacity)	 // 0xb13358;
	void SetDesiredSizeInViewport(const struct FVector2D& Size)	 // 0x6717a90;
	void SetForegroundColor(const struct FSlateColor& InForegroundColor)	 // 0x6717dec;
	void SetInputActionBlocking(bool bShouldBlock)	 // 0x6718518;
	void SetInputActionPriority(int32 NewPriority)	 // 0x67185dc;
	void SetNumLoopsToPlay(const class UWidgetAnimation* InAnimation, int32 NumLoopsToPlay)	 // 0x6718d80;
	void SetOwningPlayer(class APlayerController* LocalPlayerController)	 // 0x6718ee8;
	void SetPadding(const struct FMargin& InPadding)	 // 0x6718fc8;
	void SetPlaybackSpeed(const class UWidgetAnimation* InAnimation, float PlaybackSpeed)	 // 0x67193d8;
	void SetPositionInViewport(const struct FVector2D& Position, bool bRemoveDPIScale)	 // 0x6719530;
	void StopAllAnimations()	 // 0x178c378;
	void StopAnimation(const class UWidgetAnimation* InAnimation)	 // 0x1204034;
	void StopAnimationsAndLatentActions()	 // 0x671a444;
	void StopListeningForAllInputActions()	 // 0x671a46c;
	void StopListeningForInputAction(class FName ActionName, EInputEvent EventType)	 // 0x671a480;
	void Tick(const struct FGeometry& MyGeometry, float InDeltaTime)	 // 0xae1e64;
	void UnbindAllFromAnimationFinished(class UWidgetAnimation* Animation)	 // 0x671ab68;
	void UnbindAllFromAnimationStarted(class UWidgetAnimation* Animation)	 // 0x671ac28;
	void UnbindFromAnimationFinished(class UWidgetAnimation* Animation, TDelegate<void()> Delegate)	 // 0x671ace8;
	void UnbindFromAnimationStarted(class UWidgetAnimation* Animation, TDelegate<void()> Delegate)	 // 0x671ae3c;
	void UnregisterInputComponent()	 // 0x671b0ec;

	struct FVector2D GetAlignmentInViewport() const	 // 0x6711f08;
	struct FAnchors GetAnchorsInViewport() const	 // 0x6712688;
	float GetAnimationCurrentTime(const class UWidgetAnimation* InAnimation) const	 // 0x671270c;
	class UUserWidgetExtension* GetExtension(TSubclassOf<class UUserWidgetExtension> ExtensionType) const	 // 0x6712ce4;
	TArray<class UUserWidgetExtension*> GetExtensions(TSubclassOf<class UUserWidgetExtension> ExtensionType) const	 // 0x6712db4;
	bool GetIsVisible() const	 // 0x66f4e7c;
	class APlayerCameraManager* GetOwningPlayerCameraManager() const	 // 0x67136d8;
	class APawn* GetOwningPlayerPawn() const	 // 0x17bf034;
	bool IsAnimationPlaying(const class UWidgetAnimation* InAnimation) const	 // 0x17365d0;
	bool IsAnyAnimationPlaying() const	 // 0x6713d40;
	bool IsInteractable() const	 // 0xae1e64;
	bool IsListeningForInputAction(class FName ActionName) const	 // 0x6713dd4;
	bool IsPlayingAnimation() const	 // 0x6713d40;
	void OnPaint(struct FPaintContext& Context) const	 // 0xae1e64;

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"UserWidget">();
	}
	static class UUserWidget* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UUserWidget>();
	}
};
static_assert(alignof(UUserWidget) == 0x000008, "Wrong alignment on UUserWidget");
static_assert(sizeof(UUserWidget) == 0x000280, "Wrong size on UUserWidget");
static_assert(offsetof(UUserWidget, ColorAndOpacity) == 0x000158, "Member 'UUserWidget::ColorAndOpacity' has a wrong offset!");
static_assert(offsetof(UUserWidget, ColorAndOpacityDelegate) == 0x000168, "Member 'UUserWidget::ColorAndOpacityDelegate' has a wrong offset!");
static_assert(offsetof(UUserWidget, ForegroundColor) == 0x000178, "Member 'UUserWidget::ForegroundColor' has a wrong offset!");
static_assert(offsetof(UUserWidget, ForegroundColorDelegate) == 0x00018C, "Member 'UUserWidget::ForegroundColorDelegate' has a wrong offset!");
static_assert(offsetof(UUserWidget, OnVisibilityChanged) == 0x0001A0, "Member 'UUserWidget::OnVisibilityChanged' has a wrong offset!");
static_assert(offsetof(UUserWidget, Padding) == 0x0001C8, "Member 'UUserWidget::Padding' has a wrong offset!");
static_assert(offsetof(UUserWidget, Priority) == 0x0001D8, "Member 'UUserWidget::Priority' has a wrong offset!");
static_assert(offsetof(UUserWidget, ActiveSequencePlayers) == 0x0001E0, "Member 'UUserWidget::ActiveSequencePlayers' has a wrong offset!");
static_assert(offsetof(UUserWidget, AnimationTickManager) == 0x0001F0, "Member 'UUserWidget::AnimationTickManager' has a wrong offset!");
static_assert(offsetof(UUserWidget, StoppedSequencePlayers) == 0x0001F8, "Member 'UUserWidget::StoppedSequencePlayers' has a wrong offset!");
static_assert(offsetof(UUserWidget, NamedSlotBindings) == 0x000208, "Member 'UUserWidget::NamedSlotBindings' has a wrong offset!");
static_assert(offsetof(UUserWidget, Extensions) == 0x000218, "Member 'UUserWidget::Extensions' has a wrong offset!");
static_assert(offsetof(UUserWidget, WidgetTree) == 0x000228, "Member 'UUserWidget::WidgetTree' has a wrong offset!");
static_assert(offsetof(UUserWidget, TickFrequency) == 0x000248, "Member 'UUserWidget::TickFrequency' has a wrong offset!");
static_assert(offsetof(UUserWidget, InputComponent) == 0x000250, "Member 'UUserWidget::InputComponent' has a wrong offset!");
static_assert(offsetof(UUserWidget, AnimationCallbacks) == 0x000258, "Member 'UUserWidget::AnimationCallbacks' has a wrong offset!");

// Class UMG.Button
// 0x0488 (0x05F0 - 0x0168)
#pragma pack(push, 0x1)
class alignas(0x10) UButton : public UContentWidget
{
public:
	uint8                                         Pad_168[0x8];                                      // 0x0168(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FButtonStyle                           WidgetStyle;                                       // 0x0170(0x03F0)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	struct FLinearColor                           ColorAndOpacity;                                   // 0x0560(0x0010)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           BackgroundColor;                                   // 0x0570(0x0010)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EButtonClickMethod                            ClickMethod;                                       // 0x0580(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EButtonTouchMethod                            TouchMethod;                                       // 0x0581(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EButtonPressMethod                            PressMethod;                                       // 0x0582(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsFocusable;                                       // 0x0583(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_584[0x4];                                      // 0x0584(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TMulticastInlineDelegate<void()>              OnClicked;                                         // 0x0588(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void()>              OnPressed;                                         // 0x0598(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void()>              OnReleased;                                        // 0x05A8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void()>              OnHovered;                                         // 0x05B8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void()>              OnUnhovered;                                       // 0x05C8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_5D8[0x10];                                     // 0x05D8(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SetBackgroundColor(const struct FLinearColor& InBackgroundColor)	 // 0x66cd70c;
	void SetClickMethod(EButtonClickMethod InClickMethod)	 // 0x66cda14;
	void SetColorAndOpacity(const struct FLinearColor& InColorAndOpacity)	 // 0x12954a4;
	void SetPressMethod(EButtonPressMethod InPressMethod)	 // 0x66cf374;
	void SetStyle(const struct FButtonStyle& InStyle)	 // 0x129678c;
	void SetTouchMethod(EButtonTouchMethod InTouchMethod)	 // 0x66cfb74;

	bool IsPressed() const	 // 0x66cc918;

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"Button">();
	}
	static class UButton* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UButton>();
	}
};
#pragma pack(pop)
static_assert(alignof(UButton) == 0x000010, "Wrong alignment on UButton");
static_assert(sizeof(UButton) == 0x0005F0, "Wrong size on UButton");
static_assert(offsetof(UButton, WidgetStyle) == 0x000170, "Member 'UButton::WidgetStyle' has a wrong offset!");
static_assert(offsetof(UButton, ColorAndOpacity) == 0x000560, "Member 'UButton::ColorAndOpacity' has a wrong offset!");
static_assert(offsetof(UButton, BackgroundColor) == 0x000570, "Member 'UButton::BackgroundColor' has a wrong offset!");
static_assert(offsetof(UButton, ClickMethod) == 0x000580, "Member 'UButton::ClickMethod' has a wrong offset!");
static_assert(offsetof(UButton, TouchMethod) == 0x000581, "Member 'UButton::TouchMethod' has a wrong offset!");
static_assert(offsetof(UButton, PressMethod) == 0x000582, "Member 'UButton::PressMethod' has a wrong offset!");
static_assert(offsetof(UButton, IsFocusable) == 0x000583, "Member 'UButton::IsFocusable' has a wrong offset!");
static_assert(offsetof(UButton, OnClicked) == 0x000588, "Member 'UButton::OnClicked' has a wrong offset!");
static_assert(offsetof(UButton, OnPressed) == 0x000598, "Member 'UButton::OnPressed' has a wrong offset!");
static_assert(offsetof(UButton, OnReleased) == 0x0005A8, "Member 'UButton::OnReleased' has a wrong offset!");
static_assert(offsetof(UButton, OnHovered) == 0x0005B8, "Member 'UButton::OnHovered' has a wrong offset!");
static_assert(offsetof(UButton, OnUnhovered) == 0x0005C8, "Member 'UButton::OnUnhovered' has a wrong offset!");

// Class UMG.TextLayoutWidget
// 0x0020 (0x0170 - 0x0150)
class UTextLayoutWidget : public UWidget
{
public:
	struct FShapedTextOptions                     ShapedTextOptions;                                 // 0x0150(0x0003)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, AdvancedDisplay, Protected, NativeAccessSpecifierProtected)
	ETextJustify                                  Justification;                                     // 0x0153(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	ETextWrappingPolicy                           WrappingPolicy;                                    // 0x0154(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         AutoWrapText : 1;                                  // 0x0155(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         Pad_156[0x2];                                      // 0x0156(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         WrapTextAt;                                        // 0x0158(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FMargin                                Margin;                                            // 0x015C(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, Protected, NativeAccessSpecifierProtected)
	float                                         LineHeightPercentage;                              // 0x016C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void SetJustification(ETextJustify InJustification)	 // 0x66fa1c0;

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"TextLayoutWidget">();
	}
	static class UTextLayoutWidget* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UTextLayoutWidget>();
	}
};
static_assert(alignof(UTextLayoutWidget) == 0x000008, "Wrong alignment on UTextLayoutWidget");
static_assert(sizeof(UTextLayoutWidget) == 0x000170, "Wrong size on UTextLayoutWidget");
static_assert(offsetof(UTextLayoutWidget, ShapedTextOptions) == 0x000150, "Member 'UTextLayoutWidget::ShapedTextOptions' has a wrong offset!");
static_assert(offsetof(UTextLayoutWidget, Justification) == 0x000153, "Member 'UTextLayoutWidget::Justification' has a wrong offset!");
static_assert(offsetof(UTextLayoutWidget, WrappingPolicy) == 0x000154, "Member 'UTextLayoutWidget::WrappingPolicy' has a wrong offset!");
static_assert(offsetof(UTextLayoutWidget, WrapTextAt) == 0x000158, "Member 'UTextLayoutWidget::WrapTextAt' has a wrong offset!");
static_assert(offsetof(UTextLayoutWidget, Margin) == 0x00015C, "Member 'UTextLayoutWidget::Margin' has a wrong offset!");
static_assert(offsetof(UTextLayoutWidget, LineHeightPercentage) == 0x00016C, "Member 'UTextLayoutWidget::LineHeightPercentage' has a wrong offset!");

// Class UMG.MovieScene2DTransformPropertySystem
// 0x0000 (0x0058 - 0x0058)
class UMovieScene2DTransformPropertySystem final : public UMovieScenePropertySystem
{
public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"MovieScene2DTransformPropertySystem">();
	}
	static class UMovieScene2DTransformPropertySystem* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UMovieScene2DTransformPropertySystem>();
	}
};
static_assert(alignof(UMovieScene2DTransformPropertySystem) == 0x000008, "Wrong alignment on UMovieScene2DTransformPropertySystem");
static_assert(sizeof(UMovieScene2DTransformPropertySystem) == 0x000058, "Wrong size on UMovieScene2DTransformPropertySystem");

// Class UMG.TextBlock
// 0x01D0 (0x0340 - 0x0170)
#pragma pack(push, 0x1)
class alignas(0x10) UTextBlock : public UTextLayoutWidget
{
public:
	class FText                                   Text;                                              // 0x0170(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	TDelegate<void()>                             TextDelegate;                                      // 0x0188(0x0010)(ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSlateColor                            ColorAndOpacity;                                   // 0x0198(0x0014)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	TDelegate<void()>                             ColorAndOpacityDelegate;                           // 0x01AC(0x0010)(ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1BC[0x4];                                      // 0x01BC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FSlateFontInfo                         Font;                                              // 0x01C0(0x0058)(Edit, BlueprintVisible, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_218[0x8];                                      // 0x0218(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FSlateBrush                            StrikeBrush;                                       // 0x0220(0x00D0)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	struct FVector2D                              ShadowOffset;                                      // 0x02F0(0x0010)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           ShadowColorAndOpacity;                             // 0x0300(0x0010)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TDelegate<void()>                             ShadowColorAndOpacityDelegate;                     // 0x0310(0x0010)(ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MinDesiredWidth;                                   // 0x0320(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bWrapWithInvalidationPanel;                        // 0x0324(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETextTransformPolicy                          TextTransformPolicy;                               // 0x0325(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETextOverflowPolicy                           TextOverflowPolicy;                                // 0x0326(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bSimpleTextMode;                                   // 0x0327(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_328[0x10];                                     // 0x0328(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	class UMaterialInstanceDynamic* GetDynamicFontMaterial()	 // 0x66f3ce8;
	class UMaterialInstanceDynamic* GetDynamicOutlineMaterial()	 // 0x66f3d0c;
	void SetAutoWrapText(bool InAutoTextWrap)	 // 0x66f6a0c;
	void SetColorAndOpacity(const struct FSlateColor& InColorAndOpacity)	 // 0xb14f9c;
	void SetFont(const struct FSlateFontInfo& InFontInfo)	 // 0x18690b4;
	void SetFontMaterial(class UMaterialInterface* InMaterial)	 // 0x66f8a90;
	void SetFontOutlineMaterial(class UMaterialInterface* InMaterial)	 // 0x66f8c4c;
	void SetMinDesiredWidth(float InMinDesiredWidth)	 // 0x66faee4;
	void SetOpacity(float InOpacity)	 // 0x66fbda8;
	void SetShadowColorAndOpacity(const struct FLinearColor& InShadowColorAndOpacity)	 // 0x17a6114;
	void SetShadowOffset(const struct FVector2D& InShadowOffset)	 // 0x1801744;
	void SetStrikeBrush(const struct FSlateBrush& InStrikeBrush)	 // 0x17fc718;
	void SetText(const class FText& InText)	 // 0xf82e40;
	void SetTextOverflowPolicy(ETextOverflowPolicy InOverflowPolicy)	 // 0x66fe200;
	void SetTextTransformPolicy(ETextTransformPolicy InTransformPolicy)	 // 0x66fe50c;

	class FText GetText() const	 // 0x66f4574;

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"TextBlock">();
	}
	static class UTextBlock* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UTextBlock>();
	}
};
#pragma pack(pop)
static_assert(alignof(UTextBlock) == 0x000010, "Wrong alignment on UTextBlock");
static_assert(sizeof(UTextBlock) == 0x000340, "Wrong size on UTextBlock");
static_assert(offsetof(UTextBlock, Text) == 0x000170, "Member 'UTextBlock::Text' has a wrong offset!");
static_assert(offsetof(UTextBlock, TextDelegate) == 0x000188, "Member 'UTextBlock::TextDelegate' has a wrong offset!");
static_assert(offsetof(UTextBlock, ColorAndOpacity) == 0x000198, "Member 'UTextBlock::ColorAndOpacity' has a wrong offset!");
static_assert(offsetof(UTextBlock, ColorAndOpacityDelegate) == 0x0001AC, "Member 'UTextBlock::ColorAndOpacityDelegate' has a wrong offset!");
static_assert(offsetof(UTextBlock, Font) == 0x0001C0, "Member 'UTextBlock::Font' has a wrong offset!");
static_assert(offsetof(UTextBlock, StrikeBrush) == 0x000220, "Member 'UTextBlock::StrikeBrush' has a wrong offset!");
static_assert(offsetof(UTextBlock, ShadowOffset) == 0x0002F0, "Member 'UTextBlock::ShadowOffset' has a wrong offset!");
static_assert(offsetof(UTextBlock, ShadowColorAndOpacity) == 0x000300, "Member 'UTextBlock::ShadowColorAndOpacity' has a wrong offset!");
static_assert(offsetof(UTextBlock, ShadowColorAndOpacityDelegate) == 0x000310, "Member 'UTextBlock::ShadowColorAndOpacityDelegate' has a wrong offset!");
static_assert(offsetof(UTextBlock, MinDesiredWidth) == 0x000320, "Member 'UTextBlock::MinDesiredWidth' has a wrong offset!");
static_assert(offsetof(UTextBlock, bWrapWithInvalidationPanel) == 0x000324, "Member 'UTextBlock::bWrapWithInvalidationPanel' has a wrong offset!");
static_assert(offsetof(UTextBlock, TextTransformPolicy) == 0x000325, "Member 'UTextBlock::TextTransformPolicy' has a wrong offset!");
static_assert(offsetof(UTextBlock, TextOverflowPolicy) == 0x000326, "Member 'UTextBlock::TextOverflowPolicy' has a wrong offset!");
static_assert(offsetof(UTextBlock, bSimpleTextMode) == 0x000327, "Member 'UTextBlock::bSimpleTextMode' has a wrong offset!");

// Class UMG.ScrollBox
// 0x0B58 (0x0CC0 - 0x0168)
class UScrollBox : public UPanelWidget
{
public:
	uint8                                         Pad_168[0x8];                                      // 0x0168(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FScrollBoxStyle                        WidgetStyle;                                       // 0x0170(0x0370)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	struct FScrollBarStyle                        WidgetBarStyle;                                    // 0x04E0(0x0770)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	EOrientation                                  Orientation;                                       // 0x0C50(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ESlateVisibility                              ScrollBarVisibility;                               // 0x0C51(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EConsumeMouseWheel                            ConsumeMouseWheel;                                 // 0x0C52(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C53[0x5];                                      // 0x0C53(0x0005)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector2D                              ScrollbarThickness;                                // 0x0C58(0x0010)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FMargin                                ScrollbarPadding;                                  // 0x0C68(0x0010)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          AlwaysShowScrollbar;                               // 0x0C78(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          AlwaysShowScrollbarTrack;                          // 0x0C79(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          AllowOverscroll;                                   // 0x0C7A(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          BackPadScrolling;                                  // 0x0C7B(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          FrontPadScrolling;                                 // 0x0C7C(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAnimateWheelScrolling;                            // 0x0C7D(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EDescendantScrollDestination                  NavigationDestination;                             // 0x0C7E(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C7F[0x1];                                      // 0x0C7F(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         NavigationScrollPadding;                           // 0x0C80(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EScrollWhenFocusChanges                       ScrollWhenFocusChanges;                            // 0x0C84(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAllowRightClickDragScrolling;                     // 0x0C85(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C86[0x2];                                      // 0x0C86(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         WheelScrollMultiplier;                             // 0x0C88(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C8C[0x4];                                      // 0x0C8C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TMulticastInlineDelegate<void(float CurrentOffset)> OnUserScrolled;                              // 0x0C90(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_CA0[0x20];                                     // 0x0CA0(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void EndInertialScrolling()	 // 0x66f35a0;
	void ScrollToEnd()	 // 0x66f5ea0;
	void ScrollToStart()	 // 0x66f5eb4;
	void ScrollWidgetIntoView(class UWidget* WidgetToFind, bool AnimateScroll, EDescendantScrollDestination ScrollDestination, float Padding)	 // 0x66f5edc;
	void SetAllowOverscroll(bool NewAllowOverscroll)	 // 0x66f63ec;
	void SetAlwaysShowScrollbar(bool NewAlwaysShowScrollbar)	 // 0x66f64b0;
	void SetAnimateWheelScrolling(bool bShouldAnimateWheelScrolling)	 // 0x66f6884;
	void SetConsumeMouseWheel(EConsumeMouseWheel NewConsumeMouseWheel)	 // 0x66f762c;
	void SetNavigationDestination(const EDescendantScrollDestination NewNavigationDestination)	 // 0x66fb2b4;
	void SetOrientation(EOrientation NewOrientation)	 // 0x66fbe6c;
	void SetScrollbarPadding(const struct FMargin& NewScrollbarPadding)	 // 0x66fcf68;
	void SetScrollbarThickness(const struct FVector2D& NewScrollbarThickness)	 // 0x66fcff8;
	void SetScrollBarVisibility(ESlateVisibility NewScrollBarVisibility)	 // 0x66fcc60;
	void SetScrollOffset(float NewScrollOffset)	 // 0x66fcde4;
	void SetScrollWhenFocusChanges(EScrollWhenFocusChanges NewScrollWhenFocusChanges)	 // 0x66fcea8;
	void SetWheelScrollMultiplier(float NewWheelScrollMultiplier)	 // 0x66ff54c;

	float GetScrollOffset() const	 // 0x66f43dc;
	float GetScrollOffsetOfEnd() const	 // 0x66f43fc;
	float GetViewFraction() const	 // 0x66f4640;
	float GetViewOffsetFraction() const	 // 0x66f46c8;

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"ScrollBox">();
	}
	static class UScrollBox* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UScrollBox>();
	}
};
static_assert(alignof(UScrollBox) == 0x000010, "Wrong alignment on UScrollBox");
static_assert(sizeof(UScrollBox) == 0x000CC0, "Wrong size on UScrollBox");
static_assert(offsetof(UScrollBox, WidgetStyle) == 0x000170, "Member 'UScrollBox::WidgetStyle' has a wrong offset!");
static_assert(offsetof(UScrollBox, WidgetBarStyle) == 0x0004E0, "Member 'UScrollBox::WidgetBarStyle' has a wrong offset!");
static_assert(offsetof(UScrollBox, Orientation) == 0x000C50, "Member 'UScrollBox::Orientation' has a wrong offset!");
static_assert(offsetof(UScrollBox, ScrollBarVisibility) == 0x000C51, "Member 'UScrollBox::ScrollBarVisibility' has a wrong offset!");
static_assert(offsetof(UScrollBox, ConsumeMouseWheel) == 0x000C52, "Member 'UScrollBox::ConsumeMouseWheel' has a wrong offset!");
static_assert(offsetof(UScrollBox, ScrollbarThickness) == 0x000C58, "Member 'UScrollBox::ScrollbarThickness' has a wrong offset!");
static_assert(offsetof(UScrollBox, ScrollbarPadding) == 0x000C68, "Member 'UScrollBox::ScrollbarPadding' has a wrong offset!");
static_assert(offsetof(UScrollBox, AlwaysShowScrollbar) == 0x000C78, "Member 'UScrollBox::AlwaysShowScrollbar' has a wrong offset!");
static_assert(offsetof(UScrollBox, AlwaysShowScrollbarTrack) == 0x000C79, "Member 'UScrollBox::AlwaysShowScrollbarTrack' has a wrong offset!");
static_assert(offsetof(UScrollBox, AllowOverscroll) == 0x000C7A, "Member 'UScrollBox::AllowOverscroll' has a wrong offset!");
static_assert(offsetof(UScrollBox, BackPadScrolling) == 0x000C7B, "Member 'UScrollBox::BackPadScrolling' has a wrong offset!");
static_assert(offsetof(UScrollBox, FrontPadScrolling) == 0x000C7C, "Member 'UScrollBox::FrontPadScrolling' has a wrong offset!");
static_assert(offsetof(UScrollBox, bAnimateWheelScrolling) == 0x000C7D, "Member 'UScrollBox::bAnimateWheelScrolling' has a wrong offset!");
static_assert(offsetof(UScrollBox, NavigationDestination) == 0x000C7E, "Member 'UScrollBox::NavigationDestination' has a wrong offset!");
static_assert(offsetof(UScrollBox, NavigationScrollPadding) == 0x000C80, "Member 'UScrollBox::NavigationScrollPadding' has a wrong offset!");
static_assert(offsetof(UScrollBox, ScrollWhenFocusChanges) == 0x000C84, "Member 'UScrollBox::ScrollWhenFocusChanges' has a wrong offset!");
static_assert(offsetof(UScrollBox, bAllowRightClickDragScrolling) == 0x000C85, "Member 'UScrollBox::bAllowRightClickDragScrolling' has a wrong offset!");
static_assert(offsetof(UScrollBox, WheelScrollMultiplier) == 0x000C88, "Member 'UScrollBox::WheelScrollMultiplier' has a wrong offset!");
static_assert(offsetof(UScrollBox, OnUserScrolled) == 0x000C90, "Member 'UScrollBox::OnUserScrolled' has a wrong offset!");

// Class UMG.Image
// 0x0160 (0x02B0 - 0x0150)
class UImage : public UWidget
{
public:
	struct FSlateBrush                            Brush;                                             // 0x0150(0x00D0)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	TDelegate<void()>                             BrushDelegate;                                     // 0x0220(0x0010)(ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           ColorAndOpacity;                                   // 0x0230(0x0010)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TDelegate<void()>                             ColorAndOpacityDelegate;                           // 0x0240(0x0010)(ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bFlipForRightToLeftFlowDirection;                  // 0x0250(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_251[0x3];                                      // 0x0251(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	TDelegate<void(const struct FGeometry& MyGeometry, const struct FPointerEvent& MouseEvent)> OnMouseButtonDownEvent; // 0x0254(0x0010)(Edit, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_264[0x4C];                                     // 0x0264(0x004C)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	class UMaterialInstanceDynamic* GetDynamicMaterial()	 // 0x1087e2c;
	void SetBrush(const struct FSlateBrush& InBrush)	 // 0x17cfb44;
	void SetBrushFromAsset(class USlateBrushAsset* Asset)	 // 0x4c0b3ec;
	void SetBrushFromAtlasInterface(TScriptInterface<class ISlateTextureAtlasInterface> AtlasRegion, bool bMatchSize)	 // 0x66f6bcc;
	void SetBrushFromMaterial(class UMaterialInterface* Material)	 // 0x17d32d4;
	void SetBrushFromSoftMaterial(TSoftObjectPtr<class UMaterialInterface> SoftMaterial)	 // 0x66f6d30;
	void SetBrushFromSoftTexture(TSoftObjectPtr<class UTexture2D> SoftTexture, bool bMatchSize)	 // 0x153b784;
	void SetBrushFromTexture(class UTexture2D* Texture, bool bMatchSize)	 // 0x162f454;
	void SetBrushFromTextureDynamic(class UTexture2DDynamic* Texture, bool bMatchSize)	 // 0x66f6e44;
	void SetBrushResourceObject(class UObject* ResourceObject)	 // 0x66f6f8c;
	void SetBrushTintColor(const struct FSlateColor& TintColor)	 // 0x66f704c;
	void SetColorAndOpacity(const struct FLinearColor& InColorAndOpacity)	 // 0xb14df4;
	void SetDesiredSizeOverride(const struct FVector2D& DesiredSize)	 // 0x66f808c;
	void SetOpacity(float InOpacity)	 // 0x158ed18;

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"Image">();
	}
	static class UImage* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UImage>();
	}
};
static_assert(alignof(UImage) == 0x000010, "Wrong alignment on UImage");
static_assert(sizeof(UImage) == 0x0002B0, "Wrong size on UImage");
static_assert(offsetof(UImage, Brush) == 0x000150, "Member 'UImage::Brush' has a wrong offset!");
static_assert(offsetof(UImage, BrushDelegate) == 0x000220, "Member 'UImage::BrushDelegate' has a wrong offset!");
static_assert(offsetof(UImage, ColorAndOpacity) == 0x000230, "Member 'UImage::ColorAndOpacity' has a wrong offset!");
static_assert(offsetof(UImage, ColorAndOpacityDelegate) == 0x000240, "Member 'UImage::ColorAndOpacityDelegate' has a wrong offset!");
static_assert(offsetof(UImage, bFlipForRightToLeftFlowDirection) == 0x000250, "Member 'UImage::bFlipForRightToLeftFlowDirection' has a wrong offset!");
static_assert(offsetof(UImage, OnMouseButtonDownEvent) == 0x000254, "Member 'UImage::OnMouseButtonDownEvent' has a wrong offset!");

// Class UMG.Viewport
// 0x0050 (0x01B8 - 0x0168)
class UViewport final : public UContentWidget
{
public:
	struct FLinearColor                           BackgroundColor;                                   // 0x0168(0x0010)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_178[0x40];                                     // 0x0178(0x0040)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SetViewLocation(const struct FVector& Location)	 // 0x66ff2cc;
	void SetViewRotation(const struct FRotator& Rotation)	 // 0x66ff3b4;
	class AActor* Spawn(TSubclassOf<class AActor> ActorClass)	 // 0x66ffa0c;

	struct FVector GetViewLocation() const	 // 0x66f4678;
	class UWorld* GetViewportWorld() const	 // 0x66f4750;
	struct FRotator GetViewRotation() const	 // 0x66f4700;

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"Viewport">();
	}
	static class UViewport* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UViewport>();
	}
};
static_assert(alignof(UViewport) == 0x000008, "Wrong alignment on UViewport");
static_assert(sizeof(UViewport) == 0x0001B8, "Wrong size on UViewport");
static_assert(offsetof(UViewport, BackgroundColor) == 0x000168, "Member 'UViewport::BackgroundColor' has a wrong offset!");

// Class UMG.ListViewBase
// 0x0118 (0x0268 - 0x0150)
class UListViewBase : public UWidget
{
public:
	TMulticastInlineDelegate<void(class UUserWidget* Widget)> BP_OnEntryGenerated;                   // 0x0150(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_160[0x10];                                     // 0x0160(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class UUserWidget>                EntryWidgetClass;                                  // 0x0170(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         WheelScrollMultiplier;                             // 0x0178(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bEnableScrollAnimation;                            // 0x017C(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          AllowOverscroll;                                   // 0x017D(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bEnableRightClickScrolling;                        // 0x017E(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bEnableFixedLineOffset;                            // 0x017F(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         FixedLineScrollOffset;                             // 0x0180(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bAllowDragging;                                    // 0x0184(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_185[0x3];                                      // 0x0185(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	TMulticastInlineDelegate<void(class UUserWidget* Widget)> BP_OnEntryReleased;                    // 0x0188(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPrivate)
	struct FUserWidgetPool                        EntryWidgetPool;                                   // 0x0198(0x0088)(Transient, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	uint8                                         Pad_220[0x48];                                     // 0x0220(0x0048)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void RegenerateAllEntries()	 // 0x66f57b0;
	void RequestRefresh()	 // 0x66f5d08;
	void ScrollToBottom()	 // 0x66f5e78;
	void ScrollToTop()	 // 0x66f5ec8;
	void SetScrollBarVisibility(ESlateVisibility InVisibility)	 // 0x66fd080;
	void SetScrollOffset(const float InScrollOffset)	 // 0x66fcd20;
	void SetWheelScrollMultiplier(float NewWheelScrollMultiplier)	 // 0x66ff488;

	const TArray<class UUserWidget*> GetDisplayedEntryWidgets() const	 // 0x66f3c98;
	float GetScrollOffset() const	 // 0x66f43ac;

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"ListViewBase">();
	}
	static class UListViewBase* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UListViewBase>();
	}
};
static_assert(alignof(UListViewBase) == 0x000008, "Wrong alignment on UListViewBase");
static_assert(sizeof(UListViewBase) == 0x000268, "Wrong size on UListViewBase");
static_assert(offsetof(UListViewBase, BP_OnEntryGenerated) == 0x000150, "Member 'UListViewBase::BP_OnEntryGenerated' has a wrong offset!");
static_assert(offsetof(UListViewBase, EntryWidgetClass) == 0x000170, "Member 'UListViewBase::EntryWidgetClass' has a wrong offset!");
static_assert(offsetof(UListViewBase, WheelScrollMultiplier) == 0x000178, "Member 'UListViewBase::WheelScrollMultiplier' has a wrong offset!");
static_assert(offsetof(UListViewBase, bEnableScrollAnimation) == 0x00017C, "Member 'UListViewBase::bEnableScrollAnimation' has a wrong offset!");
static_assert(offsetof(UListViewBase, AllowOverscroll) == 0x00017D, "Member 'UListViewBase::AllowOverscroll' has a wrong offset!");
static_assert(offsetof(UListViewBase, bEnableRightClickScrolling) == 0x00017E, "Member 'UListViewBase::bEnableRightClickScrolling' has a wrong offset!");
static_assert(offsetof(UListViewBase, bEnableFixedLineOffset) == 0x00017F, "Member 'UListViewBase::bEnableFixedLineOffset' has a wrong offset!");
static_assert(offsetof(UListViewBase, FixedLineScrollOffset) == 0x000180, "Member 'UListViewBase::FixedLineScrollOffset' has a wrong offset!");
static_assert(offsetof(UListViewBase, bAllowDragging) == 0x000184, "Member 'UListViewBase::bAllowDragging' has a wrong offset!");
static_assert(offsetof(UListViewBase, BP_OnEntryReleased) == 0x000188, "Member 'UListViewBase::BP_OnEntryReleased' has a wrong offset!");
static_assert(offsetof(UListViewBase, EntryWidgetPool) == 0x000198, "Member 'UListViewBase::EntryWidgetPool' has a wrong offset!");

// Class UMG.ListView
// 0x09D8 (0x0C40 - 0x0268)
class UListView : public UListViewBase
{
public:
	uint8                                         Pad_268[0xD8];                                     // 0x0268(0x00D8)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTableViewStyle                        WidgetStyle;                                       // 0x0340(0x00E0)(Edit, BlueprintVisible, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)
	struct FScrollBarStyle                        ScrollBarStyle;                                    // 0x0420(0x0770)(Edit, BlueprintVisible, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)
	EOrientation                                  Orientation;                                       // 0x0B90(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	ESelectionMode                                SelectionMode;                                     // 0x0B91(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EConsumeMouseWheel                            ConsumeMouseWheel;                                 // 0x0B92(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bClearSelectionOnClick;                            // 0x0B93(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIsFocusable;                                      // 0x0B94(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_B95[0x3];                                      // 0x0B95(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         EntrySpacing;                                      // 0x0B98(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bReturnFocusToSelection;                           // 0x0B9C(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_B9D[0x3];                                      // 0x0B9D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FMargin                                ScrollbarPadding;                                  // 0x0BA0(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)
	TArray<class UObject*>                        ListItems;                                         // 0x0BB0(0x0010)(ZeroConstructor, Transient, Protected, UObjectWrapper, NativeAccessSpecifierProtected)
	uint8                                         Pad_BC0[0x10];                                     // 0x0BC0(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	TMulticastInlineDelegate<void(class UObject* Item, class UUserWidget* Widget)> BP_OnEntryInitialized; // 0x0BD0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPrivate)
	TMulticastInlineDelegate<void(class UObject* Item)> BP_OnItemClicked;                            // 0x0BE0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPrivate)
	TMulticastInlineDelegate<void(class UObject* Item)> BP_OnItemDoubleClicked;                      // 0x0BF0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPrivate)
	TMulticastInlineDelegate<void(class UObject* Item, bool bIsHovered)> BP_OnItemIsHoveredChanged;  // 0x0C00(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPrivate)
	TMulticastInlineDelegate<void(class UObject* Item, bool bIsSelected)> BP_OnItemSelectionChanged; // 0x0C10(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPrivate)
	TMulticastInlineDelegate<void(class UObject* Item, class UUserWidget* Widget)> BP_OnItemScrolledIntoView; // 0x0C20(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPrivate)
	TMulticastInlineDelegate<void(float ItemOffset, float DistanceRemaining)> BP_OnListViewScrolled; // 0x0C30(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPrivate)

public:
	void AddItem(class UObject* Item)	 // 0x66f2a3c;
	void BP_CancelScrollIntoView()	 // 0x66f2bf4;
	void BP_ClearSelection()	 // 0x66f2c28;
	void BP_NavigateToItem(class UObject* Item)	 // 0x66f2ef0;
	void BP_ScrollItemIntoView(class UObject* Item)	 // 0x66f2fbc;
	void BP_SetItemSelection(class UObject* Item, bool bSelected)	 // 0x66f30b4;
	void BP_SetListItems(const TArray<class UObject*>& InListItems)	 // 0x66f3218;
	void BP_SetSelectedItem(class UObject* Item)	 // 0x66f32b4;
	void ClearListItems()	 // 0x66f33fc;
	void NavigateToIndex(int32 Index_0)	 // 0x66f535c;
	void OnListItemEndPlayed(class AActor* Item, EEndPlayReason EndPlayReason)	 // 0x66f5430;
	void OnListItemOuterEndPlayed(class AActor* ItemOuter, EEndPlayReason EndPlayReason)	 // 0x66f5568;
	void RemoveItem(class UObject* Item)	 // 0x66f5960;
	void ScrollIndexIntoView(int32 Index_0)	 // 0x66f5db0;
	void SetSelectedIndex(int32 Index_0)	 // 0x66fd170;
	void SetSelectionMode(ESelectionMode SelectionMode_0)	 // 0x66fd2ec;

	int32 BP_GetNumItemsSelected() const	 // 0x66f2c58;
	class UObject* BP_GetSelectedItem() const	 // 0x66f2ca0;
	bool BP_GetSelectedItems(TArray<class UObject*>* Items) const	 // 0x66f2d24;
	bool BP_IsItemVisible(class UObject* Item) const	 // 0x66f2df4;
	int32 GetIndexForItem(const class UObject* Item) const	 // 0x66f3eec;
	class UObject* GetItemAt(int32 Index_0) const	 // 0x66f404c;
	const TArray<class UObject*> GetListItems() const	 // 0x66f411c;
	int32 GetNumItems() const	 // 0x66f4270;
	bool IsRefreshPending() const	 // 0x66f4ed4;

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"ListView">();
	}
	static class UListView* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UListView>();
	}
};
static_assert(alignof(UListView) == 0x000010, "Wrong alignment on UListView");
static_assert(sizeof(UListView) == 0x000C40, "Wrong size on UListView");
static_assert(offsetof(UListView, WidgetStyle) == 0x000340, "Member 'UListView::WidgetStyle' has a wrong offset!");
static_assert(offsetof(UListView, ScrollBarStyle) == 0x000420, "Member 'UListView::ScrollBarStyle' has a wrong offset!");
static_assert(offsetof(UListView, Orientation) == 0x000B90, "Member 'UListView::Orientation' has a wrong offset!");
static_assert(offsetof(UListView, SelectionMode) == 0x000B91, "Member 'UListView::SelectionMode' has a wrong offset!");
static_assert(offsetof(UListView, ConsumeMouseWheel) == 0x000B92, "Member 'UListView::ConsumeMouseWheel' has a wrong offset!");
static_assert(offsetof(UListView, bClearSelectionOnClick) == 0x000B93, "Member 'UListView::bClearSelectionOnClick' has a wrong offset!");
static_assert(offsetof(UListView, bIsFocusable) == 0x000B94, "Member 'UListView::bIsFocusable' has a wrong offset!");
static_assert(offsetof(UListView, EntrySpacing) == 0x000B98, "Member 'UListView::EntrySpacing' has a wrong offset!");
static_assert(offsetof(UListView, bReturnFocusToSelection) == 0x000B9C, "Member 'UListView::bReturnFocusToSelection' has a wrong offset!");
static_assert(offsetof(UListView, ScrollbarPadding) == 0x000BA0, "Member 'UListView::ScrollbarPadding' has a wrong offset!");
static_assert(offsetof(UListView, ListItems) == 0x000BB0, "Member 'UListView::ListItems' has a wrong offset!");
static_assert(offsetof(UListView, BP_OnEntryInitialized) == 0x000BD0, "Member 'UListView::BP_OnEntryInitialized' has a wrong offset!");
static_assert(offsetof(UListView, BP_OnItemClicked) == 0x000BE0, "Member 'UListView::BP_OnItemClicked' has a wrong offset!");
static_assert(offsetof(UListView, BP_OnItemDoubleClicked) == 0x000BF0, "Member 'UListView::BP_OnItemDoubleClicked' has a wrong offset!");
static_assert(offsetof(UListView, BP_OnItemIsHoveredChanged) == 0x000C00, "Member 'UListView::BP_OnItemIsHoveredChanged' has a wrong offset!");
static_assert(offsetof(UListView, BP_OnItemSelectionChanged) == 0x000C10, "Member 'UListView::BP_OnItemSelectionChanged' has a wrong offset!");
static_assert(offsetof(UListView, BP_OnItemScrolledIntoView) == 0x000C20, "Member 'UListView::BP_OnItemScrolledIntoView' has a wrong offset!");
static_assert(offsetof(UListView, BP_OnListViewScrolled) == 0x000C30, "Member 'UListView::BP_OnListViewScrolled' has a wrong offset!");

// Class UMG.PanelSlot
// 0x0010 (0x0038 - 0x0028)
class UPanelSlot : public UVisual
{
public:
	class UPanelWidget*                           Parent;                                            // 0x0028(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, PersistentInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UWidget*                                Content;                                           // 0x0030(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, PersistentInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"PanelSlot">();
	}
	static class UPanelSlot* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UPanelSlot>();
	}
};
static_assert(alignof(UPanelSlot) == 0x000008, "Wrong alignment on UPanelSlot");
static_assert(sizeof(UPanelSlot) == 0x000038, "Wrong size on UPanelSlot");
static_assert(offsetof(UPanelSlot, Parent) == 0x000028, "Member 'UPanelSlot::Parent' has a wrong offset!");
static_assert(offsetof(UPanelSlot, Content) == 0x000030, "Member 'UPanelSlot::Content' has a wrong offset!");

// Class UMG.RichTextBlock
// 0x0700 (0x0870 - 0x0170)
class URichTextBlock : public UTextLayoutWidget
{
public:
	class FText                                   Text;                                              // 0x0170(0x0018)(Edit, BlueprintVisible, Protected, NativeAccessSpecifierProtected)
	class UDataTable*                             TextStyleSet;                                      // 0x0188(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<TSubclassOf<class URichTextBlockDecorator>> DecoratorClasses;                             // 0x0190(0x0010)(Edit, ZeroConstructor, Protected, UObjectWrapper, NativeAccessSpecifierProtected)
	bool                                          bOverrideDefaultStyle;                             // 0x01A0(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1A1[0xF];                                      // 0x01A1(0x000F)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTextBlockStyle                        DefaultTextStyleOverride;                          // 0x01B0(0x0340)(Edit, BlueprintVisible, Protected, NativeAccessSpecifierProtected)
	float                                         MinDesiredWidth;                                   // 0x04F0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	ETextTransformPolicy                          TextTransformPolicy;                               // 0x04F4(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	ETextOverflowPolicy                           TextOverflowPolicy;                                // 0x04F5(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_4F6[0xA];                                      // 0x04F6(0x000A)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTextBlockStyle                        DefaultTextStyle;                                  // 0x0500(0x0340)(Transient, Protected, NativeAccessSpecifierProtected)
	TArray<class URichTextBlockDecorator*>        InstanceDecorators;                                // 0x0840(0x0010)(ZeroConstructor, Transient, Protected, UObjectWrapper, NativeAccessSpecifierProtected)
	uint8                                         Pad_850[0x20];                                     // 0x0850(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ClearAllDefaultStyleOverrides()	 // 0x66f337c;
	class URichTextBlockDecorator* GetDecoratorByClass(TSubclassOf<class URichTextBlockDecorator> DecoratorClass)	 // 0x66f3b14;
	class UMaterialInstanceDynamic* GetDefaultDynamicMaterial()	 // 0x66f3c2c;
	void RefreshTextLayout()	 // 0x66f5788;
	void SetAutoWrapText(bool InAutoTextWrap)	 // 0x66f6948;
	void SetDecorators(const TArray<TSubclassOf<class URichTextBlockDecorator>>& InDecoratorClasses)	 // 0x66f7870;
	void SetDefaultColorAndOpacity(const struct FSlateColor& InColorAndOpacity)	 // 0x66f790c;
	void SetDefaultFont(const struct FSlateFontInfo& InFontInfo)	 // 0x66f79ec;
	void SetDefaultMaterial(class UMaterialInterface* InMaterial)	 // 0x66f7b50;
	void SetDefaultShadowColorAndOpacity(const struct FLinearColor& InShadowColorAndOpacity)	 // 0x66f7c24;
	void SetDefaultShadowOffset(const struct FVector2D& InShadowOffset)	 // 0x66f7d00;
	void SetDefaultStrikeBrush(struct FSlateBrush* InStrikeBrush)	 // 0x66f7df4;
	void SetDefaultTextStyle(const struct FTextBlockStyle& InDefaultTextStyle)	 // 0x66f7f24;
	void SetMinDesiredWidth(float InMinDesiredWidth)	 // 0x66fae20;
	void SetText(const class FText& InText)	 // 0x1809bd8;
	void SetTextOverflowPolicy(ETextOverflowPolicy InOverflowPolicy)	 // 0x66fe140;
	void SetTextStyleSet(class UDataTable* NewTextStyleSet)	 // 0x66fe38c;
	void SetTextTransformPolicy(ETextTransformPolicy InTransformPolicy)	 // 0x66fe44c;

	class FText GetText() const	 // 0x66f4520;
	class UDataTable* GetTextStyleSet() const	 // 0x66f45c8;

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"RichTextBlock">();
	}
	static class URichTextBlock* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<URichTextBlock>();
	}
};
static_assert(alignof(URichTextBlock) == 0x000010, "Wrong alignment on URichTextBlock");
static_assert(sizeof(URichTextBlock) == 0x000870, "Wrong size on URichTextBlock");
static_assert(offsetof(URichTextBlock, Text) == 0x000170, "Member 'URichTextBlock::Text' has a wrong offset!");
static_assert(offsetof(URichTextBlock, TextStyleSet) == 0x000188, "Member 'URichTextBlock::TextStyleSet' has a wrong offset!");
static_assert(offsetof(URichTextBlock, DecoratorClasses) == 0x000190, "Member 'URichTextBlock::DecoratorClasses' has a wrong offset!");
static_assert(offsetof(URichTextBlock, bOverrideDefaultStyle) == 0x0001A0, "Member 'URichTextBlock::bOverrideDefaultStyle' has a wrong offset!");
static_assert(offsetof(URichTextBlock, DefaultTextStyleOverride) == 0x0001B0, "Member 'URichTextBlock::DefaultTextStyleOverride' has a wrong offset!");
static_assert(offsetof(URichTextBlock, MinDesiredWidth) == 0x0004F0, "Member 'URichTextBlock::MinDesiredWidth' has a wrong offset!");
static_assert(offsetof(URichTextBlock, TextTransformPolicy) == 0x0004F4, "Member 'URichTextBlock::TextTransformPolicy' has a wrong offset!");
static_assert(offsetof(URichTextBlock, TextOverflowPolicy) == 0x0004F5, "Member 'URichTextBlock::TextOverflowPolicy' has a wrong offset!");
static_assert(offsetof(URichTextBlock, DefaultTextStyle) == 0x000500, "Member 'URichTextBlock::DefaultTextStyle' has a wrong offset!");
static_assert(offsetof(URichTextBlock, InstanceDecorators) == 0x000840, "Member 'URichTextBlock::InstanceDecorators' has a wrong offset!");

// Class UMG.PropertyBinding
// 0x0048 (0x0070 - 0x0028)
class UPropertyBinding : public UObject
{
public:
	TWeakObjectPtr<class UObject>                 SourceObject;                                      // 0x0028(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FDynamicPropertyPath                   SourcePath;                                        // 0x0030(0x0038)(NativeAccessSpecifierPublic)
	class FName                                   DestinationProperty;                               // 0x0068(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"PropertyBinding">();
	}
	static class UPropertyBinding* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UPropertyBinding>();
	}
};
static_assert(alignof(UPropertyBinding) == 0x000008, "Wrong alignment on UPropertyBinding");
static_assert(sizeof(UPropertyBinding) == 0x000070, "Wrong size on UPropertyBinding");
static_assert(offsetof(UPropertyBinding, SourceObject) == 0x000028, "Member 'UPropertyBinding::SourceObject' has a wrong offset!");
static_assert(offsetof(UPropertyBinding, SourcePath) == 0x000030, "Member 'UPropertyBinding::SourcePath' has a wrong offset!");
static_assert(offsetof(UPropertyBinding, DestinationProperty) == 0x000068, "Member 'UPropertyBinding::DestinationProperty' has a wrong offset!");

// Class UMG.Int32Binding
// 0x0000 (0x0070 - 0x0070)
class UInt32Binding final : public UPropertyBinding
{
public:
	int32 GetValue() const	 // 0x66cc428;

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"Int32Binding">();
	}
	static class UInt32Binding* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UInt32Binding>();
	}
};
static_assert(alignof(UInt32Binding) == 0x000008, "Wrong alignment on UInt32Binding");
static_assert(sizeof(UInt32Binding) == 0x000070, "Wrong size on UInt32Binding");

// Class UMG.TileView
// 0x0020 (0x0C60 - 0x0C40)
class UTileView : public UListView
{
public:
	float                                         EntryHeight;                                       // 0x0C40(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         EntryWidth;                                        // 0x0C44(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EListItemAlignment                            TileAlignment;                                     // 0x0C48(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bWrapHorizontalNavigation;                         // 0x0C49(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_C4A[0x16];                                     // 0x0C4A(0x0016)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SetEntryHeight(float NewHeight)	 // 0x66f839c;
	void SetEntryWidth(float NewWidth)	 // 0x66f8460;

	float GetEntryHeight() const	 // 0x66f3dbc;
	float GetEntryWidth() const	 // 0x66f3dd4;

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"TileView">();
	}
	static class UTileView* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UTileView>();
	}
};
static_assert(alignof(UTileView) == 0x000010, "Wrong alignment on UTileView");
static_assert(sizeof(UTileView) == 0x000C60, "Wrong size on UTileView");
static_assert(offsetof(UTileView, EntryHeight) == 0x000C40, "Member 'UTileView::EntryHeight' has a wrong offset!");
static_assert(offsetof(UTileView, EntryWidth) == 0x000C44, "Member 'UTileView::EntryWidth' has a wrong offset!");
static_assert(offsetof(UTileView, TileAlignment) == 0x000C48, "Member 'UTileView::TileAlignment' has a wrong offset!");
static_assert(offsetof(UTileView, bWrapHorizontalNavigation) == 0x000C49, "Member 'UTileView::bWrapHorizontalNavigation' has a wrong offset!");

// Class UMG.WidgetAnimationPlayCallbackProxy
// 0x0018 (0x0040 - 0x0028)
class UWidgetAnimationPlayCallbackProxy final : public UObject
{
public:
	TMulticastInlineDelegate<void()>              Finished;                                          // 0x0028(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_38[0x8];                                       // 0x0038(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UWidgetAnimationPlayCallbackProxy* CreatePlayAnimationProxyObject(class UUMGSequencePlayer** Result, class UUserWidget* Widget, class UWidgetAnimation* InAnimation, float StartAtTime, int32 NumLoopsToPlay, EUMGSequencePlayMode PlayMode, float PlaybackSpeed)	 // 0x16761cc;
	static class UWidgetAnimationPlayCallbackProxy* CreatePlayAnimationTimeRangeProxyObject(class UUMGSequencePlayer** Result, class UUserWidget* Widget, class UWidgetAnimation* InAnimation, float StartAtTime, float EndAtTime, int32 NumLoopsToPlay, EUMGSequencePlayMode PlayMode, float PlaybackSpeed)	 // 0x66cb5bc;

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"WidgetAnimationPlayCallbackProxy">();
	}
	static class UWidgetAnimationPlayCallbackProxy* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UWidgetAnimationPlayCallbackProxy>();
	}
};
static_assert(alignof(UWidgetAnimationPlayCallbackProxy) == 0x000008, "Wrong alignment on UWidgetAnimationPlayCallbackProxy");
static_assert(sizeof(UWidgetAnimationPlayCallbackProxy) == 0x000040, "Wrong size on UWidgetAnimationPlayCallbackProxy");
static_assert(offsetof(UWidgetAnimationPlayCallbackProxy, Finished) == 0x000028, "Member 'UWidgetAnimationPlayCallbackProxy::Finished' has a wrong offset!");

// Class UMG.TreeView
// 0x0060 (0x0CA0 - 0x0C40)
class UTreeView : public UListView
{
public:
	uint8                                         Pad_C40[0x10];                                     // 0x0C40(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	TDelegate<void(class UObject* Item, TArray<class UObject*>* Children)> BP_OnGetItemChildren;     // 0x0C50(0x0010)(Edit, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TMulticastInlineDelegate<void(class UObject* Item, bool bIsExpanded)> BP_OnItemExpansionChanged; // 0x0C60(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPrivate)
	uint8                                         Pad_C70[0x30];                                     // 0x0C70(0x0030)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void CollapseAll()	 // 0x66f3520;
	void ExpandAll()	 // 0x66f35b4;
	void SetItemExpansion(class UObject* Item, bool bExpandItem)	 // 0x66f9fa8;

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"TreeView">();
	}
	static class UTreeView* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UTreeView>();
	}
};
static_assert(alignof(UTreeView) == 0x000010, "Wrong alignment on UTreeView");
static_assert(sizeof(UTreeView) == 0x000CA0, "Wrong size on UTreeView");
static_assert(offsetof(UTreeView, BP_OnGetItemChildren) == 0x000C50, "Member 'UTreeView::BP_OnGetItemChildren' has a wrong offset!");
static_assert(offsetof(UTreeView, BP_OnItemExpansionChanged) == 0x000C60, "Member 'UTreeView::BP_OnItemExpansionChanged' has a wrong offset!");

// Class UMG.WidgetBinding
// 0x0000 (0x0070 - 0x0070)
class UWidgetBinding final : public UPropertyBinding
{
public:
	class UWidget* GetValue() const	 // 0x66cc4d4;

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"WidgetBinding">();
	}
	static class UWidgetBinding* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UWidgetBinding>();
	}
};
static_assert(alignof(UWidgetBinding) == 0x000008, "Wrong alignment on UWidgetBinding");
static_assert(sizeof(UWidgetBinding) == 0x000070, "Wrong size on UWidgetBinding");

// Class UMG.Overlay
// 0x0010 (0x0178 - 0x0168)
class UOverlay : public UPanelWidget
{
public:
	uint8                                         Pad_168[0x10];                                     // 0x0168(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	class UOverlaySlot* AddChildToOverlay(class UWidget* Content)	 // 0x17e91f0;
	bool ReplaceOverlayChildAt(int32 Index_0, class UWidget* Content)	 // 0x66f5a20;

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"Overlay">();
	}
	static class UOverlay* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UOverlay>();
	}
};
static_assert(alignof(UOverlay) == 0x000008, "Wrong alignment on UOverlay");
static_assert(sizeof(UOverlay) == 0x000178, "Wrong size on UOverlay");

// Class UMG.OverlaySlot
// 0x0020 (0x0058 - 0x0038)
class UOverlaySlot : public UPanelSlot
{
public:
	uint8                                         Pad_38[0x8];                                       // 0x0038(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FMargin                                Padding;                                           // 0x0040(0x0010)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	EHorizontalAlignment                          HorizontalAlignment;                               // 0x0050(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EVerticalAlignment                            VerticalAlignment;                                 // 0x0051(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_52[0x6];                                       // 0x0052(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SetHorizontalAlignment(EHorizontalAlignment InHorizontalAlignment)	 // 0x66f94bc;
	void SetPadding(const struct FMargin& InPadding)	 // 0xb17494;
	void SetVerticalAlignment(EVerticalAlignment InVerticalAlignment)	 // 0x66fef0c;

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"OverlaySlot">();
	}
	static class UOverlaySlot* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UOverlaySlot>();
	}
};
static_assert(alignof(UOverlaySlot) == 0x000008, "Wrong alignment on UOverlaySlot");
static_assert(sizeof(UOverlaySlot) == 0x000058, "Wrong size on UOverlaySlot");
static_assert(offsetof(UOverlaySlot, Padding) == 0x000040, "Member 'UOverlaySlot::Padding' has a wrong offset!");
static_assert(offsetof(UOverlaySlot, HorizontalAlignment) == 0x000050, "Member 'UOverlaySlot::HorizontalAlignment' has a wrong offset!");
static_assert(offsetof(UOverlaySlot, VerticalAlignment) == 0x000051, "Member 'UOverlaySlot::VerticalAlignment' has a wrong offset!");

// Class UMG.SizeBox
// 0x0038 (0x01A0 - 0x0168)
class USizeBox : public UContentWidget
{
public:
	uint8                                         Pad_168[0x10];                                     // 0x0168(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         WidthOverride;                                     // 0x0178(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HeightOverride;                                    // 0x017C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MinDesiredWidth;                                   // 0x0180(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MinDesiredHeight;                                  // 0x0184(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxDesiredWidth;                                   // 0x0188(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxDesiredHeight;                                  // 0x018C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MinAspectRatio;                                    // 0x0190(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxAspectRatio;                                    // 0x0194(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverride_WidthOverride : 1;                       // 0x0198(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bOverride_HeightOverride : 1;                      // 0x0198(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bOverride_MinDesiredWidth : 1;                     // 0x0198(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bOverride_MinDesiredHeight : 1;                    // 0x0198(0x0001)(BitIndex: 0x03, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bOverride_MaxDesiredWidth : 1;                     // 0x0198(0x0001)(BitIndex: 0x04, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bOverride_MaxDesiredHeight : 1;                    // 0x0198(0x0001)(BitIndex: 0x05, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bOverride_MinAspectRatio : 1;                      // 0x0198(0x0001)(BitIndex: 0x06, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bOverride_MaxAspectRatio : 1;                      // 0x0198(0x0001)(BitIndex: 0x07, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_199[0x7];                                      // 0x0199(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ClearHeightOverride()	 // 0x66f33e8;
	void ClearMaxAspectRatio()	 // 0x66f3410;
	void ClearMaxDesiredHeight()	 // 0x66f3424;
	void ClearMaxDesiredWidth()	 // 0x66f3438;
	void ClearMinAspectRatio()	 // 0x66f3474;
	void ClearMinDesiredHeight()	 // 0x66f3488;
	void ClearMinDesiredWidth()	 // 0x66f349c;
	void ClearWidthOverride()	 // 0x66f34d8;
	void SetHeightOverride(float InHeightOverride)	 // 0x16c9a64;
	void SetMaxAspectRatio(float InMaxAspectRatio)	 // 0x66fa5b8;
	void SetMaxDesiredHeight(float InMaxDesiredHeight)	 // 0x66fa67c;
	void SetMaxDesiredWidth(float InMaxDesiredWidth)	 // 0x66fa740;
	void SetMinAspectRatio(float InMinAspectRatio)	 // 0x66fab10;
	void SetMinDesiredHeight(float InMinDesiredHeight)	 // 0x66fabd4;
	void SetMinDesiredWidth(float InMinDesiredWidth)	 // 0x16c5d9c;
	void SetWidthOverride(float InWidthOverride)	 // 0xb43ec8;

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"SizeBox">();
	}
	static class USizeBox* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<USizeBox>();
	}
};
static_assert(alignof(USizeBox) == 0x000008, "Wrong alignment on USizeBox");
static_assert(sizeof(USizeBox) == 0x0001A0, "Wrong size on USizeBox");
static_assert(offsetof(USizeBox, WidthOverride) == 0x000178, "Member 'USizeBox::WidthOverride' has a wrong offset!");
static_assert(offsetof(USizeBox, HeightOverride) == 0x00017C, "Member 'USizeBox::HeightOverride' has a wrong offset!");
static_assert(offsetof(USizeBox, MinDesiredWidth) == 0x000180, "Member 'USizeBox::MinDesiredWidth' has a wrong offset!");
static_assert(offsetof(USizeBox, MinDesiredHeight) == 0x000184, "Member 'USizeBox::MinDesiredHeight' has a wrong offset!");
static_assert(offsetof(USizeBox, MaxDesiredWidth) == 0x000188, "Member 'USizeBox::MaxDesiredWidth' has a wrong offset!");
static_assert(offsetof(USizeBox, MaxDesiredHeight) == 0x00018C, "Member 'USizeBox::MaxDesiredHeight' has a wrong offset!");
static_assert(offsetof(USizeBox, MinAspectRatio) == 0x000190, "Member 'USizeBox::MinAspectRatio' has a wrong offset!");
static_assert(offsetof(USizeBox, MaxAspectRatio) == 0x000194, "Member 'USizeBox::MaxAspectRatio' has a wrong offset!");

// Class UMG.NotifyFieldValueChanged
// 0x0000 (0x0000 - 0x0000)
class INotifyFieldValueChanged final
{
public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"NotifyFieldValueChanged">();
	}
	static class INotifyFieldValueChanged* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<INotifyFieldValueChanged>();
	}

	class UObject* AsUObject()	 // 0x0
	{
		return reinterpret_cast<UObject*>(this);
	}
	const class UObject* AsUObject() const	 // 0x0
	{
		return reinterpret_cast<const UObject*>(this);
	}
};
static_assert(alignof(INotifyFieldValueChanged) == 0x000001, "Wrong alignment on INotifyFieldValueChanged");
static_assert(sizeof(INotifyFieldValueChanged) == 0x000001, "Wrong size on INotifyFieldValueChanged");

// Class UMG.WidgetComponent
// 0x0140 (0x0720 - 0x05E0)
class UWidgetComponent : public UMeshComponent
{
public:
	EWidgetSpace                                  Space;                                             // 0x05E0(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EWidgetTimingPolicy                           TimingPolicy;                                      // 0x05E1(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_5E2[0x6];                                      // 0x05E2(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class UUserWidget>                WidgetClass;                                       // 0x05E8(0x0008)(Edit, ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FIntPoint                              DrawSize;                                          // 0x05F0(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bManuallyRedraw;                                   // 0x05F8(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bRedrawRequested;                                  // 0x05F9(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_5FA[0x2];                                      // 0x05FA(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         RedrawTime;                                        // 0x05FC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_600[0x8];                                      // 0x0600(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FIntPoint                              CurrentDrawSize;                                   // 0x0608(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bDrawAtDesiredSize;                                // 0x0610(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_611[0x7];                                      // 0x0611(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector2D                              Pivot;                                             // 0x0618(0x0010)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bReceiveHardwareInput;                             // 0x0628(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bWindowFocusable;                                  // 0x0629(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EWindowVisibility                             WindowVisibility;                                  // 0x062A(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bApplyGammaCorrection;                             // 0x062B(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_62C[0x4];                                      // 0x062C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class ULocalPlayer*                           OwnerPlayer;                                       // 0x0630(0x0008)(ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FLinearColor                           BackgroundColor;                                   // 0x0638(0x0010)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FLinearColor                           TintColorAndOpacity;                               // 0x0648(0x0010)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         OpacityFromTexture;                                // 0x0658(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EWidgetBlendMode                              BlendMode;                                         // 0x065C(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIsTwoSided;                                       // 0x065D(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          TickWhenOffscreen;                                 // 0x065E(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_65F[0x1];                                      // 0x065F(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	class UBodySetup*                             BodySetup;                                         // 0x0660(0x0008)(ZeroConstructor, Transient, DuplicateTransient, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UMaterialInterface*                     TranslucentMaterial;                               // 0x0668(0x0008)(ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UMaterialInterface*                     TranslucentMaterial_OneSided;                      // 0x0670(0x0008)(ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UMaterialInterface*                     OpaqueMaterial;                                    // 0x0678(0x0008)(ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UMaterialInterface*                     OpaqueMaterial_OneSided;                           // 0x0680(0x0008)(ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UMaterialInterface*                     MaskedMaterial;                                    // 0x0688(0x0008)(ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UMaterialInterface*                     MaskedMaterial_OneSided;                           // 0x0690(0x0008)(ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextureRenderTarget2D*                 RenderTarget;                                      // 0x0698(0x0008)(ZeroConstructor, Transient, DuplicateTransient, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UMaterialInstanceDynamic*               MaterialInstance;                                  // 0x06A0(0x0008)(ZeroConstructor, Transient, DuplicateTransient, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bAddedToScreen;                                    // 0x06A8(0x0001)(ZeroConstructor, Transient, DuplicateTransient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bEditTimeUsable;                                   // 0x06A9(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_6AA[0x2];                                      // 0x06AA(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   SharedLayerName;                                   // 0x06AC(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         LayerZOrder;                                       // 0x06B4(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bUseCustomZOrder;                                  // 0x06B8(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EWidgetGeometryMode                           GeometryMode;                                      // 0x06B9(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_6BA[0x2];                                      // 0x06BA(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         CylinderArcAngle;                                  // 0x06BC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	ETickMode                                     TickMode;                                          // 0x06C0(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_6C1[0x2F];                                     // 0x06C1(0x002F)(Fixing Size After Last Property [ Dumper-7 ])
	class UUserWidget*                            Widget;                                            // 0x06F0(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, DuplicateTransient, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_6F8[0x28];                                     // 0x06F8(0x0028)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void RequestRedraw()	 // 0x66f5cf0;
	void RequestRenderUpdate()	 // 0x162ba8c;
	void SetBackgroundColor(const struct FLinearColor& NewBackgroundColor)	 // 0x66f6ad0;
	void SetCylinderArcAngle(const float InCylinderArcAngle)	 // 0x66f77ac;
	void SetDrawAtDesiredSize(bool bInDrawAtDesiredSize)	 // 0x66f8154;
	void SetDrawSize(const struct FVector2D& Size)	 // 0x66f8214;
	void SetGeometryMode(EWidgetGeometryMode InGeometryMode)	 // 0x66f8fe8;
	void SetManuallyRedraw(bool bUseManualRedraw)	 // 0x66fa4f8;
	void SetOwnerPlayer(class ULocalPlayer* LocalPlayer)	 // 0x66fbf2c;
	void SetPivot(const struct FVector2D& InPivot)	 // 0x66fc318;
	void SetRedrawTime(float InRedrawTime)	 // 0x66fc464;
	void SetTickMode(ETickMode InTickMode)	 // 0x16e97cc;
	void SetTickWhenOffscreen(const bool bWantTickWhenOffscreen)	 // 0x66fe68c;
	void SetTintColorAndOpacity(const struct FLinearColor& NewTintColorAndOpacity)	 // 0x66fe74c;
	void SetTwoSided(const bool bWantTwoSided)	 // 0x66fe9a4;
	void SetWidget(class UUserWidget* Widget_0)	 // 0x66ff610;
	void SetWidgetSpace(EWidgetSpace NewSpace)	 // 0x66ff6d4;
	void SetWindowFocusable(bool bInWindowFocusable)	 // 0x66ff84c;
	void SetWindowVisibility(EWindowVisibility InVisibility)	 // 0x66ff918;

	struct FVector2D GetCurrentDrawSize() const	 // 0x66f3ac8;
	float GetCylinderArcAngle() const	 // 0x66f3afc;
	bool GetDrawAtDesiredSize() const	 // 0x4859400;
	struct FVector2D GetDrawSize() const	 // 0x66f3cb4;
	EWidgetGeometryMode GetGeometryMode() const	 // 0x66f3e2c;
	bool GetManuallyRedraw() const	 // 0x66f4148;
	class UMaterialInstanceDynamic* GetMaterialInstance() const	 // 0x17d7df0;
	class ULocalPlayer* GetOwnerPlayer() const	 // 0x66f4288;
	struct FVector2D GetPivot() const	 // 0x66f4320;
	float GetRedrawTime() const	 // 0x66f433c;
	class UTextureRenderTarget2D* GetRenderTarget() const	 // 0x66f437c;
	bool GetTickWhenOffscreen() const	 // 0x66f45e0;
	bool GetTwoSided() const	 // 0x66f45f8;
	class UUserWidget* GetUserWidgetObject() const	 // 0x66f4610;
	class UUserWidget* GetWidget() const	 // 0x16e6354;
	EWidgetSpace GetWidgetSpace() const	 // 0x66f4770;
	bool GetWindowFocusable() const	 // 0x66f4788;
	EWindowVisibility GetWindowVisiblility() const	 // 0x66f47a0;
	bool IsWidgetVisible() const	 // 0x66f4f8c;

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"WidgetComponent">();
	}
	static class UWidgetComponent* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UWidgetComponent>();
	}
};
static_assert(alignof(UWidgetComponent) == 0x000010, "Wrong alignment on UWidgetComponent");
static_assert(sizeof(UWidgetComponent) == 0x000720, "Wrong size on UWidgetComponent");
static_assert(offsetof(UWidgetComponent, Space) == 0x0005E0, "Member 'UWidgetComponent::Space' has a wrong offset!");
static_assert(offsetof(UWidgetComponent, TimingPolicy) == 0x0005E1, "Member 'UWidgetComponent::TimingPolicy' has a wrong offset!");
static_assert(offsetof(UWidgetComponent, WidgetClass) == 0x0005E8, "Member 'UWidgetComponent::WidgetClass' has a wrong offset!");
static_assert(offsetof(UWidgetComponent, DrawSize) == 0x0005F0, "Member 'UWidgetComponent::DrawSize' has a wrong offset!");
static_assert(offsetof(UWidgetComponent, bManuallyRedraw) == 0x0005F8, "Member 'UWidgetComponent::bManuallyRedraw' has a wrong offset!");
static_assert(offsetof(UWidgetComponent, bRedrawRequested) == 0x0005F9, "Member 'UWidgetComponent::bRedrawRequested' has a wrong offset!");
static_assert(offsetof(UWidgetComponent, RedrawTime) == 0x0005FC, "Member 'UWidgetComponent::RedrawTime' has a wrong offset!");
static_assert(offsetof(UWidgetComponent, CurrentDrawSize) == 0x000608, "Member 'UWidgetComponent::CurrentDrawSize' has a wrong offset!");
static_assert(offsetof(UWidgetComponent, bDrawAtDesiredSize) == 0x000610, "Member 'UWidgetComponent::bDrawAtDesiredSize' has a wrong offset!");
static_assert(offsetof(UWidgetComponent, Pivot) == 0x000618, "Member 'UWidgetComponent::Pivot' has a wrong offset!");
static_assert(offsetof(UWidgetComponent, bReceiveHardwareInput) == 0x000628, "Member 'UWidgetComponent::bReceiveHardwareInput' has a wrong offset!");
static_assert(offsetof(UWidgetComponent, bWindowFocusable) == 0x000629, "Member 'UWidgetComponent::bWindowFocusable' has a wrong offset!");
static_assert(offsetof(UWidgetComponent, WindowVisibility) == 0x00062A, "Member 'UWidgetComponent::WindowVisibility' has a wrong offset!");
static_assert(offsetof(UWidgetComponent, bApplyGammaCorrection) == 0x00062B, "Member 'UWidgetComponent::bApplyGammaCorrection' has a wrong offset!");
static_assert(offsetof(UWidgetComponent, OwnerPlayer) == 0x000630, "Member 'UWidgetComponent::OwnerPlayer' has a wrong offset!");
static_assert(offsetof(UWidgetComponent, BackgroundColor) == 0x000638, "Member 'UWidgetComponent::BackgroundColor' has a wrong offset!");
static_assert(offsetof(UWidgetComponent, TintColorAndOpacity) == 0x000648, "Member 'UWidgetComponent::TintColorAndOpacity' has a wrong offset!");
static_assert(offsetof(UWidgetComponent, OpacityFromTexture) == 0x000658, "Member 'UWidgetComponent::OpacityFromTexture' has a wrong offset!");
static_assert(offsetof(UWidgetComponent, BlendMode) == 0x00065C, "Member 'UWidgetComponent::BlendMode' has a wrong offset!");
static_assert(offsetof(UWidgetComponent, bIsTwoSided) == 0x00065D, "Member 'UWidgetComponent::bIsTwoSided' has a wrong offset!");
static_assert(offsetof(UWidgetComponent, TickWhenOffscreen) == 0x00065E, "Member 'UWidgetComponent::TickWhenOffscreen' has a wrong offset!");
static_assert(offsetof(UWidgetComponent, BodySetup) == 0x000660, "Member 'UWidgetComponent::BodySetup' has a wrong offset!");
static_assert(offsetof(UWidgetComponent, TranslucentMaterial) == 0x000668, "Member 'UWidgetComponent::TranslucentMaterial' has a wrong offset!");
static_assert(offsetof(UWidgetComponent, TranslucentMaterial_OneSided) == 0x000670, "Member 'UWidgetComponent::TranslucentMaterial_OneSided' has a wrong offset!");
static_assert(offsetof(UWidgetComponent, OpaqueMaterial) == 0x000678, "Member 'UWidgetComponent::OpaqueMaterial' has a wrong offset!");
static_assert(offsetof(UWidgetComponent, OpaqueMaterial_OneSided) == 0x000680, "Member 'UWidgetComponent::OpaqueMaterial_OneSided' has a wrong offset!");
static_assert(offsetof(UWidgetComponent, MaskedMaterial) == 0x000688, "Member 'UWidgetComponent::MaskedMaterial' has a wrong offset!");
static_assert(offsetof(UWidgetComponent, MaskedMaterial_OneSided) == 0x000690, "Member 'UWidgetComponent::MaskedMaterial_OneSided' has a wrong offset!");
static_assert(offsetof(UWidgetComponent, RenderTarget) == 0x000698, "Member 'UWidgetComponent::RenderTarget' has a wrong offset!");
static_assert(offsetof(UWidgetComponent, MaterialInstance) == 0x0006A0, "Member 'UWidgetComponent::MaterialInstance' has a wrong offset!");
static_assert(offsetof(UWidgetComponent, bAddedToScreen) == 0x0006A8, "Member 'UWidgetComponent::bAddedToScreen' has a wrong offset!");
static_assert(offsetof(UWidgetComponent, bEditTimeUsable) == 0x0006A9, "Member 'UWidgetComponent::bEditTimeUsable' has a wrong offset!");
static_assert(offsetof(UWidgetComponent, SharedLayerName) == 0x0006AC, "Member 'UWidgetComponent::SharedLayerName' has a wrong offset!");
static_assert(offsetof(UWidgetComponent, LayerZOrder) == 0x0006B4, "Member 'UWidgetComponent::LayerZOrder' has a wrong offset!");
static_assert(offsetof(UWidgetComponent, bUseCustomZOrder) == 0x0006B8, "Member 'UWidgetComponent::bUseCustomZOrder' has a wrong offset!");
static_assert(offsetof(UWidgetComponent, GeometryMode) == 0x0006B9, "Member 'UWidgetComponent::GeometryMode' has a wrong offset!");
static_assert(offsetof(UWidgetComponent, CylinderArcAngle) == 0x0006BC, "Member 'UWidgetComponent::CylinderArcAngle' has a wrong offset!");
static_assert(offsetof(UWidgetComponent, TickMode) == 0x0006C0, "Member 'UWidgetComponent::TickMode' has a wrong offset!");
static_assert(offsetof(UWidgetComponent, Widget) == 0x0006F0, "Member 'UWidgetComponent::Widget' has a wrong offset!");

// Class UMG.WidgetBlueprintGeneratedClassExtension
// 0x0000 (0x0028 - 0x0028)
class UWidgetBlueprintGeneratedClassExtension final : public UObject
{
public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"WidgetBlueprintGeneratedClassExtension">();
	}
	static class UWidgetBlueprintGeneratedClassExtension* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UWidgetBlueprintGeneratedClassExtension>();
	}
};
static_assert(alignof(UWidgetBlueprintGeneratedClassExtension) == 0x000008, "Wrong alignment on UWidgetBlueprintGeneratedClassExtension");
static_assert(sizeof(UWidgetBlueprintGeneratedClassExtension) == 0x000028, "Wrong size on UWidgetBlueprintGeneratedClassExtension");

// Class UMG.RetainerBox
// 0x0030 (0x0198 - 0x0168)
class URetainerBox : public UContentWidget
{
public:
	bool                                          bRetainRender;                                     // 0x0168(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          RenderOnInvalidation;                              // 0x0169(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          RenderOnPhase;                                     // 0x016A(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_16B[0x1];                                      // 0x016B(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         Phase;                                             // 0x016C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         PhaseCount;                                        // 0x0170(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_174[0x4];                                      // 0x0174(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UMaterialInterface*                     EffectMaterial;                                    // 0x0178(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   TextureParameter;                                  // 0x0180(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_188[0x10];                                     // 0x0188(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void RequestRender()	 // 0x66f5d1c;
	void SetEffectMaterial(class UMaterialInterface* EffectMaterial_0)	 // 0x66f82dc;
	void SetRenderingPhase(int32 RenderPhase, int32 TotalPhases)	 // 0x66fc6b4;
	void SetRetainRendering(bool bInRetainRendering)	 // 0x66fc820;
	void SetTextureParameter(class FName TextureParameter_0)	 // 0x66fe5cc;

	class UMaterialInstanceDynamic* GetEffectMaterial() const	 // 0x66f3d9c;

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"RetainerBox">();
	}
	static class URetainerBox* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<URetainerBox>();
	}
};
static_assert(alignof(URetainerBox) == 0x000008, "Wrong alignment on URetainerBox");
static_assert(sizeof(URetainerBox) == 0x000198, "Wrong size on URetainerBox");
static_assert(offsetof(URetainerBox, bRetainRender) == 0x000168, "Member 'URetainerBox::bRetainRender' has a wrong offset!");
static_assert(offsetof(URetainerBox, RenderOnInvalidation) == 0x000169, "Member 'URetainerBox::RenderOnInvalidation' has a wrong offset!");
static_assert(offsetof(URetainerBox, RenderOnPhase) == 0x00016A, "Member 'URetainerBox::RenderOnPhase' has a wrong offset!");
static_assert(offsetof(URetainerBox, Phase) == 0x00016C, "Member 'URetainerBox::Phase' has a wrong offset!");
static_assert(offsetof(URetainerBox, PhaseCount) == 0x000170, "Member 'URetainerBox::PhaseCount' has a wrong offset!");
static_assert(offsetof(URetainerBox, EffectMaterial) == 0x000178, "Member 'URetainerBox::EffectMaterial' has a wrong offset!");
static_assert(offsetof(URetainerBox, TextureParameter) == 0x000180, "Member 'URetainerBox::TextureParameter' has a wrong offset!");

// Class UMG.ListViewDesignerPreviewItem
// 0x0000 (0x0028 - 0x0028)
class UListViewDesignerPreviewItem final : public UObject
{
public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"ListViewDesignerPreviewItem">();
	}
	static class UListViewDesignerPreviewItem* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UListViewDesignerPreviewItem>();
	}
};
static_assert(alignof(UListViewDesignerPreviewItem) == 0x000008, "Wrong alignment on UListViewDesignerPreviewItem");
static_assert(sizeof(UListViewDesignerPreviewItem) == 0x000028, "Wrong size on UListViewDesignerPreviewItem");

// Class UMG.SlateAccessibleWidgetData
// 0x0058 (0x0080 - 0x0028)
class USlateAccessibleWidgetData final : public UObject
{
public:
	bool                                          bCanChildrenBeAccessible;                          // 0x0028(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ESlateAccessibleBehavior                      AccessibleBehavior;                                // 0x0029(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ESlateAccessibleBehavior                      AccessibleSummaryBehavior;                         // 0x002A(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2B[0x5];                                       // 0x002B(0x0005)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   AccessibleText;                                    // 0x0030(0x0018)(NativeAccessSpecifierPublic)
	TDelegate<void()>                             AccessibleTextDelegate;                            // 0x0048(0x0010)(ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FText                                   AccessibleSummaryText;                             // 0x0058(0x0018)(NativeAccessSpecifierPublic)
	TDelegate<void()>                             AccessibleSummaryTextDelegate;                     // 0x0070(0x0010)(ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"SlateAccessibleWidgetData">();
	}
	static class USlateAccessibleWidgetData* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<USlateAccessibleWidgetData>();
	}
};
static_assert(alignof(USlateAccessibleWidgetData) == 0x000008, "Wrong alignment on USlateAccessibleWidgetData");
static_assert(sizeof(USlateAccessibleWidgetData) == 0x000080, "Wrong size on USlateAccessibleWidgetData");
static_assert(offsetof(USlateAccessibleWidgetData, bCanChildrenBeAccessible) == 0x000028, "Member 'USlateAccessibleWidgetData::bCanChildrenBeAccessible' has a wrong offset!");
static_assert(offsetof(USlateAccessibleWidgetData, AccessibleBehavior) == 0x000029, "Member 'USlateAccessibleWidgetData::AccessibleBehavior' has a wrong offset!");
static_assert(offsetof(USlateAccessibleWidgetData, AccessibleSummaryBehavior) == 0x00002A, "Member 'USlateAccessibleWidgetData::AccessibleSummaryBehavior' has a wrong offset!");
static_assert(offsetof(USlateAccessibleWidgetData, AccessibleText) == 0x000030, "Member 'USlateAccessibleWidgetData::AccessibleText' has a wrong offset!");
static_assert(offsetof(USlateAccessibleWidgetData, AccessibleTextDelegate) == 0x000048, "Member 'USlateAccessibleWidgetData::AccessibleTextDelegate' has a wrong offset!");
static_assert(offsetof(USlateAccessibleWidgetData, AccessibleSummaryText) == 0x000058, "Member 'USlateAccessibleWidgetData::AccessibleSummaryText' has a wrong offset!");
static_assert(offsetof(USlateAccessibleWidgetData, AccessibleSummaryTextDelegate) == 0x000070, "Member 'USlateAccessibleWidgetData::AccessibleSummaryTextDelegate' has a wrong offset!");

// Class UMG.UserWidgetBlueprint
// 0x0000 (0x00A8 - 0x00A8)
class UUserWidgetBlueprint final : public UBlueprint
{
public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"UserWidgetBlueprint">();
	}
	static class UUserWidgetBlueprint* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UUserWidgetBlueprint>();
	}
};
static_assert(alignof(UUserWidgetBlueprint) == 0x000008, "Wrong alignment on UUserWidgetBlueprint");
static_assert(sizeof(UUserWidgetBlueprint) == 0x0000A8, "Wrong size on UUserWidgetBlueprint");

// Class UMG.UserWidgetExtension
// 0x0000 (0x0028 - 0x0028)
class UUserWidgetExtension : public UObject
{
public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"UserWidgetExtension">();
	}
	static class UUserWidgetExtension* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UUserWidgetExtension>();
	}
};
static_assert(alignof(UUserWidgetExtension) == 0x000008, "Wrong alignment on UUserWidgetExtension");
static_assert(sizeof(UUserWidgetExtension) == 0x000028, "Wrong size on UUserWidgetExtension");

// Class UMG.WidgetFieldNotificationExtension
// 0x0018 (0x0040 - 0x0028)
class UWidgetFieldNotificationExtension final : public UUserWidgetExtension
{
public:
	uint8                                         Pad_28[0x18];                                      // 0x0028(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"WidgetFieldNotificationExtension">();
	}
	static class UWidgetFieldNotificationExtension* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UWidgetFieldNotificationExtension>();
	}
};
static_assert(alignof(UWidgetFieldNotificationExtension) == 0x000008, "Wrong alignment on UWidgetFieldNotificationExtension");
static_assert(sizeof(UWidgetFieldNotificationExtension) == 0x000040, "Wrong size on UWidgetFieldNotificationExtension");

// Class UMG.CheckedStateBinding
// 0x0008 (0x0078 - 0x0070)
class UCheckedStateBinding final : public UPropertyBinding
{
public:
	uint8                                         Pad_70[0x8];                                       // 0x0070(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	ECheckBoxState GetValue() const	 // 0x66cc3dc;

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"CheckedStateBinding">();
	}
	static class UCheckedStateBinding* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UCheckedStateBinding>();
	}
};
static_assert(alignof(UCheckedStateBinding) == 0x000008, "Wrong alignment on UCheckedStateBinding");
static_assert(sizeof(UCheckedStateBinding) == 0x000078, "Wrong size on UCheckedStateBinding");

// Class UMG.WrapBox
// 0x0028 (0x0190 - 0x0168)
class UWrapBox final : public UPanelWidget
{
public:
	struct FVector2D                              InnerSlotPadding;                                  // 0x0168(0x0010)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         WrapSize;                                          // 0x0178(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bExplicitWrapSize;                                 // 0x017C(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EHorizontalAlignment                          HorizontalAlignment;                               // 0x017D(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EOrientation                                  Orientation;                                       // 0x017E(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_17F[0x11];                                     // 0x017F(0x0011)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	class UWrapBoxSlot* AddChildToWrapBox(class UWidget* Content)	 // 0x670ee3c;
	void SetHorizontalAlignment(EHorizontalAlignment InHorizontalAlignment)	 // 0x67182d0;
	void SetInnerSlotPadding(const struct FVector2D& InPadding)	 // 0x6718450;

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"WrapBox">();
	}
	static class UWrapBox* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UWrapBox>();
	}
};
static_assert(alignof(UWrapBox) == 0x000008, "Wrong alignment on UWrapBox");
static_assert(sizeof(UWrapBox) == 0x000190, "Wrong size on UWrapBox");
static_assert(offsetof(UWrapBox, InnerSlotPadding) == 0x000168, "Member 'UWrapBox::InnerSlotPadding' has a wrong offset!");
static_assert(offsetof(UWrapBox, WrapSize) == 0x000178, "Member 'UWrapBox::WrapSize' has a wrong offset!");
static_assert(offsetof(UWrapBox, bExplicitWrapSize) == 0x00017C, "Member 'UWrapBox::bExplicitWrapSize' has a wrong offset!");
static_assert(offsetof(UWrapBox, HorizontalAlignment) == 0x00017D, "Member 'UWrapBox::HorizontalAlignment' has a wrong offset!");
static_assert(offsetof(UWrapBox, Orientation) == 0x00017E, "Member 'UWrapBox::Orientation' has a wrong offset!");

// Class UMG.WidgetNavigation
// 0x00D8 (0x0100 - 0x0028)
class UWidgetNavigation final : public UObject
{
public:
	struct FWidgetNavigationData                  Up;                                                // 0x0028(0x0024)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	struct FWidgetNavigationData                  Down;                                              // 0x004C(0x0024)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	struct FWidgetNavigationData                  Left;                                              // 0x0070(0x0024)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	struct FWidgetNavigationData                  Right;                                             // 0x0094(0x0024)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	struct FWidgetNavigationData                  Next;                                              // 0x00B8(0x0024)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	struct FWidgetNavigationData                  Previous;                                          // 0x00DC(0x0024)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"WidgetNavigation">();
	}
	static class UWidgetNavigation* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UWidgetNavigation>();
	}
};
static_assert(alignof(UWidgetNavigation) == 0x000008, "Wrong alignment on UWidgetNavigation");
static_assert(sizeof(UWidgetNavigation) == 0x000100, "Wrong size on UWidgetNavigation");
static_assert(offsetof(UWidgetNavigation, Up) == 0x000028, "Member 'UWidgetNavigation::Up' has a wrong offset!");
static_assert(offsetof(UWidgetNavigation, Down) == 0x00004C, "Member 'UWidgetNavigation::Down' has a wrong offset!");
static_assert(offsetof(UWidgetNavigation, Left) == 0x000070, "Member 'UWidgetNavigation::Left' has a wrong offset!");
static_assert(offsetof(UWidgetNavigation, Right) == 0x000094, "Member 'UWidgetNavigation::Right' has a wrong offset!");
static_assert(offsetof(UWidgetNavigation, Next) == 0x0000B8, "Member 'UWidgetNavigation::Next' has a wrong offset!");
static_assert(offsetof(UWidgetNavigation, Previous) == 0x0000DC, "Member 'UWidgetNavigation::Previous' has a wrong offset!");

// Class UMG.MouseCursorBinding
// 0x0000 (0x0070 - 0x0070)
class UMouseCursorBinding final : public UPropertyBinding
{
public:
	EMouseCursor GetValue() const	 // 0x66cc480;

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"MouseCursorBinding">();
	}
	static class UMouseCursorBinding* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UMouseCursorBinding>();
	}
};
static_assert(alignof(UMouseCursorBinding) == 0x000008, "Wrong alignment on UMouseCursorBinding");
static_assert(sizeof(UMouseCursorBinding) == 0x000070, "Wrong size on UMouseCursorBinding");

// Class UMG.SlateVectorArtData
// 0x0048 (0x0070 - 0x0028)
class USlateVectorArtData final : public UObject
{
public:
	TArray<struct FSlateMeshVertex>               VertexData;                                        // 0x0028(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	TArray<uint32>                                IndexData;                                         // 0x0038(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	class UMaterialInterface*                     Material;                                          // 0x0048(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FVector2D                              ExtentMin;                                         // 0x0050(0x0010)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FVector2D                              ExtentMax;                                         // 0x0060(0x0010)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"SlateVectorArtData">();
	}
	static class USlateVectorArtData* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<USlateVectorArtData>();
	}
};
static_assert(alignof(USlateVectorArtData) == 0x000008, "Wrong alignment on USlateVectorArtData");
static_assert(sizeof(USlateVectorArtData) == 0x000070, "Wrong size on USlateVectorArtData");
static_assert(offsetof(USlateVectorArtData, VertexData) == 0x000028, "Member 'USlateVectorArtData::VertexData' has a wrong offset!");
static_assert(offsetof(USlateVectorArtData, IndexData) == 0x000038, "Member 'USlateVectorArtData::IndexData' has a wrong offset!");
static_assert(offsetof(USlateVectorArtData, Material) == 0x000048, "Member 'USlateVectorArtData::Material' has a wrong offset!");
static_assert(offsetof(USlateVectorArtData, ExtentMin) == 0x000050, "Member 'USlateVectorArtData::ExtentMin' has a wrong offset!");
static_assert(offsetof(USlateVectorArtData, ExtentMax) == 0x000060, "Member 'USlateVectorArtData::ExtentMax' has a wrong offset!");

// Class UMG.MovieSceneMarginPropertySystem
// 0x0000 (0x0058 - 0x0058)
class UMovieSceneMarginPropertySystem final : public UMovieScenePropertySystem
{
public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"MovieSceneMarginPropertySystem">();
	}
	static class UMovieSceneMarginPropertySystem* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UMovieSceneMarginPropertySystem>();
	}
};
static_assert(alignof(UMovieSceneMarginPropertySystem) == 0x000008, "Wrong alignment on UMovieSceneMarginPropertySystem");
static_assert(sizeof(UMovieSceneMarginPropertySystem) == 0x000058, "Wrong size on UMovieSceneMarginPropertySystem");

// Class UMG.MovieSceneMarginTrack
// 0x0000 (0x00C8 - 0x00C8)
class UMovieSceneMarginTrack final : public UMovieScenePropertyTrack
{
public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"MovieSceneMarginTrack">();
	}
	static class UMovieSceneMarginTrack* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UMovieSceneMarginTrack>();
	}
};
static_assert(alignof(UMovieSceneMarginTrack) == 0x000008, "Wrong alignment on UMovieSceneMarginTrack");
static_assert(sizeof(UMovieSceneMarginTrack) == 0x0000C8, "Wrong size on UMovieSceneMarginTrack");

// Class UMG.MovieSceneWidgetMaterialSystem
// 0x0160 (0x01A0 - 0x0040)
class UMovieSceneWidgetMaterialSystem final : public UMovieSceneEntitySystem
{
public:
	uint8                                         Pad_40[0x160];                                     // 0x0040(0x0160)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"MovieSceneWidgetMaterialSystem">();
	}
	static class UMovieSceneWidgetMaterialSystem* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UMovieSceneWidgetMaterialSystem>();
	}
};
static_assert(alignof(UMovieSceneWidgetMaterialSystem) == 0x000008, "Wrong alignment on UMovieSceneWidgetMaterialSystem");
static_assert(sizeof(UMovieSceneWidgetMaterialSystem) == 0x0001A0, "Wrong size on UMovieSceneWidgetMaterialSystem");

// Class UMG.UMGSequenceTickManager
// 0x0098 (0x00C0 - 0x0028)
class UUMGSequenceTickManager final : public UObject
{
public:
	TMap<TWeakObjectPtr<class UUserWidget>, struct FSequenceTickManagerWidgetData> WeakUserWidgetData; // 0x0028(0x0050)(Transient, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	class UMovieSceneEntitySystemLinker*          Linker;                                            // 0x0078(0x0008)(ZeroConstructor, Transient, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_80[0x40];                                      // 0x0080(0x0040)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"UMGSequenceTickManager">();
	}
	static class UUMGSequenceTickManager* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UUMGSequenceTickManager>();
	}
};
static_assert(alignof(UUMGSequenceTickManager) == 0x000008, "Wrong alignment on UUMGSequenceTickManager");
static_assert(sizeof(UUMGSequenceTickManager) == 0x0000C0, "Wrong size on UUMGSequenceTickManager");
static_assert(offsetof(UUMGSequenceTickManager, WeakUserWidgetData) == 0x000028, "Member 'UUMGSequenceTickManager::WeakUserWidgetData' has a wrong offset!");
static_assert(offsetof(UUMGSequenceTickManager, Linker) == 0x000078, "Member 'UUMGSequenceTickManager::Linker' has a wrong offset!");

// Class UMG.TextBinding
// 0x0008 (0x0078 - 0x0070)
class UTextBinding final : public UPropertyBinding
{
public:
	uint8                                         Pad_70[0x8];                                       // 0x0070(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	class FString GetStringValue() const	 // 0x66cc240;
	class FText GetTextValue() const	 // 0x66cc2d4;

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"TextBinding">();
	}
	static class UTextBinding* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UTextBinding>();
	}
};
static_assert(alignof(UTextBinding) == 0x000008, "Wrong alignment on UTextBinding");
static_assert(sizeof(UTextBinding) == 0x000078, "Wrong size on UTextBinding");

// Class UMG.WidgetAnimation
// 0x0030 (0x0098 - 0x0068)
class UWidgetAnimation final : public UMovieSceneSequence
{
public:
	class UMovieScene*                            MovieScene;                                        // 0x0068(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FWidgetAnimationBinding>        AnimationBindings;                                 // 0x0070(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	bool                                          bLegacyFinishOnStop;                               // 0x0080(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_81[0x7];                                       // 0x0081(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 DisplayLabel;                                      // 0x0088(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void BindToAnimationFinished(class UUserWidget* Widget, TDelegate<void()> Delegate)	 // 0x66cb274;
	void BindToAnimationStarted(class UUserWidget* Widget, TDelegate<void()> Delegate)	 // 0x66cb3dc;
	void UnbindAllFromAnimationFinished(class UUserWidget* Widget)	 // 0x66d0b40;
	void UnbindAllFromAnimationStarted(class UUserWidget* Widget)	 // 0x66d0c00;
	void UnbindFromAnimationFinished(class UUserWidget* Widget, TDelegate<void()> Delegate)	 // 0x66d0cc0;
	void UnbindFromAnimationStarted(class UUserWidget* Widget, TDelegate<void()> Delegate)	 // 0x66d0e28;

	float GetEndTime() const	 // 0x66cbd10;
	float GetStartTime() const	 // 0x66cc220;

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"WidgetAnimation">();
	}
	static class UWidgetAnimation* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UWidgetAnimation>();
	}
};
static_assert(alignof(UWidgetAnimation) == 0x000008, "Wrong alignment on UWidgetAnimation");
static_assert(sizeof(UWidgetAnimation) == 0x000098, "Wrong size on UWidgetAnimation");
static_assert(offsetof(UWidgetAnimation, MovieScene) == 0x000068, "Member 'UWidgetAnimation::MovieScene' has a wrong offset!");
static_assert(offsetof(UWidgetAnimation, AnimationBindings) == 0x000070, "Member 'UWidgetAnimation::AnimationBindings' has a wrong offset!");
static_assert(offsetof(UWidgetAnimation, bLegacyFinishOnStop) == 0x000080, "Member 'UWidgetAnimation::bLegacyFinishOnStop' has a wrong offset!");
static_assert(offsetof(UWidgetAnimation, DisplayLabel) == 0x000088, "Member 'UWidgetAnimation::DisplayLabel' has a wrong offset!");

// Class UMG.UserListEntry
// 0x0000 (0x0000 - 0x0000)
class IUserListEntry final
{
public:
	void BP_OnEntryReleased()	 // 0xae1e64;
	void BP_OnItemExpansionChanged(bool bIsExpanded)	 // 0xae1e64;
	void BP_OnItemSelectionChanged(bool bIsSelected)	 // 0xae1e64;

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"UserListEntry">();
	}
	static class IUserListEntry* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<IUserListEntry>();
	}

	class UObject* AsUObject()	 // 0x0
	{
		return reinterpret_cast<UObject*>(this);
	}
	const class UObject* AsUObject() const	 // 0x0
	{
		return reinterpret_cast<const UObject*>(this);
	}
};
static_assert(alignof(IUserListEntry) == 0x000001, "Wrong alignment on IUserListEntry");
static_assert(sizeof(IUserListEntry) == 0x000001, "Wrong size on IUserListEntry");

// Class UMG.UserObjectListEntry
// 0x0000 (0x0000 - 0x0000)
class IUserObjectListEntry final
{
public:
	void OnListItemObjectSet(class UObject* ListItemObject)	 // 0xae1e64;

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"UserObjectListEntry">();
	}
	static class IUserObjectListEntry* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<IUserObjectListEntry>();
	}

	class UObject* AsUObject()	 // 0x0
	{
		return reinterpret_cast<UObject*>(this);
	}
	const class UObject* AsUObject() const	 // 0x0
	{
		return reinterpret_cast<const UObject*>(this);
	}
};
static_assert(alignof(IUserObjectListEntry) == 0x000001, "Wrong alignment on IUserObjectListEntry");
static_assert(sizeof(IUserObjectListEntry) == 0x000001, "Wrong size on IUserObjectListEntry");

// Class UMG.WidgetAnimationDelegateBinding
// 0x0010 (0x0038 - 0x0028)
class UWidgetAnimationDelegateBinding final : public UDynamicBlueprintBinding
{
public:
	TArray<struct FBlueprintWidgetAnimationDelegateBinding> WidgetAnimationDelegateBindings;         // 0x0028(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"WidgetAnimationDelegateBinding">();
	}
	static class UWidgetAnimationDelegateBinding* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UWidgetAnimationDelegateBinding>();
	}
};
static_assert(alignof(UWidgetAnimationDelegateBinding) == 0x000008, "Wrong alignment on UWidgetAnimationDelegateBinding");
static_assert(sizeof(UWidgetAnimationDelegateBinding) == 0x000038, "Wrong size on UWidgetAnimationDelegateBinding");
static_assert(offsetof(UWidgetAnimationDelegateBinding, WidgetAnimationDelegateBindings) == 0x000028, "Member 'UWidgetAnimationDelegateBinding::WidgetAnimationDelegateBindings' has a wrong offset!");

// Class UMG.BoolBinding
// 0x0000 (0x0070 - 0x0070)
class UBoolBinding final : public UPropertyBinding
{
public:
	bool GetValue() const	 // 0x66cc340;

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"BoolBinding">();
	}
	static class UBoolBinding* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UBoolBinding>();
	}
};
static_assert(alignof(UBoolBinding) == 0x000008, "Wrong alignment on UBoolBinding");
static_assert(sizeof(UBoolBinding) == 0x000070, "Wrong size on UBoolBinding");

// Class UMG.BrushBinding
// 0x0008 (0x0078 - 0x0070)
class UBrushBinding final : public UPropertyBinding
{
public:
	uint8                                         Pad_70[0x8];                                       // 0x0070(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	struct FSlateBrush GetValue() const	 // 0x66cc398;

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"BrushBinding">();
	}
	static class UBrushBinding* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UBrushBinding>();
	}
};
static_assert(alignof(UBrushBinding) == 0x000008, "Wrong alignment on UBrushBinding");
static_assert(sizeof(UBrushBinding) == 0x000078, "Wrong size on UBrushBinding");

// Class UMG.ColorBinding
// 0x0008 (0x0078 - 0x0070)
class UColorBinding final : public UPropertyBinding
{
public:
	uint8                                         Pad_70[0x8];                                       // 0x0070(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	struct FLinearColor GetLinearValue() const	 // 0x66cbdec;
	struct FSlateColor GetSlateValue() const	 // 0x66cc1ec;

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"ColorBinding">();
	}
	static class UColorBinding* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UColorBinding>();
	}
};
static_assert(alignof(UColorBinding) == 0x000008, "Wrong alignment on UColorBinding");
static_assert(sizeof(UColorBinding) == 0x000078, "Wrong size on UColorBinding");

// Class UMG.FloatBinding
// 0x0000 (0x0070 - 0x0070)
class UFloatBinding final : public UPropertyBinding
{
public:
	float GetValue() const	 // 0x66cc400;

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"FloatBinding">();
	}
	static class UFloatBinding* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UFloatBinding>();
	}
};
static_assert(alignof(UFloatBinding) == 0x000008, "Wrong alignment on UFloatBinding");
static_assert(sizeof(UFloatBinding) == 0x000070, "Wrong size on UFloatBinding");

// Class UMG.VisibilityBinding
// 0x0000 (0x0070 - 0x0070)
class UVisibilityBinding final : public UPropertyBinding
{
public:
	ESlateVisibility GetValue() const	 // 0x15f185c;

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"VisibilityBinding">();
	}
	static class UVisibilityBinding* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UVisibilityBinding>();
	}
};
static_assert(alignof(UVisibilityBinding) == 0x000008, "Wrong alignment on UVisibilityBinding");
static_assert(sizeof(UVisibilityBinding) == 0x000070, "Wrong size on UVisibilityBinding");

// Class UMG.GameViewportSubsystem
// 0x0080 (0x00B0 - 0x0030)
class UGameViewportSubsystem final : public UEngineSubsystem
{
public:
	uint8                                         Pad_30[0x80];                                      // 0x0030(0x0080)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static struct FGameViewportWidgetSlot SetWidgetSlotDesiredSize(const struct FGameViewportWidgetSlot& Slot, const struct FVector2D& Size)	 // 0x66d05fc;
	static struct FGameViewportWidgetSlot SetWidgetSlotPosition(const struct FGameViewportWidgetSlot& Slot, const class UWidget* Widget, const struct FVector2D& Position, bool bRemoveDPIScale)	 // 0x66d07c4;

	void AddWidget(class UWidget* Widget, const struct FGameViewportWidgetSlot& Slot)	 // 0x66cad54;
	void AddWidgetForPlayer(class UWidget* Widget, class ULocalPlayer* Player, const struct FGameViewportWidgetSlot& Slot)	 // 0x66caed4;
	void RemoveWidget(class UWidget* Widget)	 // 0x66cd068;
	void SetWidgetSlot(class UWidget* Widget, const struct FGameViewportWidgetSlot& Slot)	 // 0x66d017c;

	struct FGameViewportWidgetSlot GetWidgetSlot(const class UWidget* Widget) const	 // 0x66cc540;
	bool IsWidgetAdded(const class UWidget* Widget) const	 // 0x66cc974;

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"GameViewportSubsystem">();
	}
	static class UGameViewportSubsystem* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UGameViewportSubsystem>();
	}
};
static_assert(alignof(UGameViewportSubsystem) == 0x000008, "Wrong alignment on UGameViewportSubsystem");
static_assert(sizeof(UGameViewportSubsystem) == 0x0000B0, "Wrong size on UGameViewportSubsystem");

// Class UMG.UserObjectListEntryLibrary
// 0x0000 (0x0028 - 0x0028)
class UUserObjectListEntryLibrary final : public UBlueprintFunctionLibrary
{
public:
	static class UObject* GetListItemObject(TScriptInterface<class IUserObjectListEntry> UserObjectListEntry)	 // 0x66cbe1c;

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"UserObjectListEntryLibrary">();
	}
	static class UUserObjectListEntryLibrary* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UUserObjectListEntryLibrary>();
	}
};
static_assert(alignof(UUserObjectListEntryLibrary) == 0x000008, "Wrong alignment on UUserObjectListEntryLibrary");
static_assert(sizeof(UUserObjectListEntryLibrary) == 0x000028, "Wrong size on UUserObjectListEntryLibrary");

// Class UMG.BackgroundBlur
// 0x0128 (0x0290 - 0x0168)
class UBackgroundBlur final : public UContentWidget
{
public:
	struct FMargin                                Padding;                                           // 0x0168(0x0010)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	EHorizontalAlignment                          HorizontalAlignment;                               // 0x0178(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EVerticalAlignment                            VerticalAlignment;                                 // 0x0179(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bApplyAlphaToBlur;                                 // 0x017A(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_17B[0x1];                                      // 0x017B(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         BlurStrength;                                      // 0x017C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bOverrideAutoRadiusCalculation;                    // 0x0180(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_181[0x3];                                      // 0x0181(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         BlurRadius;                                        // 0x0184(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_188[0x8];                                      // 0x0188(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector4                               CornerRadius;                                      // 0x0190(0x0020)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSlateBrush                            LowQualityFallbackBrush;                           // 0x01B0(0x00D0)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	uint8                                         Pad_280[0x10];                                     // 0x0280(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SetApplyAlphaToBlur(bool bInApplyAlphaToBlur)	 // 0x66cd584;
	void SetBlurRadius(int32 InBlurRadius)	 // 0x66cd7d4;
	void SetBlurStrength(float InStrength)	 // 0x160ef28;
	void SetCornerRadius(const struct FVector4& InCornerRadius)	 // 0x66cdd08;
	void SetHorizontalAlignment(EHorizontalAlignment InHorizontalAlignment)	 // 0x66ce320;
	void SetLowQualityFallbackBrush(const struct FSlateBrush& InBrush)	 // 0x66cea84;
	void SetPadding(const struct FMargin& InPadding)	 // 0x66cef70;
	void SetVerticalAlignment(EVerticalAlignment InVerticalAlignment)	 // 0x66cfdb4;

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"BackgroundBlur">();
	}
	static class UBackgroundBlur* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UBackgroundBlur>();
	}
};
static_assert(alignof(UBackgroundBlur) == 0x000010, "Wrong alignment on UBackgroundBlur");
static_assert(sizeof(UBackgroundBlur) == 0x000290, "Wrong size on UBackgroundBlur");
static_assert(offsetof(UBackgroundBlur, Padding) == 0x000168, "Member 'UBackgroundBlur::Padding' has a wrong offset!");
static_assert(offsetof(UBackgroundBlur, HorizontalAlignment) == 0x000178, "Member 'UBackgroundBlur::HorizontalAlignment' has a wrong offset!");
static_assert(offsetof(UBackgroundBlur, VerticalAlignment) == 0x000179, "Member 'UBackgroundBlur::VerticalAlignment' has a wrong offset!");
static_assert(offsetof(UBackgroundBlur, bApplyAlphaToBlur) == 0x00017A, "Member 'UBackgroundBlur::bApplyAlphaToBlur' has a wrong offset!");
static_assert(offsetof(UBackgroundBlur, BlurStrength) == 0x00017C, "Member 'UBackgroundBlur::BlurStrength' has a wrong offset!");
static_assert(offsetof(UBackgroundBlur, bOverrideAutoRadiusCalculation) == 0x000180, "Member 'UBackgroundBlur::bOverrideAutoRadiusCalculation' has a wrong offset!");
static_assert(offsetof(UBackgroundBlur, BlurRadius) == 0x000184, "Member 'UBackgroundBlur::BlurRadius' has a wrong offset!");
static_assert(offsetof(UBackgroundBlur, CornerRadius) == 0x000190, "Member 'UBackgroundBlur::CornerRadius' has a wrong offset!");
static_assert(offsetof(UBackgroundBlur, LowQualityFallbackBrush) == 0x0001B0, "Member 'UBackgroundBlur::LowQualityFallbackBrush' has a wrong offset!");

// Class UMG.BackgroundBlurSlot
// 0x0028 (0x0060 - 0x0038)
class UBackgroundBlurSlot final : public UPanelSlot
{
public:
	struct FMargin                                Padding;                                           // 0x0038(0x0010)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)
	EHorizontalAlignment                          HorizontalAlignment;                               // 0x0048(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EVerticalAlignment                            VerticalAlignment;                                 // 0x0049(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_4A[0x16];                                      // 0x004A(0x0016)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SetHorizontalAlignment(EHorizontalAlignment InHorizontalAlignment)	 // 0x66ce3e0;
	void SetPadding(const struct FMargin& InPadding)	 // 0x66cf040;
	void SetVerticalAlignment(EVerticalAlignment InVerticalAlignment)	 // 0x66cfe74;

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"BackgroundBlurSlot">();
	}
	static class UBackgroundBlurSlot* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UBackgroundBlurSlot>();
	}
};
static_assert(alignof(UBackgroundBlurSlot) == 0x000008, "Wrong alignment on UBackgroundBlurSlot");
static_assert(sizeof(UBackgroundBlurSlot) == 0x000060, "Wrong size on UBackgroundBlurSlot");
static_assert(offsetof(UBackgroundBlurSlot, Padding) == 0x000038, "Member 'UBackgroundBlurSlot::Padding' has a wrong offset!");
static_assert(offsetof(UBackgroundBlurSlot, HorizontalAlignment) == 0x000048, "Member 'UBackgroundBlurSlot::HorizontalAlignment' has a wrong offset!");
static_assert(offsetof(UBackgroundBlurSlot, VerticalAlignment) == 0x000049, "Member 'UBackgroundBlurSlot::VerticalAlignment' has a wrong offset!");

// Class UMG.BorderSlot
// 0x0028 (0x0060 - 0x0038)
class UBorderSlot final : public UPanelSlot
{
public:
	struct FMargin                                Padding;                                           // 0x0038(0x0010)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)
	EHorizontalAlignment                          HorizontalAlignment;                               // 0x0048(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EVerticalAlignment                            VerticalAlignment;                                 // 0x0049(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_4A[0x16];                                      // 0x004A(0x0016)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SetHorizontalAlignment(EHorizontalAlignment InHorizontalAlignment)	 // 0x66ce564;
	void SetPadding(const struct FMargin& InPadding)	 // 0x165c2f0;
	void SetVerticalAlignment(EVerticalAlignment InVerticalAlignment)	 // 0x66cfff8;

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"BorderSlot">();
	}
	static class UBorderSlot* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UBorderSlot>();
	}
};
static_assert(alignof(UBorderSlot) == 0x000008, "Wrong alignment on UBorderSlot");
static_assert(sizeof(UBorderSlot) == 0x000060, "Wrong size on UBorderSlot");
static_assert(offsetof(UBorderSlot, Padding) == 0x000038, "Member 'UBorderSlot::Padding' has a wrong offset!");
static_assert(offsetof(UBorderSlot, HorizontalAlignment) == 0x000048, "Member 'UBorderSlot::HorizontalAlignment' has a wrong offset!");
static_assert(offsetof(UBorderSlot, VerticalAlignment) == 0x000049, "Member 'UBorderSlot::VerticalAlignment' has a wrong offset!");

// Class UMG.ButtonSlot
// 0x0028 (0x0060 - 0x0038)
class UButtonSlot final : public UPanelSlot
{
public:
	struct FMargin                                Padding;                                           // 0x0038(0x0010)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	EHorizontalAlignment                          HorizontalAlignment;                               // 0x0048(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EVerticalAlignment                            VerticalAlignment;                                 // 0x0049(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4A[0x16];                                      // 0x004A(0x0016)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SetHorizontalAlignment(EHorizontalAlignment InHorizontalAlignment)	 // 0x66ce628;
	void SetPadding(const struct FMargin& InPadding)	 // 0x66cf1e0;
	void SetVerticalAlignment(EVerticalAlignment InVerticalAlignment)	 // 0x66d00bc;

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"ButtonSlot">();
	}
	static class UButtonSlot* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UButtonSlot>();
	}
};
static_assert(alignof(UButtonSlot) == 0x000008, "Wrong alignment on UButtonSlot");
static_assert(sizeof(UButtonSlot) == 0x000060, "Wrong size on UButtonSlot");
static_assert(offsetof(UButtonSlot, Padding) == 0x000038, "Member 'UButtonSlot::Padding' has a wrong offset!");
static_assert(offsetof(UButtonSlot, HorizontalAlignment) == 0x000048, "Member 'UButtonSlot::HorizontalAlignment' has a wrong offset!");
static_assert(offsetof(UButtonSlot, VerticalAlignment) == 0x000049, "Member 'UButtonSlot::VerticalAlignment' has a wrong offset!");

// Class UMG.CanvasPanel
// 0x0010 (0x0178 - 0x0168)
class UCanvasPanel final : public UPanelWidget
{
public:
	uint8                                         Pad_168[0x10];                                     // 0x0168(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	class UCanvasPanelSlot* AddChildToCanvas(class UWidget* Content)	 // 0x66caaf4;

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"CanvasPanel">();
	}
	static class UCanvasPanel* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UCanvasPanel>();
	}
};
static_assert(alignof(UCanvasPanel) == 0x000008, "Wrong alignment on UCanvasPanel");
static_assert(sizeof(UCanvasPanel) == 0x000178, "Wrong size on UCanvasPanel");

// Class UMG.CanvasPanelSlot
// 0x0050 (0x0088 - 0x0038)
class UCanvasPanelSlot final : public UPanelSlot
{
public:
	struct FAnchorData                            LayoutData;                                        // 0x0038(0x0040)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          bAutoSize;                                         // 0x0078(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_79[0x3];                                       // 0x0079(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         ZOrder;                                            // 0x007C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_80[0x8];                                       // 0x0080(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SetAlignment(const struct FVector2D& InAlignment)	 // 0x66cd3dc;
	void SetAnchors(const struct FAnchors& InAnchors)	 // 0x66cd4a4;
	void SetAutoSize(bool InbAutoSize)	 // 0x66cd648;
	void SetLayout(const struct FAnchorData& InLayoutData)	 // 0x66ce9f4;
	void SetMaximum(const struct FVector2D& InMaximumAnchors)	 // 0x66ceb8c;
	void SetMinimum(const struct FVector2D& InMinimumAnchors)	 // 0x66cec54;
	void SetOffsets(const struct FMargin& InOffset)	 // 0x66ceea0;
	void SetPosition(const struct FVector2D& InPosition)	 // 0x13ea658;
	void SetSize(const struct FVector2D& InSize)	 // 0xf61650;
	void SetZOrder(int32 InZOrder)	 // 0x66d0a80;

	struct FVector2D GetAlignment() const	 // 0x66cbba8;
	struct FAnchors GetAnchors() const	 // 0x66cbc08;
	bool GetAutoSize() const	 // 0x66cbc58;
	struct FAnchorData GetLayout() const	 // 0x66cbdb8;
	struct FMargin GetOffsets() const	 // 0x66cbf04;
	struct FVector2D GetPosition() const	 // 0x66cc100;
	struct FVector2D GetSize() const	 // 0x66cc194;
	int32 GetZOrder() const	 // 0x66cc644;

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"CanvasPanelSlot">();
	}
	static class UCanvasPanelSlot* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UCanvasPanelSlot>();
	}
};
static_assert(alignof(UCanvasPanelSlot) == 0x000008, "Wrong alignment on UCanvasPanelSlot");
static_assert(sizeof(UCanvasPanelSlot) == 0x000088, "Wrong size on UCanvasPanelSlot");
static_assert(offsetof(UCanvasPanelSlot, LayoutData) == 0x000038, "Member 'UCanvasPanelSlot::LayoutData' has a wrong offset!");
static_assert(offsetof(UCanvasPanelSlot, bAutoSize) == 0x000078, "Member 'UCanvasPanelSlot::bAutoSize' has a wrong offset!");
static_assert(offsetof(UCanvasPanelSlot, ZOrder) == 0x00007C, "Member 'UCanvasPanelSlot::ZOrder' has a wrong offset!");

// Class UMG.CircularThrobber
// 0x0100 (0x0250 - 0x0150)
class UCircularThrobber final : public UWidget
{
public:
	int32                                         NumberOfPieces;                                    // 0x0150(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Period;                                            // 0x0154(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Radius;                                            // 0x0158(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_15C[0x4];                                      // 0x015C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FSlateBrush                            Image;                                             // 0x0160(0x00D0)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	bool                                          bEnableRadius;                                     // 0x0230(0x0001)(Edit, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_231[0x1F];                                     // 0x0231(0x001F)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SetNumberOfPieces(int32 InNumberOfPieces)	 // 0x66cede0;
	void SetPeriod(float InPeriod)	 // 0x66cf2b0;
	void SetRadius(float InRadius)	 // 0x66cf590;

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"CircularThrobber">();
	}
	static class UCircularThrobber* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UCircularThrobber>();
	}
};
static_assert(alignof(UCircularThrobber) == 0x000010, "Wrong alignment on UCircularThrobber");
static_assert(sizeof(UCircularThrobber) == 0x000250, "Wrong size on UCircularThrobber");
static_assert(offsetof(UCircularThrobber, NumberOfPieces) == 0x000150, "Member 'UCircularThrobber::NumberOfPieces' has a wrong offset!");
static_assert(offsetof(UCircularThrobber, Period) == 0x000154, "Member 'UCircularThrobber::Period' has a wrong offset!");
static_assert(offsetof(UCircularThrobber, Radius) == 0x000158, "Member 'UCircularThrobber::Radius' has a wrong offset!");
static_assert(offsetof(UCircularThrobber, Image) == 0x000160, "Member 'UCircularThrobber::Image' has a wrong offset!");
static_assert(offsetof(UCircularThrobber, bEnableRadius) == 0x000230, "Member 'UCircularThrobber::bEnableRadius' has a wrong offset!");

// Class UMG.ComboBox
// 0x07B0 (0x0900 - 0x0150)
class UComboBox final : public UWidget
{
public:
	struct FScrollBarStyle                        ScrollBarStyle;                                    // 0x0150(0x0770)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	TArray<class UObject*>                        Items;                                             // 0x08C0(0x0010)(Edit, BlueprintVisible, ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
	TDelegate<void(class UObject* Item)>          OnGenerateWidgetEvent;                             // 0x08D0(0x0010)(Edit, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsFocusable;                                      // 0x08E0(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_8E1[0x1F];                                     // 0x08E1(0x001F)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"ComboBox">();
	}
	static class UComboBox* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UComboBox>();
	}
};
static_assert(alignof(UComboBox) == 0x000010, "Wrong alignment on UComboBox");
static_assert(sizeof(UComboBox) == 0x000900, "Wrong size on UComboBox");
static_assert(offsetof(UComboBox, ScrollBarStyle) == 0x000150, "Member 'UComboBox::ScrollBarStyle' has a wrong offset!");
static_assert(offsetof(UComboBox, Items) == 0x0008C0, "Member 'UComboBox::Items' has a wrong offset!");
static_assert(offsetof(UComboBox, OnGenerateWidgetEvent) == 0x0008D0, "Member 'UComboBox::OnGenerateWidgetEvent' has a wrong offset!");
static_assert(offsetof(UComboBox, bIsFocusable) == 0x0008E0, "Member 'UComboBox::bIsFocusable' has a wrong offset!");

// Class UMG.ComboBoxKey
// 0x1BD0 (0x1D20 - 0x0150)
class UComboBoxKey final : public UWidget
{
public:
	TArray<class FName>                           OPTIONS;                                           // 0x0150(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPrivate)
	class FName                                   SelectedOption;                                    // 0x0160(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_168[0x8];                                      // 0x0168(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FComboBoxStyle                         WidgetStyle;                                       // 0x0170(0x0660)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	struct FTableRowStyle                         ItemStyle;                                         // 0x07D0(0x0D50)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	struct FScrollBarStyle                        ScrollBarStyle;                                    // 0x1520(0x0770)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FSlateColor                            ForegroundColor;                                   // 0x1C90(0x0014)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FMargin                                ContentPadding;                                    // 0x1CA4(0x0010)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	float                                         MaxListHeight;                                     // 0x1CB4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bHasDownArrow;                                     // 0x1CB8(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bEnableGamepadNavigationMode;                      // 0x1CB9(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsFocusable;                                      // 0x1CBA(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1CBB[0x1];                                     // 0x1CBB(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	TDelegate<void(class FName Item)>             OnGenerateContentWidget;                           // 0x1CBC(0x0010)(Edit, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TDelegate<void(class FName Item)>             OnGenerateItemWidget;                              // 0x1CCC(0x0010)(Edit, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1CDC[0x4];                                     // 0x1CDC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TMulticastInlineDelegate<void(class FName SelectedItem, ESelectInfo SelectionType)> OnSelectionChanged; // 0x1CE0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void()>              OnOpening;                                         // 0x1CF0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_1D00[0x20];                                    // 0x1D00(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void AddOption(class FName Option)	 // 0x66cabc4;
	void ClearOptions()	 // 0x66cb544;
	void ClearSelection()	 // 0x66cb594;
	bool RemoveOption(class FName Option)	 // 0x66cce58;
	void SetSelectedOption(class FName Option)	 // 0x66cf714;

	class FName GetSelectedOption() const	 // 0x17423ec;
	bool IsOpen() const	 // 0x66cc8a8;

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"ComboBoxKey">();
	}
	static class UComboBoxKey* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UComboBoxKey>();
	}
};
static_assert(alignof(UComboBoxKey) == 0x000010, "Wrong alignment on UComboBoxKey");
static_assert(sizeof(UComboBoxKey) == 0x001D20, "Wrong size on UComboBoxKey");
static_assert(offsetof(UComboBoxKey, OPTIONS) == 0x000150, "Member 'UComboBoxKey::OPTIONS' has a wrong offset!");
static_assert(offsetof(UComboBoxKey, SelectedOption) == 0x000160, "Member 'UComboBoxKey::SelectedOption' has a wrong offset!");
static_assert(offsetof(UComboBoxKey, WidgetStyle) == 0x000170, "Member 'UComboBoxKey::WidgetStyle' has a wrong offset!");
static_assert(offsetof(UComboBoxKey, ItemStyle) == 0x0007D0, "Member 'UComboBoxKey::ItemStyle' has a wrong offset!");
static_assert(offsetof(UComboBoxKey, ScrollBarStyle) == 0x001520, "Member 'UComboBoxKey::ScrollBarStyle' has a wrong offset!");
static_assert(offsetof(UComboBoxKey, ForegroundColor) == 0x001C90, "Member 'UComboBoxKey::ForegroundColor' has a wrong offset!");
static_assert(offsetof(UComboBoxKey, ContentPadding) == 0x001CA4, "Member 'UComboBoxKey::ContentPadding' has a wrong offset!");
static_assert(offsetof(UComboBoxKey, MaxListHeight) == 0x001CB4, "Member 'UComboBoxKey::MaxListHeight' has a wrong offset!");
static_assert(offsetof(UComboBoxKey, bHasDownArrow) == 0x001CB8, "Member 'UComboBoxKey::bHasDownArrow' has a wrong offset!");
static_assert(offsetof(UComboBoxKey, bEnableGamepadNavigationMode) == 0x001CB9, "Member 'UComboBoxKey::bEnableGamepadNavigationMode' has a wrong offset!");
static_assert(offsetof(UComboBoxKey, bIsFocusable) == 0x001CBA, "Member 'UComboBoxKey::bIsFocusable' has a wrong offset!");
static_assert(offsetof(UComboBoxKey, OnGenerateContentWidget) == 0x001CBC, "Member 'UComboBoxKey::OnGenerateContentWidget' has a wrong offset!");
static_assert(offsetof(UComboBoxKey, OnGenerateItemWidget) == 0x001CCC, "Member 'UComboBoxKey::OnGenerateItemWidget' has a wrong offset!");
static_assert(offsetof(UComboBoxKey, OnSelectionChanged) == 0x001CE0, "Member 'UComboBoxKey::OnSelectionChanged' has a wrong offset!");
static_assert(offsetof(UComboBoxKey, OnOpening) == 0x001CF0, "Member 'UComboBoxKey::OnOpening' has a wrong offset!");

// Class UMG.ComboBoxString
// 0x1C50 (0x1DA0 - 0x0150)
class UComboBoxString final : public UWidget
{
public:
	TArray<class FString>                         DefaultOptions;                                    // 0x0150(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPrivate)
	class FString                                 SelectedOption;                                    // 0x0160(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FComboBoxStyle                         WidgetStyle;                                       // 0x0170(0x0660)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	struct FTableRowStyle                         ItemStyle;                                         // 0x07D0(0x0D50)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	struct FScrollBarStyle                        ScrollBarStyle;                                    // 0x1520(0x0770)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FMargin                                ContentPadding;                                    // 0x1C90(0x0010)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	float                                         MaxListHeight;                                     // 0x1CA0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          HasDownArrow;                                      // 0x1CA4(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          EnableGamepadNavigationMode;                       // 0x1CA5(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1CA6[0x2];                                     // 0x1CA6(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	struct FSlateFontInfo                         Font;                                              // 0x1CA8(0x0058)(Edit, BlueprintVisible, BlueprintReadOnly, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSlateColor                            ForegroundColor;                                   // 0x1D00(0x0014)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	bool                                          bIsFocusable;                                      // 0x1D14(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1D15[0x3];                                     // 0x1D15(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	TDelegate<void(const class FString& Item)>    OnGenerateWidgetEvent;                             // 0x1D18(0x0010)(Edit, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(const class FString& SelectedItem, ESelectInfo SelectionType)> OnSelectionChanged; // 0x1D28(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void()>              OnOpening;                                         // 0x1D38(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_1D48[0x58];                                    // 0x1D48(0x0058)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void AddOption(const class FString& Option)	 // 0x66cac84;
	void ClearOptions()	 // 0x12c391c;
	void ClearSelection()	 // 0x66cb5a8;
	void RefreshOptions()	 // 0x66ccb30;
	bool RemoveOption(const class FString& Option)	 // 0x66ccf28;
	void SetSelectedIndex(const int32 Index_0)	 // 0x66cf654;
	void SetSelectedOption(const class FString& Option)	 // 0x66cf834;

	int32 FindOptionIndex(const class FString& Option) const	 // 0x66cbac8;
	class FString GetOptionAtIndex(int32 Index_0) const	 // 0x66cbf34;
	int32 GetOptionCount() const	 // 0x66cc018;
	int32 GetSelectedIndex() const	 // 0x66cc130;
	class FString GetSelectedOption() const	 // 0x66cc154;
	bool IsOpen() const	 // 0x66cc8e0;

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"ComboBoxString">();
	}
	static class UComboBoxString* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UComboBoxString>();
	}
};
static_assert(alignof(UComboBoxString) == 0x000010, "Wrong alignment on UComboBoxString");
static_assert(sizeof(UComboBoxString) == 0x001DA0, "Wrong size on UComboBoxString");
static_assert(offsetof(UComboBoxString, DefaultOptions) == 0x000150, "Member 'UComboBoxString::DefaultOptions' has a wrong offset!");
static_assert(offsetof(UComboBoxString, SelectedOption) == 0x000160, "Member 'UComboBoxString::SelectedOption' has a wrong offset!");
static_assert(offsetof(UComboBoxString, WidgetStyle) == 0x000170, "Member 'UComboBoxString::WidgetStyle' has a wrong offset!");
static_assert(offsetof(UComboBoxString, ItemStyle) == 0x0007D0, "Member 'UComboBoxString::ItemStyle' has a wrong offset!");
static_assert(offsetof(UComboBoxString, ScrollBarStyle) == 0x001520, "Member 'UComboBoxString::ScrollBarStyle' has a wrong offset!");
static_assert(offsetof(UComboBoxString, ContentPadding) == 0x001C90, "Member 'UComboBoxString::ContentPadding' has a wrong offset!");
static_assert(offsetof(UComboBoxString, MaxListHeight) == 0x001CA0, "Member 'UComboBoxString::MaxListHeight' has a wrong offset!");
static_assert(offsetof(UComboBoxString, HasDownArrow) == 0x001CA4, "Member 'UComboBoxString::HasDownArrow' has a wrong offset!");
static_assert(offsetof(UComboBoxString, EnableGamepadNavigationMode) == 0x001CA5, "Member 'UComboBoxString::EnableGamepadNavigationMode' has a wrong offset!");
static_assert(offsetof(UComboBoxString, Font) == 0x001CA8, "Member 'UComboBoxString::Font' has a wrong offset!");
static_assert(offsetof(UComboBoxString, ForegroundColor) == 0x001D00, "Member 'UComboBoxString::ForegroundColor' has a wrong offset!");
static_assert(offsetof(UComboBoxString, bIsFocusable) == 0x001D14, "Member 'UComboBoxString::bIsFocusable' has a wrong offset!");
static_assert(offsetof(UComboBoxString, OnGenerateWidgetEvent) == 0x001D18, "Member 'UComboBoxString::OnGenerateWidgetEvent' has a wrong offset!");
static_assert(offsetof(UComboBoxString, OnSelectionChanged) == 0x001D28, "Member 'UComboBoxString::OnSelectionChanged' has a wrong offset!");
static_assert(offsetof(UComboBoxString, OnOpening) == 0x001D38, "Member 'UComboBoxString::OnOpening' has a wrong offset!");

// Class UMG.DynamicEntryBox
// 0x0008 (0x0238 - 0x0230)
class UDynamicEntryBox final : public UDynamicEntryBoxBase
{
public:
	TSubclassOf<class UUserWidget>                EntryWidgetClass;                                  // 0x0230(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	class UUserWidget* BP_CreateEntry()	 // 0x66cb0e8;
	class UUserWidget* BP_CreateEntryOfClass(TSubclassOf<class UUserWidget> EntryClass)	 // 0x66cb118;
	void RemoveEntry(class UUserWidget* EntryWidget)	 // 0x66ccb44;
	void Reset(bool bDeleteWidgets)	 // 0x66cd318;

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"DynamicEntryBox">();
	}
	static class UDynamicEntryBox* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UDynamicEntryBox>();
	}
};
static_assert(alignof(UDynamicEntryBox) == 0x000008, "Wrong alignment on UDynamicEntryBox");
static_assert(sizeof(UDynamicEntryBox) == 0x000238, "Wrong size on UDynamicEntryBox");
static_assert(offsetof(UDynamicEntryBox, EntryWidgetClass) == 0x000230, "Member 'UDynamicEntryBox::EntryWidgetClass' has a wrong offset!");

// Class UMG.EditableText
// 0x0390 (0x04E0 - 0x0150)
class UEditableText final : public UWidget
{
public:
	class FText                                   Text;                                              // 0x0150(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	TDelegate<void()>                             TextDelegate;                                      // 0x0168(0x0010)(ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FText                                   HintText;                                          // 0x0178(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	TDelegate<void()>                             HintTextDelegate;                                  // 0x0190(0x0010)(ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FEditableTextStyle                     WidgetStyle;                                       // 0x01A0(0x02F0)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	bool                                          IsReadOnly;                                        // 0x0490(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsPassword;                                        // 0x0491(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_492[0x2];                                      // 0x0492(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MinimumDesiredWidth;                               // 0x0494(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsCaretMovedWhenGainFocus;                         // 0x0498(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          SelectAllTextWhenFocused;                          // 0x0499(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          RevertTextOnEscape;                                // 0x049A(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ClearKeyboardFocusOnCommit;                        // 0x049B(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          SelectAllTextOnCommit;                             // 0x049C(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          AllowContextMenu;                                  // 0x049D(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EVirtualKeyboardType                          KeyboardType;                                      // 0x049E(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVirtualKeyboardOptions                VirtualKeyboardOptions;                            // 0x049F(0x0001)(Edit, NoDestructor, AdvancedDisplay, NativeAccessSpecifierPublic)
	EVirtualKeyboardTrigger                       VirtualKeyboardTrigger;                            // 0x04A0(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EVirtualKeyboardDismissAction                 VirtualKeyboardDismissAction;                      // 0x04A1(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETextJustify                                  Justification;                                     // 0x04A2(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETextOverflowPolicy                           OverflowPolicy;                                    // 0x04A3(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FShapedTextOptions                     ShapedTextOptions;                                 // 0x04A4(0x0003)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, AdvancedDisplay, NativeAccessSpecifierPublic)
	uint8                                         Pad_4A7[0x1];                                      // 0x04A7(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	TMulticastInlineDelegate<void(const class FText& Text)> OnTextChanged;                           // 0x04A8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(const class FText& Text, ETextCommit CommitMethod)> OnTextCommitted; // 0x04B8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_4C8[0x18];                                     // 0x04C8(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SetFont(const struct FSlateFontInfo& InFontInfo)	 // 0x66cdf40;
	void SetFontMaterial(class UMaterialInterface* InMaterial)	 // 0x66ce0a4;
	void SetFontOutlineMaterial(class UMaterialInterface* InMaterial)	 // 0x66ce174;
	void SetHintText(const class FText& InHintText)	 // 0x66ce244;
	void SetIsPassword(bool InbIsPassword)	 // 0x66ce7ac;
	void SetIsReadOnly(bool InbIsReadyOnly)	 // 0x66ce870;
	void SetJustification(ETextJustify InJustification)	 // 0x66ce934;
	void SetMinimumDesiredWidth(float InMinDesiredWidth)	 // 0x66ced1c;
	void SetText(const class FText& InText)	 // 0x66cf9d8;
	void SetTextOverflowPolicy(ETextOverflowPolicy InOverflowPolicy)	 // 0x66cfab4;

	const struct FSlateFontInfo GetFont() const	 // 0x66cbd30;
	class FText GetHintText() const	 // 0x66cbd4c;
	ETextJustify GetJustification() const	 // 0x66cbda0;
	class FText GetText() const	 // 0x66cc280;

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"EditableText">();
	}
	static class UEditableText* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UEditableText>();
	}
};
static_assert(alignof(UEditableText) == 0x000010, "Wrong alignment on UEditableText");
static_assert(sizeof(UEditableText) == 0x0004E0, "Wrong size on UEditableText");
static_assert(offsetof(UEditableText, Text) == 0x000150, "Member 'UEditableText::Text' has a wrong offset!");
static_assert(offsetof(UEditableText, TextDelegate) == 0x000168, "Member 'UEditableText::TextDelegate' has a wrong offset!");
static_assert(offsetof(UEditableText, HintText) == 0x000178, "Member 'UEditableText::HintText' has a wrong offset!");
static_assert(offsetof(UEditableText, HintTextDelegate) == 0x000190, "Member 'UEditableText::HintTextDelegate' has a wrong offset!");
static_assert(offsetof(UEditableText, WidgetStyle) == 0x0001A0, "Member 'UEditableText::WidgetStyle' has a wrong offset!");
static_assert(offsetof(UEditableText, IsReadOnly) == 0x000490, "Member 'UEditableText::IsReadOnly' has a wrong offset!");
static_assert(offsetof(UEditableText, IsPassword) == 0x000491, "Member 'UEditableText::IsPassword' has a wrong offset!");
static_assert(offsetof(UEditableText, MinimumDesiredWidth) == 0x000494, "Member 'UEditableText::MinimumDesiredWidth' has a wrong offset!");
static_assert(offsetof(UEditableText, IsCaretMovedWhenGainFocus) == 0x000498, "Member 'UEditableText::IsCaretMovedWhenGainFocus' has a wrong offset!");
static_assert(offsetof(UEditableText, SelectAllTextWhenFocused) == 0x000499, "Member 'UEditableText::SelectAllTextWhenFocused' has a wrong offset!");
static_assert(offsetof(UEditableText, RevertTextOnEscape) == 0x00049A, "Member 'UEditableText::RevertTextOnEscape' has a wrong offset!");
static_assert(offsetof(UEditableText, ClearKeyboardFocusOnCommit) == 0x00049B, "Member 'UEditableText::ClearKeyboardFocusOnCommit' has a wrong offset!");
static_assert(offsetof(UEditableText, SelectAllTextOnCommit) == 0x00049C, "Member 'UEditableText::SelectAllTextOnCommit' has a wrong offset!");
static_assert(offsetof(UEditableText, AllowContextMenu) == 0x00049D, "Member 'UEditableText::AllowContextMenu' has a wrong offset!");
static_assert(offsetof(UEditableText, KeyboardType) == 0x00049E, "Member 'UEditableText::KeyboardType' has a wrong offset!");
static_assert(offsetof(UEditableText, VirtualKeyboardOptions) == 0x00049F, "Member 'UEditableText::VirtualKeyboardOptions' has a wrong offset!");
static_assert(offsetof(UEditableText, VirtualKeyboardTrigger) == 0x0004A0, "Member 'UEditableText::VirtualKeyboardTrigger' has a wrong offset!");
static_assert(offsetof(UEditableText, VirtualKeyboardDismissAction) == 0x0004A1, "Member 'UEditableText::VirtualKeyboardDismissAction' has a wrong offset!");
static_assert(offsetof(UEditableText, Justification) == 0x0004A2, "Member 'UEditableText::Justification' has a wrong offset!");
static_assert(offsetof(UEditableText, OverflowPolicy) == 0x0004A3, "Member 'UEditableText::OverflowPolicy' has a wrong offset!");
static_assert(offsetof(UEditableText, ShapedTextOptions) == 0x0004A4, "Member 'UEditableText::ShapedTextOptions' has a wrong offset!");
static_assert(offsetof(UEditableText, OnTextChanged) == 0x0004A8, "Member 'UEditableText::OnTextChanged' has a wrong offset!");
static_assert(offsetof(UEditableText, OnTextCommitted) == 0x0004B8, "Member 'UEditableText::OnTextCommitted' has a wrong offset!");

// Class UMG.EditableTextBox
// 0x0F20 (0x1070 - 0x0150)
class UEditableTextBox final : public UWidget
{
public:
	class FText                                   Text;                                              // 0x0150(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	TDelegate<void()>                             TextDelegate;                                      // 0x0168(0x0010)(ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_178[0x8];                                      // 0x0178(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FEditableTextBoxStyle                  WidgetStyle;                                       // 0x0180(0x0E80)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	class FText                                   HintText;                                          // 0x1000(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	TDelegate<void()>                             HintTextDelegate;                                  // 0x1018(0x0010)(ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsReadOnly;                                        // 0x1028(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsPassword;                                        // 0x1029(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_102A[0x2];                                     // 0x102A(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MinimumDesiredWidth;                               // 0x102C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsCaretMovedWhenGainFocus;                         // 0x1030(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          SelectAllTextWhenFocused;                          // 0x1031(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          RevertTextOnEscape;                                // 0x1032(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ClearKeyboardFocusOnCommit;                        // 0x1033(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          SelectAllTextOnCommit;                             // 0x1034(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          AllowContextMenu;                                  // 0x1035(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EVirtualKeyboardType                          KeyboardType;                                      // 0x1036(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVirtualKeyboardOptions                VirtualKeyboardOptions;                            // 0x1037(0x0001)(Edit, NoDestructor, AdvancedDisplay, NativeAccessSpecifierPublic)
	EVirtualKeyboardTrigger                       VirtualKeyboardTrigger;                            // 0x1038(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EVirtualKeyboardDismissAction                 VirtualKeyboardDismissAction;                      // 0x1039(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETextJustify                                  Justification;                                     // 0x103A(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETextOverflowPolicy                           OverflowPolicy;                                    // 0x103B(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FShapedTextOptions                     ShapedTextOptions;                                 // 0x103C(0x0003)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, AdvancedDisplay, NativeAccessSpecifierPublic)
	uint8                                         Pad_103F[0x1];                                     // 0x103F(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	TMulticastInlineDelegate<void(const class FText& Text)> OnTextChanged;                           // 0x1040(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(const class FText& Text, ETextCommit CommitMethod)> OnTextCommitted; // 0x1050(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_1060[0x10];                                    // 0x1060(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ClearError()	 // 0x66f33b0;
	void SetError(const class FText& InError)	 // 0x66f8524;
	void SetForegroundColor(const struct FLinearColor& Color)	 // 0x66f8d38;
	void SetHintText(const class FText& InText)	 // 0x66f90a8;
	void SetIsPassword(bool bIsPassword)	 // 0x66f9c98;
	void SetIsReadOnly(bool bReadOnly)	 // 0x66f9d5c;
	void SetJustification(ETextJustify InJustification)	 // 0x66fa100;
	void SetText(const class FText& InText)	 // 0x178ef28;
	void SetTextOverflowPolicy(ETextOverflowPolicy InOverflowPolicy)	 // 0x66fe080;

	class FText GetText() const	 // 0x66f4424;
	bool HasError() const	 // 0x66f4910;

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"EditableTextBox">();
	}
	static class UEditableTextBox* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UEditableTextBox>();
	}
};
static_assert(alignof(UEditableTextBox) == 0x000010, "Wrong alignment on UEditableTextBox");
static_assert(sizeof(UEditableTextBox) == 0x001070, "Wrong size on UEditableTextBox");
static_assert(offsetof(UEditableTextBox, Text) == 0x000150, "Member 'UEditableTextBox::Text' has a wrong offset!");
static_assert(offsetof(UEditableTextBox, TextDelegate) == 0x000168, "Member 'UEditableTextBox::TextDelegate' has a wrong offset!");
static_assert(offsetof(UEditableTextBox, WidgetStyle) == 0x000180, "Member 'UEditableTextBox::WidgetStyle' has a wrong offset!");
static_assert(offsetof(UEditableTextBox, HintText) == 0x001000, "Member 'UEditableTextBox::HintText' has a wrong offset!");
static_assert(offsetof(UEditableTextBox, HintTextDelegate) == 0x001018, "Member 'UEditableTextBox::HintTextDelegate' has a wrong offset!");
static_assert(offsetof(UEditableTextBox, IsReadOnly) == 0x001028, "Member 'UEditableTextBox::IsReadOnly' has a wrong offset!");
static_assert(offsetof(UEditableTextBox, IsPassword) == 0x001029, "Member 'UEditableTextBox::IsPassword' has a wrong offset!");
static_assert(offsetof(UEditableTextBox, MinimumDesiredWidth) == 0x00102C, "Member 'UEditableTextBox::MinimumDesiredWidth' has a wrong offset!");
static_assert(offsetof(UEditableTextBox, IsCaretMovedWhenGainFocus) == 0x001030, "Member 'UEditableTextBox::IsCaretMovedWhenGainFocus' has a wrong offset!");
static_assert(offsetof(UEditableTextBox, SelectAllTextWhenFocused) == 0x001031, "Member 'UEditableTextBox::SelectAllTextWhenFocused' has a wrong offset!");
static_assert(offsetof(UEditableTextBox, RevertTextOnEscape) == 0x001032, "Member 'UEditableTextBox::RevertTextOnEscape' has a wrong offset!");
static_assert(offsetof(UEditableTextBox, ClearKeyboardFocusOnCommit) == 0x001033, "Member 'UEditableTextBox::ClearKeyboardFocusOnCommit' has a wrong offset!");
static_assert(offsetof(UEditableTextBox, SelectAllTextOnCommit) == 0x001034, "Member 'UEditableTextBox::SelectAllTextOnCommit' has a wrong offset!");
static_assert(offsetof(UEditableTextBox, AllowContextMenu) == 0x001035, "Member 'UEditableTextBox::AllowContextMenu' has a wrong offset!");
static_assert(offsetof(UEditableTextBox, KeyboardType) == 0x001036, "Member 'UEditableTextBox::KeyboardType' has a wrong offset!");
static_assert(offsetof(UEditableTextBox, VirtualKeyboardOptions) == 0x001037, "Member 'UEditableTextBox::VirtualKeyboardOptions' has a wrong offset!");
static_assert(offsetof(UEditableTextBox, VirtualKeyboardTrigger) == 0x001038, "Member 'UEditableTextBox::VirtualKeyboardTrigger' has a wrong offset!");
static_assert(offsetof(UEditableTextBox, VirtualKeyboardDismissAction) == 0x001039, "Member 'UEditableTextBox::VirtualKeyboardDismissAction' has a wrong offset!");
static_assert(offsetof(UEditableTextBox, Justification) == 0x00103A, "Member 'UEditableTextBox::Justification' has a wrong offset!");
static_assert(offsetof(UEditableTextBox, OverflowPolicy) == 0x00103B, "Member 'UEditableTextBox::OverflowPolicy' has a wrong offset!");
static_assert(offsetof(UEditableTextBox, ShapedTextOptions) == 0x00103C, "Member 'UEditableTextBox::ShapedTextOptions' has a wrong offset!");
static_assert(offsetof(UEditableTextBox, OnTextChanged) == 0x001040, "Member 'UEditableTextBox::OnTextChanged' has a wrong offset!");
static_assert(offsetof(UEditableTextBox, OnTextCommitted) == 0x001050, "Member 'UEditableTextBox::OnTextCommitted' has a wrong offset!");

// Class UMG.ExpandableArea
// 0x0310 (0x0460 - 0x0150)
class UExpandableArea final : public UWidget
{
public:
	uint8                                         Pad_150[0x10];                                     // 0x0150(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	struct FExpandableAreaStyle                   Style;                                             // 0x0160(0x01C0)(Edit, NativeAccessSpecifierPublic)
	struct FSlateBrush                            BorderBrush;                                       // 0x0320(0x00D0)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	struct FSlateColor                            BorderColor;                                       // 0x03F0(0x0014)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	bool                                          bIsExpanded;                                       // 0x0404(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_405[0x3];                                      // 0x0405(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MaxHeight;                                         // 0x0408(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FMargin                                HeaderPadding;                                     // 0x040C(0x0010)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FMargin                                AreaPadding;                                       // 0x041C(0x0010)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_42C[0x4];                                      // 0x042C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TMulticastInlineDelegate<void(class UExpandableArea* Area, bool bIsExpanded)> OnExpansionChanged; // 0x0430(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	class UWidget*                                HeaderContent;                                     // 0x0440(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidget*                                BodyContent;                                       // 0x0448(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_450[0x10];                                     // 0x0450(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SetIsExpanded(bool IsExpanded)	 // 0x66f9a04;
	void SetIsExpanded_Animated(bool IsExpanded)	 // 0x66f9ac8;

	bool GetIsExpanded() const	 // 0x66f400c;

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"ExpandableArea">();
	}
	static class UExpandableArea* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UExpandableArea>();
	}
};
static_assert(alignof(UExpandableArea) == 0x000010, "Wrong alignment on UExpandableArea");
static_assert(sizeof(UExpandableArea) == 0x000460, "Wrong size on UExpandableArea");
static_assert(offsetof(UExpandableArea, Style) == 0x000160, "Member 'UExpandableArea::Style' has a wrong offset!");
static_assert(offsetof(UExpandableArea, BorderBrush) == 0x000320, "Member 'UExpandableArea::BorderBrush' has a wrong offset!");
static_assert(offsetof(UExpandableArea, BorderColor) == 0x0003F0, "Member 'UExpandableArea::BorderColor' has a wrong offset!");
static_assert(offsetof(UExpandableArea, bIsExpanded) == 0x000404, "Member 'UExpandableArea::bIsExpanded' has a wrong offset!");
static_assert(offsetof(UExpandableArea, MaxHeight) == 0x000408, "Member 'UExpandableArea::MaxHeight' has a wrong offset!");
static_assert(offsetof(UExpandableArea, HeaderPadding) == 0x00040C, "Member 'UExpandableArea::HeaderPadding' has a wrong offset!");
static_assert(offsetof(UExpandableArea, AreaPadding) == 0x00041C, "Member 'UExpandableArea::AreaPadding' has a wrong offset!");
static_assert(offsetof(UExpandableArea, OnExpansionChanged) == 0x000430, "Member 'UExpandableArea::OnExpansionChanged' has a wrong offset!");
static_assert(offsetof(UExpandableArea, HeaderContent) == 0x000440, "Member 'UExpandableArea::HeaderContent' has a wrong offset!");
static_assert(offsetof(UExpandableArea, BodyContent) == 0x000448, "Member 'UExpandableArea::BodyContent' has a wrong offset!");

// Class UMG.GridPanel
// 0x0030 (0x0198 - 0x0168)
class UGridPanel final : public UPanelWidget
{
public:
	TArray<float>                                 ColumnFill;                                        // 0x0168(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<float>                                 RowFill;                                           // 0x0178(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_188[0x10];                                     // 0x0188(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	class UGridSlot* AddChildToGrid(class UWidget* Content, int32 InRow, int32 InColumn)	 // 0x66f2390;
	void SetColumnFill(int32 columnIndex, float Coefficient)	 // 0x66f7430;
	void SetRowFill(int32 rowIndex, float Coefficient)	 // 0x66fca64;

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"GridPanel">();
	}
	static class UGridPanel* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UGridPanel>();
	}
};
static_assert(alignof(UGridPanel) == 0x000008, "Wrong alignment on UGridPanel");
static_assert(sizeof(UGridPanel) == 0x000198, "Wrong size on UGridPanel");
static_assert(offsetof(UGridPanel, ColumnFill) == 0x000168, "Member 'UGridPanel::ColumnFill' has a wrong offset!");
static_assert(offsetof(UGridPanel, RowFill) == 0x000178, "Member 'UGridPanel::RowFill' has a wrong offset!");

// Class UMG.GridSlot
// 0x0040 (0x0078 - 0x0038)
class UGridSlot final : public UPanelSlot
{
public:
	struct FMargin                                Padding;                                           // 0x0038(0x0010)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	EHorizontalAlignment                          HorizontalAlignment;                               // 0x0048(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EVerticalAlignment                            VerticalAlignment;                                 // 0x0049(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4A[0x2];                                       // 0x004A(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         Row;                                               // 0x004C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         RowSpan;                                           // 0x0050(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Column;                                            // 0x0054(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ColumnSpan;                                        // 0x0058(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Layer;                                             // 0x005C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              Nudge;                                             // 0x0060(0x0010)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_70[0x8];                                       // 0x0070(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SetColumn(int32 InColumn)	 // 0x66f72b0;
	void SetColumnSpan(int32 InColumnSpan)	 // 0x66f756c;
	void SetHorizontalAlignment(EHorizontalAlignment InHorizontalAlignment)	 // 0x66f933c;
	void SetLayer(int32 InLayer)	 // 0x66fa374;
	void SetNudge(const struct FVector2D& InNudge)	 // 0x66fbc20;
	void SetPadding(const struct FMargin& InPadding)	 // 0x66fbffc;
	void SetRow(int32 InRow)	 // 0x66fc8e4;
	void SetRowSpan(int32 InRowSpan)	 // 0x66fcba0;
	void SetVerticalAlignment(EVerticalAlignment InVerticalAlignment)	 // 0x66fed8c;

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"GridSlot">();
	}
	static class UGridSlot* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UGridSlot>();
	}
};
static_assert(alignof(UGridSlot) == 0x000008, "Wrong alignment on UGridSlot");
static_assert(sizeof(UGridSlot) == 0x000078, "Wrong size on UGridSlot");
static_assert(offsetof(UGridSlot, Padding) == 0x000038, "Member 'UGridSlot::Padding' has a wrong offset!");
static_assert(offsetof(UGridSlot, HorizontalAlignment) == 0x000048, "Member 'UGridSlot::HorizontalAlignment' has a wrong offset!");
static_assert(offsetof(UGridSlot, VerticalAlignment) == 0x000049, "Member 'UGridSlot::VerticalAlignment' has a wrong offset!");
static_assert(offsetof(UGridSlot, Row) == 0x00004C, "Member 'UGridSlot::Row' has a wrong offset!");
static_assert(offsetof(UGridSlot, RowSpan) == 0x000050, "Member 'UGridSlot::RowSpan' has a wrong offset!");
static_assert(offsetof(UGridSlot, Column) == 0x000054, "Member 'UGridSlot::Column' has a wrong offset!");
static_assert(offsetof(UGridSlot, ColumnSpan) == 0x000058, "Member 'UGridSlot::ColumnSpan' has a wrong offset!");
static_assert(offsetof(UGridSlot, Layer) == 0x00005C, "Member 'UGridSlot::Layer' has a wrong offset!");
static_assert(offsetof(UGridSlot, Nudge) == 0x000060, "Member 'UGridSlot::Nudge' has a wrong offset!");

// Class UMG.HorizontalBox
// 0x0010 (0x0178 - 0x0168)
class UHorizontalBox final : public UPanelWidget
{
public:
	uint8                                         Pad_168[0x10];                                     // 0x0168(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	class UHorizontalBoxSlot* AddChildToHorizontalBox(class UWidget* Content)	 // 0x66f254c;

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"HorizontalBox">();
	}
	static class UHorizontalBox* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UHorizontalBox>();
	}
};
static_assert(alignof(UHorizontalBox) == 0x000008, "Wrong alignment on UHorizontalBox");
static_assert(sizeof(UHorizontalBox) == 0x000178, "Wrong size on UHorizontalBox");

// Class UMG.HorizontalBoxSlot
// 0x0028 (0x0060 - 0x0038)
class UHorizontalBoxSlot final : public UPanelSlot
{
public:
	uint8                                         Pad_38[0x8];                                       // 0x0038(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FSlateChildSize                        Size;                                              // 0x0040(0x0008)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	struct FMargin                                Padding;                                           // 0x0048(0x0010)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	EHorizontalAlignment                          HorizontalAlignment;                               // 0x0058(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EVerticalAlignment                            VerticalAlignment;                                 // 0x0059(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5A[0x6];                                       // 0x005A(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SetHorizontalAlignment(EHorizontalAlignment InHorizontalAlignment)	 // 0x66f93fc;
	void SetPadding(const struct FMargin& InPadding)	 // 0xb19dec;
	void SetSize(const struct FSlateChildSize& InSize)	 // 0x66fd660;
	void SetVerticalAlignment(EVerticalAlignment InVerticalAlignment)	 // 0x66fee4c;

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"HorizontalBoxSlot">();
	}
	static class UHorizontalBoxSlot* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UHorizontalBoxSlot>();
	}
};
static_assert(alignof(UHorizontalBoxSlot) == 0x000008, "Wrong alignment on UHorizontalBoxSlot");
static_assert(sizeof(UHorizontalBoxSlot) == 0x000060, "Wrong size on UHorizontalBoxSlot");
static_assert(offsetof(UHorizontalBoxSlot, Size) == 0x000040, "Member 'UHorizontalBoxSlot::Size' has a wrong offset!");
static_assert(offsetof(UHorizontalBoxSlot, Padding) == 0x000048, "Member 'UHorizontalBoxSlot::Padding' has a wrong offset!");
static_assert(offsetof(UHorizontalBoxSlot, HorizontalAlignment) == 0x000058, "Member 'UHorizontalBoxSlot::HorizontalAlignment' has a wrong offset!");
static_assert(offsetof(UHorizontalBoxSlot, VerticalAlignment) == 0x000059, "Member 'UHorizontalBoxSlot::VerticalAlignment' has a wrong offset!");

// Class UMG.InputKeySelector
// 0x07E0 (0x0930 - 0x0150)
class UInputKeySelector final : public UWidget
{
public:
	struct FButtonStyle                           WidgetStyle;                                       // 0x0150(0x03F0)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	struct FTextBlockStyle                        TextStyle;                                         // 0x0540(0x0340)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	struct FInputChord                            SelectedKey;                                       // 0x0880(0x0020)(BlueprintVisible, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FMargin                                Margin;                                            // 0x08A0(0x0010)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	class FText                                   KeySelectionText;                                  // 0x08B0(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	class FText                                   NoKeySpecifiedText;                                // 0x08C8(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	bool                                          bAllowModifierKeys;                                // 0x08E0(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAllowGamepadKeys;                                 // 0x08E1(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_8E2[0x6];                                      // 0x08E2(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FKey>                           EscapeKeys;                                        // 0x08E8(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(const struct FInputChord& SelectedKey)> OnKeySelected;             // 0x08F8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void()>              OnIsSelectingKeyChanged;                           // 0x0908(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_918[0x18];                                     // 0x0918(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SetAllowGamepadKeys(bool bInAllowGamepadKeys)	 // 0x66f6264;
	void SetAllowModifierKeys(bool bInAllowModifierKeys)	 // 0x66f6328;
	void SetEscapeKeys(const TArray<struct FKey>& InKeys)	 // 0x66f86f4;
	void SetKeySelectionText(const class FText& InKeySelectionText)	 // 0x66fa284;
	void SetNoKeySpecifiedText(const class FText& InNoKeySpecifiedText)	 // 0x66fbb44;
	void SetSelectedKey(const struct FInputChord& InSelectedKey)	 // 0x66fd250;
	void SetTextBlockVisibility(const ESlateVisibility InVisibility)	 // 0x66fdf8c;

	bool GetIsSelectingKey() const	 // 0x66f4024;

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"InputKeySelector">();
	}
	static class UInputKeySelector* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UInputKeySelector>();
	}
};
static_assert(alignof(UInputKeySelector) == 0x000010, "Wrong alignment on UInputKeySelector");
static_assert(sizeof(UInputKeySelector) == 0x000930, "Wrong size on UInputKeySelector");
static_assert(offsetof(UInputKeySelector, WidgetStyle) == 0x000150, "Member 'UInputKeySelector::WidgetStyle' has a wrong offset!");
static_assert(offsetof(UInputKeySelector, TextStyle) == 0x000540, "Member 'UInputKeySelector::TextStyle' has a wrong offset!");
static_assert(offsetof(UInputKeySelector, SelectedKey) == 0x000880, "Member 'UInputKeySelector::SelectedKey' has a wrong offset!");
static_assert(offsetof(UInputKeySelector, Margin) == 0x0008A0, "Member 'UInputKeySelector::Margin' has a wrong offset!");
static_assert(offsetof(UInputKeySelector, KeySelectionText) == 0x0008B0, "Member 'UInputKeySelector::KeySelectionText' has a wrong offset!");
static_assert(offsetof(UInputKeySelector, NoKeySpecifiedText) == 0x0008C8, "Member 'UInputKeySelector::NoKeySpecifiedText' has a wrong offset!");
static_assert(offsetof(UInputKeySelector, bAllowModifierKeys) == 0x0008E0, "Member 'UInputKeySelector::bAllowModifierKeys' has a wrong offset!");
static_assert(offsetof(UInputKeySelector, bAllowGamepadKeys) == 0x0008E1, "Member 'UInputKeySelector::bAllowGamepadKeys' has a wrong offset!");
static_assert(offsetof(UInputKeySelector, EscapeKeys) == 0x0008E8, "Member 'UInputKeySelector::EscapeKeys' has a wrong offset!");
static_assert(offsetof(UInputKeySelector, OnKeySelected) == 0x0008F8, "Member 'UInputKeySelector::OnKeySelected' has a wrong offset!");
static_assert(offsetof(UInputKeySelector, OnIsSelectingKeyChanged) == 0x000908, "Member 'UInputKeySelector::OnIsSelectingKeyChanged' has a wrong offset!");

// Class UMG.InvalidationBox
// 0x0018 (0x0180 - 0x0168)
class UInvalidationBox final : public UContentWidget
{
public:
	bool                                          bCanCache;                                         // 0x0168(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_169[0x17];                                     // 0x0169(0x0017)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void InvalidateCache()	 // 0x17c7f2c;
	void SetCanCache(bool CanCache)	 // 0x66f712c;

	bool GetCanCache() const	 // 0x66f39b4;

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"InvalidationBox">();
	}
	static class UInvalidationBox* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UInvalidationBox>();
	}
};
static_assert(alignof(UInvalidationBox) == 0x000008, "Wrong alignment on UInvalidationBox");
static_assert(sizeof(UInvalidationBox) == 0x000180, "Wrong size on UInvalidationBox");
static_assert(offsetof(UInvalidationBox, bCanCache) == 0x000168, "Member 'UInvalidationBox::bCanCache' has a wrong offset!");

// Class UMG.MenuAnchor
// 0x0050 (0x01B8 - 0x0168)
class UMenuAnchor final : public UContentWidget
{
public:
	TSubclassOf<class UUserWidget>                MenuClass;                                         // 0x0168(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TDelegate<void()>                             OnGetMenuContentEvent;                             // 0x0170(0x0010)(Edit, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TDelegate<void()>                             OnGetUserMenuContentEvent;                         // 0x0180(0x0010)(Edit, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EMenuPlacement                                Placement;                                         // 0x0190(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bFitInWindow;                                      // 0x0191(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ShouldDeferPaintingAfterWindowContent;             // 0x0192(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          UseApplicationMenuStack;                           // 0x0193(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_194[0x4];                                      // 0x0194(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TMulticastInlineDelegate<void(bool bIsOpen)>  OnMenuOpenChanged;                                 // 0x0198(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_1A8[0x10];                                     // 0x01A8(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Close()	 // 0x66f34ec;
	void FitInWindow(bool bFit)	 // 0x66f3624;
	void Open(bool bFocusMenu)	 // 0x66f56a8;
	void SetPlacement(EMenuPlacement InPlacement)	 // 0x66fc3a4;
	void ToggleOpen(bool bFocusOnOpen)	 // 0x66ffadc;

	struct FVector2D GetMenuPosition() const	 // 0x66f41b8;
	bool HasOpenSubMenus() const	 // 0x66f4b9c;
	bool IsOpen() const	 // 0x66f4ea0;
	bool ShouldOpenDueToClick() const	 // 0x66ff9d8;

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"MenuAnchor">();
	}
	static class UMenuAnchor* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UMenuAnchor>();
	}
};
static_assert(alignof(UMenuAnchor) == 0x000008, "Wrong alignment on UMenuAnchor");
static_assert(sizeof(UMenuAnchor) == 0x0001B8, "Wrong size on UMenuAnchor");
static_assert(offsetof(UMenuAnchor, MenuClass) == 0x000168, "Member 'UMenuAnchor::MenuClass' has a wrong offset!");
static_assert(offsetof(UMenuAnchor, OnGetMenuContentEvent) == 0x000170, "Member 'UMenuAnchor::OnGetMenuContentEvent' has a wrong offset!");
static_assert(offsetof(UMenuAnchor, OnGetUserMenuContentEvent) == 0x000180, "Member 'UMenuAnchor::OnGetUserMenuContentEvent' has a wrong offset!");
static_assert(offsetof(UMenuAnchor, Placement) == 0x000190, "Member 'UMenuAnchor::Placement' has a wrong offset!");
static_assert(offsetof(UMenuAnchor, bFitInWindow) == 0x000191, "Member 'UMenuAnchor::bFitInWindow' has a wrong offset!");
static_assert(offsetof(UMenuAnchor, ShouldDeferPaintingAfterWindowContent) == 0x000192, "Member 'UMenuAnchor::ShouldDeferPaintingAfterWindowContent' has a wrong offset!");
static_assert(offsetof(UMenuAnchor, UseApplicationMenuStack) == 0x000193, "Member 'UMenuAnchor::UseApplicationMenuStack' has a wrong offset!");
static_assert(offsetof(UMenuAnchor, OnMenuOpenChanged) == 0x000198, "Member 'UMenuAnchor::OnMenuOpenChanged' has a wrong offset!");

// Class UMG.MultiLineEditableText
// 0x03C0 (0x0530 - 0x0170)
class UMultiLineEditableText final : public UTextLayoutWidget
{
public:
	class FText                                   Text;                                              // 0x0170(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	class FText                                   HintText;                                          // 0x0188(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	TDelegate<void()>                             HintTextDelegate;                                  // 0x01A0(0x0010)(ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FTextBlockStyle                        WidgetStyle;                                       // 0x01B0(0x0340)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	bool                                          bIsReadOnly;                                       // 0x04F0(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          SelectAllTextWhenFocused;                          // 0x04F1(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ClearTextSelectionOnFocusLoss;                     // 0x04F2(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          RevertTextOnEscape;                                // 0x04F3(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ClearKeyboardFocusOnCommit;                        // 0x04F4(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          AllowContextMenu;                                  // 0x04F5(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVirtualKeyboardOptions                VirtualKeyboardOptions;                            // 0x04F6(0x0001)(Edit, NoDestructor, AdvancedDisplay, NativeAccessSpecifierPublic)
	EVirtualKeyboardDismissAction                 VirtualKeyboardDismissAction;                      // 0x04F7(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(const class FText& Text)> OnTextChanged;                           // 0x04F8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(const class FText& Text, ETextCommit CommitMethod)> OnTextCommitted; // 0x0508(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_518[0x18];                                     // 0x0518(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SetFont(const struct FSlateFontInfo& InFontInfo)	 // 0x66f885c;
	void SetFontMaterial(class UMaterialInterface* InMaterial)	 // 0x66f89c0;
	void SetFontOutlineMaterial(class UMaterialInterface* InMaterial)	 // 0x66f8b7c;
	void SetHintText(const class FText& InHintText)	 // 0x66f9184;
	void SetIsReadOnly(bool bReadOnly)	 // 0x66f9e20;
	void SetText(const class FText& InText)	 // 0x1869274;
	void SetWidgetStyle(const struct FTextBlockStyle& InWidgetStyle)	 // 0x66ff794;

	const struct FSlateFontInfo GetFont() const	 // 0x66f3dec;
	class FText GetHintText() const	 // 0x66f3e44;
	class FText GetText() const	 // 0x66f4478;

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"MultiLineEditableText">();
	}
	static class UMultiLineEditableText* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UMultiLineEditableText>();
	}
};
static_assert(alignof(UMultiLineEditableText) == 0x000010, "Wrong alignment on UMultiLineEditableText");
static_assert(sizeof(UMultiLineEditableText) == 0x000530, "Wrong size on UMultiLineEditableText");
static_assert(offsetof(UMultiLineEditableText, Text) == 0x000170, "Member 'UMultiLineEditableText::Text' has a wrong offset!");
static_assert(offsetof(UMultiLineEditableText, HintText) == 0x000188, "Member 'UMultiLineEditableText::HintText' has a wrong offset!");
static_assert(offsetof(UMultiLineEditableText, HintTextDelegate) == 0x0001A0, "Member 'UMultiLineEditableText::HintTextDelegate' has a wrong offset!");
static_assert(offsetof(UMultiLineEditableText, WidgetStyle) == 0x0001B0, "Member 'UMultiLineEditableText::WidgetStyle' has a wrong offset!");
static_assert(offsetof(UMultiLineEditableText, bIsReadOnly) == 0x0004F0, "Member 'UMultiLineEditableText::bIsReadOnly' has a wrong offset!");
static_assert(offsetof(UMultiLineEditableText, SelectAllTextWhenFocused) == 0x0004F1, "Member 'UMultiLineEditableText::SelectAllTextWhenFocused' has a wrong offset!");
static_assert(offsetof(UMultiLineEditableText, ClearTextSelectionOnFocusLoss) == 0x0004F2, "Member 'UMultiLineEditableText::ClearTextSelectionOnFocusLoss' has a wrong offset!");
static_assert(offsetof(UMultiLineEditableText, RevertTextOnEscape) == 0x0004F3, "Member 'UMultiLineEditableText::RevertTextOnEscape' has a wrong offset!");
static_assert(offsetof(UMultiLineEditableText, ClearKeyboardFocusOnCommit) == 0x0004F4, "Member 'UMultiLineEditableText::ClearKeyboardFocusOnCommit' has a wrong offset!");
static_assert(offsetof(UMultiLineEditableText, AllowContextMenu) == 0x0004F5, "Member 'UMultiLineEditableText::AllowContextMenu' has a wrong offset!");
static_assert(offsetof(UMultiLineEditableText, VirtualKeyboardOptions) == 0x0004F6, "Member 'UMultiLineEditableText::VirtualKeyboardOptions' has a wrong offset!");
static_assert(offsetof(UMultiLineEditableText, VirtualKeyboardDismissAction) == 0x0004F7, "Member 'UMultiLineEditableText::VirtualKeyboardDismissAction' has a wrong offset!");
static_assert(offsetof(UMultiLineEditableText, OnTextChanged) == 0x0004F8, "Member 'UMultiLineEditableText::OnTextChanged' has a wrong offset!");
static_assert(offsetof(UMultiLineEditableText, OnTextCommitted) == 0x000508, "Member 'UMultiLineEditableText::OnTextCommitted' has a wrong offset!");

// Class UMG.MultiLineEditableTextBox
// 0x0F00 (0x1070 - 0x0170)
class UMultiLineEditableTextBox final : public UTextLayoutWidget
{
public:
	class FText                                   Text;                                              // 0x0170(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	class FText                                   HintText;                                          // 0x0188(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	TDelegate<void()>                             HintTextDelegate;                                  // 0x01A0(0x0010)(ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FEditableTextBoxStyle                  WidgetStyle;                                       // 0x01B0(0x0E80)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	bool                                          bIsReadOnly;                                       // 0x1030(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          AllowContextMenu;                                  // 0x1031(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVirtualKeyboardOptions                VirtualKeyboardOptions;                            // 0x1032(0x0001)(Edit, NoDestructor, AdvancedDisplay, NativeAccessSpecifierPublic)
	EVirtualKeyboardDismissAction                 VirtualKeyboardDismissAction;                      // 0x1033(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1034[0x4];                                     // 0x1034(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TMulticastInlineDelegate<void(const class FText& Text)> OnTextChanged;                           // 0x1038(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(const class FText& Text, ETextCommit CommitMethod)> OnTextCommitted; // 0x1048(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_1058[0x18];                                    // 0x1058(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SetError(const class FText& InError)	 // 0x66f860c;
	void SetForegroundColor(const struct FLinearColor& Color)	 // 0x66f8e2c;
	void SetHintText(const class FText& InHintText)	 // 0x66f9260;
	void SetIsReadOnly(bool bReadOnly)	 // 0x66f9ee4;
	void SetText(const class FText& InText)	 // 0x66fdeb0;
	void SetTextStyle(const struct FTextBlockStyle& InTextStyle)	 // 0x66fe2cc;

	class FText GetHintText() const	 // 0x66f3e98;
	class FText GetText() const	 // 0x66f44cc;

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"MultiLineEditableTextBox">();
	}
	static class UMultiLineEditableTextBox* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UMultiLineEditableTextBox>();
	}
};
static_assert(alignof(UMultiLineEditableTextBox) == 0x000010, "Wrong alignment on UMultiLineEditableTextBox");
static_assert(sizeof(UMultiLineEditableTextBox) == 0x001070, "Wrong size on UMultiLineEditableTextBox");
static_assert(offsetof(UMultiLineEditableTextBox, Text) == 0x000170, "Member 'UMultiLineEditableTextBox::Text' has a wrong offset!");
static_assert(offsetof(UMultiLineEditableTextBox, HintText) == 0x000188, "Member 'UMultiLineEditableTextBox::HintText' has a wrong offset!");
static_assert(offsetof(UMultiLineEditableTextBox, HintTextDelegate) == 0x0001A0, "Member 'UMultiLineEditableTextBox::HintTextDelegate' has a wrong offset!");
static_assert(offsetof(UMultiLineEditableTextBox, WidgetStyle) == 0x0001B0, "Member 'UMultiLineEditableTextBox::WidgetStyle' has a wrong offset!");
static_assert(offsetof(UMultiLineEditableTextBox, bIsReadOnly) == 0x001030, "Member 'UMultiLineEditableTextBox::bIsReadOnly' has a wrong offset!");
static_assert(offsetof(UMultiLineEditableTextBox, AllowContextMenu) == 0x001031, "Member 'UMultiLineEditableTextBox::AllowContextMenu' has a wrong offset!");
static_assert(offsetof(UMultiLineEditableTextBox, VirtualKeyboardOptions) == 0x001032, "Member 'UMultiLineEditableTextBox::VirtualKeyboardOptions' has a wrong offset!");
static_assert(offsetof(UMultiLineEditableTextBox, VirtualKeyboardDismissAction) == 0x001033, "Member 'UMultiLineEditableTextBox::VirtualKeyboardDismissAction' has a wrong offset!");
static_assert(offsetof(UMultiLineEditableTextBox, OnTextChanged) == 0x001038, "Member 'UMultiLineEditableTextBox::OnTextChanged' has a wrong offset!");
static_assert(offsetof(UMultiLineEditableTextBox, OnTextCommitted) == 0x001048, "Member 'UMultiLineEditableTextBox::OnTextCommitted' has a wrong offset!");

// Class UMG.NamedSlot
// 0x0010 (0x0178 - 0x0168)
class UNamedSlot final : public UContentWidget
{
public:
	uint8                                         Pad_168[0x10];                                     // 0x0168(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"NamedSlot">();
	}
	static class UNamedSlot* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UNamedSlot>();
	}
};
static_assert(alignof(UNamedSlot) == 0x000008, "Wrong alignment on UNamedSlot");
static_assert(sizeof(UNamedSlot) == 0x000178, "Wrong size on UNamedSlot");

// Class UMG.NamedSlotInterface
// 0x0000 (0x0000 - 0x0000)
class INamedSlotInterface final
{
public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"NamedSlotInterface">();
	}
	static class INamedSlotInterface* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<INamedSlotInterface>();
	}

	class UObject* AsUObject()	 // 0x0
	{
		return reinterpret_cast<UObject*>(this);
	}
	const class UObject* AsUObject() const	 // 0x0
	{
		return reinterpret_cast<const UObject*>(this);
	}
};
static_assert(alignof(INamedSlotInterface) == 0x000001, "Wrong alignment on INamedSlotInterface");
static_assert(sizeof(INamedSlotInterface) == 0x000001, "Wrong size on INamedSlotInterface");

// Class UMG.ProgressBar
// 0x02F0 (0x0440 - 0x0150)
class UProgressBar final : public UWidget
{
public:
	struct FProgressBarStyle                      WidgetStyle;                                       // 0x0150(0x0290)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	float                                         Percent;                                           // 0x03E0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EProgressBarFillType                          BarFillType;                                       // 0x03E4(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EProgressBarFillStyle                         BarFillStyle;                                      // 0x03E5(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsMarquee;                                        // 0x03E6(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3E7[0x1];                                      // 0x03E7(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector2D                              BorderPadding;                                     // 0x03E8(0x0010)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TDelegate<void()>                             PercentDelegate;                                   // 0x03F8(0x0010)(ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           FillColorAndOpacity;                               // 0x0408(0x0010)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TDelegate<void()>                             FillColorAndOpacityDelegate;                       // 0x0418(0x0010)(ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_428[0x18];                                     // 0x0428(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SetFillColorAndOpacity(const struct FLinearColor& InColor)	 // 0x1228138;
	void SetIsMarquee(bool InbIsMarquee)	 // 0x66f9bd4;
	void SetPercent(float InPercent)	 // 0x1691abc;

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"ProgressBar">();
	}
	static class UProgressBar* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UProgressBar>();
	}
};
static_assert(alignof(UProgressBar) == 0x000010, "Wrong alignment on UProgressBar");
static_assert(sizeof(UProgressBar) == 0x000440, "Wrong size on UProgressBar");
static_assert(offsetof(UProgressBar, WidgetStyle) == 0x000150, "Member 'UProgressBar::WidgetStyle' has a wrong offset!");
static_assert(offsetof(UProgressBar, Percent) == 0x0003E0, "Member 'UProgressBar::Percent' has a wrong offset!");
static_assert(offsetof(UProgressBar, BarFillType) == 0x0003E4, "Member 'UProgressBar::BarFillType' has a wrong offset!");
static_assert(offsetof(UProgressBar, BarFillStyle) == 0x0003E5, "Member 'UProgressBar::BarFillStyle' has a wrong offset!");
static_assert(offsetof(UProgressBar, bIsMarquee) == 0x0003E6, "Member 'UProgressBar::bIsMarquee' has a wrong offset!");
static_assert(offsetof(UProgressBar, BorderPadding) == 0x0003E8, "Member 'UProgressBar::BorderPadding' has a wrong offset!");
static_assert(offsetof(UProgressBar, PercentDelegate) == 0x0003F8, "Member 'UProgressBar::PercentDelegate' has a wrong offset!");
static_assert(offsetof(UProgressBar, FillColorAndOpacity) == 0x000408, "Member 'UProgressBar::FillColorAndOpacity' has a wrong offset!");
static_assert(offsetof(UProgressBar, FillColorAndOpacityDelegate) == 0x000418, "Member 'UProgressBar::FillColorAndOpacityDelegate' has a wrong offset!");

// Class UMG.RichTextBlockDecorator
// 0x0000 (0x0028 - 0x0028)
class URichTextBlockDecorator : public UObject
{
public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"RichTextBlockDecorator">();
	}
	static class URichTextBlockDecorator* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<URichTextBlockDecorator>();
	}
};
static_assert(alignof(URichTextBlockDecorator) == 0x000008, "Wrong alignment on URichTextBlockDecorator");
static_assert(sizeof(URichTextBlockDecorator) == 0x000028, "Wrong size on URichTextBlockDecorator");

// Class UMG.RichTextBlockImageDecorator
// 0x0008 (0x0030 - 0x0028)
class URichTextBlockImageDecorator : public URichTextBlockDecorator
{
public:
	class UDataTable*                             ImageSet;                                          // 0x0028(0x0008)(Edit, ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"RichTextBlockImageDecorator">();
	}
	static class URichTextBlockImageDecorator* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<URichTextBlockImageDecorator>();
	}
};
static_assert(alignof(URichTextBlockImageDecorator) == 0x000008, "Wrong alignment on URichTextBlockImageDecorator");
static_assert(sizeof(URichTextBlockImageDecorator) == 0x000030, "Wrong size on URichTextBlockImageDecorator");
static_assert(offsetof(URichTextBlockImageDecorator, ImageSet) == 0x000028, "Member 'URichTextBlockImageDecorator::ImageSet' has a wrong offset!");

// Class UMG.SafeZone
// 0x0018 (0x0180 - 0x0168)
class USafeZone final : public UContentWidget
{
public:
	bool                                          PadLeft;                                           // 0x0168(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          PadRight;                                          // 0x0169(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          PadTop;                                            // 0x016A(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          PadBottom;                                         // 0x016B(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_16C[0x14];                                     // 0x016C(0x0014)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SetSidesToPad(bool InPadLeft, bool InPadRight, bool InPadTop, bool InPadBottom)	 // 0x66fd40c;

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"SafeZone">();
	}
	static class USafeZone* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<USafeZone>();
	}
};
static_assert(alignof(USafeZone) == 0x000008, "Wrong alignment on USafeZone");
static_assert(sizeof(USafeZone) == 0x000180, "Wrong size on USafeZone");
static_assert(offsetof(USafeZone, PadLeft) == 0x000168, "Member 'USafeZone::PadLeft' has a wrong offset!");
static_assert(offsetof(USafeZone, PadRight) == 0x000169, "Member 'USafeZone::PadRight' has a wrong offset!");
static_assert(offsetof(USafeZone, PadTop) == 0x00016A, "Member 'USafeZone::PadTop' has a wrong offset!");
static_assert(offsetof(USafeZone, PadBottom) == 0x00016B, "Member 'USafeZone::PadBottom' has a wrong offset!");

// Class UMG.SafeZoneSlot
// 0x0038 (0x0070 - 0x0038)
class USafeZoneSlot final : public UPanelSlot
{
public:
	bool                                          bIsTitleSafe;                                      // 0x0038(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_39[0x3];                                       // 0x0039(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FMargin                                SafeAreaScale;                                     // 0x003C(0x0010)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	EHorizontalAlignment                          HAlign;                                            // 0x004C(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EVerticalAlignment                            VAlign;                                            // 0x004D(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4E[0x2];                                       // 0x004E(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	struct FMargin                                Padding;                                           // 0x0050(0x0010)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_60[0x10];                                      // 0x0060(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"SafeZoneSlot">();
	}
	static class USafeZoneSlot* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<USafeZoneSlot>();
	}
};
static_assert(alignof(USafeZoneSlot) == 0x000008, "Wrong alignment on USafeZoneSlot");
static_assert(sizeof(USafeZoneSlot) == 0x000070, "Wrong size on USafeZoneSlot");
static_assert(offsetof(USafeZoneSlot, bIsTitleSafe) == 0x000038, "Member 'USafeZoneSlot::bIsTitleSafe' has a wrong offset!");
static_assert(offsetof(USafeZoneSlot, SafeAreaScale) == 0x00003C, "Member 'USafeZoneSlot::SafeAreaScale' has a wrong offset!");
static_assert(offsetof(USafeZoneSlot, HAlign) == 0x00004C, "Member 'USafeZoneSlot::HAlign' has a wrong offset!");
static_assert(offsetof(USafeZoneSlot, VAlign) == 0x00004D, "Member 'USafeZoneSlot::VAlign' has a wrong offset!");
static_assert(offsetof(USafeZoneSlot, Padding) == 0x000050, "Member 'USafeZoneSlot::Padding' has a wrong offset!");

// Class UMG.ScaleBox
// 0x0020 (0x0188 - 0x0168)
class UScaleBox final : public UContentWidget
{
public:
	EStretch                                      Stretch;                                           // 0x0168(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EStretchDirection                             StretchDirection;                                  // 0x0169(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_16A[0x2];                                      // 0x016A(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         UserSpecifiedScale;                                // 0x016C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IgnoreInheritedScale;                              // 0x0170(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_171[0x17];                                     // 0x0171(0x0017)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SetIgnoreInheritedScale(bool bInIgnoreInheritedScale)	 // 0x66f987c;
	void SetStretch(EStretch InStretch)	 // 0x66fdd30;
	void SetStretchDirection(EStretchDirection InStretchDirection)	 // 0x66fddf0;
	void SetUserSpecifiedScale(float InUserSpecifiedScale)	 // 0x1640170;

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"ScaleBox">();
	}
	static class UScaleBox* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UScaleBox>();
	}
};
static_assert(alignof(UScaleBox) == 0x000008, "Wrong alignment on UScaleBox");
static_assert(sizeof(UScaleBox) == 0x000188, "Wrong size on UScaleBox");
static_assert(offsetof(UScaleBox, Stretch) == 0x000168, "Member 'UScaleBox::Stretch' has a wrong offset!");
static_assert(offsetof(UScaleBox, StretchDirection) == 0x000169, "Member 'UScaleBox::StretchDirection' has a wrong offset!");
static_assert(offsetof(UScaleBox, UserSpecifiedScale) == 0x00016C, "Member 'UScaleBox::UserSpecifiedScale' has a wrong offset!");
static_assert(offsetof(UScaleBox, IgnoreInheritedScale) == 0x000170, "Member 'UScaleBox::IgnoreInheritedScale' has a wrong offset!");

// Class UMG.ScaleBoxSlot
// 0x0018 (0x0050 - 0x0038)
class UScaleBoxSlot final : public UPanelSlot
{
public:
	EHorizontalAlignment                          HorizontalAlignment;                               // 0x0038(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EVerticalAlignment                            VerticalAlignment;                                 // 0x0039(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3A[0x16];                                      // 0x003A(0x0016)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SetHorizontalAlignment(EHorizontalAlignment InHorizontalAlignment)	 // 0x66f957c;
	void SetPadding(const struct FMargin& InPadding)	 // 0x66fc0cc;
	void SetVerticalAlignment(EVerticalAlignment InVerticalAlignment)	 // 0x66fefcc;

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"ScaleBoxSlot">();
	}
	static class UScaleBoxSlot* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UScaleBoxSlot>();
	}
};
static_assert(alignof(UScaleBoxSlot) == 0x000008, "Wrong alignment on UScaleBoxSlot");
static_assert(sizeof(UScaleBoxSlot) == 0x000050, "Wrong size on UScaleBoxSlot");
static_assert(offsetof(UScaleBoxSlot, HorizontalAlignment) == 0x000038, "Member 'UScaleBoxSlot::HorizontalAlignment' has a wrong offset!");
static_assert(offsetof(UScaleBoxSlot, VerticalAlignment) == 0x000039, "Member 'UScaleBoxSlot::VerticalAlignment' has a wrong offset!");

// Class UMG.ScrollBoxSlot
// 0x0028 (0x0060 - 0x0038)
class UScrollBoxSlot final : public UPanelSlot
{
public:
	struct FSlateChildSize                        Size;                                              // 0x0038(0x0008)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPrivate)
	struct FMargin                                Padding;                                           // 0x0040(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	EHorizontalAlignment                          HorizontalAlignment;                               // 0x0050(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EVerticalAlignment                            VerticalAlignment;                                 // 0x0051(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_52[0xE];                                       // 0x0052(0x000E)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SetHorizontalAlignment(EHorizontalAlignment InHorizontalAlignment)	 // 0x66f963c;
	void SetPadding(const struct FMargin& InPadding)	 // 0x66fc178;
	void SetVerticalAlignment(EVerticalAlignment InVerticalAlignment)	 // 0x66ff08c;

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"ScrollBoxSlot">();
	}
	static class UScrollBoxSlot* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UScrollBoxSlot>();
	}
};
static_assert(alignof(UScrollBoxSlot) == 0x000008, "Wrong alignment on UScrollBoxSlot");
static_assert(sizeof(UScrollBoxSlot) == 0x000060, "Wrong size on UScrollBoxSlot");
static_assert(offsetof(UScrollBoxSlot, Size) == 0x000038, "Member 'UScrollBoxSlot::Size' has a wrong offset!");
static_assert(offsetof(UScrollBoxSlot, Padding) == 0x000040, "Member 'UScrollBoxSlot::Padding' has a wrong offset!");
static_assert(offsetof(UScrollBoxSlot, HorizontalAlignment) == 0x000050, "Member 'UScrollBoxSlot::HorizontalAlignment' has a wrong offset!");
static_assert(offsetof(UScrollBoxSlot, VerticalAlignment) == 0x000051, "Member 'UScrollBoxSlot::VerticalAlignment' has a wrong offset!");

// Class UMG.SizeBoxSlot
// 0x0028 (0x0060 - 0x0038)
class USizeBoxSlot final : public UPanelSlot
{
public:
	struct FMargin                                Padding;                                           // 0x0038(0x0010)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_48[0x10];                                      // 0x0048(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	EHorizontalAlignment                          HorizontalAlignment;                               // 0x0058(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EVerticalAlignment                            VerticalAlignment;                                 // 0x0059(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5A[0x6];                                       // 0x005A(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SetHorizontalAlignment(EHorizontalAlignment InHorizontalAlignment)	 // 0x66f96fc;
	void SetPadding(const struct FMargin& InPadding)	 // 0x16b1ea8;
	void SetVerticalAlignment(EVerticalAlignment InVerticalAlignment)	 // 0x66ff14c;

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"SizeBoxSlot">();
	}
	static class USizeBoxSlot* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<USizeBoxSlot>();
	}
};
static_assert(alignof(USizeBoxSlot) == 0x000008, "Wrong alignment on USizeBoxSlot");
static_assert(sizeof(USizeBoxSlot) == 0x000060, "Wrong size on USizeBoxSlot");
static_assert(offsetof(USizeBoxSlot, Padding) == 0x000038, "Member 'USizeBoxSlot::Padding' has a wrong offset!");
static_assert(offsetof(USizeBoxSlot, HorizontalAlignment) == 0x000058, "Member 'USizeBoxSlot::HorizontalAlignment' has a wrong offset!");
static_assert(offsetof(USizeBoxSlot, VerticalAlignment) == 0x000059, "Member 'USizeBoxSlot::VerticalAlignment' has a wrong offset!");

// Class UMG.Spacer
// 0x0020 (0x0170 - 0x0150)
class USpacer final : public UWidget
{
public:
	struct FVector2D                              Size;                                              // 0x0150(0x0010)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_160[0x10];                                     // 0x0160(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SetSize(const struct FVector2D& InSize)	 // 0x66fd728;

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"Spacer">();
	}
	static class USpacer* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<USpacer>();
	}
};
static_assert(alignof(USpacer) == 0x000008, "Wrong alignment on USpacer");
static_assert(sizeof(USpacer) == 0x000170, "Wrong size on USpacer");
static_assert(offsetof(USpacer, Size) == 0x000150, "Member 'USpacer::Size' has a wrong offset!");

// Class UMG.SpinBox
// 0x0720 (0x0870 - 0x0150)
class USpinBox final : public UWidget
{
public:
	float                                         Value;                                             // 0x0150(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TDelegate<void()>                             ValueDelegate;                                     // 0x0154(0x0010)(ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_164[0xC];                                      // 0x0164(0x000C)(Fixing Size After Last Property [ Dumper-7 ])
	struct FSpinBoxStyle                          WidgetStyle;                                       // 0x0170(0x0600)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	int32                                         MinFractionalDigits;                               // 0x0770(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MaxFractionalDigits;                               // 0x0774(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAlwaysUsesDeltaSnap;                              // 0x0778(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bEnableSlider;                                     // 0x0779(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_77A[0x2];                                      // 0x077A(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Delta;                                             // 0x077C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SliderExponent;                                    // 0x0780(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_784[0x4];                                      // 0x0784(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FSlateFontInfo                         Font;                                              // 0x0788(0x0058)(Edit, BlueprintVisible, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETextJustify                                  Justification;                                     // 0x07E0(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_7E1[0x3];                                      // 0x07E1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MinDesiredWidth;                                   // 0x07E4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EVirtualKeyboardType                          KeyboardType;                                      // 0x07E8(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ClearKeyboardFocusOnCommit;                        // 0x07E9(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          SelectAllTextOnCommit;                             // 0x07EA(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_7EB[0x1];                                      // 0x07EB(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	struct FSlateColor                            ForegroundColor;                                   // 0x07EC(0x0014)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(float InValue)> OnValueChanged;                                    // 0x0800(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(float InValue, ETextCommit CommitMethod)> OnValueCommitted;        // 0x0810(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void()>              OnBeginSliderMovement;                             // 0x0820(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(float InValue)> OnEndSliderMovement;                               // 0x0830(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         bOverride_MinValue : 1;                            // 0x0840(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bOverride_MaxValue : 1;                            // 0x0840(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bOverride_MinSliderValue : 1;                      // 0x0840(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Edit, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bOverride_MaxSliderValue : 1;                      // 0x0840(0x0001)(BitIndex: 0x03, PropSize: 0x0001 (Edit, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         Pad_841[0x3];                                      // 0x0841(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MinValue;                                          // 0x0844(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MaxValue;                                          // 0x0848(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MinSliderValue;                                    // 0x084C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MaxSliderValue;                                    // 0x0850(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_854[0x1C];                                     // 0x0854(0x001C)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ClearMaxSliderValue()	 // 0x66f344c;
	void ClearMaxValue()	 // 0x66f3460;
	void ClearMinSliderValue()	 // 0x66f34b0;
	void ClearMinValue()	 // 0x66f34c4;
	void SetAlwaysUsesDeltaSnap(bool bNewValue)	 // 0x66f6574;
	void SetDelta(float NewValue)	 // 0x66f7fc8;
	void SetForegroundColor(const struct FSlateColor& InForegroundColor)	 // 0x66f8f08;
	void SetMaxFractionalDigits(int32 NewValue)	 // 0x66fa804;
	void SetMaxSliderValue(float NewValue)	 // 0x66fa8c4;
	void SetMaxValue(float NewValue)	 // 0x66faa4c;
	void SetMinFractionalDigits(int32 NewValue)	 // 0x66fafa8;
	void SetMinSliderValue(float NewValue)	 // 0x66fb068;
	void SetMinValue(float NewValue)	 // 0x66fb1f0;
	void SetValue(float NewValue)	 // 0x66fecc8;

	bool GetAlwaysUsesDeltaSnap() const	 // 0x66f3964;
	float GetDelta() const	 // 0x66f3c50;
	int32 GetMaxFractionalDigits() const	 // 0x66f4160;
	float GetMaxSliderValue() const	 // 0x66f4178;
	float GetMaxValue() const	 // 0x66f4198;
	int32 GetMinFractionalDigits() const	 // 0x66f41f8;
	float GetMinSliderValue() const	 // 0x66f4210;
	float GetMinValue() const	 // 0x66f4230;
	float GetValue() const	 // 0x66f4628;

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"SpinBox">();
	}
	static class USpinBox* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<USpinBox>();
	}
};
static_assert(alignof(USpinBox) == 0x000010, "Wrong alignment on USpinBox");
static_assert(sizeof(USpinBox) == 0x000870, "Wrong size on USpinBox");
static_assert(offsetof(USpinBox, Value) == 0x000150, "Member 'USpinBox::Value' has a wrong offset!");
static_assert(offsetof(USpinBox, ValueDelegate) == 0x000154, "Member 'USpinBox::ValueDelegate' has a wrong offset!");
static_assert(offsetof(USpinBox, WidgetStyle) == 0x000170, "Member 'USpinBox::WidgetStyle' has a wrong offset!");
static_assert(offsetof(USpinBox, MinFractionalDigits) == 0x000770, "Member 'USpinBox::MinFractionalDigits' has a wrong offset!");
static_assert(offsetof(USpinBox, MaxFractionalDigits) == 0x000774, "Member 'USpinBox::MaxFractionalDigits' has a wrong offset!");
static_assert(offsetof(USpinBox, bAlwaysUsesDeltaSnap) == 0x000778, "Member 'USpinBox::bAlwaysUsesDeltaSnap' has a wrong offset!");
static_assert(offsetof(USpinBox, bEnableSlider) == 0x000779, "Member 'USpinBox::bEnableSlider' has a wrong offset!");
static_assert(offsetof(USpinBox, Delta) == 0x00077C, "Member 'USpinBox::Delta' has a wrong offset!");
static_assert(offsetof(USpinBox, SliderExponent) == 0x000780, "Member 'USpinBox::SliderExponent' has a wrong offset!");
static_assert(offsetof(USpinBox, Font) == 0x000788, "Member 'USpinBox::Font' has a wrong offset!");
static_assert(offsetof(USpinBox, Justification) == 0x0007E0, "Member 'USpinBox::Justification' has a wrong offset!");
static_assert(offsetof(USpinBox, MinDesiredWidth) == 0x0007E4, "Member 'USpinBox::MinDesiredWidth' has a wrong offset!");
static_assert(offsetof(USpinBox, KeyboardType) == 0x0007E8, "Member 'USpinBox::KeyboardType' has a wrong offset!");
static_assert(offsetof(USpinBox, ClearKeyboardFocusOnCommit) == 0x0007E9, "Member 'USpinBox::ClearKeyboardFocusOnCommit' has a wrong offset!");
static_assert(offsetof(USpinBox, SelectAllTextOnCommit) == 0x0007EA, "Member 'USpinBox::SelectAllTextOnCommit' has a wrong offset!");
static_assert(offsetof(USpinBox, ForegroundColor) == 0x0007EC, "Member 'USpinBox::ForegroundColor' has a wrong offset!");
static_assert(offsetof(USpinBox, OnValueChanged) == 0x000800, "Member 'USpinBox::OnValueChanged' has a wrong offset!");
static_assert(offsetof(USpinBox, OnValueCommitted) == 0x000810, "Member 'USpinBox::OnValueCommitted' has a wrong offset!");
static_assert(offsetof(USpinBox, OnBeginSliderMovement) == 0x000820, "Member 'USpinBox::OnBeginSliderMovement' has a wrong offset!");
static_assert(offsetof(USpinBox, OnEndSliderMovement) == 0x000830, "Member 'USpinBox::OnEndSliderMovement' has a wrong offset!");
static_assert(offsetof(USpinBox, MinValue) == 0x000844, "Member 'USpinBox::MinValue' has a wrong offset!");
static_assert(offsetof(USpinBox, MaxValue) == 0x000848, "Member 'USpinBox::MaxValue' has a wrong offset!");
static_assert(offsetof(USpinBox, MinSliderValue) == 0x00084C, "Member 'USpinBox::MinSliderValue' has a wrong offset!");
static_assert(offsetof(USpinBox, MaxSliderValue) == 0x000850, "Member 'USpinBox::MaxSliderValue' has a wrong offset!");

// Class UMG.StackBox
// 0x0018 (0x0180 - 0x0168)
class UStackBox final : public UPanelWidget
{
public:
	EOrientation                                  Orientation;                                       // 0x0168(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_169[0x17];                                     // 0x0169(0x0017)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	class UStackBoxSlot* AddChildToStackBox(class UWidget* Content)	 // 0x66f261c;
	bool ReplaceStackBoxChildAt(int32 Index_0, class UWidget* Content)	 // 0x66f5b88;

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"StackBox">();
	}
	static class UStackBox* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UStackBox>();
	}
};
static_assert(alignof(UStackBox) == 0x000008, "Wrong alignment on UStackBox");
static_assert(sizeof(UStackBox) == 0x000180, "Wrong size on UStackBox");
static_assert(offsetof(UStackBox, Orientation) == 0x000168, "Member 'UStackBox::Orientation' has a wrong offset!");

// Class UMG.StackBoxSlot
// 0x0028 (0x0060 - 0x0038)
class UStackBoxSlot final : public UPanelSlot
{
public:
	struct FMargin                                Padding;                                           // 0x0038(0x0010)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPrivate)
	struct FSlateChildSize                        Size;                                              // 0x0048(0x0008)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPrivate)
	EHorizontalAlignment                          HorizontalAlignment;                               // 0x0050(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	EVerticalAlignment                            VerticalAlignment;                                 // 0x0051(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_52[0xE];                                       // 0x0052(0x000E)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"StackBoxSlot">();
	}
	static class UStackBoxSlot* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UStackBoxSlot>();
	}
};
static_assert(alignof(UStackBoxSlot) == 0x000008, "Wrong alignment on UStackBoxSlot");
static_assert(sizeof(UStackBoxSlot) == 0x000060, "Wrong size on UStackBoxSlot");
static_assert(offsetof(UStackBoxSlot, Padding) == 0x000038, "Member 'UStackBoxSlot::Padding' has a wrong offset!");
static_assert(offsetof(UStackBoxSlot, Size) == 0x000048, "Member 'UStackBoxSlot::Size' has a wrong offset!");
static_assert(offsetof(UStackBoxSlot, HorizontalAlignment) == 0x000050, "Member 'UStackBoxSlot::HorizontalAlignment' has a wrong offset!");
static_assert(offsetof(UStackBoxSlot, VerticalAlignment) == 0x000051, "Member 'UStackBoxSlot::VerticalAlignment' has a wrong offset!");

// Class UMG.UniformGridPanel
// 0x0028 (0x0190 - 0x0168)
class UUniformGridPanel final : public UPanelWidget
{
public:
	struct FMargin                                SlotPadding;                                       // 0x0168(0x0010)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	float                                         MinDesiredSlotWidth;                               // 0x0178(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MinDesiredSlotHeight;                              // 0x017C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_180[0x10];                                     // 0x0180(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	class UUniformGridSlot* AddChildToUniformGrid(class UWidget* Content, int32 InRow, int32 InColumn)	 // 0x66f27b0;
	void SetMinDesiredSlotHeight(float InMinDesiredSlotHeight)	 // 0x66fac98;
	void SetMinDesiredSlotWidth(float InMinDesiredSlotWidth)	 // 0x66fad5c;
	void SetSlotPadding(const struct FMargin& InSlotPadding)	 // 0x66fda48;

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"UniformGridPanel">();
	}
	static class UUniformGridPanel* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UUniformGridPanel>();
	}
};
static_assert(alignof(UUniformGridPanel) == 0x000008, "Wrong alignment on UUniformGridPanel");
static_assert(sizeof(UUniformGridPanel) == 0x000190, "Wrong size on UUniformGridPanel");
static_assert(offsetof(UUniformGridPanel, SlotPadding) == 0x000168, "Member 'UUniformGridPanel::SlotPadding' has a wrong offset!");
static_assert(offsetof(UUniformGridPanel, MinDesiredSlotWidth) == 0x000178, "Member 'UUniformGridPanel::MinDesiredSlotWidth' has a wrong offset!");
static_assert(offsetof(UUniformGridPanel, MinDesiredSlotHeight) == 0x00017C, "Member 'UUniformGridPanel::MinDesiredSlotHeight' has a wrong offset!");

// Class UMG.UniformGridSlot
// 0x0018 (0x0050 - 0x0038)
class UUniformGridSlot final : public UPanelSlot
{
public:
	EHorizontalAlignment                          HorizontalAlignment;                               // 0x0038(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EVerticalAlignment                            VerticalAlignment;                                 // 0x0039(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3A[0x2];                                       // 0x003A(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         Row;                                               // 0x003C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Column;                                            // 0x0040(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_44[0xC];                                       // 0x0044(0x000C)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SetColumn(int32 InColumn)	 // 0x66f7370;
	void SetHorizontalAlignment(EHorizontalAlignment InHorizontalAlignment)	 // 0x66f97bc;
	void SetRow(int32 InRow)	 // 0x66fc9a4;
	void SetVerticalAlignment(EVerticalAlignment InVerticalAlignment)	 // 0x66ff20c;

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"UniformGridSlot">();
	}
	static class UUniformGridSlot* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UUniformGridSlot>();
	}
};
static_assert(alignof(UUniformGridSlot) == 0x000008, "Wrong alignment on UUniformGridSlot");
static_assert(sizeof(UUniformGridSlot) == 0x000050, "Wrong size on UUniformGridSlot");
static_assert(offsetof(UUniformGridSlot, HorizontalAlignment) == 0x000038, "Member 'UUniformGridSlot::HorizontalAlignment' has a wrong offset!");
static_assert(offsetof(UUniformGridSlot, VerticalAlignment) == 0x000039, "Member 'UUniformGridSlot::VerticalAlignment' has a wrong offset!");
static_assert(offsetof(UUniformGridSlot, Row) == 0x00003C, "Member 'UUniformGridSlot::Row' has a wrong offset!");
static_assert(offsetof(UUniformGridSlot, Column) == 0x000040, "Member 'UUniformGridSlot::Column' has a wrong offset!");

// Class UMG.VerticalBox
// 0x0010 (0x0178 - 0x0168)
class UVerticalBox final : public UPanelWidget
{
public:
	uint8                                         Pad_168[0x10];                                     // 0x0168(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	class UVerticalBoxSlot* AddChildToVerticalBox(class UWidget* Content)	 // 0x66f296c;

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"VerticalBox">();
	}
	static class UVerticalBox* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UVerticalBox>();
	}
};
static_assert(alignof(UVerticalBox) == 0x000008, "Wrong alignment on UVerticalBox");
static_assert(sizeof(UVerticalBox) == 0x000178, "Wrong size on UVerticalBox");

// Class UMG.VerticalBoxSlot
// 0x0028 (0x0060 - 0x0038)
class UVerticalBoxSlot final : public UPanelSlot
{
public:
	struct FSlateChildSize                        Size;                                              // 0x0038(0x0008)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	struct FMargin                                Padding;                                           // 0x0040(0x0010)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	EHorizontalAlignment                          HorizontalAlignment;                               // 0x0050(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EVerticalAlignment                            VerticalAlignment;                                 // 0x0051(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_52[0xE];                                       // 0x0052(0x000E)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SetHorizontalAlignment(EHorizontalAlignment InHorizontalAlignment)	 // 0xd8bec0;
	void SetPadding(const struct FMargin& InPadding)	 // 0x66fc248;
	void SetSize(const struct FSlateChildSize& InSize)	 // 0x66fd7f0;
	void SetVerticalAlignment(EVerticalAlignment InVerticalAlignment)	 // 0x66ff08c;

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"VerticalBoxSlot">();
	}
	static class UVerticalBoxSlot* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UVerticalBoxSlot>();
	}
};
static_assert(alignof(UVerticalBoxSlot) == 0x000008, "Wrong alignment on UVerticalBoxSlot");
static_assert(sizeof(UVerticalBoxSlot) == 0x000060, "Wrong size on UVerticalBoxSlot");
static_assert(offsetof(UVerticalBoxSlot, Size) == 0x000038, "Member 'UVerticalBoxSlot::Size' has a wrong offset!");
static_assert(offsetof(UVerticalBoxSlot, Padding) == 0x000040, "Member 'UVerticalBoxSlot::Padding' has a wrong offset!");
static_assert(offsetof(UVerticalBoxSlot, HorizontalAlignment) == 0x000050, "Member 'UVerticalBoxSlot::HorizontalAlignment' has a wrong offset!");
static_assert(offsetof(UVerticalBoxSlot, VerticalAlignment) == 0x000051, "Member 'UVerticalBoxSlot::VerticalAlignment' has a wrong offset!");

// Class UMG.WidgetInteractionComponent
// 0x02D0 (0x05B0 - 0x02E0)
class UWidgetInteractionComponent final : public USceneComponent
{
public:
	TMulticastInlineDelegate<void(class UWidgetComponent* WidgetComponent, class UWidgetComponent* PreviousWidgetComponent)> OnHoveredWidgetChanged; // 0x02E0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_2F0[0x10];                                     // 0x02F0(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         VirtualUserIndex;                                  // 0x0300(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         PointerIndex;                                      // 0x0304(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECollisionChannel                             TraceChannel;                                      // 0x0308(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_309[0x3];                                      // 0x0309(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         InteractionDistance;                               // 0x030C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EWidgetInteractionSource                      InteractionSource;                                 // 0x0310(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bEnableHitTesting;                                 // 0x0311(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bShowDebug;                                        // 0x0312(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_313[0x1];                                      // 0x0313(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         DebugSphereLineThickness;                          // 0x0314(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DebugLineThickness;                                // 0x0318(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           DebugColor;                                        // 0x031C(0x0010)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_32C[0x7C];                                     // 0x032C(0x007C)(Fixing Size After Last Property [ Dumper-7 ])
	struct FHitResult                             CustomHitResult;                                   // 0x03A8(0x00E8)(Transient, IsPlainOldData, NoDestructor, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	struct FVector2D                              LocalHitLocation;                                  // 0x0490(0x0010)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector2D                              LastLocalHitLocation;                              // 0x04A0(0x0010)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetComponent*                       HoveredWidgetComponent;                            // 0x04B0(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FHitResult                             LastHitResult;                                     // 0x04B8(0x00E8)(Transient, IsPlainOldData, NoDestructor, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	bool                                          bIsHoveredWidgetInteractable;                      // 0x05A0(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIsHoveredWidgetFocusable;                         // 0x05A1(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIsHoveredWidgetHitTestVisible;                    // 0x05A2(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_5A3[0xD];                                      // 0x05A3(0x000D)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	bool PressAndReleaseKey(const struct FKey& Key)	 // 0x67157d8;
	bool PressKey(const struct FKey& Key, bool bRepeat)	 // 0x6715928;
	void PressPointerKey(const struct FKey& Key)	 // 0x6715afc;
	bool ReleaseKey(const struct FKey& Key)	 // 0x671617c;
	void ReleasePointerKey(const struct FKey& Key)	 // 0x67163c4;
	void ScrollWheel(float ScrollDelta)	 // 0x6716fe4;
	bool SendKeyChar(const class FString& Characters, bool bRepeat)	 // 0x67170ac;
	void SetCustomHitResult(const struct FHitResult& HitResult)	 // 0x6717978;
	void SetFocus(class UWidget* FocusWidget)	 // 0x6717ce0;

	struct FVector2D Get2DHitLocation() const	 // 0x6711ea4;
	class UWidgetComponent* GetHoveredWidgetComponent() const	 // 0x6712ebc;
	const struct FHitResult GetLastHitResult() const	 // 0x6713284;
	bool IsOverFocusableWidget() const	 // 0x6713ee0;
	bool IsOverHitTestVisibleWidget() const	 // 0x6713ef8;
	bool IsOverInteractableWidget() const	 // 0x6713f10;

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"WidgetInteractionComponent">();
	}
	static class UWidgetInteractionComponent* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UWidgetInteractionComponent>();
	}
};
static_assert(alignof(UWidgetInteractionComponent) == 0x000010, "Wrong alignment on UWidgetInteractionComponent");
static_assert(sizeof(UWidgetInteractionComponent) == 0x0005B0, "Wrong size on UWidgetInteractionComponent");
static_assert(offsetof(UWidgetInteractionComponent, OnHoveredWidgetChanged) == 0x0002E0, "Member 'UWidgetInteractionComponent::OnHoveredWidgetChanged' has a wrong offset!");
static_assert(offsetof(UWidgetInteractionComponent, VirtualUserIndex) == 0x000300, "Member 'UWidgetInteractionComponent::VirtualUserIndex' has a wrong offset!");
static_assert(offsetof(UWidgetInteractionComponent, PointerIndex) == 0x000304, "Member 'UWidgetInteractionComponent::PointerIndex' has a wrong offset!");
static_assert(offsetof(UWidgetInteractionComponent, TraceChannel) == 0x000308, "Member 'UWidgetInteractionComponent::TraceChannel' has a wrong offset!");
static_assert(offsetof(UWidgetInteractionComponent, InteractionDistance) == 0x00030C, "Member 'UWidgetInteractionComponent::InteractionDistance' has a wrong offset!");
static_assert(offsetof(UWidgetInteractionComponent, InteractionSource) == 0x000310, "Member 'UWidgetInteractionComponent::InteractionSource' has a wrong offset!");
static_assert(offsetof(UWidgetInteractionComponent, bEnableHitTesting) == 0x000311, "Member 'UWidgetInteractionComponent::bEnableHitTesting' has a wrong offset!");
static_assert(offsetof(UWidgetInteractionComponent, bShowDebug) == 0x000312, "Member 'UWidgetInteractionComponent::bShowDebug' has a wrong offset!");
static_assert(offsetof(UWidgetInteractionComponent, DebugSphereLineThickness) == 0x000314, "Member 'UWidgetInteractionComponent::DebugSphereLineThickness' has a wrong offset!");
static_assert(offsetof(UWidgetInteractionComponent, DebugLineThickness) == 0x000318, "Member 'UWidgetInteractionComponent::DebugLineThickness' has a wrong offset!");
static_assert(offsetof(UWidgetInteractionComponent, DebugColor) == 0x00031C, "Member 'UWidgetInteractionComponent::DebugColor' has a wrong offset!");
static_assert(offsetof(UWidgetInteractionComponent, CustomHitResult) == 0x0003A8, "Member 'UWidgetInteractionComponent::CustomHitResult' has a wrong offset!");
static_assert(offsetof(UWidgetInteractionComponent, LocalHitLocation) == 0x000490, "Member 'UWidgetInteractionComponent::LocalHitLocation' has a wrong offset!");
static_assert(offsetof(UWidgetInteractionComponent, LastLocalHitLocation) == 0x0004A0, "Member 'UWidgetInteractionComponent::LastLocalHitLocation' has a wrong offset!");
static_assert(offsetof(UWidgetInteractionComponent, HoveredWidgetComponent) == 0x0004B0, "Member 'UWidgetInteractionComponent::HoveredWidgetComponent' has a wrong offset!");
static_assert(offsetof(UWidgetInteractionComponent, LastHitResult) == 0x0004B8, "Member 'UWidgetInteractionComponent::LastHitResult' has a wrong offset!");
static_assert(offsetof(UWidgetInteractionComponent, bIsHoveredWidgetInteractable) == 0x0005A0, "Member 'UWidgetInteractionComponent::bIsHoveredWidgetInteractable' has a wrong offset!");
static_assert(offsetof(UWidgetInteractionComponent, bIsHoveredWidgetFocusable) == 0x0005A1, "Member 'UWidgetInteractionComponent::bIsHoveredWidgetFocusable' has a wrong offset!");
static_assert(offsetof(UWidgetInteractionComponent, bIsHoveredWidgetHitTestVisible) == 0x0005A2, "Member 'UWidgetInteractionComponent::bIsHoveredWidgetHitTestVisible' has a wrong offset!");

// Class UMG.WidgetSwitcherSlot
// 0x0020 (0x0058 - 0x0038)
class UWidgetSwitcherSlot final : public UPanelSlot
{
public:
	uint8                                         Pad_38[0x8];                                       // 0x0038(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FMargin                                Padding;                                           // 0x0040(0x0010)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	EHorizontalAlignment                          HorizontalAlignment;                               // 0x0050(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EVerticalAlignment                            VerticalAlignment;                                 // 0x0051(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_52[0x6];                                       // 0x0052(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SetHorizontalAlignment(EHorizontalAlignment InHorizontalAlignment)	 // 0x66f94bc;
	void SetPadding(const struct FMargin& InPadding)	 // 0x6719098;
	void SetVerticalAlignment(EVerticalAlignment InVerticalAlignment)	 // 0x66fef0c;

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"WidgetSwitcherSlot">();
	}
	static class UWidgetSwitcherSlot* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UWidgetSwitcherSlot>();
	}
};
static_assert(alignof(UWidgetSwitcherSlot) == 0x000008, "Wrong alignment on UWidgetSwitcherSlot");
static_assert(sizeof(UWidgetSwitcherSlot) == 0x000058, "Wrong size on UWidgetSwitcherSlot");
static_assert(offsetof(UWidgetSwitcherSlot, Padding) == 0x000040, "Member 'UWidgetSwitcherSlot::Padding' has a wrong offset!");
static_assert(offsetof(UWidgetSwitcherSlot, HorizontalAlignment) == 0x000050, "Member 'UWidgetSwitcherSlot::HorizontalAlignment' has a wrong offset!");
static_assert(offsetof(UWidgetSwitcherSlot, VerticalAlignment) == 0x000051, "Member 'UWidgetSwitcherSlot::VerticalAlignment' has a wrong offset!");

// Class UMG.WindowTitleBarArea
// 0x0020 (0x0188 - 0x0168)
class UWindowTitleBarArea final : public UContentWidget
{
public:
	bool                                          bWindowButtonsEnabled;                             // 0x0168(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDoubleClickTogglesFullscreen;                     // 0x0169(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_16A[0x1E];                                     // 0x016A(0x001E)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SetHorizontalAlignment(EHorizontalAlignment InHorizontalAlignment)	 // 0x671814c;
	void SetPadding(const struct FMargin& InPadding)	 // 0x6719168;
	void SetVerticalAlignment(EVerticalAlignment InVerticalAlignment)	 // 0x6719688;

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"WindowTitleBarArea">();
	}
	static class UWindowTitleBarArea* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UWindowTitleBarArea>();
	}
};
static_assert(alignof(UWindowTitleBarArea) == 0x000008, "Wrong alignment on UWindowTitleBarArea");
static_assert(sizeof(UWindowTitleBarArea) == 0x000188, "Wrong size on UWindowTitleBarArea");
static_assert(offsetof(UWindowTitleBarArea, bWindowButtonsEnabled) == 0x000168, "Member 'UWindowTitleBarArea::bWindowButtonsEnabled' has a wrong offset!");
static_assert(offsetof(UWindowTitleBarArea, bDoubleClickTogglesFullscreen) == 0x000169, "Member 'UWindowTitleBarArea::bDoubleClickTogglesFullscreen' has a wrong offset!");

// Class UMG.WindowTitleBarAreaSlot
// 0x0028 (0x0060 - 0x0038)
class UWindowTitleBarAreaSlot final : public UPanelSlot
{
public:
	struct FMargin                                Padding;                                           // 0x0038(0x0010)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)
	EHorizontalAlignment                          HorizontalAlignment;                               // 0x0048(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EVerticalAlignment                            VerticalAlignment;                                 // 0x0049(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_4A[0x16];                                      // 0x004A(0x0016)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SetHorizontalAlignment(EHorizontalAlignment InHorizontalAlignment)	 // 0x671820c;
	void SetPadding(const struct FMargin& InPadding)	 // 0x6719238;
	void SetVerticalAlignment(EVerticalAlignment InVerticalAlignment)	 // 0x6719748;

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"WindowTitleBarAreaSlot">();
	}
	static class UWindowTitleBarAreaSlot* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UWindowTitleBarAreaSlot>();
	}
};
static_assert(alignof(UWindowTitleBarAreaSlot) == 0x000008, "Wrong alignment on UWindowTitleBarAreaSlot");
static_assert(sizeof(UWindowTitleBarAreaSlot) == 0x000060, "Wrong size on UWindowTitleBarAreaSlot");
static_assert(offsetof(UWindowTitleBarAreaSlot, Padding) == 0x000038, "Member 'UWindowTitleBarAreaSlot::Padding' has a wrong offset!");
static_assert(offsetof(UWindowTitleBarAreaSlot, HorizontalAlignment) == 0x000048, "Member 'UWindowTitleBarAreaSlot::HorizontalAlignment' has a wrong offset!");
static_assert(offsetof(UWindowTitleBarAreaSlot, VerticalAlignment) == 0x000049, "Member 'UWindowTitleBarAreaSlot::VerticalAlignment' has a wrong offset!");

// Class UMG.WrapBoxSlot
// 0x0020 (0x0058 - 0x0038)
class UWrapBoxSlot final : public UPanelSlot
{
public:
	struct FMargin                                Padding;                                           // 0x0038(0x0010)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	float                                         FillSpanWhenLessThan;                              // 0x0048(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EHorizontalAlignment                          HorizontalAlignment;                               // 0x004C(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EVerticalAlignment                            VerticalAlignment;                                 // 0x004D(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bFillEmptySpace;                                   // 0x004E(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bForceNewLine;                                     // 0x004F(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_50[0x8];                                       // 0x0050(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SetFillEmptySpace(bool InbFillEmptySpace)	 // 0x6717b58;
	void SetFillSpanWhenLessThan(float InFillSpanWhenLessThan)	 // 0x6717c1c;
	void SetHorizontalAlignment(EHorizontalAlignment InHorizontalAlignment)	 // 0x6718390;
	void SetNewLine(bool InForceNewLine)	 // 0x6718cbc;
	void SetPadding(const struct FMargin& InPadding)	 // 0x6719308;
	void SetVerticalAlignment(EVerticalAlignment InVerticalAlignment)	 // 0x671980c;

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"WrapBoxSlot">();
	}
	static class UWrapBoxSlot* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UWrapBoxSlot>();
	}
};
static_assert(alignof(UWrapBoxSlot) == 0x000008, "Wrong alignment on UWrapBoxSlot");
static_assert(sizeof(UWrapBoxSlot) == 0x000058, "Wrong size on UWrapBoxSlot");
static_assert(offsetof(UWrapBoxSlot, Padding) == 0x000038, "Member 'UWrapBoxSlot::Padding' has a wrong offset!");
static_assert(offsetof(UWrapBoxSlot, FillSpanWhenLessThan) == 0x000048, "Member 'UWrapBoxSlot::FillSpanWhenLessThan' has a wrong offset!");
static_assert(offsetof(UWrapBoxSlot, HorizontalAlignment) == 0x00004C, "Member 'UWrapBoxSlot::HorizontalAlignment' has a wrong offset!");
static_assert(offsetof(UWrapBoxSlot, VerticalAlignment) == 0x00004D, "Member 'UWrapBoxSlot::VerticalAlignment' has a wrong offset!");
static_assert(offsetof(UWrapBoxSlot, bFillEmptySpace) == 0x00004E, "Member 'UWrapBoxSlot::bFillEmptySpace' has a wrong offset!");
static_assert(offsetof(UWrapBoxSlot, bForceNewLine) == 0x00004F, "Member 'UWrapBoxSlot::bForceNewLine' has a wrong offset!");

// Class UMG.DragDropOperation
// 0x0070 (0x0098 - 0x0028)
class UDragDropOperation final : public UObject
{
public:
	class FString                                 Tag;                                               // 0x0028(0x0010)(Edit, BlueprintVisible, ZeroConstructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UObject*                                Payload;                                           // 0x0038(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, ExposeOnSpawn, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UWidget*                                DefaultDragVisual;                                 // 0x0040(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, ExposeOnSpawn, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EDragPivot                                    Pivot;                                             // 0x0048(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_49[0x7];                                       // 0x0049(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector2D                              Offset;                                            // 0x0050(0x0010)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_60[0x8];                                       // 0x0060(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TMulticastInlineDelegate<void(class UDragDropOperation* Operation)> OnDrop;                      // 0x0068(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(class UDragDropOperation* Operation)> OnDragCancelled;             // 0x0078(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(class UDragDropOperation* Operation)> OnDragged;                   // 0x0088(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)

public:
	void DragCancelled(const struct FPointerEvent& PointerEvent)	 // 0x180202c;
	void Dragged(const struct FPointerEvent& PointerEvent)	 // 0xd97874;
	void Drop(const struct FPointerEvent& PointerEvent)	 // 0x17faa1c;

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"DragDropOperation">();
	}
	static class UDragDropOperation* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UDragDropOperation>();
	}
};
static_assert(alignof(UDragDropOperation) == 0x000008, "Wrong alignment on UDragDropOperation");
static_assert(sizeof(UDragDropOperation) == 0x000098, "Wrong size on UDragDropOperation");
static_assert(offsetof(UDragDropOperation, Tag) == 0x000028, "Member 'UDragDropOperation::Tag' has a wrong offset!");
static_assert(offsetof(UDragDropOperation, Payload) == 0x000038, "Member 'UDragDropOperation::Payload' has a wrong offset!");
static_assert(offsetof(UDragDropOperation, DefaultDragVisual) == 0x000040, "Member 'UDragDropOperation::DefaultDragVisual' has a wrong offset!");
static_assert(offsetof(UDragDropOperation, Pivot) == 0x000048, "Member 'UDragDropOperation::Pivot' has a wrong offset!");
static_assert(offsetof(UDragDropOperation, Offset) == 0x000050, "Member 'UDragDropOperation::Offset' has a wrong offset!");
static_assert(offsetof(UDragDropOperation, OnDrop) == 0x000068, "Member 'UDragDropOperation::OnDrop' has a wrong offset!");
static_assert(offsetof(UDragDropOperation, OnDragCancelled) == 0x000078, "Member 'UDragDropOperation::OnDragCancelled' has a wrong offset!");
static_assert(offsetof(UDragDropOperation, OnDragged) == 0x000088, "Member 'UDragDropOperation::OnDragged' has a wrong offset!");

// Class UMG.SlateBlueprintLibrary
// 0x0000 (0x0028 - 0x0028)
class USlateBlueprintLibrary final : public UBlueprintFunctionLibrary
{
public:
	static struct FVector2D AbsoluteToLocal(const struct FGeometry& Geometry, const struct FVector2D& AbsoluteCoordinate)	 // 0x670eb00;
	static void AbsoluteToViewport(class UObject* WorldContextObject, const struct FVector2D& AbsoluteDesktopCoordinate, struct FVector2D* PixelPosition, struct FVector2D* ViewportPosition)	 // 0x670ec74;
	static bool EqualEqual_SlateBrush(const struct FSlateBrush& A, const struct FSlateBrush& B)	 // 0x6711c9c;
	static struct FVector2D GetAbsoluteSize(const struct FGeometry& Geometry)	 // 0x151df9c;
	static struct FVector2D GetLocalSize(const struct FGeometry& Geometry)	 // 0x151dec0;
	static struct FVector2D GetLocalTopLeft(const struct FGeometry& Geometry)	 // 0x6713328;
	static bool IsUnderLocation(const struct FGeometry& Geometry, const struct FVector2D& AbsoluteCoordinate)	 // 0x6713f28;
	static struct FVector2D LocalToAbsolute(const struct FGeometry& Geometry, const struct FVector2D& LocalCoordinate)	 // 0x67142a4;
	static void LocalToViewport(class UObject* WorldContextObject, const struct FGeometry& Geometry, const struct FVector2D& LocalCoordinate, struct FVector2D* PixelPosition, struct FVector2D* ViewportPosition)	 // 0x6714418;
	static void ScreenToViewport(class UObject* WorldContextObject, const struct FVector2D& ScreenPosition, struct FVector2D* ViewportPosition)	 // 0x67168fc;
	static void ScreenToWidgetAbsolute(class UObject* WorldContextObject, const struct FVector2D& ScreenPosition, struct FVector2D* AbsoluteCoordinate, bool bIncludeWindowPosition)	 // 0x6716a84;
	static void ScreenToWidgetLocal(class UObject* WorldContextObject, const struct FGeometry& Geometry, const struct FVector2D& ScreenPosition, struct FVector2D* LocalCoordinate, bool bIncludeWindowPosition)	 // 0x6716ce4;
	static float TransformScalarAbsoluteToLocal(const struct FGeometry& Geometry, float AbsoluteScalar)	 // 0x671a5c0;
	static float TransformScalarLocalToAbsolute(const struct FGeometry& Geometry, float LocalScalar)	 // 0x671a720;
	static struct FVector2D TransformVectorAbsoluteToLocal(const struct FGeometry& Geometry, const struct FVector2D& AbsoluteVector)	 // 0x671a880;
	static struct FVector2D TransformVectorLocalToAbsolute(const struct FGeometry& Geometry, const struct FVector2D& LocalVector)	 // 0x671a9f4;

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"SlateBlueprintLibrary">();
	}
	static class USlateBlueprintLibrary* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<USlateBlueprintLibrary>();
	}
};
static_assert(alignof(USlateBlueprintLibrary) == 0x000008, "Wrong alignment on USlateBlueprintLibrary");
static_assert(sizeof(USlateBlueprintLibrary) == 0x000028, "Wrong size on USlateBlueprintLibrary");

// Class UMG.WidgetBlueprintGeneratedClass
// 0x0080 (0x03F0 - 0x0370)
class UWidgetBlueprintGeneratedClass final : public UBlueprintGeneratedClass
{
public:
	class UWidgetTree*                            WidgetTree;                                        // 0x0370(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<class UWidgetBlueprintGeneratedClassExtension*> Extensions;                               // 0x0378(0x0010)(ExportObject, ZeroConstructor, ContainsInstancedReference, UObjectWrapper, NativeAccessSpecifierPrivate)
	TArray<struct FFieldNotificationId>           FieldNotifyNames;                                  // 0x0388(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	uint8                                         Pad_398[0x4];                                      // 0x0398(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	uint8                                         bClassRequiresNativeTick : 1;                      // 0x039C(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate))
	uint8                                         Pad_39D[0x3];                                      // 0x039D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FDelegateRuntimeBinding>        Bindings;                                          // 0x03A0(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<class UWidgetAnimation*>               Animations;                                        // 0x03B0(0x0010)(ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
	TArray<class FName>                           NamedSlots;                                        // 0x03C0(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<class FName>                           AvailableNamedSlots;                               // 0x03D0(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<class FName>                           InstanceNamedSlots;                                // 0x03E0(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"WidgetBlueprintGeneratedClass">();
	}
	static class UWidgetBlueprintGeneratedClass* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UWidgetBlueprintGeneratedClass>();
	}
};
static_assert(alignof(UWidgetBlueprintGeneratedClass) == 0x000010, "Wrong alignment on UWidgetBlueprintGeneratedClass");
static_assert(sizeof(UWidgetBlueprintGeneratedClass) == 0x0003F0, "Wrong size on UWidgetBlueprintGeneratedClass");
static_assert(offsetof(UWidgetBlueprintGeneratedClass, WidgetTree) == 0x000370, "Member 'UWidgetBlueprintGeneratedClass::WidgetTree' has a wrong offset!");
static_assert(offsetof(UWidgetBlueprintGeneratedClass, Extensions) == 0x000378, "Member 'UWidgetBlueprintGeneratedClass::Extensions' has a wrong offset!");
static_assert(offsetof(UWidgetBlueprintGeneratedClass, FieldNotifyNames) == 0x000388, "Member 'UWidgetBlueprintGeneratedClass::FieldNotifyNames' has a wrong offset!");
static_assert(offsetof(UWidgetBlueprintGeneratedClass, Bindings) == 0x0003A0, "Member 'UWidgetBlueprintGeneratedClass::Bindings' has a wrong offset!");
static_assert(offsetof(UWidgetBlueprintGeneratedClass, Animations) == 0x0003B0, "Member 'UWidgetBlueprintGeneratedClass::Animations' has a wrong offset!");
static_assert(offsetof(UWidgetBlueprintGeneratedClass, NamedSlots) == 0x0003C0, "Member 'UWidgetBlueprintGeneratedClass::NamedSlots' has a wrong offset!");
static_assert(offsetof(UWidgetBlueprintGeneratedClass, AvailableNamedSlots) == 0x0003D0, "Member 'UWidgetBlueprintGeneratedClass::AvailableNamedSlots' has a wrong offset!");
static_assert(offsetof(UWidgetBlueprintGeneratedClass, InstanceNamedSlots) == 0x0003E0, "Member 'UWidgetBlueprintGeneratedClass::InstanceNamedSlots' has a wrong offset!");

// Class UMG.WidgetBlueprintLibrary
// 0x0000 (0x0028 - 0x0028)
class UWidgetBlueprintLibrary final : public UBlueprintFunctionLibrary
{
public:
	static void CancelDragDrop()	 // 0x670f1fc;
	static struct FEventReply CaptureJoystick(struct FEventReply& Reply, class UWidget* CapturingWidget, bool bInAllJoysticks)	 // 0x670f22c;
	static struct FEventReply CaptureMouse(struct FEventReply& Reply, class UWidget* CapturingWidget)	 // 0x670f54c;
	static struct FEventReply ClearUserFocus(struct FEventReply& Reply, bool bInAllUsers)	 // 0x670f778;
	static class UUserWidget* Create(class UObject* WorldContextObject, TSubclassOf<class UUserWidget> WidgetType, class APlayerController* OwningPlayer)	 // 0x1796f58;
	static class UDragDropOperation* CreateDragDropOperation(TSubclassOf<class UDragDropOperation> OperationClass)	 // 0x670f954;
	static struct FEventReply DetectDrag(struct FEventReply& Reply, class UWidget* WidgetDetectingDrag, const struct FKey& DragKey)	 // 0x670fa14;
	static struct FEventReply DetectDragIfPressed(const struct FPointerEvent& PointerEvent, class UWidget* WidgetDetectingDrag, const struct FKey& DragKey)	 // 0x176e0c8;
	static void DismissAllMenus()	 // 0x670fd50;
	static void DrawBox(struct FPaintContext& Context, const struct FVector2D& Position, const struct FVector2D& Size, class USlateBrushAsset* Brush, const struct FLinearColor& Tint)	 // 0x670fd6c;
	static void DrawLine(struct FPaintContext& Context, const struct FVector2D& PositionA, const struct FVector2D& PositionB, const struct FLinearColor& Tint, bool bAntiAlias, float Thickness)	 // 0x67102b4;
	static void DrawLines(struct FPaintContext& Context, const TArray<struct FVector2D>& Points, const struct FLinearColor& Tint, bool bAntiAlias, float Thickness)	 // 0x67107b8;
	static void DrawSpline(struct FPaintContext& Context, const struct FVector2D& Start, const struct FVector2D& StartDir, const struct FVector2D& End, const struct FVector2D& EndDir, const struct FLinearColor& Tint, float Thickness)	 // 0x6710b64;
	static void DrawText(struct FPaintContext& Context, const class FString& InString, const struct FVector2D& Position, const struct FLinearColor& Tint)	 // 0x671116c;
	static void DrawTextFormatted(struct FPaintContext& Context, const class FText& Text, const struct FVector2D& Position, class UFont* Font, int32 FontSize, class FName FontTypeFace, const struct FLinearColor& Tint)	 // 0x67114d4;
	static struct FEventReply EndDragDrop(struct FEventReply& Reply)	 // 0x6711ba4;
	static void GetAllWidgetsOfClass(class UObject* WorldContextObject, TArray<class UUserWidget*>* FoundWidgets, TSubclassOf<class UUserWidget> WidgetClass, bool TopLevelOnly)	 // 0x6711f84;
	static void GetAllWidgetsWithInterface(class UObject* WorldContextObject, TArray<class UUserWidget*>* FoundWidgets, TSubclassOf<class IInterface> Interface, bool TopLevelOnly)	 // 0x6712258;
	static class UObject* GetBrushResource(const struct FSlateBrush& Brush)	 // 0x671283c;
	static class UMaterialInterface* GetBrushResourceAsMaterial(const struct FSlateBrush& Brush)	 // 0x6712948;
	static class UTexture2D* GetBrushResourceAsTexture2D(const struct FSlateBrush& Brush)	 // 0x6712a60;
	static class UDragDropOperation* GetDragDroppingContent()	 // 0x6712b78;
	static class UMaterialInstanceDynamic* GetDynamicMaterial(struct FSlateBrush& Brush)	 // 0x6712b9c;
	static struct FInputEvent GetInputEventFromCharacterEvent(const struct FCharacterEvent& Event)	 // 0x6712ed4;
	static struct FInputEvent GetInputEventFromKeyEvent(const struct FKeyEvent& Event)	 // 0x6712fb4;
	static struct FInputEvent GetInputEventFromNavigationEvent(const struct FNavigationEvent& Event)	 // 0x67130ac;
	static struct FInputEvent GetInputEventFromPointerEvent(const struct FPointerEvent& Event)	 // 0xd965e4;
	static struct FKeyEvent GetKeyEventFromAnalogInputEvent(const struct FAnalogInputEvent& Event)	 // 0x6713190;
	static void GetSafeZonePadding(class UObject* WorldContextObject, struct FVector4* SafePadding, struct FVector2D* SafePaddingScale, struct FVector4* SpillOverPadding)	 // 0x6713804;
	static struct FEventReply Handled()	 // 0x176e064;
	static bool IsDragDropping()	 // 0x6713d5c;
	static struct FEventReply LockMouse(struct FEventReply& Reply, class UWidget* CapturingWidget)	 // 0x6714684;
	static struct FSlateBrush MakeBrushFromAsset(class USlateBrushAsset* BrushAsset)	 // 0x67148b0;
	static struct FSlateBrush MakeBrushFromMaterial(class UMaterialInterface* Material, int32 Width, int32 Height)	 // 0x67149e4;
	static struct FSlateBrush MakeBrushFromTexture(class UTexture2D* Texture, int32 Width, int32 Height)	 // 0x6714c44;
	static struct FSlateBrush NoResourceBrush()	 // 0x6714e24;
	static struct FEventReply ReleaseJoystickCapture(struct FEventReply& Reply, bool bInAllJoysticks)	 // 0x6715fa0;
	static struct FEventReply ReleaseMouseCapture(struct FEventReply& Reply)	 // 0x67162cc;
	static void RestorePreviousWindowTitleBarState()	 // 0x67167c8;
	static void SetBrushResourceToMaterial(struct FSlateBrush& Brush, class UMaterialInterface* Material)	 // 0x6717548;
	static void SetBrushResourceToTexture(struct FSlateBrush& Brush, class UTexture2D* Texture)	 // 0x6717548;
	static void SetColorVisionDeficiencyType(EColorVisionDeficiency Type, float Severity, bool CorrectDeficiency, bool ShowCorrectionWithDeficiency)	 // 0x6717744;
	static void SetFocusToGameViewport()	 // 0x6717dd0;
	static bool SetHardwareCursor(class UObject* WorldContextObject, EMouseCursor CursorShape, class FName CursorName, const struct FVector2D& HotSpot)	 // 0x6717ecc;
	static void SetInputMode_GameAndUIEx(class APlayerController* PlayerController, class UWidget* InWidgetToFocus, EMouseLockMode InMouseLockMode, bool bHideCursorDuringCapture, const bool bFlushInput)	 // 0x17c78b8;
	static void SetInputMode_GameOnly(class APlayerController* PlayerController, const bool bFlushInput)	 // 0x671869c;
	static void SetInputMode_UIOnlyEx(class APlayerController* PlayerController, class UWidget* InWidgetToFocus, EMouseLockMode InMouseLockMode, const bool bFlushInput)	 // 0x671880c;
	static struct FEventReply SetMousePosition(struct FEventReply& Reply, const struct FVector2D& NewMousePosition)	 // 0x6718ac4;
	static struct FEventReply SetUserFocus(struct FEventReply& Reply, class UWidget* FocusWidget, bool bInAllUsers)	 // 0x670f22c;
	static void SetWindowTitleBarCloseButtonActive(bool bActive)	 // 0x67198cc;
	static void SetWindowTitleBarOnCloseClickedDelegate(TDelegate<void()> Delegate)	 // 0x6719980;
	static void SetWindowTitleBarState(class UWidget* TitleBarContent, EWindowTitleBarMode Mode, bool bTitleBarDragEnabled, bool bWindowButtonsVisible, bool bTitleBarVisible)	 // 0x6719a64;
	static struct FEventReply Unhandled()	 // 0x671af90;
	static struct FEventReply UnlockMouse(struct FEventReply& Reply)	 // 0x671aff4;

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"WidgetBlueprintLibrary">();
	}
	static class UWidgetBlueprintLibrary* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UWidgetBlueprintLibrary>();
	}
};
static_assert(alignof(UWidgetBlueprintLibrary) == 0x000008, "Wrong alignment on UWidgetBlueprintLibrary");
static_assert(sizeof(UWidgetBlueprintLibrary) == 0x000028, "Wrong size on UWidgetBlueprintLibrary");

// Class UMG.WidgetLayoutLibrary
// 0x0000 (0x0028 - 0x0028)
class UWidgetLayoutLibrary final : public UBlueprintFunctionLibrary
{
public:
	static struct FVector2D GetMousePositionOnPlatform()	 // 0x671340c;
	static struct FVector2D GetMousePositionOnViewport(class UObject* WorldContextObject)	 // 0x671343c;
	static bool GetMousePositionScaledByDPI(class APlayerController* Player, float* LocationX, float* LocationY)	 // 0x6713508;
	static struct FGeometry GetPlayerScreenWidgetGeometry(class APlayerController* PlayerController)	 // 0x6713718;
	static float GetViewportScale(const class UObject* WorldContextObject)	 // 0x67139c4;
	static struct FVector2D GetViewportSize(class UObject* WorldContextObject)	 // 0x17a9ad4;
	static struct FGeometry GetViewportWidgetGeometry(class UObject* WorldContextObject)	 // 0x6713a88;
	static bool ProjectWorldLocationToWidgetPosition(class APlayerController* PlayerController, const struct FVector& WorldLocation, struct FVector2D* ScreenPosition, bool bPlayerViewportRelative)	 // 0x6715c3c;
	static void RemoveAllWidgets(class UObject* WorldContextObject)	 // 0x6716504;
	static class UBorderSlot* SlotAsBorderSlot(class UWidget* Widget)	 // 0x1607780;
	static class UCanvasPanelSlot* SlotAsCanvasSlot(class UWidget* Widget)	 // 0xb47ba0;
	static class UGridSlot* SlotAsGridSlot(class UWidget* Widget)	 // 0x6719d28;
	static class UHorizontalBoxSlot* SlotAsHorizontalBoxSlot(class UWidget* Widget)	 // 0xb443cc;
	static class UOverlaySlot* SlotAsOverlaySlot(class UWidget* Widget)	 // 0xb1ae44;
	static class USafeZoneSlot* SlotAsSafeBoxSlot(class UWidget* Widget)	 // 0x6719e2c;
	static class UScaleBoxSlot* SlotAsScaleBoxSlot(class UWidget* Widget)	 // 0x6719f30;
	static class UScrollBoxSlot* SlotAsScrollBoxSlot(class UWidget* Widget)	 // 0x671a034;
	static class USizeBoxSlot* SlotAsSizeBoxSlot(class UWidget* Widget)	 // 0x1698f44;
	static class UUniformGridSlot* SlotAsUniformGridSlot(class UWidget* Widget)	 // 0x671a138;
	static class UVerticalBoxSlot* SlotAsVerticalBoxSlot(class UWidget* Widget)	 // 0xd8bd48;
	static class UWidgetSwitcherSlot* SlotAsWidgetSwitcherSlot(class UWidget* Widget)	 // 0x671a23c;
	static class UWrapBoxSlot* SlotAsWrapBoxSlot(class UWidget* Widget)	 // 0x671a340;

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"WidgetLayoutLibrary">();
	}
	static class UWidgetLayoutLibrary* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UWidgetLayoutLibrary>();
	}
};
static_assert(alignof(UWidgetLayoutLibrary) == 0x000008, "Wrong alignment on UWidgetLayoutLibrary");
static_assert(sizeof(UWidgetLayoutLibrary) == 0x000028, "Wrong size on UWidgetLayoutLibrary");

}

