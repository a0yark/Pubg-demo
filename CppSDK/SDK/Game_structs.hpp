#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: Game

#include "Basic.hpp"

#include "Engine_structs.hpp"
#include "SlateCore_structs.hpp"
#include "GameplayTags_structs.hpp"
#include "NetCore_structs.hpp"
#include "CoreUObject_structs.hpp"
#include "GameplayAbilities_structs.hpp"
#include "DataRegistry_structs.hpp"
#include "EnhancedInput_structs.hpp"
#include "InputCore_structs.hpp"
#include "AkAudio_structs.hpp"


namespace SDK
{

// Enum Game.EP2WwiseTeamStatus
// NumValues: 0x0004
enum class EP2WwiseTeamStatus : uint8
{
	Local                                    = 0,
	AlliedRemote                             = 1,
	EnemyRemote                              = 2,
	EP2WwiseTeamStatus_MAX                   = 3,
};

// Enum Game.EP2SkelMeshUpdateRateShiftBucket
// NumValues: 0x0007
enum class EP2SkelMeshUpdateRateShiftBucket : uint8
{
	ShiftBucket0                             = 0,
	ShiftBucket1                             = 1,
	ShiftBucket2                             = 2,
	ShiftBucket3                             = 3,
	ShiftBucket4                             = 4,
	ShiftBucket5                             = 5,
	EP2SkelMeshUpdateRateShiftBucket_MAX     = 6,
};

// Enum Game.EP2AnomalyMovingState
// NumValues: 0x0003
enum class EP2AnomalyMovingState : uint8
{
	Standing                                 = 0,
	Moving                                   = 1,
	EP2AnomalyMovingState_MAX                = 2,
};

// Enum Game.EP2AnomalyDeformationType
// NumValues: 0x0004
enum class EP2AnomalyDeformationType : uint8
{
	None                                     = 0,
	ShouldGrow                               = 1,
	ShouldShrink                             = 2,
	EP2AnomalyDeformationType_MAX            = 3,
};

// Enum Game.EP2ShutdownState
// NumValues: 0x0004
enum class EP2ShutdownState : uint8
{
	Disabled                                 = 0,
	Moving                                   = 1,
	Stopped                                  = 2,
	EP2ShutdownState_MAX                     = 3,
};

// Enum Game.EP2PlsdTab
// NumValues: 0x0008
enum class EP2PlsdTab : uint8
{
	Health                                   = 0,
	Character                                = 1,
	Contracts                                = 2,
	Map                                      = 3,
	Extract                                  = 4,
	NUM                                      = 5,
	None                                     = 6,
	EP2PlsdTab_MAX                           = 7,
};

// Enum Game.EP2PodDisplayState
// NumValues: 0x0005
enum class EP2PodDisplayState : uint8
{
	None                                     = 0,
	Free                                     = 1,
	Occupied                                 = 2,
	Extracting                               = 3,
	EP2PodDisplayState_MAX                   = 4,
};

// Enum Game.EP2ExfiltrationAUVState
// NumValues: 0x0009
enum class EP2ExfiltrationAUVState : uint8
{
	NotSet                                   = 0,
	Inactive                                 = 1,
	Activating                               = 2,
	Active                                   = 3,
	Occupied                                 = 4,
	BlockedByAnomaly                         = 5,
	Exfiltrating                             = 6,
	Exfiltrated                              = 7,
	EP2ExfiltrationAUVState_MAX              = 8,
};

// Enum Game.EP2ExtractionTunnelState
// NumValues: 0x0008
enum class EP2ExtractionTunnelState : uint8
{
	Inactive                                 = 0,
	Spawning                                 = 1,
	Idle                                     = 2,
	Initiation                               = 3,
	Formation                                = 4,
	Countdown                                = 5,
	Collapsed                                = 6,
	MAX                                      = 7,
};

// Enum Game.EMessageCategory
// NumValues: 0x0003
enum class EMessageCategory : uint8
{
	CATEGORY_NONE                            = 0,
	CATEGORY_WARNING                         = 1,
	CATEGORY_MAX                             = 2,
};

// Enum Game.EP2GameplayContextRequirementType
// NumValues: 0x0007
enum class EP2GameplayContextRequirementType : uint8
{
	EnableRequirement                        = 0,
	TriggerRequirement                       = 1,
	CompleteRequirement                      = 2,
	FailRequirement                          = 3,
	RestartRequirement                       = 4,
	None                                     = 5,
	EP2GameplayContextRequirementType_MAX    = 6,
};

// Enum Game.EP2ContextualHelperWidgetIconType
// NumValues: 0x0004
enum class EP2ContextualHelperWidgetIconType : uint8
{
	Info                                     = 0,
	Narrative                                = 1,
	Tip                                      = 2,
	EP2ContextualHelperWidgetIconType_MAX    = 3,
};

// Enum Game.EP2GameplayContextMessageType
// NumValues: 0x0005
enum class EP2GameplayContextMessageType : uint8
{
	Checkbox                                 = 0,
	Core                                     = 1,
	Normal                                   = 2,
	None                                     = 3,
	EP2GameplayContextMessageType_MAX        = 4,
};

// Enum Game.EP2LightLifeStateType
// NumValues: 0x0005
enum class EP2LightLifeStateType : uint8
{
	Indestructible                           = 0,
	Working                                  = 1,
	Damaged                                  = 2,
	Destroyed                                = 3,
	EP2LightLifeStateType_MAX                = 4,
};

// Enum Game.EP2LightOperatingStateType
// NumValues: 0x0003
enum class EP2LightOperatingStateType : uint8
{
	Off                                      = 0,
	On                                       = 1,
	EP2LightOperatingStateType_MAX           = 2,
};

// Enum Game.EP2LightGamplayTagEventType
// NumValues: 0x0003
enum class EP2LightGamplayTagEventType : uint8
{
	Added                                    = 0,
	Removed                                  = 1,
	EP2LightGamplayTagEventType_MAX          = 2,
};

// Enum Game.EP2ContractRequirementState
// NumValues: 0x0004
enum class EP2ContractRequirementState : uint8
{
	Uncomplete                               = 0,
	Complete                                 = 1,
	Unset                                    = 2,
	EP2ContractRequirementState_MAX          = 3,
};

// Enum Game.EP2ContractState
// NumValues: 0x0007
enum class EP2ContractState : uint8
{
	Unavailable                              = 0,
	Available                                = 1,
	Active                                   = 2,
	Claimable                                = 3,
	Completed                                = 4,
	Canceled                                 = 5,
	EP2ContractState_MAX                     = 6,
};

// Enum Game.EP2MapProjectionMode
// NumValues: 0x0004
enum class EP2MapProjectionMode : uint8
{
	Perspective                              = 0,
	Orthographic                             = 1,
	OrthographicTiling                       = 2,
	EP2MapProjectionMode_MAX                 = 3,
};

// Enum Game.EP2MapDeploymentZoneState
// NumValues: 0x0006
enum class EP2MapDeploymentZoneState : uint8
{
	Unavailable                              = 0,
	FullUnselected                           = 1,
	Available                                = 2,
	Selected                                 = 3,
	SelectedFull                             = 4,
	EP2MapDeploymentZoneState_MAX            = 5,
};

// Enum Game.EDoorState
// NumValues: 0x0004
enum class EDoorState : uint8
{
	Closed                                   = 0,
	Open                                     = 1,
	SpecificAlpha                            = 2,
	EDoorState_MAX                           = 3,
};

// Enum Game.EP2OperationalTaskNodeState
// NumValues: 0x0004
enum class EP2OperationalTaskNodeState : uint8
{
	Unavailable                              = 0,
	Available                                = 1,
	Completed                                = 2,
	EP2OperationalTaskNodeState_MAX          = 3,
};

// Enum Game.EP2OperationalTaskStageRequirementState
// NumValues: 0x0004
enum class EP2OperationalTaskStageRequirementState : uint8
{
	Uncomplete                               = 0,
	Complete                                 = 1,
	Unset                                    = 2,
	EP2OperationalTaskStageRequirementState_MAX = 3,
};

// Enum Game.EP2OperationalTaskStageState
// NumValues: 0x0005
enum class EP2OperationalTaskStageState : uint8
{
	Unavailable                              = 0,
	InProgress                               = 1,
	Claimable                                = 2,
	Completed                                = 3,
	EP2OperationalTaskStageState_MAX         = 4,
};

// Enum Game.EP2ResearchNodeRequirementState
// NumValues: 0x0004
enum class EP2ResearchNodeRequirementState : uint8
{
	Uncomplete                               = 0,
	Complete                                 = 1,
	Unset                                    = 2,
	EP2ResearchNodeRequirementState_MAX      = 3,
};

// Enum Game.EP2ResearchNodeState
// NumValues: 0x0005
enum class EP2ResearchNodeState : uint8
{
	Unavailable                              = 0,
	Available                                = 1,
	Claimable                                = 2,
	Completed                                = 3,
	EP2ResearchNodeState_MAX                 = 4,
};

// Enum Game.EP2ResearchStepState
// NumValues: 0x0006
enum class EP2ResearchStepState : uint8
{
	Unavailable                              = 0,
	Available                                = 1,
	Ready                                    = 2,
	InProgress                               = 3,
	Completed                                = 4,
	EP2ResearchStepState_MAX                 = 5,
};

// Enum Game.EP2ContractRequirementType
// NumValues: 0x0004
enum class EP2ContractRequirementType : uint8
{
	Acceptance                               = 0,
	Completion                               = 1,
	Optional                                 = 2,
	EP2ContractRequirementType_MAX           = 3,
};

// Enum Game.EP2ContractLoggedState
// NumValues: 0x0004
enum class EP2ContractLoggedState : uint8
{
	Canceled                                 = 0,
	Completed                                = 1,
	Timedout                                 = 2,
	EP2ContractLoggedState_MAX               = 3,
};

// Enum Game.EP2ContextHelperSkipModeType
// NumValues: 0x0004
enum class EP2ContextHelperSkipModeType : uint8
{
	NoSkip                                   = 0,
	SkipOnlyTutorial                         = 1,
	SkipAll                                  = 2,
	EP2ContextHelperSkipModeType_MAX         = 3,
};

// Enum Game.EP2GameplayContextRequirementState
// NumValues: 0x0004
enum class EP2GameplayContextRequirementState : uint8
{
	Uncompleted                              = 0,
	Completed                                = 1,
	None                                     = 2,
	EP2GameplayContextRequirementState_MAX   = 3,
};

// Enum Game.EP2GameplayContextStateChangedReason
// NumValues: 0x0005
enum class EP2GameplayContextStateChangedReason : uint8
{
	Update                                   = 0,
	Override                                 = 1,
	Reset                                    = 2,
	None                                     = 3,
	EP2GameplayContextStateChangedReason_MAX = 4,
};

// Enum Game.EP2GameplayContextState
// NumValues: 0x0007
enum class EP2GameplayContextState : uint8
{
	Disabled                                 = 0,
	Enabled                                  = 1,
	Triggered                                = 2,
	Completed                                = 3,
	Failed                                   = 4,
	None                                     = 5,
	EP2GameplayContextState_MAX              = 6,
};

// Enum Game.EP2CategoryState
// NumValues: 0x0005
enum class EP2CategoryState : uint8
{
	All                                      = 0,
	Wishlist                                 = 1,
	MainCategory                             = 2,
	SubCategory                              = 3,
	EP2CategoryState_MAX                     = 4,
};

// Enum Game.EPopupButtonID
// NumValues: 0x0008
enum class EPopupButtonID : uint8
{
	Cancel_Or_No                             = 0,
	Yes_Or_OK                                = 1,
	Neutral                                  = 2,
	Default                                  = 3,
	Clear                                    = 4,
	Replace                                  = 5,
	Back                                     = 6,
	EPopupButtonID_MAX                       = 7,
};

// Enum Game.EP2ScalableFloatCurveType
// NumValues: 0x0005
enum class EP2ScalableFloatCurveType : uint8
{
	None                                     = 0,
	Distance                                 = 1,
	EffectLevel                              = 2,
	StackCount                               = 3,
	EP2ScalableFloatCurveType_MAX            = 4,
};

// Enum Game.EP2ButtonActionAudioType
// NumValues: 0x0005
enum class EP2ButtonActionAudioType : uint8
{
	None                                     = 0,
	Pressed                                  = 1,
	Released                                 = 2,
	Hovered                                  = 3,
	EP2ButtonActionAudioType_MAX             = 4,
};

// Enum Game.EInventoryDragType
// NumValues: 0x0008
enum class EInventoryDragType : uint8
{
	Normal                                   = 0,
	Move                                     = 1,
	Equip                                    = 2,
	Swap                                     = 3,
	Swap_Attachment                          = 4,
	Discard                                  = 5,
	Unavailable                              = 6,
	EInventoryDragType_MAX                   = 7,
};

// Enum Game.EP2DisplayDurabilityType
// NumValues: 0x0003
enum class EP2DisplayDurabilityType : uint8
{
	InventoryItem                            = 0,
	DetailPopup                              = 1,
	EP2DisplayDurabilityType_MAX             = 2,
};

// Enum Game.EP2SlotBlockQueryType
// NumValues: 0x0004
enum class EP2SlotBlockQueryType : uint8
{
	Unblocked                                = 0,
	Blocked                                  = 1,
	All                                      = 2,
	EP2SlotBlockQueryType_MAX                = 3,
};

// Enum Game.EP2SlotModQueryType
// NumValues: 0x0004
enum class EP2SlotModQueryType : uint8
{
	Attachments                              = 0,
	Mods                                     = 1,
	All                                      = 2,
	EP2SlotModQueryType_MAX                  = 3,
};

// Enum Game.EP2ExchangeInfoRandomGrade
// NumValues: 0x0004
enum class EP2ExchangeInfoRandomGrade : uint8
{
	Fail                                     = 0,
	Good                                     = 1,
	Great                                    = 2,
	EP2ExchangeInfoRandomGrade_MAX           = 3,
};

// Enum Game.EP2ContractItemWidgetState
// NumValues: 0x0005
enum class EP2ContractItemWidgetState : uint8
{
	None                                     = 0,
	Default                                  = 1,
	Selected                                 = 2,
	Disabled                                 = 3,
	EP2ContractItemWidgetState_MAX           = 4,
};

// Enum Game.EP2ContractType
// NumValues: 0x0007
enum class EP2ContractType : uint8
{
	Contract                                 = 0,
	Mission                                  = 1,
	RaidContract                             = 2,
	Tutorial                                 = 3,
	TimedEvent                               = 4,
	Side                                     = 5,
	EP2ContractType_MAX                      = 6,
};

// Enum Game.EP2ItemPlacement
// NumValues: 0x0004
enum class EP2ItemPlacement : uint8
{
	None                                     = 0,
	InGrid                                   = 1,
	InSlot                                   = 2,
	EP2ItemPlacement_MAX                     = 3,
};

// Enum Game.EP2ItemWidgetPropertiesSize
// NumValues: 0x0005
enum class EP2ItemWidgetPropertiesSize : uint8
{
	Small                                    = 0,
	Medium                                   = 1,
	Large                                    = 2,
	XLarge                                   = 3,
	EP2ItemWidgetPropertiesSize_MAX          = 4,
};

// Enum Game.EP2AspectRatio
// NumValues: 0x0006
enum class EP2AspectRatio : uint8
{
	None                                     = 0,
	Classic                                  = 1,
	Laptop                                   = 2,
	WideScreen                               = 3,
	UltraWide                                = 4,
	EP2AspectRatio_MAX                       = 5,
};

// Enum Game.EP2VoiceChatMode
// NumValues: 0x0005
enum class EP2VoiceChatMode : uint8
{
	PushToTalk                               = 0,
	AlwaysOnForTeam                          = 1,
	AlwaysOnForProximity                     = 2,
	Disabled                                 = 3,
	EP2VoiceChatMode_MAX                     = 4,
};

// Enum Game.EP2DLSSMode
// NumValues: 0x000A
enum class EP2DLSSMode : uint8
{
	Off                                      = 0,
	Auto                                     = 1,
	DLAA                                     = 2,
	UltraQuality                             = 3,
	Quality                                  = 4,
	Balanced                                 = 5,
	Performance                              = 6,
	UltraPerformance                         = 7,
	DynamicResolution                        = 8,
	EP2DLSSMode_MAX                          = 9,
};

// Enum Game.EP2FSR3QualityMode
// NumValues: 0x0007
enum class EP2FSR3QualityMode : uint8
{
	NativeAA                                 = 0,
	Quality                                  = 1,
	Balanced                                 = 2,
	Performance                              = 3,
	HighPerformance                          = 4,
	DynamicResolution                        = 5,
	EP2FSR3QualityMode_MAX                   = 6,
};

// Enum Game.EP2AntialiasingMethod
// NumValues: 0x0007
enum class EP2AntialiasingMethod : uint8
{
	OFF                                      = 0,
	FXAA                                     = 1,
	TAA                                      = 2,
	TSR                                      = 3,
	FSR3                                     = 4,
	DLSS                                     = 5,
	EP2AntialiasingMethod_MAX                = 6,
};

// Enum Game.EP2RenderScaleMethod
// NumValues: 0x0005
enum class EP2RenderScaleMethod : uint8
{
	FHD                                      = 0,
	Manual                                   = 1,
	Native                                   = 2,
	DynamicResolution                        = 3,
	EP2RenderScaleMethod_MAX                 = 4,
};

// Enum Game.EP2AllyHealthStatus
// NumValues: 0x0005
enum class EP2AllyHealthStatus : uint8
{
	Invalid                                  = 0,
	Alive                                    = 1,
	Dbno                                     = 2,
	Dead                                     = 3,
	EP2AllyHealthStatus_MAX                  = 4,
};

// Enum Game.EInputMode
// NumValues: 0x0005
enum class EInputMode : uint8
{
	None                                     = 0,
	GameAndUI                                = 1,
	OnlyUI                                   = 2,
	OnlyGame                                 = 3,
	EInputMode_MAX                           = 4,
};

// Enum Game.EKeyFocusMoveDir
// NumValues: 0x0005
enum class EKeyFocusMoveDir : uint8
{
	Dir_UP                                   = 0,
	Dir_Down                                 = 1,
	Dir_Left                                 = 2,
	Dir_Right                                = 3,
	Dir_MAX                                  = 4,
};

// Enum Game.EP2ItemActionWidgetType
// NumValues: 0x0004
enum class EP2ItemActionWidgetType : uint8
{
	None                                     = 0,
	Inventory                                = 1,
	Trading                                  = 2,
	EP2ItemActionWidgetType_MAX              = 3,
};

// Enum Game.EP2ItemIconFitType
// NumValues: 0x0003
enum class EP2ItemIconFitType : uint8
{
	FixedSize                                = 0,
	AutoExpand                               = 1,
	EP2ItemIconFitType_MAX                   = 2,
};

// Enum Game.EPopupStyle
// NumValues: 0x000B
enum class EPopupStyle : uint8
{
	Accept_Cancel                            = 0,
	Confirm_Cancel                           = 1,
	Confirm                                  = 2,
	Yes_No                                   = 3,
	Save_Discard                             = 4,
	Proceed_Recheck                          = 5,
	Cancel_Clear                             = 6,
	Back_Replace                             = 7,
	Back                                     = 8,
	QuickPurchase                            = 9,
	EPopupStyle_MAX                          = 10,
};

// Enum Game.EP2DestructibleState
// NumValues: 0x0005
enum class EP2DestructibleState : uint8
{
	Indestructible                           = 0,
	Undamaged                                = 1,
	Damaged                                  = 2,
	Destroyed                                = 3,
	EP2DestructibleState_MAX                 = 4,
};

// Enum Game.EP2HitType
// NumValues: 0x0004
enum class EP2HitType : uint8
{
	Melee                                    = 0,
	Bullet                                   = 1,
	Explosion                                = 2,
	EP2HitType_MAX                           = 3,
};

// Enum Game.EP2LockState
// NumValues: 0x0004
enum class EP2LockState : uint8
{
	Inaccessible                             = 0,
	Locked                                   = 1,
	Unlocked                                 = 2,
	EP2LockState_MAX                         = 3,
};

// Enum Game.EP2LootSpawnBias
// NumValues: 0x0007
enum class EP2LootSpawnBias : uint8
{
	LSB_INVALID                              = 0,
	LSB_VeryLow                              = 1,
	LSB_Low                                  = 2,
	LSB_Medium                               = 4,
	LSB_High                                 = 8,
	LSB_VeryHigh                             = 16,
	LSB_Max                                  = 32,
};

// Enum Game.EP2LootSpawnPointType
// NumValues: 0x0004
enum class EP2LootSpawnPointType : uint8
{
	Item                                     = 0,
	Crate                                    = 1,
	Any                                      = 2,
	MAX                                      = 3,
};

// Enum Game.EP2OperationalTaskNodeRequirementType
// NumValues: 0x0003
enum class EP2OperationalTaskNodeRequirementType : uint8
{
	Acceptance                               = 0,
	Completion                               = 1,
	EP2OperationalTaskNodeRequirementType_MAX = 2,
};

// Enum Game.EP2ResearchNodeRequirementType
// NumValues: 0x0003
enum class EP2ResearchNodeRequirementType : uint8
{
	Acceptance                               = 0,
	Completion                               = 1,
	EP2ResearchNodeRequirementType_MAX       = 2,
};

// Enum Game.EP2GripType
// NumValues: 0x0004
enum class EP2GripType : uint8
{
	RightHand                                = 0,
	LeftHand                                 = 1,
	Both                                     = 2,
	EP2GripType_MAX                          = 3,
};

// Enum Game.EP2MeshReturnType
// NumValues: 0x0004
enum class EP2MeshReturnType : uint8
{
	None                                     = 0,
	FPP                                      = 1,
	TPP                                      = 2,
	EP2MeshReturnType_MAX                    = 3,
};

// Enum Game.EP2ChamberType
// NumValues: 0x0004
enum class EP2ChamberType : uint8
{
	Auto                                     = 0,
	SemiAuto                                 = 1,
	Manual                                   = 2,
	EP2ChamberType_MAX                       = 3,
};

// Enum Game.EP2Firemode
// NumValues: 0x0004
enum class EP2Firemode : uint8
{
	Single                                   = 0,
	Burst                                    = 1,
	FullAuto                                 = 2,
	EP2Firemode_MAX                          = 3,
};

// Enum Game.EP2CharacterConnectionStatus
// NumValues: 0x0004
enum class EP2CharacterConnectionStatus : uint8
{
	None                                     = 0,
	InRaid                                   = 1,
	Hideout                                  = 2,
	EP2CharacterConnectionStatus_MAX         = 3,
};

// Enum Game.EP2ModdingFactilityCameraMoveType
// NumValues: 0x0003
enum class EP2ModdingFactilityCameraMoveType : uint8
{
	Focus_ModifyItemActor                    = 0,
	Focus_HologramModifyItemActor            = 1,
	Focus_MAX                                = 2,
};

// Enum Game.EP2ArmorMaterialType
// NumValues: 0x000A
enum class EP2ArmorMaterialType : uint8
{
	Kevlar                                   = 0,
	Twalon                                   = 1,
	Spectra                                  = 2,
	Ceramic                                  = 3,
	Metal                                    = 4,
	HardFiberLaminate                        = 5,
	Acrylic                                  = 6,
	Polycarbonate                            = 7,
	PMMAPC                                   = 8,
	EP2ArmorMaterialType_MAX                 = 9,
};

// Enum Game.EP2InGameMailCategory
// NumValues: 0x0006
enum class EP2InGameMailCategory : uint8
{
	Normal                                   = 0,
	Drone                                    = 1,
	Facility                                 = 2,
	Unlock                                   = 3,
	Survey                                   = 4,
	EP2InGameMailCategory_MAX                = 5,
};

// Enum Game.EP2MarkerType
// NumValues: 0x000A
enum class EP2MarkerType : uint8
{
	MapMarker                                = 0,
	Move                                     = 1,
	Danger                                   = 2,
	Defend                                   = 3,
	Attack                                   = 4,
	Loot                                     = 5,
	Contract                                 = 6,
	Waypoint                                 = 7,
	PingMarker                               = 8,
	EP2MarkerType_MAX                        = 9,
};

// Enum Game.EInventoryContainerType
// NumValues: 0x0006
enum class EInventoryContainerType : uint8
{
	OnlyInternalInventory                    = 0,
	OnlyInventory                            = 1,
	OnlyStash                                = 2,
	InventoryAndStash                        = 3,
	StashAndInventory                        = 4,
	EInventoryContainerType_MAX              = 5,
};

// Enum Game.EP2EconomyActionType
// NumValues: 0x0020
enum class EP2EconomyActionType : uint8
{
	None                                     = 0,
	Trade                                    = 1,
	Barter                                   = 2,
	QuickPurchase_Modding                    = 3,
	QuickPurchase_FacilityInstall            = 4,
	QuickPurchase_DecorationFacilityInstall  = 5,
	QuickPurchase_FacilityUpgrade            = 6,
	QuickPurchase_Crafting                   = 7,
	QuickPurchase_HideoutExpand              = 8,
	QuickPurchase_Outfitting                 = 9,
	QuickPurchase_Research                   = 10,
	QuickPurchase_LoadoutPreset              = 11,
	Resupply                                 = 12,
	Mail                                     = 13,
	Reward                                   = 14,
	Cheat                                    = 15,
	FactionWage                              = 16,
	Offer                                    = 17,
	ClothingUpgrade_Upgrade                  = 18,
	Facility_Destroy                         = 19,
	FacilityInstall                          = 20,
	FacilityInstall_Cancel                   = 21,
	FacilityModuleInstall                    = 22,
	FacilityModuleInstall_Cancel             = 23,
	FacilityModuleUninstall                  = 24,
	FacilityModuleUninstall_Cancel           = 25,
	Craft                                    = 26,
	Craft_Cancel                             = 27,
	Initialize                               = 28,
	ApplyPreset                              = 29,
	PlayerDataLoad                           = 30,
	EP2EconomyActionType_MAX                 = 31,
};

// Enum Game.EP2UpsellingStoreType
// NumValues: 0x0005
enum class EP2UpsellingStoreType : uint8
{
	GENERAL                                  = 0,
	ALPHA                                    = 1,
	BRAVO                                    = 2,
	CHARLIE                                  = 3,
	EP2UpsellingStoreType_MAX                = 4,
};

// Enum Game.EP2AbilityActivationPolicy
// NumValues: 0x0005
enum class EP2AbilityActivationPolicy : uint8
{
	OnInputTriggered                         = 0,
	WhileInputActive                         = 1,
	WhileInputActiveTriggerOnce              = 2,
	OnSpawn                                  = 3,
	EP2AbilityActivationPolicy_MAX           = 4,
};

// Enum Game.EP2AbilityActivationGroup
// NumValues: 0x0004
enum class EP2AbilityActivationGroup : uint8
{
	Independent                              = 0,
	Exclusive_Replaceable                    = 1,
	Exclusive_Blocking                       = 2,
	MAX                                      = 3,
};

// Enum Game.EP2ReloadType
// NumValues: 0x0009
enum class EP2ReloadType : uint8
{
	MagazineSwap                             = 0,
	MagazineRemove                           = 1,
	MagazineAdd                              = 2,
	Load                                     = 3,
	Chamber                                  = 4,
	ReplaceAmmo                              = 5,
	LoadIntoChamber                          = 6,
	None                                     = 7,
	EP2ReloadType_MAX                        = 8,
};

// Enum Game.EPlsdViewType
// NumValues: 0x0004
enum class EPlsdViewType : uint8
{
	Wrist                                    = 0,
	Full                                     = 1,
	None                                     = 2,
	EPlsdViewType_MAX                        = 3,
};

// Enum Game.EP2ThrowState
// NumValues: 0x0005
enum class EP2ThrowState : uint8
{
	Idle                                     = 1,
	Prepare                                  = 2,
	Ready                                    = 4,
	Throw                                    = 8,
	EP2ThrowState_MAX                        = 9,
};

// Enum Game.EP2RequirementsFailReason
// NumValues: 0x0004
enum class EP2RequirementsFailReason : uint8
{
	None                                     = 0,
	NotEnoughSpace                           = 1,
	RequiresItem                             = 2,
	EP2RequirementsFailReason_MAX            = 3,
};

// Enum Game.EP2AkEventLocality
// NumValues: 0x0004
enum class EP2AkEventLocality : uint8
{
	SingleEvent                              = 0,
	LocalRemote                              = 1,
	LocalRemoteAlliedEnemy                   = 2,
	EP2AkEventLocality_MAX                   = 3,
};

// Enum Game.EAkEventLocalityType
// NumValues: 0x0004
enum class EAkEventLocalityType : uint8
{
	PlayInWorld                              = 0,
	PlayOnActorAkComponent                   = 1,
	CreateNewAkComponent                     = 2,
	EAkEventLocalityType_MAX                 = 3,
};

// Enum Game.EP2AKVolumePriority
// NumValues: 0x0004
enum class EP2AKVolumePriority : uint8
{
	VolumePriority_Global                    = 0,
	VolumePriority_SemiGlobal                = 1,
	VolumePriority_Indoor                    = 2,
	VolumePriority_MAX                       = 3,
};

// Enum Game.EMoveActionEndStance
// NumValues: 0x0003
enum class EMoveActionEndStance : uint8
{
	Stand                                    = 0,
	Crouch                                   = 1,
	EMoveActionEndStance_MAX                 = 2,
};

// Enum Game.EP2MontagePerspective
// NumValues: 0x0004
enum class EP2MontagePerspective : uint8
{
	FPP                                      = 0,
	TPP                                      = 1,
	Item                                     = 2,
	EP2MontagePerspective_MAX                = 3,
};

// Enum Game.EP2MoveActionCancelType
// NumValues: 0x0004
enum class EP2MoveActionCancelType : uint8
{
	None                                     = 0,
	Reverse                                  = 1,
	JumpOff                                  = 2,
	EP2MoveActionCancelType_MAX              = 3,
};

// Enum Game.EAnomalyReqCurveValueTypes
// NumValues: 0x0007
enum class EAnomalyReqCurveValueTypes : uint8
{
	Area                                     = 0,
	DeployCoastLine                          = 1,
	MaxShrinkSpeed                           = 2,
	MaxGrowSpeed                             = 3,
	AnomalyWarningKeysTime                   = 4,
	AnomalyWarningStopMoving                 = 5,
	EAnomalyReqCurveValueTypes_MAX           = 6,
};

// Enum Game.EP2BubblePhase
// NumValues: 0x0006
enum class EP2BubblePhase : uint8
{
	None                                     = 0,
	WaitToStart                              = 1,
	ToFrom                                   = 2,
	Stay                                     = 3,
	Disappear                                = 4,
	EP2BubblePhase_MAX                       = 5,
};

// Enum Game.EP2ModifierOp
// NumValues: 0x0004
enum class EP2ModifierOp : uint8
{
	Add                                      = 0,
	AddPercent                               = 1,
	Multiply                                 = 2,
	EP2ModifierOp_MAX                        = 3,
};

// Enum Game.EP2AttributeClampMode
// NumValues: 0x0004
enum class EP2AttributeClampMode : uint8
{
	NoClamp                                  = 0,
	Float                                    = 1,
	Attribute                                = 2,
	EP2AttributeClampMode_MAX                = 3,
};

// Enum Game.EP2AUVInteractionStage
// NumValues: 0x0005
enum class EP2AUVInteractionStage : uint8
{
	None                                     = 0,
	Entering                                 = 1,
	Idle                                     = 2,
	Exiting                                  = 3,
	EP2AUVInteractionStage_MAX               = 4,
};

// Enum Game.EP2BulletPassByLocation
// NumValues: 0x0003
enum class EP2BulletPassByLocation : uint8
{
	DetectionAreaEntry                       = 0,
	ClosestToListener                        = 1,
	EP2BulletPassByLocation_MAX              = 2,
};

// Enum Game.EP2BulletHitType
// NumValues: 0x0004
enum class EP2BulletHitType : uint8
{
	Blocking                                 = 0,
	PenetrationEnter                         = 1,
	PenetrationExit                          = 2,
	EP2BulletHitType_MAX                     = 3,
};

// Enum Game.EP2BulletHitProcessingPolicy
// NumValues: 0x0006
enum class EP2BulletHitProcessingPolicy : uint8
{
	Default                                  = 0,
	NoPhysics                                = 1,
	KillAmmoInstance                         = 2,
	GenerateHitEvent                         = 3,
	ServerValidate                           = 4,
	EP2BulletHitProcessingPolicy_MAX         = 5,
};

// Enum Game.EP2CameraModeBlendFunction
// NumValues: 0x0006
enum class EP2CameraModeBlendFunction : uint8
{
	Linear                                   = 0,
	EaseIn                                   = 1,
	EaseOut                                  = 2,
	EaseInOut                                = 3,
	COUNT                                    = 4,
	EP2CameraModeBlendFunction_MAX           = 5,
};

// Enum Game.ECharacterStance
// NumValues: 0x0004
enum class ECharacterStance : uint8
{
	Stand                                    = 0,
	Crouch                                   = 1,
	Dbno                                     = 2,
	ECharacterStance_MAX                     = 3,
};

// Enum Game.EAnimArmState
// NumValues: 0x0007
enum class EAnimArmState : uint8
{
	Hipfire                                  = 0,
	Aim                                      = 1,
	Uneasy                                   = 2,
	PLSD                                     = 3,
	FullPLSD                                 = 4,
	Healing                                  = 5,
	EAnimArmState_MAX                        = 6,
};

// Enum Game.ESecondaryState
// NumValues: 0x0003
enum class ESecondaryState : uint8
{
	None                                     = 0,
	Swimming                                 = 1,
	ESecondaryState_MAX                      = 2,
};

// Enum Game.EMovementDirection
// NumValues: 0x0009
enum class EMovementDirection : uint8
{
	B                                        = 0,
	BL                                       = 1,
	L                                        = 2,
	FL                                       = 3,
	F                                        = 4,
	FR                                       = 5,
	R                                        = 6,
	BR                                       = 7,
	EMovementDirection_MAX                   = 8,
};

// Enum Game.ECardinalDirection
// NumValues: 0x0005
enum class ECardinalDirection : uint8
{
	F                                        = 0,
	B                                        = 1,
	L                                        = 2,
	R                                        = 3,
	ECardinalDirection_MAX                   = 4,
};

// Enum Game.ERootYawOffsetMode
// NumValues: 0x0004
enum class ERootYawOffsetMode : uint8
{
	BlendOut                                 = 0,
	Hold                                     = 1,
	Accumulate                               = 2,
	ERootYawOffsetMode_MAX                   = 3,
};

// Enum Game.EP2SwimSurfaceType
// NumValues: 0x0003
enum class EP2SwimSurfaceType : uint8
{
	AboveSurface                             = 0,
	BellowSurface                            = 1,
	EP2SwimSurfaceType_MAX                   = 2,
};

// Enum Game.EP2RewardType
// NumValues: 0x0005
enum class EP2RewardType : uint8
{
	Contract                                 = 0,
	MessageHub                               = 1,
	OperationalTask                          = 2,
	None                                     = 3,
	EP2RewardType_MAX                        = 4,
};

// Enum Game.EP2ContextMenuStatus
// NumValues: 0x0005
enum class EP2ContextMenuStatus : uint8
{
	None                                     = 0,
	Normal                                   = 1,
	Select                                   = 2,
	Disable                                  = 3,
	EP2ContextMenuStatus_MAX                 = 4,
};

// Enum Game.EP2ContractRewardType
// NumValues: 0x0006
enum class EP2ContractRewardType : uint8
{
	Item                                     = 0,
	Exp                                      = 1,
	Money                                    = 2,
	UnKnown                                  = 3,
	FactionRequtation                        = 4,
	EP2ContractRewardType_MAX                = 5,
};

// Enum Game.ECrosshairPropertyOverride
// NumValues: 0x0004
enum class ECrosshairPropertyOverride : uint8
{
	Default                                  = 0,
	ForceEnable                              = 1,
	ForceDisable                             = 2,
	ECrosshairPropertyOverride_MAX           = 3,
};

// Enum Game.EP2DeployableState
// NumValues: 0x0005
enum class EP2DeployableState : uint8
{
	ITEM                                     = 0,
	INACTIVE                                 = 1,
	DEPLOYED                                 = 2,
	DISABLED                                 = 3,
	EP2DeployableState_MAX                   = 4,
};

// Enum Game.EP2DeployZoneUnavailableReason
// NumValues: 0x0003
enum class EP2DeployZoneUnavailableReason : uint8
{
	Available                                = 0,
	JumpTicketRequired                       = 1,
	EP2DeployZoneUnavailableReason_MAX       = 2,
};

// Enum Game.EP2DetailPopupAttachmentsType
// NumValues: 0x0004
enum class EP2DetailPopupAttachmentsType : uint8
{
	Attachments                              = 0,
	ModParts                                 = 1,
	Chamber                                  = 2,
	EP2DetailPopupAttachmentsType_MAX        = 3,
};

// Enum Game.EP2DialogueQueryPriority
// NumValues: 0x0005
enum class EP2DialogueQueryPriority : uint8
{
	Low                                      = 0,
	Medium                                   = 1,
	High                                     = 2,
	Critical                                 = 3,
	EP2DialogueQueryPriority_MAX             = 4,
};

// Enum Game.EP2DialogueQueryType
// NumValues: 0x0006
enum class EP2DialogueQueryType : uint8
{
	Verbal                                   = 0,
	StatusEffects                            = 1,
	Vocalisation                             = 2,
	Damage                                   = 3,
	Actions                                  = 4,
	EP2DialogueQueryType_MAX                 = 5,
};

// Enum Game.EDialogueArgumentType
// NumValues: 0x0009
enum class EDialogueArgumentType : uint8
{
	DialogueTrigger                          = 0,
	DialoguePerspective                      = 1,
	DialogueActionState                      = 2,
	DialogueEquipment                        = 3,
	DialogueDamageSeverity                   = 4,
	DialogueInjuryState                      = 5,
	DialogueMovementSubType                  = 6,
	DialogueVoice                            = 7,
	EDialogueArgumentType_MAX                = 8,
};

// Enum Game.EP2DistanceTrackDelegateType
// NumValues: 0x0005
enum class EP2DistanceTrackDelegateType : uint8
{
	EntersRadius                             = 0,
	ExitsRadius                              = 1,
	EntersRadiusVincinity                    = 2,
	ExitsRadiusVincinity                     = 3,
	EP2DistanceTrackDelegateType_MAX         = 4,
};

// Enum Game.EP2DayOfWeek
// NumValues: 0x0009
enum class EP2DayOfWeek : uint8
{
	None                                     = 8,
	Monday                                   = 0,
	Tuesday                                  = 1,
	Wednesday                                = 2,
	Thursday                                 = 3,
	Friday                                   = 4,
	Saturday                                 = 5,
	Sunday                                   = 6,
	EP2DayOfWeek_MAX                         = 9,
};

// Enum Game.EP2ContractRequirementCompleteCondition
// NumValues: 0x000F
enum class EP2ContractRequirementCompleteCondition : uint8
{
	Collect                                  = 0,
	Contract                                 = 1,
	Date                                     = 2,
	Deliver                                  = 3,
	Enter                                    = 4,
	EnterTrigger                             = 5,
	Facility                                 = 6,
	Instruction                              = 7,
	Interact                                 = 8,
	Kill                                     = 9,
	PMCLevel                                 = 10,
	Reputation                               = 11,
	Timeout                                  = 12,
	None                                     = 13,
	EP2ContractRequirementCompleteCondition_MAX = 14,
};

// Enum Game.EP2ContractOrder
// NumValues: 0x0003
enum class EP2ContractOrder : uint8
{
	NotOrdered                               = 0,
	FactionReputationAndDifficulty           = 1,
	EP2ContractOrder_MAX                     = 2,
};

// Enum Game.EP2ContractDifficulty
// NumValues: 0x0006
enum class EP2ContractDifficulty : uint8
{
	None                                     = 0,
	Easy                                     = 1,
	Medium                                   = 2,
	Hard                                     = 3,
	Deadly                                   = 4,
	MAX                                      = 5,
};

// Enum Game.EP2FiremodeState
// NumValues: 0x000A
enum class EP2FiremodeState : uint8
{
	CannotFire                               = 0,
	Ready                                    = 1,
	Charging                                 = 2,
	PointOfNoReturn                          = 3,
	Overcharging                             = 4,
	RateOfFireCooldown                       = 5,
	PostBurstCooldown                        = 6,
	ChargeCooldown                           = 7,
	OverchargeCooldown                       = 8,
	EP2FiremodeState_MAX                     = 9,
};

// Enum Game.EP2WaterPositionType
// NumValues: 0x0004
enum class EP2WaterPositionType : uint8
{
	OFF_WATER                                = 0,
	INTERSECT_WATER                          = 1,
	UNDERWATER                               = 2,
	EP2WaterPositionType_MAX                 = 3,
};

// Enum Game.EP2LowSpecHardwareType
// NumValues: 0x0003
enum class EP2LowSpecHardwareType : uint8
{
	CPU                                      = 0,
	GPU                                      = 1,
	EP2LowSpecHardwareType_MAX               = 2,
};

// Enum Game.EP2OptionPopupType
// NumValues: 0x0003
enum class EP2OptionPopupType : uint8
{
	UnsavedChanges                           = 0,
	RequireConfirmation                      = 1,
	EP2OptionPopupType_MAX                   = 2,
};

// Enum Game.EP2TutorialWidgetType
// NumValues: 0x0003
enum class EP2TutorialWidgetType : uint8
{
	Guide                                    = 0,
	Highlight                                = 1,
	EP2TutorialWidgetType_MAX                = 2,
};

// Enum Game.EP2WidgetHighlightType
// NumValues: 0x0003
enum class EP2WidgetHighlightType : uint8
{
	Source                                   = 0,
	Target                                   = 1,
	EP2WidgetHighlightType_MAX               = 2,
};

// Enum Game.EP2HighlightInventoryWidgetType
// NumValues: 0x0004
enum class EP2HighlightInventoryWidgetType : uint8
{
	None                                     = 0,
	Slot                                     = 1,
	Item                                     = 2,
	EP2HighlightInventoryWidgetType_MAX      = 3,
};

// Enum Game.EP2GameplayContextRequirementAbilityActionType
// NumValues: 0x0005
enum class EP2GameplayContextRequirementAbilityActionType : uint8
{
	Activated                                = 0,
	Committed                                = 1,
	Failed                                   = 2,
	Ended                                    = 3,
	EP2GameplayContextRequirementAbilityActionType_MAX = 4,
};

// Enum Game.EP2GameplayContextRequirementInventoryComparison
// NumValues: 0x0005
enum class EP2GameplayContextRequirementInventoryComparison : uint8
{
	GreaterThan                              = 0,
	LessThan                                 = 1,
	Equal                                    = 2,
	Change                                   = 3,
	EP2GameplayContextRequirementInventoryComparison_MAX = 4,
};

// Enum Game.EP2ContextRequirement_ItemRequirementsSource
// NumValues: 0x0004
enum class EP2ContextRequirement_ItemRequirementsSource : uint8
{
	InventoryOnly                            = 0,
	StashOnly                                = 1,
	InventoryAndStash                        = 2,
	EP2ContextRequirement_MAX                = 3,
};

// Enum Game.EP2ContextRequirement_ItemRequirementsType
// NumValues: 0x0004
enum class EP2ContextRequirement_ItemRequirementsType : uint8
{
	Equal                                    = 0,
	GreaterEqual                             = 1,
	LessEqual                                = 2,
	EP2ContextRequirement_MAX                = 3,
};

// Enum Game.EP2ContextRequirementLevelType
// NumValues: 0x0006
enum class EP2ContextRequirementLevelType : uint8
{
	EqualTo                                  = 0,
	LessThan                                 = 1,
	LessEqualThan                            = 2,
	MoreThan                                 = 3,
	MoreEqualThan                            = 4,
	EP2ContextRequirementLevelType_MAX       = 5,
};

// Enum Game.EP2LoadOutCheckRequirementType
// NumValues: 0x0003
enum class EP2LoadOutCheckRequirementType : uint8
{
	ShouldHaveLoadout                        = 0,
	ShouldNotHaveLoadout                     = 1,
	EP2LoadOutCheckRequirementType_MAX       = 2,
};

// Enum Game.EP2GameplayContextDataType
// NumValues: 0x0004
enum class EP2GameplayContextDataType : uint8
{
	GameplayContext                          = 0,
	GameplayContextGroup                     = 1,
	None                                     = 2,
	EP2GameplayContextDataType_MAX           = 3,
};

// Enum Game.EP2GameplayContextDependencyType
// NumValues: 0x0005
enum class EP2GameplayContextDependencyType : uint8
{
	Complete                                 = 0,
	Fail                                     = 1,
	Any                                      = 2,
	None                                     = 3,
	EP2GameplayContextDependencyType_MAX     = 4,
};

// Enum Game.EP2GameplayContextArchiveType
// NumValues: 0x0005
enum class EP2GameplayContextArchiveType : uint8
{
	Deactivated                              = 0,
	Completed                                = 1,
	Failed                                   = 2,
	None                                     = 3,
	EP2GameplayContextArchiveType_MAX        = 4,
};

// Enum Game.EP2GameplayContextGroupState
// NumValues: 0x0005
enum class EP2GameplayContextGroupState : uint8
{
	Disabled                                 = 0,
	Enabled                                  = 1,
	Completed                                = 2,
	None                                     = 3,
	EP2GameplayContextGroupState_MAX         = 4,
};

// Enum Game.EP2GameplayContextRequirementNetPolicy
// NumValues: 0x0004
enum class EP2GameplayContextRequirementNetPolicy : uint32
{
	Server                                   = 0,
	Client                                   = 1,
	None                                     = 2,
	EP2GameplayContextRequirementNetPolicy_MAX = 3,
};

// Enum Game.EP2GameplayContextEventType
// NumValues: 0x0006
enum class EP2GameplayContextEventType : uint8
{
	OnEnabledEvent                           = 0,
	OnTriggeredEvent                         = 1,
	OnCompletedEvent                         = 2,
	OnFailedEvent                            = 3,
	None                                     = 4,
	EP2GameplayContextEventType_MAX          = 5,
};

// Enum Game.EP2GameplayContextEventNetPolicy
// NumValues: 0x0004
enum class EP2GameplayContextEventNetPolicy : uint32
{
	Server                                   = 0,
	Client                                   = 1,
	None                                     = 2,
	EP2GameplayContextEventNetPolicy_MAX     = 3,
};

// Enum Game.EP2GameplayContextOnFailedBehavior
// NumValues: 0x0005
enum class EP2GameplayContextOnFailedBehavior : uint8
{
	Archived                                 = 0,
	RestartNow                               = 1,
	RestartWithRequirements                  = 2,
	None                                     = 3,
	EP2GameplayContextOnFailedBehavior_MAX   = 4,
};

// Enum Game.EP2ContractStateQueryType
// NumValues: 0x0003
enum class EP2ContractStateQueryType : uint8
{
	And                                      = 0,
	Or                                       = 1,
	EP2ContractStateQueryType_MAX            = 2,
};

// Enum Game.EAudioEventType
// NumValues: 0x0004
enum class EAudioEventType : uint8
{
	MIDI                                     = 0,
	WwiseLoop                                = 1,
	SingleEventForFullAuto                   = 2,
	EAudioEventType_MAX                      = 3,
};

// Enum Game.EP2GameUserSettingDirtyBit
// NumValues: 0x001D
enum class EP2GameUserSettingDirtyBit : uint32
{
	CurrentCulture                           = 1,
	DisplayMode                              = 2,
	Resolution                               = 4,
	MouseSensitivy                           = 8,
	RenderScale                              = 16,
	RenderScaleMethod                        = 32,
	Scalability                              = 64,
	UseSharpen                               = 128,
	MasterVolume                             = 256,
	OutGameMusic                             = 512,
	AntiAliasingType                         = 1024,
	MicVolume                                = 2048,
	AudioInputDevice                         = 4096,
	ReduceStunBrightness                     = 8192,
	WorldFOV                                 = 16384,
	ViewModelFOVOffset                       = 32768,
	ADSMultiplier                            = 65536,
	InverseInput                             = 131072,
	AutoReload                               = 262144,
	FireMode                                 = 524288,
	AudioOutputDevice                        = 1048576,
	PLSDAudioVolume                          = 2097152,
	VoiceChatMode                            = 4194304,
	VoiceChatEnable                          = 8388608,
	VSync                                    = 8388608,
	MaxFrameRate                             = 16777216,
	FPP                                      = 33554432,
	VoiceChatVolume                          = 67108864,
	EP2GameUserSettingDirtyBit_MAX           = 67108865,
};

// Enum Game.EP2HUDMessageType
// NumValues: 0x0004
enum class EP2HUDMessageType : uint8
{
	None                                     = 0,
	Tooltip                                  = 1,
	DetailPopup                              = 2,
	EP2HUDMessageType_MAX                    = 3,
};

// Enum Game.EInventorySlotWidgetType
// NumValues: 0x000A
enum class EInventorySlotWidgetType : uint8
{
	None                                     = 0,
	Primary                                  = 1,
	Pistol                                   = 2,
	Melee                                    = 3,
	Helmet                                   = 4,
	ArmArmor                                 = 5,
	LegArmor                                 = 6,
	Vest                                     = 7,
	Backpack                                 = 8,
	EInventorySlotWidgetType_MAX             = 9,
};

// Enum Game.EInventoryContainerWidgetType
// NumValues: 0x0009
enum class EInventoryContainerWidgetType : uint8
{
	None                                     = 0,
	Helmet                                   = 1,
	ArmArmor                                 = 2,
	LegArmor                                 = 3,
	Vest                                     = 4,
	Backpack                                 = 5,
	Stash                                    = 6,
	Vicinity                                 = 7,
	EInventoryContainerWidgetType_MAX        = 8,
};

// Enum Game.EP2SkillSlotWidgetType
// NumValues: 0x0003
enum class EP2SkillSlotWidgetType : uint8
{
	Drone                                    = 0,
	Multitool                                = 1,
	EP2SkillSlotWidgetType_MAX               = 2,
};

// Enum Game.EP2ItemTickRule
// NumValues: 0x000A
enum class EP2ItemTickRule : uint8
{
	None                                     = 0,
	Owner                                    = 1,
	Server                                   = 2,
	OwnerAndServer                           = 3,
	Client                                   = 4,
	OwnerAndClient                           = 5,
	OwnerAndSpectator                        = 6,
	Spectator                                = 7,
	All                                      = 8,
	EP2ItemTickRule_MAX                      = 9,
};

// Enum Game.EArmIndex
// NumValues: 0x0006
enum class EArmIndex : uint8
{
	None                                     = 0,
	ArmIndex1                                = 1,
	ArmIndex2                                = 2,
	ArmIndex3                                = 3,
	ArmIndex4                                = 4,
	EArmIndex_MAX                            = 5,
};

// Enum Game.EP2SlotAttachmentType
// NumValues: 0x0003
enum class EP2SlotAttachmentType : uint8
{
	Direct                                   = 0,
	Root                                     = 1,
	EP2SlotAttachmentType_MAX                = 2,
};

// Enum Game.EP2ContainerItemSortType
// NumValues: 0x0007
enum class EP2ContainerItemSortType : uint8
{
	Default                                  = 0,
	Recent                                   = 1,
	Size                                     = 2,
	Weight                                   = 3,
	Value                                    = 4,
	MaterialUsage                            = 5,
	EP2ContainerItemSortType_MAX             = 6,
};

// Enum Game.EP2ItemDetailInfoTabType
// NumValues: 0x0003
enum class EP2ItemDetailInfoTabType : uint8
{
	Stats                                    = 0,
	Description                              = 1,
	EP2ItemDetailInfoTabType_MAX             = 2,
};

// Enum Game.EP2RenderActorType
// NumValues: 0x0004
enum class EP2RenderActorType : uint8
{
	None                                     = 0,
	Item                                     = 1,
	ItemData                                 = 2,
	EP2RenderActorType_MAX                   = 3,
};

// Enum Game.EP2StatWidgetType
// NumValues: 0x0003
enum class EP2StatWidgetType : uint8
{
	ItemDetailPopup                          = 0,
	Modding                                  = 1,
	EP2StatWidgetType_MAX                    = 2,
};

// Enum Game.EP2ItemDataPropertyType
// NumValues: 0x0008
enum class EP2ItemDataPropertyType : uint8
{
	Text                                     = 0,
	FloatingPoint                            = 1,
	Int                                      = 2,
	Bool                                     = 3,
	FloatMapValue                            = 4,
	TextDescriptionGE                        = 5,
	FloatMap                                 = 6,
	EP2ItemDataPropertyType_MAX              = 7,
};

// Enum Game.EP2ArmorSetupVariableName
// NumValues: 0x0004
enum class EP2ArmorSetupVariableName : uint32
{
	StatusEffectResistance                   = 0,
	DestructibilityMultiplierFromDamageType  = 1,
	Custom                                   = 2,
	EP2ArmorSetupVariableName_MAX            = 3,
};

// Enum Game.EP2ArmorZoneVariableName
// NumValues: 0x0004
enum class EP2ArmorZoneVariableName : uint32
{
	PenetrationProtectionByDamageType        = 0,
	DamageMultiplierByDamageType             = 1,
	Custom                                   = 2,
	EP2ArmorZoneVariableName_MAX             = 3,
};

// Enum Game.EP2StatSpanType
// NumValues: 0x0004
enum class EP2StatSpanType : uint32
{
	Left                                     = 0,
	Right                                    = 1,
	Full                                     = 2,
	EP2StatSpanType_MAX                      = 3,
};

// Enum Game.EP2ProjectileType
// NumValues: 0x0003
enum class EP2ProjectileType : uint8
{
	Bullet                                   = 0,
	Grenade                                  = 1,
	EP2ProjectileType_MAX                    = 2,
};

// Enum Game.EP2LapsCaliberTiers
// NumValues: 0x0004
enum class EP2LapsCaliberTiers : uint8
{
	Tier1                                    = 0,
	Tier2                                    = 1,
	Tier3                                    = 2,
	EP2LapsCaliberTiers_MAX                  = 3,
};

// Enum Game.EP2MultitoolNoiseLevel
// NumValues: 0x0004
enum class EP2MultitoolNoiseLevel : uint8
{
	Low                                      = 0,
	Medium                                   = 1,
	High                                     = 2,
	EP2MultitoolNoiseLevel_MAX               = 3,
};

// Enum Game.EP2LootSpawnFixedPointType
// NumValues: 0x0005
enum class EP2LootSpawnFixedPointType : uint8
{
	Any                                      = 0,
	PointActor                               = 1,
	ContextActor                             = 2,
	SelfPoint                                = 3,
	MAX                                      = 4,
};

// Enum Game.EP2LootSpawnMobilityFilter
// NumValues: 0x0004
enum class EP2LootSpawnMobilityFilter : uint8
{
	Any                                      = 0,
	Static                                   = 1,
	Movable                                  = 2,
	EP2LootSpawnMobilityFilter_MAX           = 3,
};

// Enum Game.EP2LootSpawnPointFilter
// NumValues: 0x0004
enum class EP2LootSpawnPointFilter : uint8
{
	Any                                      = 0,
	Require                                  = 1,
	Avoid                                    = 2,
	EP2LootSpawnPointFilter_MAX              = 3,
};

// Enum Game.EP2WorldLocationType
// NumValues: 0x0010
enum class EP2WorldLocationType : uint8
{
	Major                                    = 0,
	UniqueMinor                              = 1,
	CommonMinor                              = 2,
	Micro                                    = 3,
	PointOfInterest                          = 4,
	Entrance                                 = 5,
	Landmark                                 = 6,
	Exfiltration                             = 7,
	Sector                                   = 8,
	MajorRoom                                = 9,
	MinorRoom                                = 10,
	UniqueMinorRoom                          = 11,
	CommonMinorRoom                          = 12,
	PointOfInterestSecret                    = 13,
	PointOfInterestGroup                     = 14,
	EP2WorldLocationType_MAX                 = 15,
};

// Enum Game.EP2MapZoomLevelType
// NumValues: 0x0005
enum class EP2MapZoomLevelType : uint8
{
	Max                                      = 0,
	High                                     = 1,
	Low                                      = 2,
	Min                                      = 3,
	LIMIT                                    = 4,
};

// Enum Game.EP2ContractRequirementAreaRadius
// NumValues: 0x0008
enum class EP2ContractRequirementAreaRadius : uint8
{
	RadiusNone                               = 0,
	Radius10m                                = 10,
	Radius25m                                = 25,
	Radius50m                                = 50,
	Radius100m                               = 100,
	Radius150m                               = 150,
	Radius200m                               = 200,
	EP2ContractRequirementAreaRadius_MAX     = 201,
};

// Enum Game.EP2MeshComponentType
// NumValues: 0x0004
enum class EP2MeshComponentType : uint8
{
	Tpp                                      = 0,
	Fpp                                      = 1,
	FakeBody                                 = 2,
	Max                                      = 3,
};

// Enum Game.EP2ShotCountingMode
// NumValues: 0x0004
enum class EP2ShotCountingMode : uint8
{
	None                                     = 0,
	EnforceMinimum                           = 1,
	FullShotCounting                         = 2,
	EP2ShotCountingMode_MAX                  = 3,
};

// Enum Game.EP2MovementInputType
// NumValues: 0x0003
enum class EP2MovementInputType : uint8
{
	Throttle                                 = 0,
	Reverse                                  = 1,
	EP2MovementInputType_MAX                 = 2,
};

// Enum Game.EP2OperationalTaskRewardType
// NumValues: 0x0005
enum class EP2OperationalTaskRewardType : uint8
{
	None                                     = 0,
	EXP                                      = 1,
	Item                                     = 2,
	SkinCustomizationUnlock                  = 3,
	EP2OperationalTaskRewardType_MAX         = 4,
};

// Enum Game.EP2PlayerStartOccupancy
// NumValues: 0x0004
enum class EP2PlayerStartOccupancy : uint8
{
	Empty                                    = 0,
	Partial                                  = 1,
	Full                                     = 2,
	EP2PlayerStartOccupancy_MAX              = 3,
};

// Enum Game.EP2PlayerConnectionType
// NumValues: 0x0005
enum class EP2PlayerConnectionType : uint8
{
	Player                                   = 0,
	LiveSpectator                            = 1,
	ReplaySpectator                          = 2,
	InactivePlayer                           = 3,
	EP2PlayerConnectionType_MAX              = 4,
};

// Enum Game.EP2RentalFailReason
// NumValues: 0x0007
enum class EP2RentalFailReason : uint8
{
	AlreadyRenting                           = 0,
	OnCooldown                               = 1,
	NotEnoughStashSpace                      = 2,
	NotEnoughReputation                      = 3,
	InVRStation                              = 4,
	None                                     = 5,
	EP2RentalFailReason_MAX                  = 6,
};

// Enum Game.EP2QuadSpeakerPosition
// NumValues: 0x0005
enum class EP2QuadSpeakerPosition : uint8
{
	FrontLeft                                = 0,
	FrontRight                               = 1,
	SurroundLeft                             = 2,
	SurroundRight                            = 3,
	EP2QuadSpeakerPosition_MAX               = 4,
};

// Enum Game.EP2RagdollControllerState
// NumValues: 0x0005
enum class EP2RagdollControllerState : uint8
{
	None                                     = 0,
	Activated                                = 1,
	Sleep                                    = 2,
	Finished                                 = 3,
	EP2RagdollControllerState_MAX            = 4,
};

// Enum Game.EP2RaidResultType
// NumValues: 0x0005
enum class EP2RaidResultType : uint8
{
	Extracted                                = 0,
	KIA                                      = 1,
	MIA                                      = 2,
	AWOL                                     = 3,
	EP2RaidResultType_MAX                    = 4,
};

// Enum Game.EP2RenderActorTargetType
// NumValues: 0x0004
enum class EP2RenderActorTargetType : uint8
{
	Actor                                    = 0,
	Character                                = 1,
	Item                                     = 2,
	EP2RenderActorTargetType_MAX             = 3,
};

// Enum Game.EP2ClassRepNodeMapping
// NumValues: 0x000A
enum class EP2ClassRepNodeMapping : uint32
{
	NotRouted                                = 0,
	RelevantAllConnections                   = 1,
	RelevantOwnerConnection                  = 2,
	PlayerStateFrequencyBuckets              = 3,
	TeamStateFrequencyBuckets                = 4,
	GenericFrequencyBuckets                  = 5,
	Spatialize_Static                        = 6,
	Spatialize_Dynamic                       = 7,
	Spatialize_Dormancy                      = 8,
	EP2ClassRepNodeMapping_MAX               = 9,
};

// Enum Game.EP2ResearchRewardType
// NumValues: 0x000D
enum class EP2ResearchRewardType : uint8
{
	None                                     = 0,
	EXP                                      = 1,
	FactionRep                               = 2,
	Item                                     = 3,
	ContractUnlock                           = 4,
	TradingUnlock                            = 5,
	FacilityUnlock                           = 6,
	OutfittingUnlock                         = 7,
	CraftRecipesUnlock                       = 8,
	SalvageRecipesUnlock                     = 9,
	SkinCustomizationUnlock                  = 10,
	DroneUnlock                              = 11,
	EP2ResearchRewardType_MAX                = 12,
};

// Enum Game.EP2MagazineSequenceType
// NumValues: 0x0003
enum class EP2MagazineSequenceType : uint8
{
	Out                                      = 0,
	In                                       = 1,
	EP2MagazineSequenceType_MAX              = 2,
};

// Enum Game.EP2SpeakerLocation
// NumValues: 0x0006
enum class EP2SpeakerLocation : uint8
{
	FL                                       = 0,
	FR                                       = 1,
	SL                                       = 2,
	SR                                       = 3,
	Num                                      = 4,
	EP2SpeakerLocation_MAX                   = 5,
};

// Enum Game.EP2RegionColor
// NumValues: 0x000A
enum class EP2RegionColor : uint8
{
	BLACK                                    = 0,
	RED                                      = 1,
	GREEN                                    = 2,
	BLUE                                     = 3,
	YELLOW                                   = 4,
	MAGENTA                                  = 5,
	CYAN                                     = 6,
	WHITE                                    = 7,
	Num                                      = 8,
	EP2RegionColor_MAX                       = 9,
};

// Enum Game.EP2SnapToFoliageLocationOffset
// NumValues: 0x0005
enum class EP2SnapToFoliageLocationOffset : uint8
{
	High                                     = 0,
	Mid                                      = 1,
	Low                                      = 2,
	Num                                      = 3,
	EP2SnapToFoliageLocationOffset_MAX       = 4,
};

// Enum Game.ESplineMoveDismountType
// NumValues: 0x0004
enum class ESplineMoveDismountType : uint8
{
	None                                     = 0,
	Jump                                     = 1,
	MoveAction                               = 2,
	MAX                                      = 3,
};

// Enum Game.EP2SplineMoveAttributeMode
// NumValues: 0x0003
enum class EP2SplineMoveAttributeMode : uint32
{
	Scalar                                   = 0,
	Additive                                 = 1,
	EP2SplineMoveAttributeMode_MAX           = 2,
};

// Enum Game.EP2SplineTravelDirection
// NumValues: 0x0003
enum class EP2SplineTravelDirection : uint8
{
	Forward                                  = 0,
	Backward                                 = 1,
	EP2SplineTravelDirection_MAX             = 2,
};

// Enum Game.EP2AkCaliberTiers
// NumValues: 0x0008
enum class EP2AkCaliberTiers : uint8
{
	Tier1                                    = 0,
	Tier2                                    = 1,
	Tier3                                    = 2,
	Tier4                                    = 3,
	Tier5                                    = 4,
	Shotgun                                  = 5,
	Laser                                    = 6,
	EP2AkCaliberTiers_MAX                    = 7,
};

// Enum Game.EP2PingType
// NumValues: 0x0005
enum class EP2PingType : uint8
{
	Undefined                                = 0,
	Enemy                                    = 1,
	Hold                                     = 2,
	Attack                                   = 3,
	EP2PingType_MAX                          = 4,
};

// Enum Game.EP2TeamComparison
// NumValues: 0x0004
enum class EP2TeamComparison : uint8
{
	OnSameTeam                               = 0,
	DifferentTeams                           = 1,
	InvalidArgument                          = 2,
	EP2TeamComparison_MAX                    = 3,
};

// Enum Game.EP2SquadUserStatus
// NumValues: 0x0006
enum class EP2SquadUserStatus : uint8
{
	Offline                                  = 0,
	Hideout                                  = 1,
	Raid                                     = 2,
	Ready                                    = 3,
	Matchmaking                              = 4,
	EP2SquadUserStatus_MAX                   = 5,
};

// Enum Game.EP2SquadUserJoinState
// NumValues: 0x0003
enum class EP2SquadUserJoinState : uint8
{
	Active                                   = 0,
	Waiting                                  = 1,
	EP2SquadUserJoinState_MAX                = 2,
};

// Enum Game.EP2VisitHideoutStatus
// NumValues: 0x0003
enum class EP2VisitHideoutStatus : uint8
{
	OwnHideout                               = 0,
	VisitHideout                             = 1,
	EP2VisitHideoutStatus_MAX                = 2,
};

// Enum Game.EP2InRaidStatus
// NumValues: 0x0004
enum class EP2InRaidStatus : uint8
{
	Alive                                    = 0,
	Dead                                     = 1,
	Exfiltrated                              = 2,
	EP2InRaidStatus_MAX                      = 3,
};

// Enum Game.EP2TeamPlayerStartSelectionType
// NumValues: 0x0004
enum class EP2TeamPlayerStartSelectionType : uint8
{
	SameSpot                                 = 0,
	SameGroup                                = 1,
	Random                                   = 2,
	EP2TeamPlayerStartSelectionType_MAX      = 3,
};

// Enum Game.EFireActorState
// NumValues: 0x0004
enum class EFireActorState : uint8
{
	None                                     = 0,
	Triggered                                = 1,
	Deployed                                 = 2,
	EFireActorState_MAX                      = 3,
};

// Enum Game.ESmokeActorState
// NumValues: 0x0004
enum class ESmokeActorState : uint8
{
	None                                     = 0,
	Triggered                                = 1,
	Deployed                                 = 2,
	ESmokeActorState_MAX                     = 3,
};

// Enum Game.EP2ThrowableVisualEventType
// NumValues: 0x0004
enum class EP2ThrowableVisualEventType : uint8
{
	Ready                                    = 0,
	Cook                                     = 1,
	Cancel                                   = 2,
	EP2ThrowableVisualEventType_MAX          = 3,
};

// Enum Game.EP2TimedEventProcessMode
// NumValues: 0x0003
enum class EP2TimedEventProcessMode : uint8
{
	Sequential                               = 0,
	Parallel                                 = 1,
	EP2TimedEventProcessMode_MAX             = 2,
};

// Enum Game.EP2TriggerZoneStackApplicationType
// NumValues: 0x0003
enum class EP2TriggerZoneStackApplicationType : uint8
{
	OncePerPeriod                            = 0,
	Continuous                               = 1,
	EP2TriggerZoneStackApplicationType_MAX   = 2,
};

// Enum Game.EP2DeathState
// NumValues: 0x0004
enum class EP2DeathState : uint8
{
	NotDead                                  = 0,
	DeathStarted                             = 1,
	DeathFinished                            = 2,
	EP2DeathState_MAX                        = 3,
};

// Enum Game.EP2DownedState
// NumValues: 0x0004
enum class EP2DownedState : uint8
{
	NotDowned                                = 0,
	DBNO                                     = 1,
	KnockedOut                               = 2,
	EP2DownedState_MAX                       = 3,
};

// Enum Game.EP2CustomMovementMode
// NumValues: 0x0007
enum class EP2CustomMovementMode : uint8
{
	Vaulting                                 = 0,
	Sliding                                  = 1,
	MoveAction                               = 2,
	SplineMove                               = 3,
	DPV                                      = 4,
	Attached                                 = 5,
	EP2CustomMovementMode_MAX                = 6,
};

// Enum Game.EP2StencilBit
// NumValues: 0x0004
enum class EP2StencilBit : uint8
{
	None                                     = 0,
	OutlineOcclusion                         = 1,
	Living                                   = 2,
	EP2StencilBit_MAX                        = 3,
};

// Enum Game.EP2StencilWriteMask
// NumValues: 0x0003
enum class EP2StencilWriteMask : uint8
{
	Default                                  = 0,
	OutlineOcclusion                         = 2,
	EP2StencilWriteMask_MAX                  = 3,
};

// Enum Game.ECameraPerspective
// NumValues: 0x0003
enum class ECameraPerspective : uint8
{
	FirstPersonCamera                        = 0,
	ThirdPersonCamera                        = 1,
	ECameraPerspective_MAX                   = 2,
};

// Enum Game.EP2MatchCountdownState
// NumValues: 0x0006
enum class EP2MatchCountdownState : uint8
{
	Inactive                                 = 0,
	Waiting                                  = 1,
	Deployment                               = 2,
	DeploymentLocked                         = 3,
	Finished                                 = 4,
	EP2MatchCountdownState_MAX               = 5,
};

// Enum Game.EP2InteractState
// NumValues: 0x0007
enum class EP2InteractState : uint8
{
	None                                     = 0,
	Visible                                  = 1,
	Focused                                  = 2,
	Unavailable                              = 3,
	Interactable                             = 4,
	Interacting                              = 5,
	EP2InteractState_MAX                     = 6,
};

// Enum Game.EP2StackSize
// NumValues: 0x0006
enum class EP2StackSize : uint8
{
	Tiny                                     = 0,
	Small                                    = 1,
	Medium                                   = 2,
	Big                                      = 3,
	Xl                                       = 4,
	EP2StackSize_MAX                         = 5,
};

// Enum Game.ECrateContainerType
// NumValues: 0x0004
enum class ECrateContainerType : uint8
{
	Stash                                    = 0,
	ContainerBox                             = 1,
	DeadBody                                 = 2,
	ECrateContainerType_MAX                  = 3,
};

// Enum Game.EItemActionFailedType
// NumValues: 0x000C
enum class EItemActionFailedType : uint8
{
	NotEnough                                = 0,
	IncompatibleContainer                    = 1,
	IncompatibleSlot                         = 2,
	IncompatibleItems                        = 3,
	InventoryItemModding                     = 4,
	UnableUseConsumable                      = 5,
	NoConsumable                             = 6,
	UnableVincinity                          = 7,
	UnableSwap                               = 8,
	UnableSort                               = 9,
	UnableUnload                             = 10,
	EItemActionFailedType_MAX                = 11,
};

// Enum Game.EP2ZoneType
// NumValues: 0x0006
enum class EP2ZoneType : uint8
{
	Any                                      = 0,
	Green                                    = 1,
	Yellow                                   = 2,
	Red                                      = 3,
	Black                                    = 4,
	EP2ZoneType_MAX                          = 5,
};

// Enum Game.EP2GameplayAttributeDisplayMethod
// NumValues: 0x0003
enum class EP2GameplayAttributeDisplayMethod : uint8
{
	FixedValue                               = 0,
	Percentage                               = 1,
	EP2GameplayAttributeDisplayMethod_MAX    = 2,
};

// Enum Game.EP2GameplayAttributeDesirableChange
// NumValues: 0x0003
enum class EP2GameplayAttributeDesirableChange : uint8
{
	Higher                                   = 0,
	Lower                                    = 1,
	EP2GameplayAttributeDesirableChange_MAX  = 2,
};

// Enum Game.EP2InputEvent
// NumValues: 0x000C
enum class EP2InputEvent : uint8
{
	None                                     = 0,
	Pressed                                  = 1,
	Released                                 = 2,
	Hold                                     = 3,
	HoldAndRelease                           = 4,
	Tap                                      = 5,
	DoubleTap                                = 6,
	Down                                     = 7,
	Pulse                                    = 8,
	Toggle                                   = 9,
	UntilRelease                             = 10,
	Max                                      = 11,
};

// Enum Game.EWeaponObstructionType
// NumValues: 0x0004
enum class EWeaponObstructionType : uint8
{
	None                                     = 0,
	Soft                                     = 1,
	Hard                                     = 2,
	EWeaponObstructionType_MAX               = 3,
};

// Enum Game.EP2StatusEffectAnimType
// NumValues: 0x0008
enum class EP2StatusEffectAnimType : uint8
{
	None                                     = 0,
	Static                                   = 1,
	Light                                    = 2,
	Medium                                   = 3,
	Heavy                                    = 4,
	Low                                      = 5,
	High                                     = 6,
	Max                                      = 7,
};

// Enum Game.EP2SplitItemType
// NumValues: 0x0003
enum class EP2SplitItemType : uint8
{
	None                                     = 0,
	Half                                     = 1,
	Max                                      = 2,
};

// Enum Game.EP2UIStatusEffectSeverityCriteria
// NumValues: 0x0005
enum class EP2UIStatusEffectSeverityCriteria : uint8
{
	StackCount                               = 0,
	Level                                    = 1,
	Attribute                                = 2,
	CustomAirLogic                           = 3,
	EP2UIStatusEffectSeverityCriteria_MAX    = 4,
};

// Enum Game.EP2SlotWidgetType
// NumValues: 0x000D
enum class EP2SlotWidgetType : uint8
{
	WearableSlotNormal                       = 0,
	WearableSlotSmall                        = 1,
	WearableSlotContainer                    = 2,
	UsableSlotPrimary                        = 3,
	UsableSlotSidearm                        = 4,
	UsableSlotMelee                          = 5,
	MagazineSlot                             = 6,
	Attachment                               = 7,
	DetailPopupAttachment                    = 8,
	DetailPopupMod                           = 9,
	DetailPopupMagazine                      = 10,
	OnBackSlot                               = 11,
	EP2SlotWidgetType_MAX                    = 12,
};

// Enum Game.EP2HealthHUDStatus
// NumValues: 0x000A
enum class EP2HealthHUDStatus : uint8
{
	None                                     = 0,
	FullyHealth                              = 1,
	Healthy                                  = 2,
	LightlyInjured                           = 3,
	Low                                      = 4,
	Critical                                 = 5,
	DBNO                                     = 6,
	Ko                                       = 7,
	KIA                                      = 8,
	EP2HealthHUDStatus_MAX                   = 9,
};

// Enum Game.EP2ItemRenderContext
// NumValues: 0x0005
enum class EP2ItemRenderContext : uint8
{
	None                                     = 0,
	InventoryItemIcon                        = 1,
	DetailPopup                              = 2,
	ItemSkinContainerIcon                    = 3,
	EP2ItemRenderContext_MAX                 = 4,
};

// Enum Game.EP2MailAttachedState
// NumValues: 0x0003
enum class EP2MailAttachedState : uint8
{
	UnClaimed                                = 0,
	Claimed                                  = 1,
	EP2MailAttachedState_MAX                 = 2,
};

// Enum Game.EP2MailState
// NumValues: 0x0003
enum class EP2MailState : uint8
{
	UnRead                                   = 0,
	Read                                     = 1,
	EP2MailState_MAX                         = 2,
};

// Enum Game.EP2RadioButtonCrateType
// NumValues: 0x0004
enum class EP2RadioButtonCrateType : uint8
{
	Horizontal                               = 0,
	Vertical                                 = 1,
	Wrap                                     = 2,
	EP2RadioButtonCrateType_MAX              = 3,
};

// Enum Game.EP2KeyBindWidgetType
// NumValues: 0x0005
enum class EP2KeyBindWidgetType : uint8
{
	None                                     = 0,
	InputTrigger                             = 1,
	InputKey                                 = 2,
	All                                      = 3,
	EP2KeyBindWidgetType_MAX                 = 4,
};

// Enum Game.EP2KeyBindPopupType
// NumValues: 0x0004
enum class EP2KeyBindPopupType : uint8
{
	Default                                  = 0,
	Duplicate                                = 1,
	InvalidKey                               = 2,
	EP2KeyBindPopupType_MAX                  = 3,
};

// Enum Game.EKeyBindResult
// NumValues: 0x0005
enum class EKeyBindResult : uint8
{
	Success                                  = 0,
	CommonKey                                = 1,
	Duplicate                                = 2,
	BlockedKey                               = 3,
	EKeyBindResult_MAX                       = 4,
};

// Enum Game.EP2ConditionOperator
// NumValues: 0x0003
enum class EP2ConditionOperator : uint8
{
	And                                      = 0,
	Or                                       = 1,
	EP2ConditionOperator_MAX                 = 2,
};

// Enum Game.EP2UnlockContentsType
// NumValues: 0x0007
enum class EP2UnlockContentsType : uint8
{
	None                                     = 0,
	Research                                 = 1,
	Contract                                 = 2,
	Level                                    = 3,
	FR_Level                                 = 4,
	DoubleLock                               = 5,
	EP2UnlockContentsType_MAX                = 6,
};

// Enum Game.EP2PartyAction
// NumValues: 0x000A
enum class EP2PartyAction : uint8
{
	SquadInviteAccepted                      = 0,
	SquadInviteRejected                      = 1,
	SquadInviteRequested                     = 2,
	SquadLeft                                = 3,
	SquadInviteSucceeded                     = 4,
	SquadInviteFailed                        = 5,
	SquadKicked                              = 6,
	RespondToSquadInvite                     = 7,
	RespondToSquadInviteFailed               = 8,
	EP2PartyAction_MAX                       = 9,
};

// Enum Game.EP2RewardWidgetType
// NumValues: 0x0003
enum class EP2RewardWidgetType : uint8
{
	Exp                                      = 0,
	Currency                                 = 1,
	EP2RewardWidgetType_MAX                  = 2,
};

// Enum Game.EP2Pivot
// NumValues: 0x0005
enum class EP2Pivot : uint8
{
	TopLeft                                  = 0,
	TopRight                                 = 1,
	BottomLeft                               = 2,
	BottomRight                              = 3,
	EP2Pivot_MAX                             = 4,
};

// Enum Game.EP2SquadManagementPlayerWidgetState
// NumValues: 0x0007
enum class EP2SquadManagementPlayerWidgetState : uint8
{
	Empty                                    = 0,
	Solo                                     = 1,
	Leader_Me                                = 2,
	Leader_Other                             = 3,
	Member_Me                                = 4,
	Member_Other                             = 5,
	EP2SquadManagementPlayerWidgetState_MAX  = 6,
};

// Enum Game.EP2UnlockContentRewardType
// NumValues: 0x0003
enum class EP2UnlockContentRewardType : uint8
{
	None                                     = 0,
	SkinCustomizationUnlock                  = 1,
	EP2UnlockContentRewardType_MAX           = 2,
};

// Enum Game.EP2VivoxPTTKey
// NumValues: 0x0004
enum class EP2VivoxPTTKey : uint8
{
	PTTNoChannel                             = 0,
	PTTAreaChannel                           = 1,
	PTTTeamChannel                           = 2,
	EP2VivoxPTTKey_MAX                       = 3,
};

// Enum Game.EP2VolumetricOffsetTexture
// NumValues: 0x0004
enum class EP2VolumetricOffsetTexture : uint8
{
	OffsetCurl                               = 0,
	OffsetCustom1                            = 1,
	OffsetCustom2                            = 2,
	Max                                      = 3,
};

// Enum Game.EP2VolumetricNoiseTexture
// NumValues: 0x0006
enum class EP2VolumetricNoiseTexture : uint8
{
	Voronoi                                  = 0,
	Erosion                                  = 1,
	Perlin                                   = 2,
	Custom1                                  = 3,
	Custom2                                  = 4,
	Max                                      = 5,
};

// Enum Game.EVolumetricShapeType
// NumValues: 0x0003
enum class EVolumetricShapeType : uint8
{
	Box                                      = 0,
	Sphere                                   = 1,
	EVolumetricShapeType_MAX                 = 2,
};

// Enum Game.EP2GlassType
// NumValues: 0x0004
enum class EP2GlassType : uint8
{
	Breakable                                = 0,
	Unbreakable                              = 1,
	NoGlass                                  = 2,
	EP2GlassType_MAX                         = 3,
};

// Enum Game.EP2PingRemoveType
// NumValues: 0x0005
enum class EP2PingRemoveType : uint8
{
	None                                     = 0,
	OnHover                                  = 1,
	NearPosition                             = 2,
	Both                                     = 3,
	EP2PingRemoveType_MAX                    = 4,
};

// Enum Game.EProceduralAnimState
// NumValues: 0x0007
enum class EProceduralAnimState : uint8
{
	None                                     = 0,
	BlendingIn                               = 1,
	Active                                   = 2,
	Interrupted                              = 3,
	BlendingOut                              = 4,
	Finished                                 = 5,
	EProceduralAnimState_MAX                 = 6,
};

// Enum Game.EAnimSpringModifierGroup
// NumValues: 0x0006
enum class EAnimSpringModifierGroup : uint8
{
	None                                     = 0,
	SwayLight                                = 1,
	SwayHeavy                                = 2,
	SwayMovementSlow                         = 3,
	SwayMovementFast                         = 4,
	EAnimSpringModifierGroup_MAX             = 5,
};

// Enum Game.EBurstSwitchMethod
// NumValues: 0x0003
enum class EBurstSwitchMethod : uint8
{
	SwitchOnShots                            = 0,
	SwitchOnTime                             = 1,
	EBurstSwitchMethod_MAX                   = 2,
};

// Enum Game.EP2StanceSpeedIndexType
// NumValues: 0x0006
enum class EP2StanceSpeedIndexType : uint8
{
	Run                                      = 0,
	Jog                                      = 1,
	FastWalk                                 = 2,
	Walk                                     = 3,
	Standstill                               = 4,
	Max                                      = 5,
};

// Enum Game.EColorMask
// NumValues: 0x0006
enum class EColorMask : uint8
{
	NONE                                     = 0,
	RED                                      = 1,
	GREEN                                    = 2,
	BLUE                                     = 4,
	ALPHA                                    = 8,
	EColorMask_MAX                           = 9,
};

// Enum Game.EAdaptiveLeanDirection
// NumValues: 0x0005
enum class EAdaptiveLeanDirection : uint8
{
	None                                     = 0,
	Left                                     = 1,
	Right                                    = 2,
	Top                                      = 3,
	EAdaptiveLeanDirection_MAX               = 4,
};

// Enum Game.EP2GameplayCueNotify_EffectPlaySpace
// NumValues: 0x0003
enum class EP2GameplayCueNotify_EffectPlaySpace : uint8
{
	WorldSpace                               = 0,
	CameraSpace                              = 1,
	EP2GameplayCueNotify_MAX                 = 2,
};

// Enum Game.EP2GameplayCueNotify_LocallyControlledSource
// NumValues: 0x0003
enum class EP2GameplayCueNotify_LocallyControlledSource : uint8
{
	InstigatorActor                          = 0,
	TargetActor                              = 1,
	EP2GameplayCueNotify_MAX                 = 2,
};

// Enum Game.EP2GameplayCueNotify_LocallyControlledPolicy
// NumValues: 0x0005
enum class EP2GameplayCueNotify_LocallyControlledPolicy : uint8
{
	Always                                   = 0,
	LocalOnly                                = 1,
	ViewTarget                               = 2,
	RemoteOnly                               = 3,
	EP2GameplayCueNotify_MAX                 = 4,
};

// Enum Game.EP2GameplayCueNotify_AttachPolicy
// NumValues: 0x0003
enum class EP2GameplayCueNotify_AttachPolicy : uint8
{
	DoNotAttach                              = 0,
	AttachToTarget                           = 1,
	EP2GameplayCueNotify_MAX                 = 2,
};

// ScriptStruct Game.P2MeshFeatureConfig
// 0x0038 (0x0038 - 0x0000)
struct FP2MeshFeatureConfig final
{
public:
	class UPhysicsAsset*                          MaterialFXUnwrapPA;                                // 0x0000(0x0008)(Edit, ZeroConstructor, NoDestructor, AssetRegistrySearchable, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UPhysicsAsset*                          MaterialFXEnvironmentPA;                           // 0x0008(0x0008)(Edit, ZeroConstructor, NoDestructor, AssetRegistrySearchable, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UP2MaterialFXData*                      MaterialFXData;                                    // 0x0010(0x0008)(Edit, ZeroConstructor, NoDestructor, AssetRegistrySearchable, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          MaterialFXDataUseDefault;                          // 0x0018(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19[0x3];                                       // 0x0019(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   MaterialFXDefaultCapsule;                          // 0x001C(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   MaterialFXDefaultBone;                             // 0x0024(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C[0x4];                                       // 0x002C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UPhysicsAsset*                          IVPhysicsAsset;                                    // 0x0030(0x0008)(Edit, ZeroConstructor, NoDestructor, AssetRegistrySearchable, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FP2MeshFeatureConfig) == 0x000008, "Wrong alignment on FP2MeshFeatureConfig");
static_assert(sizeof(FP2MeshFeatureConfig) == 0x000038, "Wrong size on FP2MeshFeatureConfig");
static_assert(offsetof(FP2MeshFeatureConfig, MaterialFXUnwrapPA) == 0x000000, "Member 'FP2MeshFeatureConfig::MaterialFXUnwrapPA' has a wrong offset!");
static_assert(offsetof(FP2MeshFeatureConfig, MaterialFXEnvironmentPA) == 0x000008, "Member 'FP2MeshFeatureConfig::MaterialFXEnvironmentPA' has a wrong offset!");
static_assert(offsetof(FP2MeshFeatureConfig, MaterialFXData) == 0x000010, "Member 'FP2MeshFeatureConfig::MaterialFXData' has a wrong offset!");
static_assert(offsetof(FP2MeshFeatureConfig, MaterialFXDataUseDefault) == 0x000018, "Member 'FP2MeshFeatureConfig::MaterialFXDataUseDefault' has a wrong offset!");
static_assert(offsetof(FP2MeshFeatureConfig, MaterialFXDefaultCapsule) == 0x00001C, "Member 'FP2MeshFeatureConfig::MaterialFXDefaultCapsule' has a wrong offset!");
static_assert(offsetof(FP2MeshFeatureConfig, MaterialFXDefaultBone) == 0x000024, "Member 'FP2MeshFeatureConfig::MaterialFXDefaultBone' has a wrong offset!");
static_assert(offsetof(FP2MeshFeatureConfig, IVPhysicsAsset) == 0x000030, "Member 'FP2MeshFeatureConfig::IVPhysicsAsset' has a wrong offset!");

// ScriptStruct Game.P2ChangeWeaponActivationContext
// 0x0014 (0x0014 - 0x0000)
struct alignas(0x04) FP2ChangeWeaponActivationContext final
{
public:
	uint8                                         Pad_0[0x14];                                       // 0x0000(0x0014)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FP2ChangeWeaponActivationContext) == 0x000004, "Wrong alignment on FP2ChangeWeaponActivationContext");
static_assert(sizeof(FP2ChangeWeaponActivationContext) == 0x000014, "Wrong size on FP2ChangeWeaponActivationContext");

// ScriptStruct Game.P2LootSpawnMinMax
// 0x0008 (0x0008 - 0x0000)
struct FP2LootSpawnMinMax final
{
public:
	int32                                         Min;                                               // 0x0000(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Max;                                               // 0x0004(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FP2LootSpawnMinMax) == 0x000004, "Wrong alignment on FP2LootSpawnMinMax");
static_assert(sizeof(FP2LootSpawnMinMax) == 0x000008, "Wrong size on FP2LootSpawnMinMax");
static_assert(offsetof(FP2LootSpawnMinMax, Min) == 0x000000, "Member 'FP2LootSpawnMinMax::Min' has a wrong offset!");
static_assert(offsetof(FP2LootSpawnMinMax, Max) == 0x000004, "Member 'FP2LootSpawnMinMax::Max' has a wrong offset!");

// ScriptStruct Game.P2LootSpawnAttachable
// 0x0018 (0x0018 - 0x0000)
struct FP2LootSpawnAttachable final
{
public:
	class UP2ItemData*                            Item;                                              // 0x0000(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FP2LootSpawnMinMax                     Stack;                                             // 0x0008(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          bShouldReplace;                                    // 0x0010(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x7];                                       // 0x0011(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FP2LootSpawnAttachable) == 0x000008, "Wrong alignment on FP2LootSpawnAttachable");
static_assert(sizeof(FP2LootSpawnAttachable) == 0x000018, "Wrong size on FP2LootSpawnAttachable");
static_assert(offsetof(FP2LootSpawnAttachable, Item) == 0x000000, "Member 'FP2LootSpawnAttachable::Item' has a wrong offset!");
static_assert(offsetof(FP2LootSpawnAttachable, Stack) == 0x000008, "Member 'FP2LootSpawnAttachable::Stack' has a wrong offset!");
static_assert(offsetof(FP2LootSpawnAttachable, bShouldReplace) == 0x000010, "Member 'FP2LootSpawnAttachable::bShouldReplace' has a wrong offset!");

// ScriptStruct Game.P2LootSpawnFixedItemSimple
// 0x0030 (0x0030 - 0x0000)
struct FP2LootSpawnFixedItemSimple final
{
public:
	class UP2ItemData*                            Item;                                              // 0x0000(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FP2LootSpawnMinMax                     Stack;                                             // 0x0008(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, NativeAccessSpecifierPublic)
	TArray<struct FP2LootSpawnAttachable>         Attachables;                                       // 0x0010(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	float                                         Probability;                                       // 0x0020(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FP2LootSpawnMinMax                     Amount;                                            // 0x0024(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C[0x4];                                       // 0x002C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FP2LootSpawnFixedItemSimple) == 0x000008, "Wrong alignment on FP2LootSpawnFixedItemSimple");
static_assert(sizeof(FP2LootSpawnFixedItemSimple) == 0x000030, "Wrong size on FP2LootSpawnFixedItemSimple");
static_assert(offsetof(FP2LootSpawnFixedItemSimple, Item) == 0x000000, "Member 'FP2LootSpawnFixedItemSimple::Item' has a wrong offset!");
static_assert(offsetof(FP2LootSpawnFixedItemSimple, Stack) == 0x000008, "Member 'FP2LootSpawnFixedItemSimple::Stack' has a wrong offset!");
static_assert(offsetof(FP2LootSpawnFixedItemSimple, Attachables) == 0x000010, "Member 'FP2LootSpawnFixedItemSimple::Attachables' has a wrong offset!");
static_assert(offsetof(FP2LootSpawnFixedItemSimple, Probability) == 0x000020, "Member 'FP2LootSpawnFixedItemSimple::Probability' has a wrong offset!");
static_assert(offsetof(FP2LootSpawnFixedItemSimple, Amount) == 0x000024, "Member 'FP2LootSpawnFixedItemSimple::Amount' has a wrong offset!");

// ScriptStruct Game.P2EquipmentAttributes
// 0x0008 (0x0008 - 0x0000)
struct FP2EquipmentAttributes final
{
public:
	float                                         TotalWeight;                                       // 0x0000(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TotalValue;                                        // 0x0004(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FP2EquipmentAttributes) == 0x000004, "Wrong alignment on FP2EquipmentAttributes");
static_assert(sizeof(FP2EquipmentAttributes) == 0x000008, "Wrong size on FP2EquipmentAttributes");
static_assert(offsetof(FP2EquipmentAttributes, TotalWeight) == 0x000000, "Member 'FP2EquipmentAttributes::TotalWeight' has a wrong offset!");
static_assert(offsetof(FP2EquipmentAttributes, TotalValue) == 0x000004, "Member 'FP2EquipmentAttributes::TotalValue' has a wrong offset!");

// ScriptStruct Game.P2InputActionInfo
// 0x0010 (0x0010 - 0x0000)
struct FP2InputActionInfo final
{
public:
	class UInputAction*                           InputAction;                                       // 0x0000(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   InputName;                                         // 0x0008(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FP2InputActionInfo) == 0x000008, "Wrong alignment on FP2InputActionInfo");
static_assert(sizeof(FP2InputActionInfo) == 0x000010, "Wrong size on FP2InputActionInfo");
static_assert(offsetof(FP2InputActionInfo, InputAction) == 0x000000, "Member 'FP2InputActionInfo::InputAction' has a wrong offset!");
static_assert(offsetof(FP2InputActionInfo, InputName) == 0x000008, "Member 'FP2InputActionInfo::InputName' has a wrong offset!");

// ScriptStruct Game.P2AnomalyReplicatedInfoDebug
// 0x0028 (0x0028 - 0x0000)
struct FP2AnomalyReplicatedInfoDebug final
{
public:
	bool                                          bDebugEnable;                                      // 0x0000(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bMatchStarted;                                     // 0x0001(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2[0x2];                                        // 0x0002(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         TimeMatchStarted;                                  // 0x0004(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LastTimeBubbleSpawn;                               // 0x0008(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bBubbleReadyToUse;                                 // 0x000C(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCanbSpawnBubble;                                  // 0x000D(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_E[0x2];                                        // 0x000E(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ScoreHeatThreshold;                                // 0x0010(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FVector>                        ListChangedCells;                                  // 0x0018(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FP2AnomalyReplicatedInfoDebug) == 0x000008, "Wrong alignment on FP2AnomalyReplicatedInfoDebug");
static_assert(sizeof(FP2AnomalyReplicatedInfoDebug) == 0x000028, "Wrong size on FP2AnomalyReplicatedInfoDebug");
static_assert(offsetof(FP2AnomalyReplicatedInfoDebug, bDebugEnable) == 0x000000, "Member 'FP2AnomalyReplicatedInfoDebug::bDebugEnable' has a wrong offset!");
static_assert(offsetof(FP2AnomalyReplicatedInfoDebug, bMatchStarted) == 0x000001, "Member 'FP2AnomalyReplicatedInfoDebug::bMatchStarted' has a wrong offset!");
static_assert(offsetof(FP2AnomalyReplicatedInfoDebug, TimeMatchStarted) == 0x000004, "Member 'FP2AnomalyReplicatedInfoDebug::TimeMatchStarted' has a wrong offset!");
static_assert(offsetof(FP2AnomalyReplicatedInfoDebug, LastTimeBubbleSpawn) == 0x000008, "Member 'FP2AnomalyReplicatedInfoDebug::LastTimeBubbleSpawn' has a wrong offset!");
static_assert(offsetof(FP2AnomalyReplicatedInfoDebug, bBubbleReadyToUse) == 0x00000C, "Member 'FP2AnomalyReplicatedInfoDebug::bBubbleReadyToUse' has a wrong offset!");
static_assert(offsetof(FP2AnomalyReplicatedInfoDebug, bCanbSpawnBubble) == 0x00000D, "Member 'FP2AnomalyReplicatedInfoDebug::bCanbSpawnBubble' has a wrong offset!");
static_assert(offsetof(FP2AnomalyReplicatedInfoDebug, ScoreHeatThreshold) == 0x000010, "Member 'FP2AnomalyReplicatedInfoDebug::ScoreHeatThreshold' has a wrong offset!");
static_assert(offsetof(FP2AnomalyReplicatedInfoDebug, ListChangedCells) == 0x000018, "Member 'FP2AnomalyReplicatedInfoDebug::ListChangedCells' has a wrong offset!");

// ScriptStruct Game.PerspectiveMontageData
// 0x0030 (0x0030 - 0x0000)
struct FPerspectiveMontageData final
{
public:
	class UAnimMontage*                           MontageFPP;                                        // 0x0000(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimMontage*                           MontageTPP;                                        // 0x0008(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimMontage*                           MontageItem;                                       // 0x0010(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bForceSection;                                     // 0x0018(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19[0x3];                                       // 0x0019(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   SectionName;                                       // 0x001C(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CharacterPlayRate;                                 // 0x0024(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ItemPlayRate;                                      // 0x0028(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C[0x4];                                       // 0x002C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FPerspectiveMontageData) == 0x000008, "Wrong alignment on FPerspectiveMontageData");
static_assert(sizeof(FPerspectiveMontageData) == 0x000030, "Wrong size on FPerspectiveMontageData");
static_assert(offsetof(FPerspectiveMontageData, MontageFPP) == 0x000000, "Member 'FPerspectiveMontageData::MontageFPP' has a wrong offset!");
static_assert(offsetof(FPerspectiveMontageData, MontageTPP) == 0x000008, "Member 'FPerspectiveMontageData::MontageTPP' has a wrong offset!");
static_assert(offsetof(FPerspectiveMontageData, MontageItem) == 0x000010, "Member 'FPerspectiveMontageData::MontageItem' has a wrong offset!");
static_assert(offsetof(FPerspectiveMontageData, bForceSection) == 0x000018, "Member 'FPerspectiveMontageData::bForceSection' has a wrong offset!");
static_assert(offsetof(FPerspectiveMontageData, SectionName) == 0x00001C, "Member 'FPerspectiveMontageData::SectionName' has a wrong offset!");
static_assert(offsetof(FPerspectiveMontageData, CharacterPlayRate) == 0x000024, "Member 'FPerspectiveMontageData::CharacterPlayRate' has a wrong offset!");
static_assert(offsetof(FPerspectiveMontageData, ItemPlayRate) == 0x000028, "Member 'FPerspectiveMontageData::ItemPlayRate' has a wrong offset!");

// ScriptStruct Game.P2ContextMenuFunctionInfo
// 0x0018 (0x0018 - 0x0000)
struct FP2ContextMenuFunctionInfo final
{
public:
	TSubclassOf<class UP2ContextMenuFunction>     DefaultContextMenuFunction;                        // 0x0000(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<TSubclassOf<class UP2ContextMenuFunction>> ContextMenuFunctions;                          // 0x0008(0x0010)(Edit, BlueprintVisible, ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
};
static_assert(alignof(FP2ContextMenuFunctionInfo) == 0x000008, "Wrong alignment on FP2ContextMenuFunctionInfo");
static_assert(sizeof(FP2ContextMenuFunctionInfo) == 0x000018, "Wrong size on FP2ContextMenuFunctionInfo");
static_assert(offsetof(FP2ContextMenuFunctionInfo, DefaultContextMenuFunction) == 0x000000, "Member 'FP2ContextMenuFunctionInfo::DefaultContextMenuFunction' has a wrong offset!");
static_assert(offsetof(FP2ContextMenuFunctionInfo, ContextMenuFunctions) == 0x000008, "Member 'FP2ContextMenuFunctionInfo::ContextMenuFunctions' has a wrong offset!");

// ScriptStruct Game.P2ContextMenuDataRow
// 0x0030 (0x0038 - 0x0008)
struct FP2ContextMenuDataRow final : public FTableRowBase
{
public:
	struct FGameplayTagContainer                  ItemTags;                                          // 0x0008(0x0020)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	TArray<struct FP2ContextMenuFunctionInfo>     ContextMenuFunctionInfos;                          // 0x0028(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FP2ContextMenuDataRow) == 0x000008, "Wrong alignment on FP2ContextMenuDataRow");
static_assert(sizeof(FP2ContextMenuDataRow) == 0x000038, "Wrong size on FP2ContextMenuDataRow");
static_assert(offsetof(FP2ContextMenuDataRow, ItemTags) == 0x000008, "Member 'FP2ContextMenuDataRow::ItemTags' has a wrong offset!");
static_assert(offsetof(FP2ContextMenuDataRow, ContextMenuFunctionInfos) == 0x000028, "Member 'FP2ContextMenuDataRow::ContextMenuFunctionInfos' has a wrong offset!");

// ScriptStruct Game.P2MeleeSwingImpactConfig
// 0x0018 (0x0018 - 0x0000)
struct FP2MeleeSwingImpactConfig final
{
public:
	struct FGameplayCueTag                        WorldHitCue;                                       // 0x0000(0x0008)(Edit, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
	struct FGameplayCueTag                        CharacterHitCue;                                   // 0x0008(0x0008)(Edit, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
	struct FGameplayCueTag                        CharacterBlockCue;                                 // 0x0010(0x0008)(Edit, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FP2MeleeSwingImpactConfig) == 0x000004, "Wrong alignment on FP2MeleeSwingImpactConfig");
static_assert(sizeof(FP2MeleeSwingImpactConfig) == 0x000018, "Wrong size on FP2MeleeSwingImpactConfig");
static_assert(offsetof(FP2MeleeSwingImpactConfig, WorldHitCue) == 0x000000, "Member 'FP2MeleeSwingImpactConfig::WorldHitCue' has a wrong offset!");
static_assert(offsetof(FP2MeleeSwingImpactConfig, CharacterHitCue) == 0x000008, "Member 'FP2MeleeSwingImpactConfig::CharacterHitCue' has a wrong offset!");
static_assert(offsetof(FP2MeleeSwingImpactConfig, CharacterBlockCue) == 0x000010, "Member 'FP2MeleeSwingImpactConfig::CharacterBlockCue' has a wrong offset!");

// ScriptStruct Game.P2FinalBlowImpulseData
// 0x0028 (0x0028 - 0x0000)
struct FP2FinalBlowImpulseData final
{
public:
	class FName                                   bone;                                              // 0x0000(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector_NetQuantize                    Impulse;                                           // 0x0008(0x0018)(BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ParentBoneImpulseScale;                            // 0x0020(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         UpperBodyImpulseScale;                             // 0x0024(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FP2FinalBlowImpulseData) == 0x000008, "Wrong alignment on FP2FinalBlowImpulseData");
static_assert(sizeof(FP2FinalBlowImpulseData) == 0x000028, "Wrong size on FP2FinalBlowImpulseData");
static_assert(offsetof(FP2FinalBlowImpulseData, bone) == 0x000000, "Member 'FP2FinalBlowImpulseData::bone' has a wrong offset!");
static_assert(offsetof(FP2FinalBlowImpulseData, Impulse) == 0x000008, "Member 'FP2FinalBlowImpulseData::Impulse' has a wrong offset!");
static_assert(offsetof(FP2FinalBlowImpulseData, ParentBoneImpulseScale) == 0x000020, "Member 'FP2FinalBlowImpulseData::ParentBoneImpulseScale' has a wrong offset!");
static_assert(offsetof(FP2FinalBlowImpulseData, UpperBodyImpulseScale) == 0x000024, "Member 'FP2FinalBlowImpulseData::UpperBodyImpulseScale' has a wrong offset!");

// ScriptStruct Game.P2ExtractionTunnelInfo
// 0x0020 (0x0020 - 0x0000)
struct FP2ExtractionTunnelInfo final
{
public:
	class AP2ExtractionTunnel*                    Tunnel;                                            // 0x0000(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector_NetQuantize100                 Location;                                          // 0x0008(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FP2ExtractionTunnelInfo) == 0x000008, "Wrong alignment on FP2ExtractionTunnelInfo");
static_assert(sizeof(FP2ExtractionTunnelInfo) == 0x000020, "Wrong size on FP2ExtractionTunnelInfo");
static_assert(offsetof(FP2ExtractionTunnelInfo, Tunnel) == 0x000000, "Member 'FP2ExtractionTunnelInfo::Tunnel' has a wrong offset!");
static_assert(offsetof(FP2ExtractionTunnelInfo, Location) == 0x000008, "Member 'FP2ExtractionTunnelInfo::Location' has a wrong offset!");

// ScriptStruct Game.P2PauseControlPointInfo
// 0x0030 (0x0030 - 0x0000)
struct FP2PauseControlPointInfo final
{
public:
	struct FP2ExtractionTunnelInfo                Tunnel;                                            // 0x0000(0x0020)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
	TArray<struct FP2ExtractionTunnelInfo>        Tunnels;                                           // 0x0020(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
};
static_assert(alignof(FP2PauseControlPointInfo) == 0x000008, "Wrong alignment on FP2PauseControlPointInfo");
static_assert(sizeof(FP2PauseControlPointInfo) == 0x000030, "Wrong size on FP2PauseControlPointInfo");
static_assert(offsetof(FP2PauseControlPointInfo, Tunnel) == 0x000000, "Member 'FP2PauseControlPointInfo::Tunnel' has a wrong offset!");
static_assert(offsetof(FP2PauseControlPointInfo, Tunnels) == 0x000020, "Member 'FP2PauseControlPointInfo::Tunnels' has a wrong offset!");

// ScriptStruct Game.P2ReplicatedPauseControlPointInfo
// 0x00E0 (0x00E0 - 0x0000)
struct FP2ReplicatedPauseControlPointInfo final
{
public:
	TArray<int32>                                 ReplicatedPausedCPs;                               // 0x0000(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TArray<struct FP2PauseControlPointInfo>       ReplicatedControlPointPausedInfos;                 // 0x0010(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TMap<int32, struct FP2PauseControlPointInfo>  ControlPointPausedInfos;                           // 0x0020(0x0050)(RepSkip, NativeAccessSpecifierPublic)
	TArray<int32>                                 ReplicatedDelayedCPs;                              // 0x0070(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TArray<struct FVector_NetQuantize100>         ReplicatedDelayedPos;                              // 0x0080(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TMap<int32, struct FVector>                   DelayedControlPoints;                              // 0x0090(0x0050)(RepSkip, NativeAccessSpecifierPublic)
};
static_assert(alignof(FP2ReplicatedPauseControlPointInfo) == 0x000008, "Wrong alignment on FP2ReplicatedPauseControlPointInfo");
static_assert(sizeof(FP2ReplicatedPauseControlPointInfo) == 0x0000E0, "Wrong size on FP2ReplicatedPauseControlPointInfo");
static_assert(offsetof(FP2ReplicatedPauseControlPointInfo, ReplicatedPausedCPs) == 0x000000, "Member 'FP2ReplicatedPauseControlPointInfo::ReplicatedPausedCPs' has a wrong offset!");
static_assert(offsetof(FP2ReplicatedPauseControlPointInfo, ReplicatedControlPointPausedInfos) == 0x000010, "Member 'FP2ReplicatedPauseControlPointInfo::ReplicatedControlPointPausedInfos' has a wrong offset!");
static_assert(offsetof(FP2ReplicatedPauseControlPointInfo, ControlPointPausedInfos) == 0x000020, "Member 'FP2ReplicatedPauseControlPointInfo::ControlPointPausedInfos' has a wrong offset!");
static_assert(offsetof(FP2ReplicatedPauseControlPointInfo, ReplicatedDelayedCPs) == 0x000070, "Member 'FP2ReplicatedPauseControlPointInfo::ReplicatedDelayedCPs' has a wrong offset!");
static_assert(offsetof(FP2ReplicatedPauseControlPointInfo, ReplicatedDelayedPos) == 0x000080, "Member 'FP2ReplicatedPauseControlPointInfo::ReplicatedDelayedPos' has a wrong offset!");
static_assert(offsetof(FP2ReplicatedPauseControlPointInfo, DelayedControlPoints) == 0x000090, "Member 'FP2ReplicatedPauseControlPointInfo::DelayedControlPoints' has a wrong offset!");

// ScriptStruct Game.P2MapFeatureRenderTargetDefinition
// 0x0020 (0x0020 - 0x0000)
struct FP2MapFeatureRenderTargetDefinition
{
public:
	int32                                         SizeX;                                             // 0x0000(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         SizeY;                                             // 0x0004(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETextureRenderTargetFormat                    RenderTargetFormat;                                // 0x0008(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x3];                                        // 0x0009(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FLinearColor                           ClearColor;                                        // 0x000C(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         OrthoWidth;                                        // 0x001C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FP2MapFeatureRenderTargetDefinition) == 0x000004, "Wrong alignment on FP2MapFeatureRenderTargetDefinition");
static_assert(sizeof(FP2MapFeatureRenderTargetDefinition) == 0x000020, "Wrong size on FP2MapFeatureRenderTargetDefinition");
static_assert(offsetof(FP2MapFeatureRenderTargetDefinition, SizeX) == 0x000000, "Member 'FP2MapFeatureRenderTargetDefinition::SizeX' has a wrong offset!");
static_assert(offsetof(FP2MapFeatureRenderTargetDefinition, SizeY) == 0x000004, "Member 'FP2MapFeatureRenderTargetDefinition::SizeY' has a wrong offset!");
static_assert(offsetof(FP2MapFeatureRenderTargetDefinition, RenderTargetFormat) == 0x000008, "Member 'FP2MapFeatureRenderTargetDefinition::RenderTargetFormat' has a wrong offset!");
static_assert(offsetof(FP2MapFeatureRenderTargetDefinition, ClearColor) == 0x00000C, "Member 'FP2MapFeatureRenderTargetDefinition::ClearColor' has a wrong offset!");
static_assert(offsetof(FP2MapFeatureRenderTargetDefinition, OrthoWidth) == 0x00001C, "Member 'FP2MapFeatureRenderTargetDefinition::OrthoWidth' has a wrong offset!");

// ScriptStruct Game.P2MapFeatureRenderTargetDefinition_Anomaly
// 0x0008 (0x0028 - 0x0020)
struct FP2MapFeatureRenderTargetDefinition_Anomaly final : public FP2MapFeatureRenderTargetDefinition
{
public:
	float                                         SampleStep;                                        // 0x0020(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SampleMinAngle;                                    // 0x0024(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FP2MapFeatureRenderTargetDefinition_Anomaly) == 0x000004, "Wrong alignment on FP2MapFeatureRenderTargetDefinition_Anomaly");
static_assert(sizeof(FP2MapFeatureRenderTargetDefinition_Anomaly) == 0x000028, "Wrong size on FP2MapFeatureRenderTargetDefinition_Anomaly");
static_assert(offsetof(FP2MapFeatureRenderTargetDefinition_Anomaly, SampleStep) == 0x000020, "Member 'FP2MapFeatureRenderTargetDefinition_Anomaly::SampleStep' has a wrong offset!");
static_assert(offsetof(FP2MapFeatureRenderTargetDefinition_Anomaly, SampleMinAngle) == 0x000024, "Member 'FP2MapFeatureRenderTargetDefinition_Anomaly::SampleMinAngle' has a wrong offset!");

// ScriptStruct Game.P2SoundInfo
// 0x0018 (0x0018 - 0x0000)
struct FP2SoundInfo final
{
public:
	struct FGameplayTag                           GeneralSoundTag;                                   // 0x0000(0x0008)(Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAkAudioEvent*                          OverrideAudioEvent;                                // 0x0008(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsMute;                                            // 0x0010(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x7];                                       // 0x0011(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FP2SoundInfo) == 0x000008, "Wrong alignment on FP2SoundInfo");
static_assert(sizeof(FP2SoundInfo) == 0x000018, "Wrong size on FP2SoundInfo");
static_assert(offsetof(FP2SoundInfo, GeneralSoundTag) == 0x000000, "Member 'FP2SoundInfo::GeneralSoundTag' has a wrong offset!");
static_assert(offsetof(FP2SoundInfo, OverrideAudioEvent) == 0x000008, "Member 'FP2SoundInfo::OverrideAudioEvent' has a wrong offset!");
static_assert(offsetof(FP2SoundInfo, IsMute) == 0x000010, "Member 'FP2SoundInfo::IsMute' has a wrong offset!");

// ScriptStruct Game.P2DynamicFactionReqData
// 0x0018 (0x0018 - 0x0000)
struct FP2DynamicFactionReqData final
{
public:
	struct FGameplayTag                           RewardTag;                                         // 0x0000(0x0008)(BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           FactionTag;                                        // 0x0008(0x0008)(BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         BaseAmount;                                        // 0x0010(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         AdjustedAmount;                                    // 0x0014(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FP2DynamicFactionReqData) == 0x000004, "Wrong alignment on FP2DynamicFactionReqData");
static_assert(sizeof(FP2DynamicFactionReqData) == 0x000018, "Wrong size on FP2DynamicFactionReqData");
static_assert(offsetof(FP2DynamicFactionReqData, RewardTag) == 0x000000, "Member 'FP2DynamicFactionReqData::RewardTag' has a wrong offset!");
static_assert(offsetof(FP2DynamicFactionReqData, FactionTag) == 0x000008, "Member 'FP2DynamicFactionReqData::FactionTag' has a wrong offset!");
static_assert(offsetof(FP2DynamicFactionReqData, BaseAmount) == 0x000010, "Member 'FP2DynamicFactionReqData::BaseAmount' has a wrong offset!");
static_assert(offsetof(FP2DynamicFactionReqData, AdjustedAmount) == 0x000014, "Member 'FP2DynamicFactionReqData::AdjustedAmount' has a wrong offset!");

// ScriptStruct Game.P2DynamicFactionReqToolTipData
// 0x0010 (0x0010 - 0x0000)
struct FP2DynamicFactionReqToolTipData final
{
public:
	TArray<struct FP2DynamicFactionReqData>       DynamicFactionReqDatas;                            // 0x0000(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FP2DynamicFactionReqToolTipData) == 0x000008, "Wrong alignment on FP2DynamicFactionReqToolTipData");
static_assert(sizeof(FP2DynamicFactionReqToolTipData) == 0x000010, "Wrong size on FP2DynamicFactionReqToolTipData");
static_assert(offsetof(FP2DynamicFactionReqToolTipData, DynamicFactionReqDatas) == 0x000000, "Member 'FP2DynamicFactionReqToolTipData::DynamicFactionReqDatas' has a wrong offset!");

// ScriptStruct Game.P2SkelMeshUpdateRateParams
// 0x0070 (0x0070 - 0x0000)
struct FP2SkelMeshUpdateRateParams final
{
public:
	EP2SkelMeshUpdateRateShiftBucket              ShiftBucket;                                       // 0x0000(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bInterpolateSkippedFrames;                         // 0x0001(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bShouldUseLodMap;                                  // 0x0002(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bShouldUseMinLod;                                  // 0x0003(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         BaseNonRenderedUpdateRate;                         // 0x0004(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MaxEvalRateForInterpolation;                       // 0x0008(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<float>                                 BaseVisibleDistanceFactorThresholds;               // 0x0010(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TMap<int32, int32>                            LODToFrameSkipMap;                                 // 0x0020(0x0050)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
};
static_assert(alignof(FP2SkelMeshUpdateRateParams) == 0x000008, "Wrong alignment on FP2SkelMeshUpdateRateParams");
static_assert(sizeof(FP2SkelMeshUpdateRateParams) == 0x000070, "Wrong size on FP2SkelMeshUpdateRateParams");
static_assert(offsetof(FP2SkelMeshUpdateRateParams, ShiftBucket) == 0x000000, "Member 'FP2SkelMeshUpdateRateParams::ShiftBucket' has a wrong offset!");
static_assert(offsetof(FP2SkelMeshUpdateRateParams, bInterpolateSkippedFrames) == 0x000001, "Member 'FP2SkelMeshUpdateRateParams::bInterpolateSkippedFrames' has a wrong offset!");
static_assert(offsetof(FP2SkelMeshUpdateRateParams, bShouldUseLodMap) == 0x000002, "Member 'FP2SkelMeshUpdateRateParams::bShouldUseLodMap' has a wrong offset!");
static_assert(offsetof(FP2SkelMeshUpdateRateParams, bShouldUseMinLod) == 0x000003, "Member 'FP2SkelMeshUpdateRateParams::bShouldUseMinLod' has a wrong offset!");
static_assert(offsetof(FP2SkelMeshUpdateRateParams, BaseNonRenderedUpdateRate) == 0x000004, "Member 'FP2SkelMeshUpdateRateParams::BaseNonRenderedUpdateRate' has a wrong offset!");
static_assert(offsetof(FP2SkelMeshUpdateRateParams, MaxEvalRateForInterpolation) == 0x000008, "Member 'FP2SkelMeshUpdateRateParams::MaxEvalRateForInterpolation' has a wrong offset!");
static_assert(offsetof(FP2SkelMeshUpdateRateParams, BaseVisibleDistanceFactorThresholds) == 0x000010, "Member 'FP2SkelMeshUpdateRateParams::BaseVisibleDistanceFactorThresholds' has a wrong offset!");
static_assert(offsetof(FP2SkelMeshUpdateRateParams, LODToFrameSkipMap) == 0x000020, "Member 'FP2SkelMeshUpdateRateParams::LODToFrameSkipMap' has a wrong offset!");

// ScriptStruct Game.P2TutorialWidgetState
// 0x0008 (0x0008 - 0x0000)
struct FP2TutorialWidgetState final
{
public:
	int32                                         StepIndex;                                         // 0x0000(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EP2TutorialWidgetType                         WidgetType;                                        // 0x0004(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bBlockInput;                                       // 0x0005(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_6[0x2];                                        // 0x0006(0x0002)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FP2TutorialWidgetState) == 0x000004, "Wrong alignment on FP2TutorialWidgetState");
static_assert(sizeof(FP2TutorialWidgetState) == 0x000008, "Wrong size on FP2TutorialWidgetState");
static_assert(offsetof(FP2TutorialWidgetState, StepIndex) == 0x000000, "Member 'FP2TutorialWidgetState::StepIndex' has a wrong offset!");
static_assert(offsetof(FP2TutorialWidgetState, WidgetType) == 0x000004, "Member 'FP2TutorialWidgetState::WidgetType' has a wrong offset!");
static_assert(offsetof(FP2TutorialWidgetState, bBlockInput) == 0x000005, "Member 'FP2TutorialWidgetState::bBlockInput' has a wrong offset!");

// ScriptStruct Game.P2AnomalyReplicatedInfo
// 0x0020 (0x0020 - 0x0000)
struct FP2AnomalyReplicatedInfo final
{
public:
	int32                                         Seed;                                              // 0x0000(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         SessionDifficulty;                                 // 0x0004(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         RaidTime;                                          // 0x0008(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           GateTag;                                           // 0x000C(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         SelectedBakedAnomaly;                              // 0x0014(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TWeakObjectPtr<class AP2ExtractionTunnel>     ExtractionTunnelCenter;                            // 0x0018(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FP2AnomalyReplicatedInfo) == 0x000004, "Wrong alignment on FP2AnomalyReplicatedInfo");
static_assert(sizeof(FP2AnomalyReplicatedInfo) == 0x000020, "Wrong size on FP2AnomalyReplicatedInfo");
static_assert(offsetof(FP2AnomalyReplicatedInfo, Seed) == 0x000000, "Member 'FP2AnomalyReplicatedInfo::Seed' has a wrong offset!");
static_assert(offsetof(FP2AnomalyReplicatedInfo, SessionDifficulty) == 0x000004, "Member 'FP2AnomalyReplicatedInfo::SessionDifficulty' has a wrong offset!");
static_assert(offsetof(FP2AnomalyReplicatedInfo, RaidTime) == 0x000008, "Member 'FP2AnomalyReplicatedInfo::RaidTime' has a wrong offset!");
static_assert(offsetof(FP2AnomalyReplicatedInfo, GateTag) == 0x00000C, "Member 'FP2AnomalyReplicatedInfo::GateTag' has a wrong offset!");
static_assert(offsetof(FP2AnomalyReplicatedInfo, SelectedBakedAnomaly) == 0x000014, "Member 'FP2AnomalyReplicatedInfo::SelectedBakedAnomaly' has a wrong offset!");
static_assert(offsetof(FP2AnomalyReplicatedInfo, ExtractionTunnelCenter) == 0x000018, "Member 'FP2AnomalyReplicatedInfo::ExtractionTunnelCenter' has a wrong offset!");

// ScriptStruct Game.P2GameplayContextInfo
// 0x0048 (0x0048 - 0x0000)
struct FP2GameplayContextInfo final
{
public:
	TSoftObjectPtr<class UP2GameplayContextDataBase> ContextDataPtr;                                 // 0x0000(0x0030)(BlueprintVisible, BlueprintReadOnly, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EP2GameplayContextDataType                    ContextType;                                       // 0x0030(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EP2GameplayContextArchiveType                 ArchiveType;                                       // 0x0031(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_32[0x6];                                       // 0x0032(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 ContextJson;                                       // 0x0038(0x0010)(ZeroConstructor, Transient, RepSkip, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FP2GameplayContextInfo) == 0x000008, "Wrong alignment on FP2GameplayContextInfo");
static_assert(sizeof(FP2GameplayContextInfo) == 0x000048, "Wrong size on FP2GameplayContextInfo");
static_assert(offsetof(FP2GameplayContextInfo, ContextDataPtr) == 0x000000, "Member 'FP2GameplayContextInfo::ContextDataPtr' has a wrong offset!");
static_assert(offsetof(FP2GameplayContextInfo, ContextType) == 0x000030, "Member 'FP2GameplayContextInfo::ContextType' has a wrong offset!");
static_assert(offsetof(FP2GameplayContextInfo, ArchiveType) == 0x000031, "Member 'FP2GameplayContextInfo::ArchiveType' has a wrong offset!");
static_assert(offsetof(FP2GameplayContextInfo, ContextJson) == 0x000038, "Member 'FP2GameplayContextInfo::ContextJson' has a wrong offset!");

// ScriptStruct Game.P2BlockedContractStateGameMode
// 0x0040 (0x0040 - 0x0000)
struct FP2BlockedContractStateGameMode final
{
public:
	TArray<EP2ContractState>                      StatesBlockedHideout;                              // 0x0000(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<EP2ContractState>                      StatesBlockedRaid;                                 // 0x0010(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<EP2ContractState>                      StatesBlockedTutorial;                             // 0x0020(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<EP2ContractState>                      StatesBlockedDeathmatch;                           // 0x0030(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FP2BlockedContractStateGameMode) == 0x000008, "Wrong alignment on FP2BlockedContractStateGameMode");
static_assert(sizeof(FP2BlockedContractStateGameMode) == 0x000040, "Wrong size on FP2BlockedContractStateGameMode");
static_assert(offsetof(FP2BlockedContractStateGameMode, StatesBlockedHideout) == 0x000000, "Member 'FP2BlockedContractStateGameMode::StatesBlockedHideout' has a wrong offset!");
static_assert(offsetof(FP2BlockedContractStateGameMode, StatesBlockedRaid) == 0x000010, "Member 'FP2BlockedContractStateGameMode::StatesBlockedRaid' has a wrong offset!");
static_assert(offsetof(FP2BlockedContractStateGameMode, StatesBlockedTutorial) == 0x000020, "Member 'FP2BlockedContractStateGameMode::StatesBlockedTutorial' has a wrong offset!");
static_assert(offsetof(FP2BlockedContractStateGameMode, StatesBlockedDeathmatch) == 0x000030, "Member 'FP2BlockedContractStateGameMode::StatesBlockedDeathmatch' has a wrong offset!");

// ScriptStruct Game.P2Zones
// 0x0018 (0x0018 - 0x0000)
struct FP2Zones final
{
public:
	TArray<TWeakObjectPtr<class UP2TriggerZoneComponent>> Array;                                     // 0x0000(0x0010)(ExportObject, ZeroConstructor, ContainsInstancedReference, UObjectWrapper, NativeAccessSpecifierPublic)
	double                                        LastApplicationTimestamp;                          // 0x0010(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FP2Zones) == 0x000008, "Wrong alignment on FP2Zones");
static_assert(sizeof(FP2Zones) == 0x000018, "Wrong size on FP2Zones");
static_assert(offsetof(FP2Zones, Array) == 0x000000, "Member 'FP2Zones::Array' has a wrong offset!");
static_assert(offsetof(FP2Zones, LastApplicationTimestamp) == 0x000010, "Member 'FP2Zones::LastApplicationTimestamp' has a wrong offset!");

// ScriptStruct Game.P2LootSpawnCategoryRatio
// 0x000C (0x000C - 0x0000)
struct FP2LootSpawnCategoryRatio final
{
public:
	struct FGameplayTag                           CategoryRatio;                                     // 0x0000(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Ratio;                                             // 0x0008(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FP2LootSpawnCategoryRatio) == 0x000004, "Wrong alignment on FP2LootSpawnCategoryRatio");
static_assert(sizeof(FP2LootSpawnCategoryRatio) == 0x00000C, "Wrong size on FP2LootSpawnCategoryRatio");
static_assert(offsetof(FP2LootSpawnCategoryRatio, CategoryRatio) == 0x000000, "Member 'FP2LootSpawnCategoryRatio::CategoryRatio' has a wrong offset!");
static_assert(offsetof(FP2LootSpawnCategoryRatio, Ratio) == 0x000008, "Member 'FP2LootSpawnCategoryRatio::Ratio' has a wrong offset!");

// ScriptStruct Game.P2UIGameplayAttributeDisplayDataRow
// 0x00B8 (0x00C0 - 0x0008)
struct FP2UIGameplayAttributeDisplayDataRow final : public FTableRowBase
{
public:
	struct FGameplayAttribute                     Attribute;                                         // 0x0008(0x0038)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTagContainer                  ModifierRequirements;                              // 0x0040(0x0020)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FGameplayTagContainer                  OngoingRequirements;                               // 0x0060(0x0020)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	class FText                                   DisplayName;                                       // 0x0080(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	EP2GameplayAttributeDisplayMethod             DisplayMethod;                                     // 0x0098(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_99[0x7];                                       // 0x0099(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   DisplayUnit;                                       // 0x00A0(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	EP2GameplayAttributeDesirableChange           DesirableChange;                                   // 0x00B8(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_B9[0x7];                                       // 0x00B9(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FP2UIGameplayAttributeDisplayDataRow) == 0x000008, "Wrong alignment on FP2UIGameplayAttributeDisplayDataRow");
static_assert(sizeof(FP2UIGameplayAttributeDisplayDataRow) == 0x0000C0, "Wrong size on FP2UIGameplayAttributeDisplayDataRow");
static_assert(offsetof(FP2UIGameplayAttributeDisplayDataRow, Attribute) == 0x000008, "Member 'FP2UIGameplayAttributeDisplayDataRow::Attribute' has a wrong offset!");
static_assert(offsetof(FP2UIGameplayAttributeDisplayDataRow, ModifierRequirements) == 0x000040, "Member 'FP2UIGameplayAttributeDisplayDataRow::ModifierRequirements' has a wrong offset!");
static_assert(offsetof(FP2UIGameplayAttributeDisplayDataRow, OngoingRequirements) == 0x000060, "Member 'FP2UIGameplayAttributeDisplayDataRow::OngoingRequirements' has a wrong offset!");
static_assert(offsetof(FP2UIGameplayAttributeDisplayDataRow, DisplayName) == 0x000080, "Member 'FP2UIGameplayAttributeDisplayDataRow::DisplayName' has a wrong offset!");
static_assert(offsetof(FP2UIGameplayAttributeDisplayDataRow, DisplayMethod) == 0x000098, "Member 'FP2UIGameplayAttributeDisplayDataRow::DisplayMethod' has a wrong offset!");
static_assert(offsetof(FP2UIGameplayAttributeDisplayDataRow, DisplayUnit) == 0x0000A0, "Member 'FP2UIGameplayAttributeDisplayDataRow::DisplayUnit' has a wrong offset!");
static_assert(offsetof(FP2UIGameplayAttributeDisplayDataRow, DesirableChange) == 0x0000B8, "Member 'FP2UIGameplayAttributeDisplayDataRow::DesirableChange' has a wrong offset!");

// ScriptStruct Game.P2MapWidgetDefinition
// 0x0080 (0x0080 - 0x0000)
struct FP2MapWidgetDefinition final
{
public:
	TArray<TSubclassOf<class UP2MapWidgetComponent>> Widgets;                                        // 0x0000(0x0010)(Edit, BlueprintVisible, ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
	TSubclassOf<class UUserWidget>                UserWidget;                                        // 0x0010(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAffectsHighlight;                                 // 0x0018(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19[0x7];                                       // 0x0019(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             Offset;                                            // 0x0020(0x0060)(Edit, BlueprintVisible, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FP2MapWidgetDefinition) == 0x000010, "Wrong alignment on FP2MapWidgetDefinition");
static_assert(sizeof(FP2MapWidgetDefinition) == 0x000080, "Wrong size on FP2MapWidgetDefinition");
static_assert(offsetof(FP2MapWidgetDefinition, Widgets) == 0x000000, "Member 'FP2MapWidgetDefinition::Widgets' has a wrong offset!");
static_assert(offsetof(FP2MapWidgetDefinition, UserWidget) == 0x000010, "Member 'FP2MapWidgetDefinition::UserWidget' has a wrong offset!");
static_assert(offsetof(FP2MapWidgetDefinition, bAffectsHighlight) == 0x000018, "Member 'FP2MapWidgetDefinition::bAffectsHighlight' has a wrong offset!");
static_assert(offsetof(FP2MapWidgetDefinition, Offset) == 0x000020, "Member 'FP2MapWidgetDefinition::Offset' has a wrong offset!");

// ScriptStruct Game.MoveActionExecData
// 0x0020 (0x0020 - 0x0000)
struct FMoveActionExecData final
{
public:
	TArray<struct FVector>                        PositionArray;                                     // 0x0000(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	float                                         PlayRate;                                          // 0x0010(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UMoveActionDataAsset*                   MoveActionDataAsset;                               // 0x0018(0x0008)(Edit, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMoveActionExecData) == 0x000008, "Wrong alignment on FMoveActionExecData");
static_assert(sizeof(FMoveActionExecData) == 0x000020, "Wrong size on FMoveActionExecData");
static_assert(offsetof(FMoveActionExecData, PositionArray) == 0x000000, "Member 'FMoveActionExecData::PositionArray' has a wrong offset!");
static_assert(offsetof(FMoveActionExecData, PlayRate) == 0x000010, "Member 'FMoveActionExecData::PlayRate' has a wrong offset!");
static_assert(offsetof(FMoveActionExecData, MoveActionDataAsset) == 0x000018, "Member 'FMoveActionExecData::MoveActionDataAsset' has a wrong offset!");

// ScriptStruct Game.SpreadPatternConfig
// 0x0048 (0x0048 - 0x0000)
struct FSpreadPatternConfig final
{
public:
	struct FVector2D                              HorizontalRange;                                   // 0x0000(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCurveFloat*                            HorizontalProbabilityCurve;                        // 0x0010(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              VerticalRange;                                     // 0x0018(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCurveFloat*                            VerticalProbabilityCurve;                          // 0x0028(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bRadial;                                           // 0x0030(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_31[0x7];                                       // 0x0031(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UCurveFloat*                            LengthRemapCurve;                                  // 0x0038(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ExclusionDistance;                                 // 0x0040(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MaxIterationsPerPellet;                            // 0x0044(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSpreadPatternConfig) == 0x000008, "Wrong alignment on FSpreadPatternConfig");
static_assert(sizeof(FSpreadPatternConfig) == 0x000048, "Wrong size on FSpreadPatternConfig");
static_assert(offsetof(FSpreadPatternConfig, HorizontalRange) == 0x000000, "Member 'FSpreadPatternConfig::HorizontalRange' has a wrong offset!");
static_assert(offsetof(FSpreadPatternConfig, HorizontalProbabilityCurve) == 0x000010, "Member 'FSpreadPatternConfig::HorizontalProbabilityCurve' has a wrong offset!");
static_assert(offsetof(FSpreadPatternConfig, VerticalRange) == 0x000018, "Member 'FSpreadPatternConfig::VerticalRange' has a wrong offset!");
static_assert(offsetof(FSpreadPatternConfig, VerticalProbabilityCurve) == 0x000028, "Member 'FSpreadPatternConfig::VerticalProbabilityCurve' has a wrong offset!");
static_assert(offsetof(FSpreadPatternConfig, bRadial) == 0x000030, "Member 'FSpreadPatternConfig::bRadial' has a wrong offset!");
static_assert(offsetof(FSpreadPatternConfig, LengthRemapCurve) == 0x000038, "Member 'FSpreadPatternConfig::LengthRemapCurve' has a wrong offset!");
static_assert(offsetof(FSpreadPatternConfig, ExclusionDistance) == 0x000040, "Member 'FSpreadPatternConfig::ExclusionDistance' has a wrong offset!");
static_assert(offsetof(FSpreadPatternConfig, MaxIterationsPerPellet) == 0x000044, "Member 'FSpreadPatternConfig::MaxIterationsPerPellet' has a wrong offset!");

// ScriptStruct Game.P2RandomAmount
// 0x000C (0x000C - 0x0000)
struct FP2RandomAmount final
{
public:
	float                                         Weight;                                            // 0x0000(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FIntPoint                              AmountMinMax;                                      // 0x0004(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FP2RandomAmount) == 0x000004, "Wrong alignment on FP2RandomAmount");
static_assert(sizeof(FP2RandomAmount) == 0x00000C, "Wrong size on FP2RandomAmount");
static_assert(offsetof(FP2RandomAmount, Weight) == 0x000000, "Member 'FP2RandomAmount::Weight' has a wrong offset!");
static_assert(offsetof(FP2RandomAmount, AmountMinMax) == 0x000004, "Member 'FP2RandomAmount::AmountMinMax' has a wrong offset!");

// ScriptStruct Game.P2ExchangeInfo
// 0x0050 (0x0050 - 0x0000)
struct FP2ExchangeInfo final
{
public:
	class UP2ItemData*                            ItemData;                                          // 0x0000(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UP2ItemSkinContainer*                   ItemSkinContainer;                                 // 0x0008(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class UP2SkinSlotPreset*>              SkinSlotPresets;                                   // 0x0010(0x0010)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TArray<class UP2AttachableData*>              Attachables;                                       // 0x0020(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	int32                                         Amount;                                            // 0x0030(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_34[0x4];                                       // 0x0034(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FP2RandomAmount>                RandomAmounts;                                     // 0x0038(0x0010)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	EP2ExchangeInfoRandomGrade                    EventGrade;                                        // 0x0048(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsMasterPiece;                                     // 0x0049(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4A[0x6];                                       // 0x004A(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FP2ExchangeInfo) == 0x000008, "Wrong alignment on FP2ExchangeInfo");
static_assert(sizeof(FP2ExchangeInfo) == 0x000050, "Wrong size on FP2ExchangeInfo");
static_assert(offsetof(FP2ExchangeInfo, ItemData) == 0x000000, "Member 'FP2ExchangeInfo::ItemData' has a wrong offset!");
static_assert(offsetof(FP2ExchangeInfo, ItemSkinContainer) == 0x000008, "Member 'FP2ExchangeInfo::ItemSkinContainer' has a wrong offset!");
static_assert(offsetof(FP2ExchangeInfo, SkinSlotPresets) == 0x000010, "Member 'FP2ExchangeInfo::SkinSlotPresets' has a wrong offset!");
static_assert(offsetof(FP2ExchangeInfo, Attachables) == 0x000020, "Member 'FP2ExchangeInfo::Attachables' has a wrong offset!");
static_assert(offsetof(FP2ExchangeInfo, Amount) == 0x000030, "Member 'FP2ExchangeInfo::Amount' has a wrong offset!");
static_assert(offsetof(FP2ExchangeInfo, RandomAmounts) == 0x000038, "Member 'FP2ExchangeInfo::RandomAmounts' has a wrong offset!");
static_assert(offsetof(FP2ExchangeInfo, EventGrade) == 0x000048, "Member 'FP2ExchangeInfo::EventGrade' has a wrong offset!");
static_assert(offsetof(FP2ExchangeInfo, IsMasterPiece) == 0x000049, "Member 'FP2ExchangeInfo::IsMasterPiece' has a wrong offset!");

// ScriptStruct Game.P2MapMeshDefinition
// 0x0080 (0x0080 - 0x0000)
struct FP2MapMeshDefinition
{
public:
	class UStaticMesh*                            Mesh;                                              // 0x0000(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAffectsBounds;                                    // 0x0008(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAffectsCollision;                                 // 0x0009(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAffectsHighlight;                                 // 0x000A(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAffectsHover;                                     // 0x000B(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             Offset;                                            // 0x0010(0x0060)(Edit, BlueprintVisible, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bRenderCustomDepth;                                // 0x0070(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_71[0x3];                                       // 0x0071(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         CustomDepthStencilValue;                           // 0x0074(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ERendererStencilMask                          CustomDepthStencilWriteMask;                       // 0x0078(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_79[0x7];                                       // 0x0079(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FP2MapMeshDefinition) == 0x000010, "Wrong alignment on FP2MapMeshDefinition");
static_assert(sizeof(FP2MapMeshDefinition) == 0x000080, "Wrong size on FP2MapMeshDefinition");
static_assert(offsetof(FP2MapMeshDefinition, Mesh) == 0x000000, "Member 'FP2MapMeshDefinition::Mesh' has a wrong offset!");
static_assert(offsetof(FP2MapMeshDefinition, bAffectsBounds) == 0x000008, "Member 'FP2MapMeshDefinition::bAffectsBounds' has a wrong offset!");
static_assert(offsetof(FP2MapMeshDefinition, bAffectsCollision) == 0x000009, "Member 'FP2MapMeshDefinition::bAffectsCollision' has a wrong offset!");
static_assert(offsetof(FP2MapMeshDefinition, bAffectsHighlight) == 0x00000A, "Member 'FP2MapMeshDefinition::bAffectsHighlight' has a wrong offset!");
static_assert(offsetof(FP2MapMeshDefinition, bAffectsHover) == 0x00000B, "Member 'FP2MapMeshDefinition::bAffectsHover' has a wrong offset!");
static_assert(offsetof(FP2MapMeshDefinition, Offset) == 0x000010, "Member 'FP2MapMeshDefinition::Offset' has a wrong offset!");
static_assert(offsetof(FP2MapMeshDefinition, bRenderCustomDepth) == 0x000070, "Member 'FP2MapMeshDefinition::bRenderCustomDepth' has a wrong offset!");
static_assert(offsetof(FP2MapMeshDefinition, CustomDepthStencilValue) == 0x000074, "Member 'FP2MapMeshDefinition::CustomDepthStencilValue' has a wrong offset!");
static_assert(offsetof(FP2MapMeshDefinition, CustomDepthStencilWriteMask) == 0x000078, "Member 'FP2MapMeshDefinition::CustomDepthStencilWriteMask' has a wrong offset!");

// ScriptStruct Game.P2CoastLineInfo
// 0x0018 (0x0018 - 0x0000)
struct FP2CoastLineInfo final
{
public:
	int32                                         InitialSize;                                       // 0x0000(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FVector2D>                      Locations;                                         // 0x0008(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, SaveGame, NativeAccessSpecifierPublic)
};
static_assert(alignof(FP2CoastLineInfo) == 0x000008, "Wrong alignment on FP2CoastLineInfo");
static_assert(sizeof(FP2CoastLineInfo) == 0x000018, "Wrong size on FP2CoastLineInfo");
static_assert(offsetof(FP2CoastLineInfo, InitialSize) == 0x000000, "Member 'FP2CoastLineInfo::InitialSize' has a wrong offset!");
static_assert(offsetof(FP2CoastLineInfo, Locations) == 0x000008, "Member 'FP2CoastLineInfo::Locations' has a wrong offset!");

// ScriptStruct Game.P2ExclusionZoneInfo
// 0x0028 (0x0028 - 0x0000)
struct FP2ExclusionZoneInfo
{
public:
	struct FGameplayTag                           Tag;                                               // 0x0000(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Location;                                          // 0x0008(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	double                                        RadiusOffset;                                      // 0x0020(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FP2ExclusionZoneInfo) == 0x000008, "Wrong alignment on FP2ExclusionZoneInfo");
static_assert(sizeof(FP2ExclusionZoneInfo) == 0x000028, "Wrong size on FP2ExclusionZoneInfo");
static_assert(offsetof(FP2ExclusionZoneInfo, Tag) == 0x000000, "Member 'FP2ExclusionZoneInfo::Tag' has a wrong offset!");
static_assert(offsetof(FP2ExclusionZoneInfo, Location) == 0x000008, "Member 'FP2ExclusionZoneInfo::Location' has a wrong offset!");
static_assert(offsetof(FP2ExclusionZoneInfo, RadiusOffset) == 0x000020, "Member 'FP2ExclusionZoneInfo::RadiusOffset' has a wrong offset!");

// ScriptStruct Game.P2ConstraintCurveExclusionZone
// 0x0088 (0x00B0 - 0x0028)
struct FP2ConstraintCurveExclusionZone final : public FP2ExclusionZoneInfo
{
public:
	struct FRuntimeFloatCurve                     Constraint;                                        // 0x0028(0x0088)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
};
static_assert(alignof(FP2ConstraintCurveExclusionZone) == 0x000008, "Wrong alignment on FP2ConstraintCurveExclusionZone");
static_assert(sizeof(FP2ConstraintCurveExclusionZone) == 0x0000B0, "Wrong size on FP2ConstraintCurveExclusionZone");
static_assert(offsetof(FP2ConstraintCurveExclusionZone, Constraint) == 0x000028, "Member 'FP2ConstraintCurveExclusionZone::Constraint' has a wrong offset!");

// ScriptStruct Game.P2AnomalyWarning
// 0x0018 (0x0018 - 0x0000)
struct FP2AnomalyWarning final
{
public:
	struct FGameplayTag                           GameplayCue;                                       // 0x0000(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<float>                                 Times;                                             // 0x0008(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
};
static_assert(alignof(FP2AnomalyWarning) == 0x000008, "Wrong alignment on FP2AnomalyWarning");
static_assert(sizeof(FP2AnomalyWarning) == 0x000018, "Wrong size on FP2AnomalyWarning");
static_assert(offsetof(FP2AnomalyWarning, GameplayCue) == 0x000000, "Member 'FP2AnomalyWarning::GameplayCue' has a wrong offset!");
static_assert(offsetof(FP2AnomalyWarning, Times) == 0x000008, "Member 'FP2AnomalyWarning::Times' has a wrong offset!");

// ScriptStruct Game.P2RuntimeExclusionZone
// 0x0020 (0x0020 - 0x0000)
struct FP2RuntimeExclusionZone final
{
public:
	int32                                         Index;                                             // 0x0000(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector2D                              Location;                                          // 0x0008(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	double                                        Radius;                                            // 0x0018(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FP2RuntimeExclusionZone) == 0x000008, "Wrong alignment on FP2RuntimeExclusionZone");
static_assert(sizeof(FP2RuntimeExclusionZone) == 0x000020, "Wrong size on FP2RuntimeExclusionZone");
static_assert(offsetof(FP2RuntimeExclusionZone, Index) == 0x000000, "Member 'FP2RuntimeExclusionZone::Index' has a wrong offset!");
static_assert(offsetof(FP2RuntimeExclusionZone, Location) == 0x000008, "Member 'FP2RuntimeExclusionZone::Location' has a wrong offset!");
static_assert(offsetof(FP2RuntimeExclusionZone, Radius) == 0x000018, "Member 'FP2RuntimeExclusionZone::Radius' has a wrong offset!");

// ScriptStruct Game.P2SplineControlPointInfo
// 0x0120 (0x0120 - 0x0000)
struct FP2SplineControlPointInfo final
{
public:
	struct FVector2D                              ControlPoint;                                      // 0x0000(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              ControlPointStartPos;                              // 0x0010(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              OutsideMaxLimit;                                   // 0x0020(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              InsideMaxLimit;                                    // 0x0030(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              MinimalLimit;                                      // 0x0040(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              Direction;                                         // 0x0050(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	double                                        MaxSize;                                           // 0x0060(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsCoastLine;                                      // 0x0068(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsCoastLineNeighbor;                              // 0x0069(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsCoastLineNeighborSeted;                         // 0x006A(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsUDG;                                            // 0x006B(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsUDGNeighbor;                                    // 0x006C(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_6D[0x3];                                       // 0x006D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector2D                              DyMaxLimit;                                        // 0x0070(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              DyMinLimit;                                        // 0x0080(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              IntersectionCoastLine;                             // 0x0090(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              DebugUDGA1;                                        // 0x00A0(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              DebugUDGA2;                                        // 0x00B0(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              DebugUDGB1;                                        // 0x00C0(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              DebugUDGB2;                                        // 0x00D0(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              DebugA1;                                           // 0x00E0(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              DebugA2;                                           // 0x00F0(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              DebugB1;                                           // 0x0100(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              DebugB2;                                           // 0x0110(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FP2SplineControlPointInfo) == 0x000008, "Wrong alignment on FP2SplineControlPointInfo");
static_assert(sizeof(FP2SplineControlPointInfo) == 0x000120, "Wrong size on FP2SplineControlPointInfo");
static_assert(offsetof(FP2SplineControlPointInfo, ControlPoint) == 0x000000, "Member 'FP2SplineControlPointInfo::ControlPoint' has a wrong offset!");
static_assert(offsetof(FP2SplineControlPointInfo, ControlPointStartPos) == 0x000010, "Member 'FP2SplineControlPointInfo::ControlPointStartPos' has a wrong offset!");
static_assert(offsetof(FP2SplineControlPointInfo, OutsideMaxLimit) == 0x000020, "Member 'FP2SplineControlPointInfo::OutsideMaxLimit' has a wrong offset!");
static_assert(offsetof(FP2SplineControlPointInfo, InsideMaxLimit) == 0x000030, "Member 'FP2SplineControlPointInfo::InsideMaxLimit' has a wrong offset!");
static_assert(offsetof(FP2SplineControlPointInfo, MinimalLimit) == 0x000040, "Member 'FP2SplineControlPointInfo::MinimalLimit' has a wrong offset!");
static_assert(offsetof(FP2SplineControlPointInfo, Direction) == 0x000050, "Member 'FP2SplineControlPointInfo::Direction' has a wrong offset!");
static_assert(offsetof(FP2SplineControlPointInfo, MaxSize) == 0x000060, "Member 'FP2SplineControlPointInfo::MaxSize' has a wrong offset!");
static_assert(offsetof(FP2SplineControlPointInfo, bIsCoastLine) == 0x000068, "Member 'FP2SplineControlPointInfo::bIsCoastLine' has a wrong offset!");
static_assert(offsetof(FP2SplineControlPointInfo, bIsCoastLineNeighbor) == 0x000069, "Member 'FP2SplineControlPointInfo::bIsCoastLineNeighbor' has a wrong offset!");
static_assert(offsetof(FP2SplineControlPointInfo, bIsCoastLineNeighborSeted) == 0x00006A, "Member 'FP2SplineControlPointInfo::bIsCoastLineNeighborSeted' has a wrong offset!");
static_assert(offsetof(FP2SplineControlPointInfo, bIsUDG) == 0x00006B, "Member 'FP2SplineControlPointInfo::bIsUDG' has a wrong offset!");
static_assert(offsetof(FP2SplineControlPointInfo, bIsUDGNeighbor) == 0x00006C, "Member 'FP2SplineControlPointInfo::bIsUDGNeighbor' has a wrong offset!");
static_assert(offsetof(FP2SplineControlPointInfo, DyMaxLimit) == 0x000070, "Member 'FP2SplineControlPointInfo::DyMaxLimit' has a wrong offset!");
static_assert(offsetof(FP2SplineControlPointInfo, DyMinLimit) == 0x000080, "Member 'FP2SplineControlPointInfo::DyMinLimit' has a wrong offset!");
static_assert(offsetof(FP2SplineControlPointInfo, IntersectionCoastLine) == 0x000090, "Member 'FP2SplineControlPointInfo::IntersectionCoastLine' has a wrong offset!");
static_assert(offsetof(FP2SplineControlPointInfo, DebugUDGA1) == 0x0000A0, "Member 'FP2SplineControlPointInfo::DebugUDGA1' has a wrong offset!");
static_assert(offsetof(FP2SplineControlPointInfo, DebugUDGA2) == 0x0000B0, "Member 'FP2SplineControlPointInfo::DebugUDGA2' has a wrong offset!");
static_assert(offsetof(FP2SplineControlPointInfo, DebugUDGB1) == 0x0000C0, "Member 'FP2SplineControlPointInfo::DebugUDGB1' has a wrong offset!");
static_assert(offsetof(FP2SplineControlPointInfo, DebugUDGB2) == 0x0000D0, "Member 'FP2SplineControlPointInfo::DebugUDGB2' has a wrong offset!");
static_assert(offsetof(FP2SplineControlPointInfo, DebugA1) == 0x0000E0, "Member 'FP2SplineControlPointInfo::DebugA1' has a wrong offset!");
static_assert(offsetof(FP2SplineControlPointInfo, DebugA2) == 0x0000F0, "Member 'FP2SplineControlPointInfo::DebugA2' has a wrong offset!");
static_assert(offsetof(FP2SplineControlPointInfo, DebugB1) == 0x000100, "Member 'FP2SplineControlPointInfo::DebugB1' has a wrong offset!");
static_assert(offsetof(FP2SplineControlPointInfo, DebugB2) == 0x000110, "Member 'FP2SplineControlPointInfo::DebugB2' has a wrong offset!");

// ScriptStruct Game.P2AnomalyPhase
// 0x0090 (0x0090 - 0x0000)
struct FP2AnomalyPhase final
{
public:
	int32                                         PhaseNum;                                          // 0x0000(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PhaseDuration;                                     // 0x0004(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	double                                        MaxShrinkDistance;                                 // 0x0008(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	double                                        MaxGrowDistance;                                   // 0x0010(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MinimalDistance;                                   // 0x0018(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C[0x4];                                       // 0x001C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	double                                        CoastLineSize;                                     // 0x0020(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EP2AnomalyDeformationType                     DeformationType;                                   // 0x0028(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_29[0x7];                                       // 0x0029(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	double                                        TargetAreaPercent;                                 // 0x0030(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	double                                        AreaPercent;                                       // 0x0038(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Actions;                                           // 0x0040(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_44[0x4];                                       // 0x0044(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FP2CoastLineInfo>               CoastLines;                                        // 0x0048(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TArray<struct FP2RuntimeExclusionZone>        ExclusionZones;                                    // 0x0058(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TArray<struct FP2SplineControlPointInfo>      AnomalyPhasesControlPoints;                        // 0x0068(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TArray<struct FVector>                        ControlPoints;                                     // 0x0078(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, SaveGame, NativeAccessSpecifierPublic)
	EP2AnomalyMovingState                         MovingState;                                       // 0x0088(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_89[0x7];                                       // 0x0089(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FP2AnomalyPhase) == 0x000008, "Wrong alignment on FP2AnomalyPhase");
static_assert(sizeof(FP2AnomalyPhase) == 0x000090, "Wrong size on FP2AnomalyPhase");
static_assert(offsetof(FP2AnomalyPhase, PhaseNum) == 0x000000, "Member 'FP2AnomalyPhase::PhaseNum' has a wrong offset!");
static_assert(offsetof(FP2AnomalyPhase, PhaseDuration) == 0x000004, "Member 'FP2AnomalyPhase::PhaseDuration' has a wrong offset!");
static_assert(offsetof(FP2AnomalyPhase, MaxShrinkDistance) == 0x000008, "Member 'FP2AnomalyPhase::MaxShrinkDistance' has a wrong offset!");
static_assert(offsetof(FP2AnomalyPhase, MaxGrowDistance) == 0x000010, "Member 'FP2AnomalyPhase::MaxGrowDistance' has a wrong offset!");
static_assert(offsetof(FP2AnomalyPhase, MinimalDistance) == 0x000018, "Member 'FP2AnomalyPhase::MinimalDistance' has a wrong offset!");
static_assert(offsetof(FP2AnomalyPhase, CoastLineSize) == 0x000020, "Member 'FP2AnomalyPhase::CoastLineSize' has a wrong offset!");
static_assert(offsetof(FP2AnomalyPhase, DeformationType) == 0x000028, "Member 'FP2AnomalyPhase::DeformationType' has a wrong offset!");
static_assert(offsetof(FP2AnomalyPhase, TargetAreaPercent) == 0x000030, "Member 'FP2AnomalyPhase::TargetAreaPercent' has a wrong offset!");
static_assert(offsetof(FP2AnomalyPhase, AreaPercent) == 0x000038, "Member 'FP2AnomalyPhase::AreaPercent' has a wrong offset!");
static_assert(offsetof(FP2AnomalyPhase, Actions) == 0x000040, "Member 'FP2AnomalyPhase::Actions' has a wrong offset!");
static_assert(offsetof(FP2AnomalyPhase, CoastLines) == 0x000048, "Member 'FP2AnomalyPhase::CoastLines' has a wrong offset!");
static_assert(offsetof(FP2AnomalyPhase, ExclusionZones) == 0x000058, "Member 'FP2AnomalyPhase::ExclusionZones' has a wrong offset!");
static_assert(offsetof(FP2AnomalyPhase, AnomalyPhasesControlPoints) == 0x000068, "Member 'FP2AnomalyPhase::AnomalyPhasesControlPoints' has a wrong offset!");
static_assert(offsetof(FP2AnomalyPhase, ControlPoints) == 0x000078, "Member 'FP2AnomalyPhase::ControlPoints' has a wrong offset!");
static_assert(offsetof(FP2AnomalyPhase, MovingState) == 0x000088, "Member 'FP2AnomalyPhase::MovingState' has a wrong offset!");

// ScriptStruct Game.P2AnomalyGenerationInfo
// 0x0090 (0x0090 - 0x0000)
struct FP2AnomalyGenerationInfo final
{
public:
	double                                        LandArea;                                          // 0x0000(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              AnomalyCenter;                                     // 0x0008(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FP2CoastLineInfo>               BaseCoastLines;                                    // 0x0018(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, SaveGame, NativeAccessSpecifierPublic)
	TArray<struct FP2ConstraintCurveExclusionZone> ExclusionZones;                                   // 0x0028(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TArray<struct FP2AnomalyPhase>                AnomalyPhases;                                     // 0x0038(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, SaveGame, NativeAccessSpecifierPublic)
	TArray<struct FVector>                        AnomalyExtraPhaseCollapsed;                        // 0x0048(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FP2AnomalyWarning                      AnomalyWarning;                                    // 0x0058(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FP2AnomalyWarning                      AnomalyWarningStopMoving;                          // 0x0070(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	float                                         MaxShrinkSpeed;                                    // 0x0088(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_8C[0x4];                                       // 0x008C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FP2AnomalyGenerationInfo) == 0x000008, "Wrong alignment on FP2AnomalyGenerationInfo");
static_assert(sizeof(FP2AnomalyGenerationInfo) == 0x000090, "Wrong size on FP2AnomalyGenerationInfo");
static_assert(offsetof(FP2AnomalyGenerationInfo, LandArea) == 0x000000, "Member 'FP2AnomalyGenerationInfo::LandArea' has a wrong offset!");
static_assert(offsetof(FP2AnomalyGenerationInfo, AnomalyCenter) == 0x000008, "Member 'FP2AnomalyGenerationInfo::AnomalyCenter' has a wrong offset!");
static_assert(offsetof(FP2AnomalyGenerationInfo, BaseCoastLines) == 0x000018, "Member 'FP2AnomalyGenerationInfo::BaseCoastLines' has a wrong offset!");
static_assert(offsetof(FP2AnomalyGenerationInfo, ExclusionZones) == 0x000028, "Member 'FP2AnomalyGenerationInfo::ExclusionZones' has a wrong offset!");
static_assert(offsetof(FP2AnomalyGenerationInfo, AnomalyPhases) == 0x000038, "Member 'FP2AnomalyGenerationInfo::AnomalyPhases' has a wrong offset!");
static_assert(offsetof(FP2AnomalyGenerationInfo, AnomalyExtraPhaseCollapsed) == 0x000048, "Member 'FP2AnomalyGenerationInfo::AnomalyExtraPhaseCollapsed' has a wrong offset!");
static_assert(offsetof(FP2AnomalyGenerationInfo, AnomalyWarning) == 0x000058, "Member 'FP2AnomalyGenerationInfo::AnomalyWarning' has a wrong offset!");
static_assert(offsetof(FP2AnomalyGenerationInfo, AnomalyWarningStopMoving) == 0x000070, "Member 'FP2AnomalyGenerationInfo::AnomalyWarningStopMoving' has a wrong offset!");
static_assert(offsetof(FP2AnomalyGenerationInfo, MaxShrinkSpeed) == 0x000088, "Member 'FP2AnomalyGenerationInfo::MaxShrinkSpeed' has a wrong offset!");

// ScriptStruct Game.AdaptiveLeanConfig
// 0x01C0 (0x01C0 - 0x0000)
struct FAdaptiveLeanConfig final
{
public:
	float                                         CapsuleForwardHitExclusionScale;                   // 0x0000(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CharacterSpaceSphereRadius;                        // 0x0004(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SideSweepDistance;                                 // 0x0008(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         WallCheckCapsuleRadius;                            // 0x000C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ForwardSweepRadius;                                // 0x0010(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ForwardOffset;                                     // 0x0014(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         UpStaticOffsetDistance;                            // 0x0018(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MainOffsetInterpSpeed;                             // 0x001C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CrouchOffsetDistance;                              // 0x0020(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_24[0x4];                                       // 0x0024(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector2D                              YawCheckInputScaleOffsetMinMax;                    // 0x0028(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              PitchCheckInputScaleOffsetMinMax;                  // 0x0038(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RotationAlphaCapsuleRadiusScale;                   // 0x0048(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MinPitchForUpLean;                                 // 0x004C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LeanAccelConstSpeed;                               // 0x0050(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LeanAccelScaleClose;                               // 0x0054(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LeanAccelScaleFar;                                 // 0x0058(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5C[0x4];                                       // 0x005C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector2D                              LeanStartInterpSpeedDistanceCloseFar;              // 0x0060(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              LeanStopTransitionSpeedCrouchOnOff;                // 0x0070(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              LeanCharacterSpeedAlphaInterpSpeed;                // 0x0080(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              LeanCharacterVelocityInterpSpeed;                  // 0x0090(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         OvertraceDistance;                                 // 0x00A0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ControlSweepDistanceSideOffset;                    // 0x00A4(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ControlSweepDistanceTopOffset;                     // 0x00A8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ControlCorrectionSpeed;                            // 0x00AC(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MovementSideOffsetDistance;                        // 0x00B0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MovementInputScalar;                               // 0x00B4(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Rep_MinOffsetSizeSq;                               // 0x00B8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SpringStiffness;                                   // 0x00BC(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SpringDamping;                                     // 0x00C0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C4[0x4];                                       // 0x00C4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<EAdaptiveLeanDirection, float>           DirectionSweepDistanceMap;                         // 0x00C8(0x0050)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	float                                         SweepHalfHeight;                                   // 0x0118(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SweepRadius;                                       // 0x011C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SweepHeightOffset;                                 // 0x0120(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   SweepCollisionProfileName;                         // 0x0124(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ManualLeanSpeed;                                   // 0x012C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         StopSpeedScale;                                    // 0x0130(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FFloatRange                            AccelScaleRange;                                   // 0x0134(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_144[0x4];                                      // 0x0144(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UCurveFloat*                            AccelRemapCurve;                                   // 0x0148(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCurveFloat*                            AlphaDistanceCurve;                                // 0x0150(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCurveFloat*                            DirectionalAlphaToHeightOffsetCurve;               // 0x0158(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxLeanCameraRoll;                                 // 0x0160(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_164[0x4];                                      // 0x0164(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UInputAction*                           Action_ManualLean_Left;                            // 0x0168(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UInputAction*                           Action_ManualLean_Right;                           // 0x0170(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTagQuery                      TagQuery;                                          // 0x0178(0x0048)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAdaptiveLeanConfig) == 0x000008, "Wrong alignment on FAdaptiveLeanConfig");
static_assert(sizeof(FAdaptiveLeanConfig) == 0x0001C0, "Wrong size on FAdaptiveLeanConfig");
static_assert(offsetof(FAdaptiveLeanConfig, CapsuleForwardHitExclusionScale) == 0x000000, "Member 'FAdaptiveLeanConfig::CapsuleForwardHitExclusionScale' has a wrong offset!");
static_assert(offsetof(FAdaptiveLeanConfig, CharacterSpaceSphereRadius) == 0x000004, "Member 'FAdaptiveLeanConfig::CharacterSpaceSphereRadius' has a wrong offset!");
static_assert(offsetof(FAdaptiveLeanConfig, SideSweepDistance) == 0x000008, "Member 'FAdaptiveLeanConfig::SideSweepDistance' has a wrong offset!");
static_assert(offsetof(FAdaptiveLeanConfig, WallCheckCapsuleRadius) == 0x00000C, "Member 'FAdaptiveLeanConfig::WallCheckCapsuleRadius' has a wrong offset!");
static_assert(offsetof(FAdaptiveLeanConfig, ForwardSweepRadius) == 0x000010, "Member 'FAdaptiveLeanConfig::ForwardSweepRadius' has a wrong offset!");
static_assert(offsetof(FAdaptiveLeanConfig, ForwardOffset) == 0x000014, "Member 'FAdaptiveLeanConfig::ForwardOffset' has a wrong offset!");
static_assert(offsetof(FAdaptiveLeanConfig, UpStaticOffsetDistance) == 0x000018, "Member 'FAdaptiveLeanConfig::UpStaticOffsetDistance' has a wrong offset!");
static_assert(offsetof(FAdaptiveLeanConfig, MainOffsetInterpSpeed) == 0x00001C, "Member 'FAdaptiveLeanConfig::MainOffsetInterpSpeed' has a wrong offset!");
static_assert(offsetof(FAdaptiveLeanConfig, CrouchOffsetDistance) == 0x000020, "Member 'FAdaptiveLeanConfig::CrouchOffsetDistance' has a wrong offset!");
static_assert(offsetof(FAdaptiveLeanConfig, YawCheckInputScaleOffsetMinMax) == 0x000028, "Member 'FAdaptiveLeanConfig::YawCheckInputScaleOffsetMinMax' has a wrong offset!");
static_assert(offsetof(FAdaptiveLeanConfig, PitchCheckInputScaleOffsetMinMax) == 0x000038, "Member 'FAdaptiveLeanConfig::PitchCheckInputScaleOffsetMinMax' has a wrong offset!");
static_assert(offsetof(FAdaptiveLeanConfig, RotationAlphaCapsuleRadiusScale) == 0x000048, "Member 'FAdaptiveLeanConfig::RotationAlphaCapsuleRadiusScale' has a wrong offset!");
static_assert(offsetof(FAdaptiveLeanConfig, MinPitchForUpLean) == 0x00004C, "Member 'FAdaptiveLeanConfig::MinPitchForUpLean' has a wrong offset!");
static_assert(offsetof(FAdaptiveLeanConfig, LeanAccelConstSpeed) == 0x000050, "Member 'FAdaptiveLeanConfig::LeanAccelConstSpeed' has a wrong offset!");
static_assert(offsetof(FAdaptiveLeanConfig, LeanAccelScaleClose) == 0x000054, "Member 'FAdaptiveLeanConfig::LeanAccelScaleClose' has a wrong offset!");
static_assert(offsetof(FAdaptiveLeanConfig, LeanAccelScaleFar) == 0x000058, "Member 'FAdaptiveLeanConfig::LeanAccelScaleFar' has a wrong offset!");
static_assert(offsetof(FAdaptiveLeanConfig, LeanStartInterpSpeedDistanceCloseFar) == 0x000060, "Member 'FAdaptiveLeanConfig::LeanStartInterpSpeedDistanceCloseFar' has a wrong offset!");
static_assert(offsetof(FAdaptiveLeanConfig, LeanStopTransitionSpeedCrouchOnOff) == 0x000070, "Member 'FAdaptiveLeanConfig::LeanStopTransitionSpeedCrouchOnOff' has a wrong offset!");
static_assert(offsetof(FAdaptiveLeanConfig, LeanCharacterSpeedAlphaInterpSpeed) == 0x000080, "Member 'FAdaptiveLeanConfig::LeanCharacterSpeedAlphaInterpSpeed' has a wrong offset!");
static_assert(offsetof(FAdaptiveLeanConfig, LeanCharacterVelocityInterpSpeed) == 0x000090, "Member 'FAdaptiveLeanConfig::LeanCharacterVelocityInterpSpeed' has a wrong offset!");
static_assert(offsetof(FAdaptiveLeanConfig, OvertraceDistance) == 0x0000A0, "Member 'FAdaptiveLeanConfig::OvertraceDistance' has a wrong offset!");
static_assert(offsetof(FAdaptiveLeanConfig, ControlSweepDistanceSideOffset) == 0x0000A4, "Member 'FAdaptiveLeanConfig::ControlSweepDistanceSideOffset' has a wrong offset!");
static_assert(offsetof(FAdaptiveLeanConfig, ControlSweepDistanceTopOffset) == 0x0000A8, "Member 'FAdaptiveLeanConfig::ControlSweepDistanceTopOffset' has a wrong offset!");
static_assert(offsetof(FAdaptiveLeanConfig, ControlCorrectionSpeed) == 0x0000AC, "Member 'FAdaptiveLeanConfig::ControlCorrectionSpeed' has a wrong offset!");
static_assert(offsetof(FAdaptiveLeanConfig, MovementSideOffsetDistance) == 0x0000B0, "Member 'FAdaptiveLeanConfig::MovementSideOffsetDistance' has a wrong offset!");
static_assert(offsetof(FAdaptiveLeanConfig, MovementInputScalar) == 0x0000B4, "Member 'FAdaptiveLeanConfig::MovementInputScalar' has a wrong offset!");
static_assert(offsetof(FAdaptiveLeanConfig, Rep_MinOffsetSizeSq) == 0x0000B8, "Member 'FAdaptiveLeanConfig::Rep_MinOffsetSizeSq' has a wrong offset!");
static_assert(offsetof(FAdaptiveLeanConfig, SpringStiffness) == 0x0000BC, "Member 'FAdaptiveLeanConfig::SpringStiffness' has a wrong offset!");
static_assert(offsetof(FAdaptiveLeanConfig, SpringDamping) == 0x0000C0, "Member 'FAdaptiveLeanConfig::SpringDamping' has a wrong offset!");
static_assert(offsetof(FAdaptiveLeanConfig, DirectionSweepDistanceMap) == 0x0000C8, "Member 'FAdaptiveLeanConfig::DirectionSweepDistanceMap' has a wrong offset!");
static_assert(offsetof(FAdaptiveLeanConfig, SweepHalfHeight) == 0x000118, "Member 'FAdaptiveLeanConfig::SweepHalfHeight' has a wrong offset!");
static_assert(offsetof(FAdaptiveLeanConfig, SweepRadius) == 0x00011C, "Member 'FAdaptiveLeanConfig::SweepRadius' has a wrong offset!");
static_assert(offsetof(FAdaptiveLeanConfig, SweepHeightOffset) == 0x000120, "Member 'FAdaptiveLeanConfig::SweepHeightOffset' has a wrong offset!");
static_assert(offsetof(FAdaptiveLeanConfig, SweepCollisionProfileName) == 0x000124, "Member 'FAdaptiveLeanConfig::SweepCollisionProfileName' has a wrong offset!");
static_assert(offsetof(FAdaptiveLeanConfig, ManualLeanSpeed) == 0x00012C, "Member 'FAdaptiveLeanConfig::ManualLeanSpeed' has a wrong offset!");
static_assert(offsetof(FAdaptiveLeanConfig, StopSpeedScale) == 0x000130, "Member 'FAdaptiveLeanConfig::StopSpeedScale' has a wrong offset!");
static_assert(offsetof(FAdaptiveLeanConfig, AccelScaleRange) == 0x000134, "Member 'FAdaptiveLeanConfig::AccelScaleRange' has a wrong offset!");
static_assert(offsetof(FAdaptiveLeanConfig, AccelRemapCurve) == 0x000148, "Member 'FAdaptiveLeanConfig::AccelRemapCurve' has a wrong offset!");
static_assert(offsetof(FAdaptiveLeanConfig, AlphaDistanceCurve) == 0x000150, "Member 'FAdaptiveLeanConfig::AlphaDistanceCurve' has a wrong offset!");
static_assert(offsetof(FAdaptiveLeanConfig, DirectionalAlphaToHeightOffsetCurve) == 0x000158, "Member 'FAdaptiveLeanConfig::DirectionalAlphaToHeightOffsetCurve' has a wrong offset!");
static_assert(offsetof(FAdaptiveLeanConfig, MaxLeanCameraRoll) == 0x000160, "Member 'FAdaptiveLeanConfig::MaxLeanCameraRoll' has a wrong offset!");
static_assert(offsetof(FAdaptiveLeanConfig, Action_ManualLean_Left) == 0x000168, "Member 'FAdaptiveLeanConfig::Action_ManualLean_Left' has a wrong offset!");
static_assert(offsetof(FAdaptiveLeanConfig, Action_ManualLean_Right) == 0x000170, "Member 'FAdaptiveLeanConfig::Action_ManualLean_Right' has a wrong offset!");
static_assert(offsetof(FAdaptiveLeanConfig, TagQuery) == 0x000178, "Member 'FAdaptiveLeanConfig::TagQuery' has a wrong offset!");

// ScriptStruct Game.P2TimedEventData
// 0x0018 (0x0018 - 0x0000)
struct FP2TimedEventData final
{
public:
	int64                                         LastUpdateTicks;                                   // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RemainingTimeSec;                                  // 0x0008(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TotalTimeSec;                                      // 0x000C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          HasCompleted;                                      // 0x0010(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x7];                                       // 0x0011(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FP2TimedEventData) == 0x000008, "Wrong alignment on FP2TimedEventData");
static_assert(sizeof(FP2TimedEventData) == 0x000018, "Wrong size on FP2TimedEventData");
static_assert(offsetof(FP2TimedEventData, LastUpdateTicks) == 0x000000, "Member 'FP2TimedEventData::LastUpdateTicks' has a wrong offset!");
static_assert(offsetof(FP2TimedEventData, RemainingTimeSec) == 0x000008, "Member 'FP2TimedEventData::RemainingTimeSec' has a wrong offset!");
static_assert(offsetof(FP2TimedEventData, TotalTimeSec) == 0x00000C, "Member 'FP2TimedEventData::TotalTimeSec' has a wrong offset!");
static_assert(offsetof(FP2TimedEventData, HasCompleted) == 0x000010, "Member 'FP2TimedEventData::HasCompleted' has a wrong offset!");

// ScriptStruct Game.P2InitialAttachablesEntry
// 0x0018 (0x0018 - 0x0000)
struct FP2InitialAttachablesEntry final
{
public:
	class UP2ItemData*                            Item;                                              // 0x0000(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FIntPoint                              Stack;                                             // 0x0008(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bShouldReplace;                                    // 0x0010(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x7];                                       // 0x0011(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FP2InitialAttachablesEntry) == 0x000008, "Wrong alignment on FP2InitialAttachablesEntry");
static_assert(sizeof(FP2InitialAttachablesEntry) == 0x000018, "Wrong size on FP2InitialAttachablesEntry");
static_assert(offsetof(FP2InitialAttachablesEntry, Item) == 0x000000, "Member 'FP2InitialAttachablesEntry::Item' has a wrong offset!");
static_assert(offsetof(FP2InitialAttachablesEntry, Stack) == 0x000008, "Member 'FP2InitialAttachablesEntry::Stack' has a wrong offset!");
static_assert(offsetof(FP2InitialAttachablesEntry, bShouldReplace) == 0x000010, "Member 'FP2InitialAttachablesEntry::bShouldReplace' has a wrong offset!");

// ScriptStruct Game.P2ContractMissionReset
// 0x0008 (0x0008 - 0x0000)
struct FP2ContractMissionReset
{
public:
	struct FGameplayTag                           MissionTag;                                        // 0x0000(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FP2ContractMissionReset) == 0x000004, "Wrong alignment on FP2ContractMissionReset");
static_assert(sizeof(FP2ContractMissionReset) == 0x000008, "Wrong size on FP2ContractMissionReset");
static_assert(offsetof(FP2ContractMissionReset, MissionTag) == 0x000000, "Member 'FP2ContractMissionReset::MissionTag' has a wrong offset!");

// ScriptStruct Game.P2ContractMissionResetConfig
// 0x0020 (0x0028 - 0x0008)
struct FP2ContractMissionResetConfig final : public FP2ContractMissionReset
{
public:
	struct FTimespan                              ResetDuration;                                     // 0x0008(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EP2DayOfWeek                                  DayOfWeek;                                         // 0x0010(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x7];                                       // 0x0011(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTimespan                              TimeOfDay;                                         // 0x0018(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FTimespan                              CooldownDuration;                                  // 0x0020(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FP2ContractMissionResetConfig) == 0x000008, "Wrong alignment on FP2ContractMissionResetConfig");
static_assert(sizeof(FP2ContractMissionResetConfig) == 0x000028, "Wrong size on FP2ContractMissionResetConfig");
static_assert(offsetof(FP2ContractMissionResetConfig, ResetDuration) == 0x000008, "Member 'FP2ContractMissionResetConfig::ResetDuration' has a wrong offset!");
static_assert(offsetof(FP2ContractMissionResetConfig, DayOfWeek) == 0x000010, "Member 'FP2ContractMissionResetConfig::DayOfWeek' has a wrong offset!");
static_assert(offsetof(FP2ContractMissionResetConfig, TimeOfDay) == 0x000018, "Member 'FP2ContractMissionResetConfig::TimeOfDay' has a wrong offset!");
static_assert(offsetof(FP2ContractMissionResetConfig, CooldownDuration) == 0x000020, "Member 'FP2ContractMissionResetConfig::CooldownDuration' has a wrong offset!");

// ScriptStruct Game.P2BakedAnomalyPhase
// 0x0018 (0x0018 - 0x0000)
struct FP2BakedAnomalyPhase final
{
public:
	TArray<struct FVector>                        ControlPoints;                                     // 0x0000(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	EP2AnomalyMovingState                         MovingState;                                       // 0x0010(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x7];                                       // 0x0011(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FP2BakedAnomalyPhase) == 0x000008, "Wrong alignment on FP2BakedAnomalyPhase");
static_assert(sizeof(FP2BakedAnomalyPhase) == 0x000018, "Wrong size on FP2BakedAnomalyPhase");
static_assert(offsetof(FP2BakedAnomalyPhase, ControlPoints) == 0x000000, "Member 'FP2BakedAnomalyPhase::ControlPoints' has a wrong offset!");
static_assert(offsetof(FP2BakedAnomalyPhase, MovingState) == 0x000010, "Member 'FP2BakedAnomalyPhase::MovingState' has a wrong offset!");

// ScriptStruct Game.P2BakedAnomalyPhases
// 0x0020 (0x0020 - 0x0000)
struct FP2BakedAnomalyPhases final
{
public:
	bool                                          IsBakedEnable;                                     // 0x0000(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FP2BakedAnomalyPhase>           Phases;                                            // 0x0008(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FGameplayTag                           Tag;                                               // 0x0018(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FP2BakedAnomalyPhases) == 0x000008, "Wrong alignment on FP2BakedAnomalyPhases");
static_assert(sizeof(FP2BakedAnomalyPhases) == 0x000020, "Wrong size on FP2BakedAnomalyPhases");
static_assert(offsetof(FP2BakedAnomalyPhases, IsBakedEnable) == 0x000000, "Member 'FP2BakedAnomalyPhases::IsBakedEnable' has a wrong offset!");
static_assert(offsetof(FP2BakedAnomalyPhases, Phases) == 0x000008, "Member 'FP2BakedAnomalyPhases::Phases' has a wrong offset!");
static_assert(offsetof(FP2BakedAnomalyPhases, Tag) == 0x000018, "Member 'FP2BakedAnomalyPhases::Tag' has a wrong offset!");

// ScriptStruct Game.P2ScalableFloat
// 0x0030 (0x0030 - 0x0000)
struct FP2ScalableFloat final
{
public:
	struct FScalableFloat                         Value;                                             // 0x0000(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	float                                         ConstValue;                                        // 0x0028(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EP2ScalableFloatCurveType                     CurveType;                                         // 0x002C(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2D[0x3];                                       // 0x002D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FP2ScalableFloat) == 0x000008, "Wrong alignment on FP2ScalableFloat");
static_assert(sizeof(FP2ScalableFloat) == 0x000030, "Wrong size on FP2ScalableFloat");
static_assert(offsetof(FP2ScalableFloat, Value) == 0x000000, "Member 'FP2ScalableFloat::Value' has a wrong offset!");
static_assert(offsetof(FP2ScalableFloat, ConstValue) == 0x000028, "Member 'FP2ScalableFloat::ConstValue' has a wrong offset!");
static_assert(offsetof(FP2ScalableFloat, CurveType) == 0x00002C, "Member 'FP2ScalableFloat::CurveType' has a wrong offset!");

// ScriptStruct Game.GunTailData
// 0x003C (0x003C - 0x0000)
struct alignas(0x04) FGunTailData final
{
public:
	uint8                                         Pad_0[0x3C];                                       // 0x0000(0x003C)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FGunTailData) == 0x000004, "Wrong alignment on FGunTailData");
static_assert(sizeof(FGunTailData) == 0x00003C, "Wrong size on FGunTailData");

// ScriptStruct Game.P2LockMeshWrapper
// 0x0020 (0x0020 - 0x0000)
struct FP2LockMeshWrapper final
{
public:
	class USkeletalMesh*                          SkeletalMeshAsset;                                 // 0x0000(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FSkeletalMaterial>              OverrideMaterials;                                 // 0x0008(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	class UP2LockMeshConfigurationBase*           LockMeshConfiguration;                             // 0x0018(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, PersistentInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FP2LockMeshWrapper) == 0x000008, "Wrong alignment on FP2LockMeshWrapper");
static_assert(sizeof(FP2LockMeshWrapper) == 0x000020, "Wrong size on FP2LockMeshWrapper");
static_assert(offsetof(FP2LockMeshWrapper, SkeletalMeshAsset) == 0x000000, "Member 'FP2LockMeshWrapper::SkeletalMeshAsset' has a wrong offset!");
static_assert(offsetof(FP2LockMeshWrapper, OverrideMaterials) == 0x000008, "Member 'FP2LockMeshWrapper::OverrideMaterials' has a wrong offset!");
static_assert(offsetof(FP2LockMeshWrapper, LockMeshConfiguration) == 0x000018, "Member 'FP2LockMeshWrapper::LockMeshConfiguration' has a wrong offset!");

// ScriptStruct Game.P2ExpReward
// 0x0008 (0x0008 - 0x0000)
struct FP2ExpReward final
{
public:
	int32                                         ExpVal;                                            // 0x0000(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         BonusExpVal;                                       // 0x0004(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FP2ExpReward) == 0x000004, "Wrong alignment on FP2ExpReward");
static_assert(sizeof(FP2ExpReward) == 0x000008, "Wrong size on FP2ExpReward");
static_assert(offsetof(FP2ExpReward, ExpVal) == 0x000000, "Member 'FP2ExpReward::ExpVal' has a wrong offset!");
static_assert(offsetof(FP2ExpReward, BonusExpVal) == 0x000004, "Member 'FP2ExpReward::BonusExpVal' has a wrong offset!");

// ScriptStruct Game.P2TargetData_SpawnThrowable
// 0x0058 (0x0060 - 0x0008)
struct FP2TargetData_SpawnThrowable final : public FGameplayAbilityTargetData
{
public:
	uint8                                         Pad_8[0x58];                                       // 0x0008(0x0058)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FP2TargetData_SpawnThrowable) == 0x000008, "Wrong alignment on FP2TargetData_SpawnThrowable");
static_assert(sizeof(FP2TargetData_SpawnThrowable) == 0x000060, "Wrong size on FP2TargetData_SpawnThrowable");

// ScriptStruct Game.P2DamageData
// 0x0060 (0x0060 - 0x0000)
struct FP2DamageData final
{
public:
	class AActor*                                 Instigator;                                        // 0x0000(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 Target;                                            // 0x0008(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_10[0x50];                                      // 0x0010(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FP2DamageData) == 0x000008, "Wrong alignment on FP2DamageData");
static_assert(sizeof(FP2DamageData) == 0x000060, "Wrong size on FP2DamageData");
static_assert(offsetof(FP2DamageData, Instigator) == 0x000000, "Member 'FP2DamageData::Instigator' has a wrong offset!");
static_assert(offsetof(FP2DamageData, Target) == 0x000008, "Member 'FP2DamageData::Target' has a wrong offset!");

// ScriptStruct Game.P2AmmoTextColorDataRow
// 0x0018 (0x0020 - 0x0008)
struct FP2AmmoTextColorDataRow final : public FTableRowBase
{
public:
	struct FGameplayTag                           AmmotTag;                                          // 0x0008(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           TextColor;                                         // 0x0010(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FP2AmmoTextColorDataRow) == 0x000008, "Wrong alignment on FP2AmmoTextColorDataRow");
static_assert(sizeof(FP2AmmoTextColorDataRow) == 0x000020, "Wrong size on FP2AmmoTextColorDataRow");
static_assert(offsetof(FP2AmmoTextColorDataRow, AmmotTag) == 0x000008, "Member 'FP2AmmoTextColorDataRow::AmmotTag' has a wrong offset!");
static_assert(offsetof(FP2AmmoTextColorDataRow, TextColor) == 0x000010, "Member 'FP2AmmoTextColorDataRow::TextColor' has a wrong offset!");

// ScriptStruct Game.P2InteriorWeaponTailConfig
// 0x0008 (0x0008 - 0x0000)
struct FP2InteriorWeaponTailConfig final
{
public:
	class UAkAudioEvent*                          AkAudioEvent;                                      // 0x0000(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FP2InteriorWeaponTailConfig) == 0x000008, "Wrong alignment on FP2InteriorWeaponTailConfig");
static_assert(sizeof(FP2InteriorWeaponTailConfig) == 0x000008, "Wrong size on FP2InteriorWeaponTailConfig");
static_assert(offsetof(FP2InteriorWeaponTailConfig, AkAudioEvent) == 0x000000, "Member 'FP2InteriorWeaponTailConfig::AkAudioEvent' has a wrong offset!");

// ScriptStruct Game.P2RaidResultChallenge
// 0x0018 (0x0018 - 0x0000)
struct FP2RaidResultChallenge final
{
public:
	class UP2ContractData*                        ContractData;                                      // 0x0000(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FDateTime                              AcceptionDate;                                     // 0x0008(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EP2ContractState                              State;                                             // 0x0010(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x7];                                       // 0x0011(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FP2RaidResultChallenge) == 0x000008, "Wrong alignment on FP2RaidResultChallenge");
static_assert(sizeof(FP2RaidResultChallenge) == 0x000018, "Wrong size on FP2RaidResultChallenge");
static_assert(offsetof(FP2RaidResultChallenge, ContractData) == 0x000000, "Member 'FP2RaidResultChallenge::ContractData' has a wrong offset!");
static_assert(offsetof(FP2RaidResultChallenge, AcceptionDate) == 0x000008, "Member 'FP2RaidResultChallenge::AcceptionDate' has a wrong offset!");
static_assert(offsetof(FP2RaidResultChallenge, State) == 0x000010, "Member 'FP2RaidResultChallenge::State' has a wrong offset!");

// ScriptStruct Game.P2AntiCheatMessage
// 0x0030 (0x0030 - 0x0000)
struct FP2AntiCheatMessage final
{
public:
	class UObject*                                Instigator;                                        // 0x0000(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UObject*                                Target;                                            // 0x0008(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 CheatType;                                         // 0x0010(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class FString>                         Description;                                       // 0x0020(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FP2AntiCheatMessage) == 0x000008, "Wrong alignment on FP2AntiCheatMessage");
static_assert(sizeof(FP2AntiCheatMessage) == 0x000030, "Wrong size on FP2AntiCheatMessage");
static_assert(offsetof(FP2AntiCheatMessage, Instigator) == 0x000000, "Member 'FP2AntiCheatMessage::Instigator' has a wrong offset!");
static_assert(offsetof(FP2AntiCheatMessage, Target) == 0x000008, "Member 'FP2AntiCheatMessage::Target' has a wrong offset!");
static_assert(offsetof(FP2AntiCheatMessage, CheatType) == 0x000010, "Member 'FP2AntiCheatMessage::CheatType' has a wrong offset!");
static_assert(offsetof(FP2AntiCheatMessage, Description) == 0x000020, "Member 'FP2AntiCheatMessage::Description' has a wrong offset!");

// ScriptStruct Game.P2ContractTypeInfo
// 0x0028 (0x0028 - 0x0000)
struct FP2ContractTypeInfo final
{
public:
	class FText                                   ContractTypeName;                                  // 0x0000(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FLinearColor                           ContractTypeColor;                                 // 0x0018(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FP2ContractTypeInfo) == 0x000008, "Wrong alignment on FP2ContractTypeInfo");
static_assert(sizeof(FP2ContractTypeInfo) == 0x000028, "Wrong size on FP2ContractTypeInfo");
static_assert(offsetof(FP2ContractTypeInfo, ContractTypeName) == 0x000000, "Member 'FP2ContractTypeInfo::ContractTypeName' has a wrong offset!");
static_assert(offsetof(FP2ContractTypeInfo, ContractTypeColor) == 0x000018, "Member 'FP2ContractTypeInfo::ContractTypeColor' has a wrong offset!");

// ScriptStruct Game.P2InputAction
// 0x0010 (0x0010 - 0x0000)
struct FP2InputAction final
{
public:
	class UInputAction*                           InputAction;                                       // 0x0000(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           InputTag;                                          // 0x0008(0x0008)(Edit, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FP2InputAction) == 0x000008, "Wrong alignment on FP2InputAction");
static_assert(sizeof(FP2InputAction) == 0x000010, "Wrong size on FP2InputAction");
static_assert(offsetof(FP2InputAction, InputAction) == 0x000000, "Member 'FP2InputAction::InputAction' has a wrong offset!");
static_assert(offsetof(FP2InputAction, InputTag) == 0x000008, "Member 'FP2InputAction::InputTag' has a wrong offset!");

// ScriptStruct Game.P2LandingSpringArmConfig
// 0x0028 (0x0028 - 0x0000)
struct FP2LandingSpringArmConfig final
{
public:
	class UAnimSpringSimData*                     LandedSpringSimData;                               // 0x0000(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              SpeedRange;                                        // 0x0008(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              SpeedScaleMap;                                     // 0x0018(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FP2LandingSpringArmConfig) == 0x000008, "Wrong alignment on FP2LandingSpringArmConfig");
static_assert(sizeof(FP2LandingSpringArmConfig) == 0x000028, "Wrong size on FP2LandingSpringArmConfig");
static_assert(offsetof(FP2LandingSpringArmConfig, LandedSpringSimData) == 0x000000, "Member 'FP2LandingSpringArmConfig::LandedSpringSimData' has a wrong offset!");
static_assert(offsetof(FP2LandingSpringArmConfig, SpeedRange) == 0x000008, "Member 'FP2LandingSpringArmConfig::SpeedRange' has a wrong offset!");
static_assert(offsetof(FP2LandingSpringArmConfig, SpeedScaleMap) == 0x000018, "Member 'FP2LandingSpringArmConfig::SpeedScaleMap' has a wrong offset!");

// ScriptStruct Game.P2ProductionBonusRate
// 0x0030 (0x0030 - 0x0000)
struct FP2ProductionBonusRate final
{
public:
	int32                                         MinRatePercentage;                                 // 0x0000(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   ToolTipText;                                       // 0x0008(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FLinearColor                           RateColor;                                         // 0x0020(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FP2ProductionBonusRate) == 0x000008, "Wrong alignment on FP2ProductionBonusRate");
static_assert(sizeof(FP2ProductionBonusRate) == 0x000030, "Wrong size on FP2ProductionBonusRate");
static_assert(offsetof(FP2ProductionBonusRate, MinRatePercentage) == 0x000000, "Member 'FP2ProductionBonusRate::MinRatePercentage' has a wrong offset!");
static_assert(offsetof(FP2ProductionBonusRate, ToolTipText) == 0x000008, "Member 'FP2ProductionBonusRate::ToolTipText' has a wrong offset!");
static_assert(offsetof(FP2ProductionBonusRate, RateColor) == 0x000020, "Member 'FP2ProductionBonusRate::RateColor' has a wrong offset!");

// ScriptStruct Game.P2ObjectiveTypeIconInfo
// 0x0048 (0x0048 - 0x0000)
struct FP2ObjectiveTypeIconInfo final
{
public:
	TSoftObjectPtr<class UTexture2D>              Icon;                                              // 0x0000(0x0030)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FText                                   ToolTip;                                           // 0x0030(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
};
static_assert(alignof(FP2ObjectiveTypeIconInfo) == 0x000008, "Wrong alignment on FP2ObjectiveTypeIconInfo");
static_assert(sizeof(FP2ObjectiveTypeIconInfo) == 0x000048, "Wrong size on FP2ObjectiveTypeIconInfo");
static_assert(offsetof(FP2ObjectiveTypeIconInfo, Icon) == 0x000000, "Member 'FP2ObjectiveTypeIconInfo::Icon' has a wrong offset!");
static_assert(offsetof(FP2ObjectiveTypeIconInfo, ToolTip) == 0x000030, "Member 'FP2ObjectiveTypeIconInfo::ToolTip' has a wrong offset!");

// ScriptStruct Game.GameplayTagStack
// 0x000C (0x0018 - 0x000C)
struct FGameplayTagStack final : public FFastArraySerializerItem
{
public:
	struct FGameplayTag                           Tag;                                               // 0x000C(0x0008)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         StackCount;                                        // 0x0014(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
};
static_assert(alignof(FGameplayTagStack) == 0x000004, "Wrong alignment on FGameplayTagStack");
static_assert(sizeof(FGameplayTagStack) == 0x000018, "Wrong size on FGameplayTagStack");
static_assert(offsetof(FGameplayTagStack, Tag) == 0x00000C, "Member 'FGameplayTagStack::Tag' has a wrong offset!");
static_assert(offsetof(FGameplayTagStack, StackCount) == 0x000014, "Member 'FGameplayTagStack::StackCount' has a wrong offset!");

// ScriptStruct Game.GameplayTagStackContainer
// 0x0060 (0x0168 - 0x0108)
struct FGameplayTagStackContainer final : public FFastArraySerializer
{
public:
	TArray<struct FGameplayTagStack>              Stacks;                                            // 0x0108(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	uint8                                         Pad_118[0x50];                                     // 0x0118(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FGameplayTagStackContainer) == 0x000008, "Wrong alignment on FGameplayTagStackContainer");
static_assert(sizeof(FGameplayTagStackContainer) == 0x000168, "Wrong size on FGameplayTagStackContainer");
static_assert(offsetof(FGameplayTagStackContainer, Stacks) == 0x000108, "Member 'FGameplayTagStackContainer::Stacks' has a wrong offset!");

// ScriptStruct Game.P2ItemWidgetParams
// 0x0040 (0x0040 - 0x0000)
struct FP2ItemWidgetParams final
{
public:
	struct FVector2D                              SpacingBorderPadding;                              // 0x0000(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FMargin                                OverlaySlotPadding;                                // 0x0010(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FIntPoint                              IconSize;                                          // 0x0020(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EP2ItemWidgetPropertiesSize                   ItemWidgetPropertiesSize;                          // 0x0028(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EP2ItemPlacement                              ItemPlacement;                                     // 0x0029(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bHidingTooltip;                                    // 0x002A(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bShowItemType;                                     // 0x002B(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bShowAmmoType;                                     // 0x002C(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bShowItemBorder;                                   // 0x002D(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bShowDisplayDurability;                            // 0x002E(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bShowItemName;                                     // 0x002F(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bShowItemNameForAmmo;                              // 0x0030(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bShowAttachmentSlot;                               // 0x0031(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bShowItemMark;                                     // 0x0032(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsRequiringItem;                                  // 0x0033(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         RequireItemAmount;                                 // 0x0034(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIncludeEquipment;                                 // 0x0038(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bShouldUpdateItemCount;                            // 0x0039(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bShowItemQuantity;                                 // 0x003A(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bApplyBlurEffect;                                  // 0x003B(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3C[0x4];                                       // 0x003C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FP2ItemWidgetParams) == 0x000008, "Wrong alignment on FP2ItemWidgetParams");
static_assert(sizeof(FP2ItemWidgetParams) == 0x000040, "Wrong size on FP2ItemWidgetParams");
static_assert(offsetof(FP2ItemWidgetParams, SpacingBorderPadding) == 0x000000, "Member 'FP2ItemWidgetParams::SpacingBorderPadding' has a wrong offset!");
static_assert(offsetof(FP2ItemWidgetParams, OverlaySlotPadding) == 0x000010, "Member 'FP2ItemWidgetParams::OverlaySlotPadding' has a wrong offset!");
static_assert(offsetof(FP2ItemWidgetParams, IconSize) == 0x000020, "Member 'FP2ItemWidgetParams::IconSize' has a wrong offset!");
static_assert(offsetof(FP2ItemWidgetParams, ItemWidgetPropertiesSize) == 0x000028, "Member 'FP2ItemWidgetParams::ItemWidgetPropertiesSize' has a wrong offset!");
static_assert(offsetof(FP2ItemWidgetParams, ItemPlacement) == 0x000029, "Member 'FP2ItemWidgetParams::ItemPlacement' has a wrong offset!");
static_assert(offsetof(FP2ItemWidgetParams, bHidingTooltip) == 0x00002A, "Member 'FP2ItemWidgetParams::bHidingTooltip' has a wrong offset!");
static_assert(offsetof(FP2ItemWidgetParams, bShowItemType) == 0x00002B, "Member 'FP2ItemWidgetParams::bShowItemType' has a wrong offset!");
static_assert(offsetof(FP2ItemWidgetParams, bShowAmmoType) == 0x00002C, "Member 'FP2ItemWidgetParams::bShowAmmoType' has a wrong offset!");
static_assert(offsetof(FP2ItemWidgetParams, bShowItemBorder) == 0x00002D, "Member 'FP2ItemWidgetParams::bShowItemBorder' has a wrong offset!");
static_assert(offsetof(FP2ItemWidgetParams, bShowDisplayDurability) == 0x00002E, "Member 'FP2ItemWidgetParams::bShowDisplayDurability' has a wrong offset!");
static_assert(offsetof(FP2ItemWidgetParams, bShowItemName) == 0x00002F, "Member 'FP2ItemWidgetParams::bShowItemName' has a wrong offset!");
static_assert(offsetof(FP2ItemWidgetParams, bShowItemNameForAmmo) == 0x000030, "Member 'FP2ItemWidgetParams::bShowItemNameForAmmo' has a wrong offset!");
static_assert(offsetof(FP2ItemWidgetParams, bShowAttachmentSlot) == 0x000031, "Member 'FP2ItemWidgetParams::bShowAttachmentSlot' has a wrong offset!");
static_assert(offsetof(FP2ItemWidgetParams, bShowItemMark) == 0x000032, "Member 'FP2ItemWidgetParams::bShowItemMark' has a wrong offset!");
static_assert(offsetof(FP2ItemWidgetParams, bIsRequiringItem) == 0x000033, "Member 'FP2ItemWidgetParams::bIsRequiringItem' has a wrong offset!");
static_assert(offsetof(FP2ItemWidgetParams, RequireItemAmount) == 0x000034, "Member 'FP2ItemWidgetParams::RequireItemAmount' has a wrong offset!");
static_assert(offsetof(FP2ItemWidgetParams, bIncludeEquipment) == 0x000038, "Member 'FP2ItemWidgetParams::bIncludeEquipment' has a wrong offset!");
static_assert(offsetof(FP2ItemWidgetParams, bShouldUpdateItemCount) == 0x000039, "Member 'FP2ItemWidgetParams::bShouldUpdateItemCount' has a wrong offset!");
static_assert(offsetof(FP2ItemWidgetParams, bShowItemQuantity) == 0x00003A, "Member 'FP2ItemWidgetParams::bShowItemQuantity' has a wrong offset!");
static_assert(offsetof(FP2ItemWidgetParams, bApplyBlurEffect) == 0x00003B, "Member 'FP2ItemWidgetParams::bApplyBlurEffect' has a wrong offset!");

// ScriptStruct Game.P2CommonRewardParams
// 0x00B0 (0x00B0 - 0x0000)
struct FP2CommonRewardParams final
{
public:
	struct FGameplayTag                           RewardTag;                                         // 0x0000(0x0008)(BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EP2RewardType                                 RewardType;                                        // 0x0008(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FP2ItemWidgetParams                    ItemWidgetParams;                                  // 0x0010(0x0040)(BlueprintVisible, BlueprintReadOnly, NoDestructor, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UTexture2D>              RewardIcon;                                        // 0x0050(0x0030)(BlueprintVisible, BlueprintReadOnly, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UP2Item*                                Item;                                              // 0x0080(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UP2ItemData*                            ItemData;                                          // 0x0088(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UP2SkinSlotPreset*                      SkinSlotPreset;                                    // 0x0090(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UP2ItemSkinContainer*                   ItemSkinContainer;                                 // 0x0098(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           FactionTag;                                        // 0x00A0(0x0008)(BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Amount;                                            // 0x00A8(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_AC[0x4];                                       // 0x00AC(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FP2CommonRewardParams) == 0x000008, "Wrong alignment on FP2CommonRewardParams");
static_assert(sizeof(FP2CommonRewardParams) == 0x0000B0, "Wrong size on FP2CommonRewardParams");
static_assert(offsetof(FP2CommonRewardParams, RewardTag) == 0x000000, "Member 'FP2CommonRewardParams::RewardTag' has a wrong offset!");
static_assert(offsetof(FP2CommonRewardParams, RewardType) == 0x000008, "Member 'FP2CommonRewardParams::RewardType' has a wrong offset!");
static_assert(offsetof(FP2CommonRewardParams, ItemWidgetParams) == 0x000010, "Member 'FP2CommonRewardParams::ItemWidgetParams' has a wrong offset!");
static_assert(offsetof(FP2CommonRewardParams, RewardIcon) == 0x000050, "Member 'FP2CommonRewardParams::RewardIcon' has a wrong offset!");
static_assert(offsetof(FP2CommonRewardParams, Item) == 0x000080, "Member 'FP2CommonRewardParams::Item' has a wrong offset!");
static_assert(offsetof(FP2CommonRewardParams, ItemData) == 0x000088, "Member 'FP2CommonRewardParams::ItemData' has a wrong offset!");
static_assert(offsetof(FP2CommonRewardParams, SkinSlotPreset) == 0x000090, "Member 'FP2CommonRewardParams::SkinSlotPreset' has a wrong offset!");
static_assert(offsetof(FP2CommonRewardParams, ItemSkinContainer) == 0x000098, "Member 'FP2CommonRewardParams::ItemSkinContainer' has a wrong offset!");
static_assert(offsetof(FP2CommonRewardParams, FactionTag) == 0x0000A0, "Member 'FP2CommonRewardParams::FactionTag' has a wrong offset!");
static_assert(offsetof(FP2CommonRewardParams, Amount) == 0x0000A8, "Member 'FP2CommonRewardParams::Amount' has a wrong offset!");

// ScriptStruct Game.P2TargetData_Reload
// 0x0048 (0x0050 - 0x0008)
struct FP2TargetData_Reload final : public FGameplayAbilityTargetData
{
public:
	uint8                                         Pad_8[0x48];                                       // 0x0008(0x0048)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FP2TargetData_Reload) == 0x000008, "Wrong alignment on FP2TargetData_Reload");
static_assert(sizeof(FP2TargetData_Reload) == 0x000050, "Wrong size on FP2TargetData_Reload");

// ScriptStruct Game.P2PodDoorState
// 0x0030 (0x0030 - 0x0000)
struct FP2PodDoorState final
{
public:
	struct FComponentReference                    Pod;                                               // 0x0000(0x0028)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	bool                                          bIsOpen;                                           // 0x0028(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EP2PodDisplayState                            DisplayState;                                      // 0x0029(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2A[0x6];                                       // 0x002A(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FP2PodDoorState) == 0x000008, "Wrong alignment on FP2PodDoorState");
static_assert(sizeof(FP2PodDoorState) == 0x000030, "Wrong size on FP2PodDoorState");
static_assert(offsetof(FP2PodDoorState, Pod) == 0x000000, "Member 'FP2PodDoorState::Pod' has a wrong offset!");
static_assert(offsetof(FP2PodDoorState, bIsOpen) == 0x000028, "Member 'FP2PodDoorState::bIsOpen' has a wrong offset!");
static_assert(offsetof(FP2PodDoorState, DisplayState) == 0x000029, "Member 'FP2PodDoorState::DisplayState' has a wrong offset!");

// ScriptStruct Game.P2NotificationSystemMessage
// 0x0030 (0x0030 - 0x0000)
struct FP2NotificationSystemMessage final
{
public:
	class FText                                   Text;                                              // 0x0000(0x0018)(NativeAccessSpecifierPublic)
	uint8                                         Pad_18[0x18];                                      // 0x0018(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FP2NotificationSystemMessage) == 0x000008, "Wrong alignment on FP2NotificationSystemMessage");
static_assert(sizeof(FP2NotificationSystemMessage) == 0x000030, "Wrong size on FP2NotificationSystemMessage");
static_assert(offsetof(FP2NotificationSystemMessage, Text) == 0x000000, "Member 'FP2NotificationSystemMessage::Text' has a wrong offset!");

// ScriptStruct Game.P2ItemPresetInfo
// 0x0018 (0x0018 - 0x0000)
struct FP2ItemPresetInfo final
{
public:
	class UP2LoadoutPresetData*                   loadoutpreset;                                     // 0x0000(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 CustomPreset;                                      // 0x0008(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FP2ItemPresetInfo) == 0x000008, "Wrong alignment on FP2ItemPresetInfo");
static_assert(sizeof(FP2ItemPresetInfo) == 0x000018, "Wrong size on FP2ItemPresetInfo");
static_assert(offsetof(FP2ItemPresetInfo, loadoutpreset) == 0x000000, "Member 'FP2ItemPresetInfo::loadoutpreset' has a wrong offset!");
static_assert(offsetof(FP2ItemPresetInfo, CustomPreset) == 0x000008, "Member 'FP2ItemPresetInfo::CustomPreset' has a wrong offset!");

// ScriptStruct Game.P2DbnoSpectateConfig
// 0x0018 (0x0018 - 0x0000)
struct FP2DbnoSpectateConfig final
{
public:
	bool                                          bSpectateInStageTwo;                               // 0x0000(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         SpectateDelay;                                     // 0x0004(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCameraFade;                                       // 0x0008(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x3];                                        // 0x0009(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         CameraFadeFrom;                                    // 0x000C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CameraFadeTo;                                      // 0x0010(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CameraFadeDuration;                                // 0x0014(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FP2DbnoSpectateConfig) == 0x000004, "Wrong alignment on FP2DbnoSpectateConfig");
static_assert(sizeof(FP2DbnoSpectateConfig) == 0x000018, "Wrong size on FP2DbnoSpectateConfig");
static_assert(offsetof(FP2DbnoSpectateConfig, bSpectateInStageTwo) == 0x000000, "Member 'FP2DbnoSpectateConfig::bSpectateInStageTwo' has a wrong offset!");
static_assert(offsetof(FP2DbnoSpectateConfig, SpectateDelay) == 0x000004, "Member 'FP2DbnoSpectateConfig::SpectateDelay' has a wrong offset!");
static_assert(offsetof(FP2DbnoSpectateConfig, bCameraFade) == 0x000008, "Member 'FP2DbnoSpectateConfig::bCameraFade' has a wrong offset!");
static_assert(offsetof(FP2DbnoSpectateConfig, CameraFadeFrom) == 0x00000C, "Member 'FP2DbnoSpectateConfig::CameraFadeFrom' has a wrong offset!");
static_assert(offsetof(FP2DbnoSpectateConfig, CameraFadeTo) == 0x000010, "Member 'FP2DbnoSpectateConfig::CameraFadeTo' has a wrong offset!");
static_assert(offsetof(FP2DbnoSpectateConfig, CameraFadeDuration) == 0x000014, "Member 'FP2DbnoSpectateConfig::CameraFadeDuration' has a wrong offset!");

// ScriptStruct Game.P2ItemEntry
// 0x0020 (0x0020 - 0x0000)
struct FP2ItemEntry
{
public:
	class UP2ItemSkinContainer*                   Skin;                                              // 0x0000(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FP2InitialAttachablesEntry>     Attachables;                                       // 0x0008(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	bool                                          bShowInUI;                                         // 0x0018(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19[0x7];                                       // 0x0019(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FP2ItemEntry) == 0x000008, "Wrong alignment on FP2ItemEntry");
static_assert(sizeof(FP2ItemEntry) == 0x000020, "Wrong size on FP2ItemEntry");
static_assert(offsetof(FP2ItemEntry, Skin) == 0x000000, "Member 'FP2ItemEntry::Skin' has a wrong offset!");
static_assert(offsetof(FP2ItemEntry, Attachables) == 0x000008, "Member 'FP2ItemEntry::Attachables' has a wrong offset!");
static_assert(offsetof(FP2ItemEntry, bShowInUI) == 0x000018, "Member 'FP2ItemEntry::bShowInUI' has a wrong offset!");

// ScriptStruct Game.P2InitialCosmeticsEntry
// 0x0008 (0x0028 - 0x0020)
struct FP2InitialCosmeticsEntry final : public FP2ItemEntry
{
public:
	class UP2WearableData*                        Wearable;                                          // 0x0020(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FP2InitialCosmeticsEntry) == 0x000008, "Wrong alignment on FP2InitialCosmeticsEntry");
static_assert(sizeof(FP2InitialCosmeticsEntry) == 0x000028, "Wrong size on FP2InitialCosmeticsEntry");
static_assert(offsetof(FP2InitialCosmeticsEntry, Wearable) == 0x000020, "Member 'FP2InitialCosmeticsEntry::Wearable' has a wrong offset!");

// ScriptStruct Game.P2InitialEquipmentEntry
// 0x0008 (0x0028 - 0x0020)
struct FP2InitialEquipmentEntry final : public FP2ItemEntry
{
public:
	class UP2EquipmentData*                       Equipment;                                         // 0x0020(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FP2InitialEquipmentEntry) == 0x000008, "Wrong alignment on FP2InitialEquipmentEntry");
static_assert(sizeof(FP2InitialEquipmentEntry) == 0x000028, "Wrong size on FP2InitialEquipmentEntry");
static_assert(offsetof(FP2InitialEquipmentEntry, Equipment) == 0x000020, "Member 'FP2InitialEquipmentEntry::Equipment' has a wrong offset!");

// ScriptStruct Game.PositionInfo
// 0x0008 (0x0008 - 0x0000)
struct FPositionInfo
{
public:
	int32                                         Position;                                          // 0x0000(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bRotation;                                         // 0x0004(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5[0x3];                                        // 0x0005(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FPositionInfo) == 0x000004, "Wrong alignment on FPositionInfo");
static_assert(sizeof(FPositionInfo) == 0x000008, "Wrong size on FPositionInfo");
static_assert(offsetof(FPositionInfo, Position) == 0x000000, "Member 'FPositionInfo::Position' has a wrong offset!");
static_assert(offsetof(FPositionInfo, bRotation) == 0x000004, "Member 'FPositionInfo::bRotation' has a wrong offset!");

// ScriptStruct Game.P2InitialItemEntry
// 0x0020 (0x0040 - 0x0020)
struct FP2InitialItemEntry final : public FP2ItemEntry
{
public:
	class UP2ItemData*                            Item;                                              // 0x0020(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FIntPoint                              Amount;                                            // 0x0028(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FIntPoint                              Stack;                                             // 0x0030(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FPositionInfo                          PredefinedPosition;                                // 0x0038(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FP2InitialItemEntry) == 0x000008, "Wrong alignment on FP2InitialItemEntry");
static_assert(sizeof(FP2InitialItemEntry) == 0x000040, "Wrong size on FP2InitialItemEntry");
static_assert(offsetof(FP2InitialItemEntry, Item) == 0x000020, "Member 'FP2InitialItemEntry::Item' has a wrong offset!");
static_assert(offsetof(FP2InitialItemEntry, Amount) == 0x000028, "Member 'FP2InitialItemEntry::Amount' has a wrong offset!");
static_assert(offsetof(FP2InitialItemEntry, Stack) == 0x000030, "Member 'FP2InitialItemEntry::Stack' has a wrong offset!");
static_assert(offsetof(FP2InitialItemEntry, PredefinedPosition) == 0x000038, "Member 'FP2InitialItemEntry::PredefinedPosition' has a wrong offset!");

// ScriptStruct Game.P2InitialItemList
// 0x0030 (0x0030 - 0x0000)
struct FP2InitialItemList final
{
public:
	TArray<struct FP2InitialCosmeticsEntry>       InitialCosmetics;                                  // 0x0000(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FP2InitialEquipmentEntry>       InitialEquipment;                                  // 0x0010(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FP2InitialItemEntry>            InitialItems;                                      // 0x0020(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FP2InitialItemList) == 0x000008, "Wrong alignment on FP2InitialItemList");
static_assert(sizeof(FP2InitialItemList) == 0x000030, "Wrong size on FP2InitialItemList");
static_assert(offsetof(FP2InitialItemList, InitialCosmetics) == 0x000000, "Member 'FP2InitialItemList::InitialCosmetics' has a wrong offset!");
static_assert(offsetof(FP2InitialItemList, InitialEquipment) == 0x000010, "Member 'FP2InitialItemList::InitialEquipment' has a wrong offset!");
static_assert(offsetof(FP2InitialItemList, InitialItems) == 0x000020, "Member 'FP2InitialItemList::InitialItems' has a wrong offset!");

// ScriptStruct Game.P2SystemMessage
// 0x0020 (0x0020 - 0x0000)
struct FP2SystemMessage final
{
public:
	class FText                                   Text;                                              // 0x0000(0x0018)(NativeAccessSpecifierPublic)
	uint8                                         Pad_18[0x8];                                       // 0x0018(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FP2SystemMessage) == 0x000008, "Wrong alignment on FP2SystemMessage");
static_assert(sizeof(FP2SystemMessage) == 0x000020, "Wrong size on FP2SystemMessage");
static_assert(offsetof(FP2SystemMessage, Text) == 0x000000, "Member 'FP2SystemMessage::Text' has a wrong offset!");

// ScriptStruct Game.P2WaypointPings
// 0x0010 (0x0010 - 0x0000)
struct FP2WaypointPings final
{
public:
	TArray<class UP2CompassWaypointWidget*>       WaypointPings;                                     // 0x0000(0x0010)(ExportObject, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(FP2WaypointPings) == 0x000008, "Wrong alignment on FP2WaypointPings");
static_assert(sizeof(FP2WaypointPings) == 0x000010, "Wrong size on FP2WaypointPings");
static_assert(offsetof(FP2WaypointPings, WaypointPings) == 0x000000, "Member 'FP2WaypointPings::WaypointPings' has a wrong offset!");

// ScriptStruct Game.P2WaterInfo
// 0x0078 (0x0078 - 0x0000)
struct FP2WaterInfo final
{
public:
	class UWaterBodyComponent*                    WaterBody;                                         // 0x0000(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ImmersionRatio;                                    // 0x0008(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ImmersionHeight;                                   // 0x000C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         WaterDepth;                                        // 0x0010(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector_NetQuantize100                 WaterSurface;                                      // 0x0018(0x0018)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector_NetQuantize100                 WaterVelocity;                                     // 0x0030(0x0018)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector_NetQuantizeNormal              WaterNormal;                                       // 0x0048(0x0018)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector_NetQuantizeNormal              WaterPlaneNormal;                                  // 0x0060(0x0018)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FP2WaterInfo) == 0x000008, "Wrong alignment on FP2WaterInfo");
static_assert(sizeof(FP2WaterInfo) == 0x000078, "Wrong size on FP2WaterInfo");
static_assert(offsetof(FP2WaterInfo, WaterBody) == 0x000000, "Member 'FP2WaterInfo::WaterBody' has a wrong offset!");
static_assert(offsetof(FP2WaterInfo, ImmersionRatio) == 0x000008, "Member 'FP2WaterInfo::ImmersionRatio' has a wrong offset!");
static_assert(offsetof(FP2WaterInfo, ImmersionHeight) == 0x00000C, "Member 'FP2WaterInfo::ImmersionHeight' has a wrong offset!");
static_assert(offsetof(FP2WaterInfo, WaterDepth) == 0x000010, "Member 'FP2WaterInfo::WaterDepth' has a wrong offset!");
static_assert(offsetof(FP2WaterInfo, WaterSurface) == 0x000018, "Member 'FP2WaterInfo::WaterSurface' has a wrong offset!");
static_assert(offsetof(FP2WaterInfo, WaterVelocity) == 0x000030, "Member 'FP2WaterInfo::WaterVelocity' has a wrong offset!");
static_assert(offsetof(FP2WaterInfo, WaterNormal) == 0x000048, "Member 'FP2WaterInfo::WaterNormal' has a wrong offset!");
static_assert(offsetof(FP2WaterInfo, WaterPlaneNormal) == 0x000060, "Member 'FP2WaterInfo::WaterPlaneNormal' has a wrong offset!");

// ScriptStruct Game.P2DamageDetailsMessage
// 0x0008 (0x0008 - 0x0000)
struct alignas(0x08) FP2DamageDetailsMessage final
{
public:
	uint8                                         Pad_0[0x8];                                        // 0x0000(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FP2DamageDetailsMessage) == 0x000008, "Wrong alignment on FP2DamageDetailsMessage");
static_assert(sizeof(FP2DamageDetailsMessage) == 0x000008, "Wrong size on FP2DamageDetailsMessage");

// ScriptStruct Game.P2LootMessageEntry
// 0x0010 (0x0010 - 0x0000)
struct FP2LootMessageEntry final
{
public:
	class UP2ItemData*                            ItemData;                                          // 0x0000(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ItemAmount;                                        // 0x0008(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ItemStackAmount;                                   // 0x000C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FP2LootMessageEntry) == 0x000008, "Wrong alignment on FP2LootMessageEntry");
static_assert(sizeof(FP2LootMessageEntry) == 0x000010, "Wrong size on FP2LootMessageEntry");
static_assert(offsetof(FP2LootMessageEntry, ItemData) == 0x000000, "Member 'FP2LootMessageEntry::ItemData' has a wrong offset!");
static_assert(offsetof(FP2LootMessageEntry, ItemAmount) == 0x000008, "Member 'FP2LootMessageEntry::ItemAmount' has a wrong offset!");
static_assert(offsetof(FP2LootMessageEntry, ItemStackAmount) == 0x00000C, "Member 'FP2LootMessageEntry::ItemStackAmount' has a wrong offset!");

// ScriptStruct Game.P2LootMessage
// 0x0010 (0x0010 - 0x0000)
struct FP2LootMessage final
{
public:
	TArray<struct FP2LootMessageEntry>            Entries;                                           // 0x0000(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FP2LootMessage) == 0x000008, "Wrong alignment on FP2LootMessage");
static_assert(sizeof(FP2LootMessage) == 0x000010, "Wrong size on FP2LootMessage");
static_assert(offsetof(FP2LootMessage, Entries) == 0x000000, "Member 'FP2LootMessage::Entries' has a wrong offset!");

// ScriptStruct Game.CameraViewLimitConfig
// 0x0020 (0x0020 - 0x0000)
struct FCameraViewLimitConfig final
{
public:
	struct FVector2D                              PitchMinMax_Hard;                                  // 0x0000(0x0010)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              PitchMinMax_Soft;                                  // 0x0010(0x0010)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCameraViewLimitConfig) == 0x000008, "Wrong alignment on FCameraViewLimitConfig");
static_assert(sizeof(FCameraViewLimitConfig) == 0x000020, "Wrong size on FCameraViewLimitConfig");
static_assert(offsetof(FCameraViewLimitConfig, PitchMinMax_Hard) == 0x000000, "Member 'FCameraViewLimitConfig::PitchMinMax_Hard' has a wrong offset!");
static_assert(offsetof(FCameraViewLimitConfig, PitchMinMax_Soft) == 0x000010, "Member 'FCameraViewLimitConfig::PitchMinMax_Soft' has a wrong offset!");

// ScriptStruct Game.P2ContractRequirementIndexInfo
// 0x0010 (0x0010 - 0x0000)
struct FP2ContractRequirementIndexInfo final
{
public:
	class UP2ContractData*                        ContractData;                                      // 0x0000(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         RequirementIndex;                                  // 0x0008(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FP2ContractRequirementIndexInfo) == 0x000008, "Wrong alignment on FP2ContractRequirementIndexInfo");
static_assert(sizeof(FP2ContractRequirementIndexInfo) == 0x000010, "Wrong size on FP2ContractRequirementIndexInfo");
static_assert(offsetof(FP2ContractRequirementIndexInfo, ContractData) == 0x000000, "Member 'FP2ContractRequirementIndexInfo::ContractData' has a wrong offset!");
static_assert(offsetof(FP2ContractRequirementIndexInfo, RequirementIndex) == 0x000008, "Member 'FP2ContractRequirementIndexInfo::RequirementIndex' has a wrong offset!");

// ScriptStruct Game.P2WaypointMarkers
// 0x0020 (0x0020 - 0x0000)
struct FP2WaypointMarkers final
{
public:
	TArray<TWeakObjectPtr<class UPrimitiveComponent>> Markers;                                       // 0x0000(0x0010)(ExportObject, ZeroConstructor, ContainsInstancedReference, UObjectWrapper, NativeAccessSpecifierPublic)
	TArray<class UStaticMeshComponent*>           WaypointLines;                                     // 0x0010(0x0010)(ExportObject, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(FP2WaypointMarkers) == 0x000008, "Wrong alignment on FP2WaypointMarkers");
static_assert(sizeof(FP2WaypointMarkers) == 0x000020, "Wrong size on FP2WaypointMarkers");
static_assert(offsetof(FP2WaypointMarkers, Markers) == 0x000000, "Member 'FP2WaypointMarkers::Markers' has a wrong offset!");
static_assert(offsetof(FP2WaypointMarkers, WaypointLines) == 0x000010, "Member 'FP2WaypointMarkers::WaypointLines' has a wrong offset!");

// ScriptStruct Game.P2GameplayCueNotify_MaterialVariation
// 0x0058 (0x0058 - 0x0000)
struct FP2GameplayCueNotify_MaterialVariation final
{
public:
	class UMaterialInterface*                     Value;                                             // 0x0000(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TMap<struct FGameplayTag, class UMaterialInterface*> Variations;                                 // 0x0008(0x0050)(Edit, BlueprintVisible, DisableEditOnInstance, UObjectWrapper, NativeAccessSpecifierPublic)
};
static_assert(alignof(FP2GameplayCueNotify_MaterialVariation) == 0x000008, "Wrong alignment on FP2GameplayCueNotify_MaterialVariation");
static_assert(sizeof(FP2GameplayCueNotify_MaterialVariation) == 0x000058, "Wrong size on FP2GameplayCueNotify_MaterialVariation");
static_assert(offsetof(FP2GameplayCueNotify_MaterialVariation, Value) == 0x000000, "Member 'FP2GameplayCueNotify_MaterialVariation::Value' has a wrong offset!");
static_assert(offsetof(FP2GameplayCueNotify_MaterialVariation, Variations) == 0x000008, "Member 'FP2GameplayCueNotify_MaterialVariation::Variations' has a wrong offset!");

// ScriptStruct Game.P2GameplayCueNotify_MaterialSet
// 0x0058 (0x0058 - 0x0000)
struct FP2GameplayCueNotify_MaterialSet final
{
public:
	class UMaterialInterface*                     Default;                                           // 0x0000(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TMap<struct FGameplayTag, struct FP2GameplayCueNotify_MaterialVariation> MaterialMap;            // 0x0008(0x0050)(Edit, BlueprintVisible, DisableEditOnInstance, NativeAccessSpecifierPublic)
};
static_assert(alignof(FP2GameplayCueNotify_MaterialSet) == 0x000008, "Wrong alignment on FP2GameplayCueNotify_MaterialSet");
static_assert(sizeof(FP2GameplayCueNotify_MaterialSet) == 0x000058, "Wrong size on FP2GameplayCueNotify_MaterialSet");
static_assert(offsetof(FP2GameplayCueNotify_MaterialSet, Default) == 0x000000, "Member 'FP2GameplayCueNotify_MaterialSet::Default' has a wrong offset!");
static_assert(offsetof(FP2GameplayCueNotify_MaterialSet, MaterialMap) == 0x000008, "Member 'FP2GameplayCueNotify_MaterialSet::MaterialMap' has a wrong offset!");

// ScriptStruct Game.P2PingDisplay
// 0x0010 (0x0010 - 0x0000)
struct FP2PingDisplay final
{
public:
	TArray<class UPrimitiveComponent*>            DisplayComponents;                                 // 0x0000(0x0010)(ExportObject, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(FP2PingDisplay) == 0x000008, "Wrong alignment on FP2PingDisplay");
static_assert(sizeof(FP2PingDisplay) == 0x000010, "Wrong size on FP2PingDisplay");
static_assert(offsetof(FP2PingDisplay, DisplayComponents) == 0x000000, "Member 'FP2PingDisplay::DisplayComponents' has a wrong offset!");

// ScriptStruct Game.P2GameplayContextRequirementInventoryTestData
// 0x0020 (0x0020 - 0x0000)
struct FP2GameplayContextRequirementInventoryTestData final
{
public:
	EP2GameplayContextRequirementInventoryComparison ComparsionType;                                 // 0x0000(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UP2ItemData*                            Item;                                              // 0x0008(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ItemCountRequired;                                 // 0x0010(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0xC];                                       // 0x0014(0x000C)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FP2GameplayContextRequirementInventoryTestData) == 0x000008, "Wrong alignment on FP2GameplayContextRequirementInventoryTestData");
static_assert(sizeof(FP2GameplayContextRequirementInventoryTestData) == 0x000020, "Wrong size on FP2GameplayContextRequirementInventoryTestData");
static_assert(offsetof(FP2GameplayContextRequirementInventoryTestData, ComparsionType) == 0x000000, "Member 'FP2GameplayContextRequirementInventoryTestData::ComparsionType' has a wrong offset!");
static_assert(offsetof(FP2GameplayContextRequirementInventoryTestData, Item) == 0x000008, "Member 'FP2GameplayContextRequirementInventoryTestData::Item' has a wrong offset!");
static_assert(offsetof(FP2GameplayContextRequirementInventoryTestData, ItemCountRequired) == 0x000010, "Member 'FP2GameplayContextRequirementInventoryTestData::ItemCountRequired' has a wrong offset!");

// ScriptStruct Game.P2MapMaterialArray
// 0x0010 (0x0010 - 0x0000)
struct FP2MapMaterialArray
{
public:
	TArray<class UMaterialInterface*>             Materials;                                         // 0x0000(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FP2MapMaterialArray) == 0x000008, "Wrong alignment on FP2MapMaterialArray");
static_assert(sizeof(FP2MapMaterialArray) == 0x000010, "Wrong size on FP2MapMaterialArray");
static_assert(offsetof(FP2MapMaterialArray, Materials) == 0x000000, "Member 'FP2MapMaterialArray::Materials' has a wrong offset!");

// ScriptStruct Game.P2MapMaterialArrayWithStencil
// 0x0010 (0x0020 - 0x0010)
struct FP2MapMaterialArrayWithStencil final : public FP2MapMaterialArray
{
public:
	bool                                          bRenderCustomDepth;                                // 0x0010(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x3];                                       // 0x0011(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         CustomDepthStencilValue;                           // 0x0014(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ERendererStencilMask                          CustomDepthStencilWriteMask;                       // 0x0018(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19[0x7];                                       // 0x0019(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FP2MapMaterialArrayWithStencil) == 0x000008, "Wrong alignment on FP2MapMaterialArrayWithStencil");
static_assert(sizeof(FP2MapMaterialArrayWithStencil) == 0x000020, "Wrong size on FP2MapMaterialArrayWithStencil");
static_assert(offsetof(FP2MapMaterialArrayWithStencil, bRenderCustomDepth) == 0x000010, "Member 'FP2MapMaterialArrayWithStencil::bRenderCustomDepth' has a wrong offset!");
static_assert(offsetof(FP2MapMaterialArrayWithStencil, CustomDepthStencilValue) == 0x000014, "Member 'FP2MapMaterialArrayWithStencil::CustomDepthStencilValue' has a wrong offset!");
static_assert(offsetof(FP2MapMaterialArrayWithStencil, CustomDepthStencilWriteMask) == 0x000018, "Member 'FP2MapMaterialArrayWithStencil::CustomDepthStencilWriteMask' has a wrong offset!");

// ScriptStruct Game.P2ContractLogRequirements
// 0x0010 (0x0010 - 0x0000)
struct FP2ContractLogRequirements final
{
public:
	TArray<int32>                                 Values;                                            // 0x0000(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FP2ContractLogRequirements) == 0x000008, "Wrong alignment on FP2ContractLogRequirements");
static_assert(sizeof(FP2ContractLogRequirements) == 0x000010, "Wrong size on FP2ContractLogRequirements");
static_assert(offsetof(FP2ContractLogRequirements, Values) == 0x000000, "Member 'FP2ContractLogRequirements::Values' has a wrong offset!");

// ScriptStruct Game.P2ContractLogEntry
// 0x0068 (0x0068 - 0x0000)
struct FP2ContractLogEntry final
{
public:
	struct FDateTime                              LoggedDate;                                        // 0x0000(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EP2ContractLoggedState                        LoggedState;                                       // 0x0008(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x3];                                        // 0x0009(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	TWeakObjectPtr<class UP2ContractData>         ContractData;                                      // 0x000C(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<EP2ContractRequirementType, struct FP2ContractLogRequirements> RequirementsValues;          // 0x0018(0x0050)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
};
static_assert(alignof(FP2ContractLogEntry) == 0x000008, "Wrong alignment on FP2ContractLogEntry");
static_assert(sizeof(FP2ContractLogEntry) == 0x000068, "Wrong size on FP2ContractLogEntry");
static_assert(offsetof(FP2ContractLogEntry, LoggedDate) == 0x000000, "Member 'FP2ContractLogEntry::LoggedDate' has a wrong offset!");
static_assert(offsetof(FP2ContractLogEntry, LoggedState) == 0x000008, "Member 'FP2ContractLogEntry::LoggedState' has a wrong offset!");
static_assert(offsetof(FP2ContractLogEntry, ContractData) == 0x00000C, "Member 'FP2ContractLogEntry::ContractData' has a wrong offset!");
static_assert(offsetof(FP2ContractLogEntry, RequirementsValues) == 0x000018, "Member 'FP2ContractLogEntry::RequirementsValues' has a wrong offset!");

// ScriptStruct Game.P2RestockDataRow
// 0x0008 (0x0010 - 0x0008)
struct FP2RestockDataRow final : public FTableRowBase
{
public:
	float                                         RestockTime;                                       // 0x0008(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FP2RestockDataRow) == 0x000008, "Wrong alignment on FP2RestockDataRow");
static_assert(sizeof(FP2RestockDataRow) == 0x000010, "Wrong size on FP2RestockDataRow");
static_assert(offsetof(FP2RestockDataRow, RestockTime) == 0x000008, "Member 'FP2RestockDataRow::RestockTime' has a wrong offset!");

// ScriptStruct Game.P2MeleeSwingConfig
// 0x03E0 (0x03E0 - 0x0000)
struct FP2MeleeSwingConfig final
{
public:
	struct FGameplayTag                           SwingMontageTag;                                   // 0x0000(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           BounceMontageTag;                                  // 0x0008(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   SocketName;                                        // 0x0010(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCanBounce;                                        // 0x0018(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCanBeBlocked;                                     // 0x0019(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bApplyDamageOnBlock;                               // 0x001A(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bBounceOnBlock;                                    // 0x001B(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bTraceCosmetic;                                    // 0x001C(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1D[0x3];                                       // 0x001D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class UGameplayEffect>            DamageGE;                                          // 0x0020(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TMap<struct FGameplayTag, struct FP2ScalableFloat> DamageProperties;                             // 0x0028(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	float                                         StaminaDrainOnBlock;                               // 0x0078(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PostSwingTraceDelay;                               // 0x007C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BouncePlayRate;                                    // 0x0080(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BounceTime;                                        // 0x0084(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BounceBlendOut;                                    // 0x0088(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         StaminaCost;                                       // 0x008C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HitAbortDistance;                                  // 0x0090(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FP2MeleeSwingImpactConfig              ImpactConfig;                                      // 0x0094(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_AC[0x4];                                       // 0x00AC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<TSubclassOf<class UGameplayEffect>>    SwingActiveGameplayEffectClasses;                  // 0x00B0(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, UObjectWrapper, NativeAccessSpecifierPublic)
	bool                                          bApplyStun;                                        // 0x00C0(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C1[0x3];                                       // 0x00C1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTag                           StunTag;                                           // 0x00C4(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUseTraceScaleCurve;                               // 0x00CC(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_CD[0x3];                                       // 0x00CD(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRuntimeVectorCurve                    SwingTraceScaleCurve;                              // 0x00D0(0x0188)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FRuntimeVectorCurve                    SwingOffsetCurve;                                  // 0x0258(0x0188)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
};
static_assert(alignof(FP2MeleeSwingConfig) == 0x000008, "Wrong alignment on FP2MeleeSwingConfig");
static_assert(sizeof(FP2MeleeSwingConfig) == 0x0003E0, "Wrong size on FP2MeleeSwingConfig");
static_assert(offsetof(FP2MeleeSwingConfig, SwingMontageTag) == 0x000000, "Member 'FP2MeleeSwingConfig::SwingMontageTag' has a wrong offset!");
static_assert(offsetof(FP2MeleeSwingConfig, BounceMontageTag) == 0x000008, "Member 'FP2MeleeSwingConfig::BounceMontageTag' has a wrong offset!");
static_assert(offsetof(FP2MeleeSwingConfig, SocketName) == 0x000010, "Member 'FP2MeleeSwingConfig::SocketName' has a wrong offset!");
static_assert(offsetof(FP2MeleeSwingConfig, bCanBounce) == 0x000018, "Member 'FP2MeleeSwingConfig::bCanBounce' has a wrong offset!");
static_assert(offsetof(FP2MeleeSwingConfig, bCanBeBlocked) == 0x000019, "Member 'FP2MeleeSwingConfig::bCanBeBlocked' has a wrong offset!");
static_assert(offsetof(FP2MeleeSwingConfig, bApplyDamageOnBlock) == 0x00001A, "Member 'FP2MeleeSwingConfig::bApplyDamageOnBlock' has a wrong offset!");
static_assert(offsetof(FP2MeleeSwingConfig, bBounceOnBlock) == 0x00001B, "Member 'FP2MeleeSwingConfig::bBounceOnBlock' has a wrong offset!");
static_assert(offsetof(FP2MeleeSwingConfig, bTraceCosmetic) == 0x00001C, "Member 'FP2MeleeSwingConfig::bTraceCosmetic' has a wrong offset!");
static_assert(offsetof(FP2MeleeSwingConfig, DamageGE) == 0x000020, "Member 'FP2MeleeSwingConfig::DamageGE' has a wrong offset!");
static_assert(offsetof(FP2MeleeSwingConfig, DamageProperties) == 0x000028, "Member 'FP2MeleeSwingConfig::DamageProperties' has a wrong offset!");
static_assert(offsetof(FP2MeleeSwingConfig, StaminaDrainOnBlock) == 0x000078, "Member 'FP2MeleeSwingConfig::StaminaDrainOnBlock' has a wrong offset!");
static_assert(offsetof(FP2MeleeSwingConfig, PostSwingTraceDelay) == 0x00007C, "Member 'FP2MeleeSwingConfig::PostSwingTraceDelay' has a wrong offset!");
static_assert(offsetof(FP2MeleeSwingConfig, BouncePlayRate) == 0x000080, "Member 'FP2MeleeSwingConfig::BouncePlayRate' has a wrong offset!");
static_assert(offsetof(FP2MeleeSwingConfig, BounceTime) == 0x000084, "Member 'FP2MeleeSwingConfig::BounceTime' has a wrong offset!");
static_assert(offsetof(FP2MeleeSwingConfig, BounceBlendOut) == 0x000088, "Member 'FP2MeleeSwingConfig::BounceBlendOut' has a wrong offset!");
static_assert(offsetof(FP2MeleeSwingConfig, StaminaCost) == 0x00008C, "Member 'FP2MeleeSwingConfig::StaminaCost' has a wrong offset!");
static_assert(offsetof(FP2MeleeSwingConfig, HitAbortDistance) == 0x000090, "Member 'FP2MeleeSwingConfig::HitAbortDistance' has a wrong offset!");
static_assert(offsetof(FP2MeleeSwingConfig, ImpactConfig) == 0x000094, "Member 'FP2MeleeSwingConfig::ImpactConfig' has a wrong offset!");
static_assert(offsetof(FP2MeleeSwingConfig, SwingActiveGameplayEffectClasses) == 0x0000B0, "Member 'FP2MeleeSwingConfig::SwingActiveGameplayEffectClasses' has a wrong offset!");
static_assert(offsetof(FP2MeleeSwingConfig, bApplyStun) == 0x0000C0, "Member 'FP2MeleeSwingConfig::bApplyStun' has a wrong offset!");
static_assert(offsetof(FP2MeleeSwingConfig, StunTag) == 0x0000C4, "Member 'FP2MeleeSwingConfig::StunTag' has a wrong offset!");
static_assert(offsetof(FP2MeleeSwingConfig, bUseTraceScaleCurve) == 0x0000CC, "Member 'FP2MeleeSwingConfig::bUseTraceScaleCurve' has a wrong offset!");
static_assert(offsetof(FP2MeleeSwingConfig, SwingTraceScaleCurve) == 0x0000D0, "Member 'FP2MeleeSwingConfig::SwingTraceScaleCurve' has a wrong offset!");
static_assert(offsetof(FP2MeleeSwingConfig, SwingOffsetCurve) == 0x000258, "Member 'FP2MeleeSwingConfig::SwingOffsetCurve' has a wrong offset!");

// ScriptStruct Game.P2ParachuteActorInfo
// 0x0010 (0x0010 - 0x0000)
struct FP2ParachuteActorInfo final
{
public:
	class AP2HeroCharacter*                       OwnerCharacter;                                    // 0x0000(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   BoneName;                                          // 0x0008(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FP2ParachuteActorInfo) == 0x000008, "Wrong alignment on FP2ParachuteActorInfo");
static_assert(sizeof(FP2ParachuteActorInfo) == 0x000010, "Wrong size on FP2ParachuteActorInfo");
static_assert(offsetof(FP2ParachuteActorInfo, OwnerCharacter) == 0x000000, "Member 'FP2ParachuteActorInfo::OwnerCharacter' has a wrong offset!");
static_assert(offsetof(FP2ParachuteActorInfo, BoneName) == 0x000008, "Member 'FP2ParachuteActorInfo::BoneName' has a wrong offset!");

// ScriptStruct Game.P2Remap
// 0x0028 (0x0028 - 0x0000)
struct FP2Remap final
{
public:
	struct FVector2D                              InputRange;                                        // 0x0000(0x0010)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              OutputRange;                                       // 0x0010(0x0010)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bClamp;                                            // 0x0020(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_21[0x7];                                       // 0x0021(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FP2Remap) == 0x000008, "Wrong alignment on FP2Remap");
static_assert(sizeof(FP2Remap) == 0x000028, "Wrong size on FP2Remap");
static_assert(offsetof(FP2Remap, InputRange) == 0x000000, "Member 'FP2Remap::InputRange' has a wrong offset!");
static_assert(offsetof(FP2Remap, OutputRange) == 0x000010, "Member 'FP2Remap::OutputRange' has a wrong offset!");
static_assert(offsetof(FP2Remap, bClamp) == 0x000020, "Member 'FP2Remap::bClamp' has a wrong offset!");

// ScriptStruct Game.P2CustomizationMaterialParameters
// 0x000C (0x000C - 0x0000)
struct FP2CustomizationMaterialParameters final
{
public:
	struct FColor                                 Color;                                             // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Slot;                                              // 0x0004(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FP2CustomizationMaterialParameters) == 0x000004, "Wrong alignment on FP2CustomizationMaterialParameters");
static_assert(sizeof(FP2CustomizationMaterialParameters) == 0x00000C, "Wrong size on FP2CustomizationMaterialParameters");
static_assert(offsetof(FP2CustomizationMaterialParameters, Color) == 0x000000, "Member 'FP2CustomizationMaterialParameters::Color' has a wrong offset!");
static_assert(offsetof(FP2CustomizationMaterialParameters, Slot) == 0x000004, "Member 'FP2CustomizationMaterialParameters::Slot' has a wrong offset!");

// ScriptStruct Game.P2LootSpawnRarityBias
// 0x0008 (0x0008 - 0x0000)
struct FP2LootSpawnRarityBias final
{
public:
	int32                                         Rarity;                                            // 0x0000(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Bias;                                              // 0x0004(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FP2LootSpawnRarityBias) == 0x000004, "Wrong alignment on FP2LootSpawnRarityBias");
static_assert(sizeof(FP2LootSpawnRarityBias) == 0x000008, "Wrong size on FP2LootSpawnRarityBias");
static_assert(offsetof(FP2LootSpawnRarityBias, Rarity) == 0x000000, "Member 'FP2LootSpawnRarityBias::Rarity' has a wrong offset!");
static_assert(offsetof(FP2LootSpawnRarityBias, Bias) == 0x000004, "Member 'FP2LootSpawnRarityBias::Bias' has a wrong offset!");

// ScriptStruct Game.P2LootSpawnPerSessionDifficultySettings
// 0x0010 (0x0010 - 0x0000)
struct FP2LootSpawnPerSessionDifficultySettings final
{
public:
	TArray<struct FP2LootSpawnRarityBias>         RarityBiases;                                      // 0x0000(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FP2LootSpawnPerSessionDifficultySettings) == 0x000008, "Wrong alignment on FP2LootSpawnPerSessionDifficultySettings");
static_assert(sizeof(FP2LootSpawnPerSessionDifficultySettings) == 0x000010, "Wrong size on FP2LootSpawnPerSessionDifficultySettings");
static_assert(offsetof(FP2LootSpawnPerSessionDifficultySettings, RarityBiases) == 0x000000, "Member 'FP2LootSpawnPerSessionDifficultySettings::RarityBiases' has a wrong offset!");

// ScriptStruct Game.P2LootSpawnZonePreset
// 0x0020 (0x0020 - 0x0000)
struct FP2LootSpawnZonePreset final
{
public:
	TArray<struct FP2LootSpawnPerSessionDifficultySettings> PerSessionDifficultySettings;            // 0x0000(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	struct FLinearColor                           Color;                                             // 0x0010(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FP2LootSpawnZonePreset) == 0x000008, "Wrong alignment on FP2LootSpawnZonePreset");
static_assert(sizeof(FP2LootSpawnZonePreset) == 0x000020, "Wrong size on FP2LootSpawnZonePreset");
static_assert(offsetof(FP2LootSpawnZonePreset, PerSessionDifficultySettings) == 0x000000, "Member 'FP2LootSpawnZonePreset::PerSessionDifficultySettings' has a wrong offset!");
static_assert(offsetof(FP2LootSpawnZonePreset, Color) == 0x000010, "Member 'FP2LootSpawnZonePreset::Color' has a wrong offset!");

// ScriptStruct Game.P2LootSpawnAreaSettings
// 0x0068 (0x0068 - 0x0000)
struct FP2LootSpawnAreaSettings final
{
public:
	struct FGameplayTag                           Preset;                                            // 0x0000(0x0008)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Bias;                                              // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           ZonePreset;                                        // 0x000C(0x0008)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FP2LootSpawnZonePreset                 ZonePresetData;                                    // 0x0018(0x0020)(Edit, DisableEditOnTemplate, NativeAccessSpecifierPublic)
	struct FGameplayTag                           ContextPreset;                                     // 0x0038(0x0008)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTagContainer                  ContextTags;                                       // 0x0040(0x0020)(Edit, DisableEditOnTemplate, NativeAccessSpecifierPublic)
	bool                                          bPresetValid;                                      // 0x0060(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bZonePresetValid;                                  // 0x0061(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bContextPresetValid;                               // 0x0062(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_63[0x5];                                       // 0x0063(0x0005)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FP2LootSpawnAreaSettings) == 0x000008, "Wrong alignment on FP2LootSpawnAreaSettings");
static_assert(sizeof(FP2LootSpawnAreaSettings) == 0x000068, "Wrong size on FP2LootSpawnAreaSettings");
static_assert(offsetof(FP2LootSpawnAreaSettings, Preset) == 0x000000, "Member 'FP2LootSpawnAreaSettings::Preset' has a wrong offset!");
static_assert(offsetof(FP2LootSpawnAreaSettings, Bias) == 0x000008, "Member 'FP2LootSpawnAreaSettings::Bias' has a wrong offset!");
static_assert(offsetof(FP2LootSpawnAreaSettings, ZonePreset) == 0x00000C, "Member 'FP2LootSpawnAreaSettings::ZonePreset' has a wrong offset!");
static_assert(offsetof(FP2LootSpawnAreaSettings, ZonePresetData) == 0x000018, "Member 'FP2LootSpawnAreaSettings::ZonePresetData' has a wrong offset!");
static_assert(offsetof(FP2LootSpawnAreaSettings, ContextPreset) == 0x000038, "Member 'FP2LootSpawnAreaSettings::ContextPreset' has a wrong offset!");
static_assert(offsetof(FP2LootSpawnAreaSettings, ContextTags) == 0x000040, "Member 'FP2LootSpawnAreaSettings::ContextTags' has a wrong offset!");
static_assert(offsetof(FP2LootSpawnAreaSettings, bPresetValid) == 0x000060, "Member 'FP2LootSpawnAreaSettings::bPresetValid' has a wrong offset!");
static_assert(offsetof(FP2LootSpawnAreaSettings, bZonePresetValid) == 0x000061, "Member 'FP2LootSpawnAreaSettings::bZonePresetValid' has a wrong offset!");
static_assert(offsetof(FP2LootSpawnAreaSettings, bContextPresetValid) == 0x000062, "Member 'FP2LootSpawnAreaSettings::bContextPresetValid' has a wrong offset!");

// ScriptStruct Game.P2DPVState
// 0x0008 (0x0008 - 0x0000)
struct alignas(0x04) FP2DPVState final
{
public:
	bool                                          bIsActive;                                         // 0x0000(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FP2DPVState) == 0x000004, "Wrong alignment on FP2DPVState");
static_assert(sizeof(FP2DPVState) == 0x000008, "Wrong size on FP2DPVState");
static_assert(offsetof(FP2DPVState, bIsActive) == 0x000000, "Member 'FP2DPVState::bIsActive' has a wrong offset!");

// ScriptStruct Game.P2HitReactionContext
// 0x00F0 (0x00F0 - 0x0000)
struct FP2HitReactionContext final
{
public:
	struct FHitResult                             HitResult;                                         // 0x0000(0x00E8)(Edit, BlueprintVisible, BlueprintReadOnly, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	float                                         Damage;                                            // 0x00E8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_EC[0x4];                                       // 0x00EC(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FP2HitReactionContext) == 0x000008, "Wrong alignment on FP2HitReactionContext");
static_assert(sizeof(FP2HitReactionContext) == 0x0000F0, "Wrong size on FP2HitReactionContext");
static_assert(offsetof(FP2HitReactionContext, HitResult) == 0x000000, "Member 'FP2HitReactionContext::HitResult' has a wrong offset!");
static_assert(offsetof(FP2HitReactionContext, Damage) == 0x0000E8, "Member 'FP2HitReactionContext::Damage' has a wrong offset!");

// ScriptStruct Game.CharacterStateContext
// 0x0020 (0x0020 - 0x0000)
struct alignas(0x08) FCharacterStateContext final
{
public:
	uint8                                         Pad_0[0x20];                                       // 0x0000(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FCharacterStateContext) == 0x000008, "Wrong alignment on FCharacterStateContext");
static_assert(sizeof(FCharacterStateContext) == 0x000020, "Wrong size on FCharacterStateContext");

// ScriptStruct Game.P2CSOData
// 0x000C (0x0018 - 0x000C)
struct FP2CSOData final : public FFastArraySerializerItem
{
public:
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UP2CustomizationObjectData*             CSODataAsset;                                      // 0x0010(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FP2CSOData) == 0x000008, "Wrong alignment on FP2CSOData");
static_assert(sizeof(FP2CSOData) == 0x000018, "Wrong size on FP2CSOData");
static_assert(offsetof(FP2CSOData, CSODataAsset) == 0x000010, "Member 'FP2CSOData::CSODataAsset' has a wrong offset!");

// ScriptStruct Game.P2MeshSplineLOD
// 0x0060 (0x0060 - 0x0000)
struct FP2MeshSplineLOD final
{
public:
	double                                        Distance;                                          // 0x0000(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         StepDistance;                                      // 0x0008(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         StaticMeshLODDistanceBase;                         // 0x000C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         StepDistanceHeight;                                // 0x0010(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TotalDistanceHeight;                               // 0x0014(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMesh*                            StaticMesh;                                        // 0x0018(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FColor                                 DebugColor;                                        // 0x0020(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_24[0x3C];                                      // 0x0024(0x003C)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FP2MeshSplineLOD) == 0x000008, "Wrong alignment on FP2MeshSplineLOD");
static_assert(sizeof(FP2MeshSplineLOD) == 0x000060, "Wrong size on FP2MeshSplineLOD");
static_assert(offsetof(FP2MeshSplineLOD, Distance) == 0x000000, "Member 'FP2MeshSplineLOD::Distance' has a wrong offset!");
static_assert(offsetof(FP2MeshSplineLOD, StepDistance) == 0x000008, "Member 'FP2MeshSplineLOD::StepDistance' has a wrong offset!");
static_assert(offsetof(FP2MeshSplineLOD, StaticMeshLODDistanceBase) == 0x00000C, "Member 'FP2MeshSplineLOD::StaticMeshLODDistanceBase' has a wrong offset!");
static_assert(offsetof(FP2MeshSplineLOD, StepDistanceHeight) == 0x000010, "Member 'FP2MeshSplineLOD::StepDistanceHeight' has a wrong offset!");
static_assert(offsetof(FP2MeshSplineLOD, TotalDistanceHeight) == 0x000014, "Member 'FP2MeshSplineLOD::TotalDistanceHeight' has a wrong offset!");
static_assert(offsetof(FP2MeshSplineLOD, StaticMesh) == 0x000018, "Member 'FP2MeshSplineLOD::StaticMesh' has a wrong offset!");
static_assert(offsetof(FP2MeshSplineLOD, DebugColor) == 0x000020, "Member 'FP2MeshSplineLOD::DebugColor' has a wrong offset!");

// ScriptStruct Game.P2GameplayContextStateInfo
// 0x000C (0x000C - 0x0000)
struct FP2GameplayContextStateInfo final
{
public:
	EP2GameplayContextState                       ContextState;                                      // 0x0000(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EP2GameplayContextState                       PreviousState;                                     // 0x0001(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EP2GameplayContextStateChangedReason          ChangedReason;                                     // 0x0002(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3[0x1];                                        // 0x0003(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         CompletedCount;                                    // 0x0004(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         FailedCount;                                       // 0x0008(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FP2GameplayContextStateInfo) == 0x000004, "Wrong alignment on FP2GameplayContextStateInfo");
static_assert(sizeof(FP2GameplayContextStateInfo) == 0x00000C, "Wrong size on FP2GameplayContextStateInfo");
static_assert(offsetof(FP2GameplayContextStateInfo, ContextState) == 0x000000, "Member 'FP2GameplayContextStateInfo::ContextState' has a wrong offset!");
static_assert(offsetof(FP2GameplayContextStateInfo, PreviousState) == 0x000001, "Member 'FP2GameplayContextStateInfo::PreviousState' has a wrong offset!");
static_assert(offsetof(FP2GameplayContextStateInfo, ChangedReason) == 0x000002, "Member 'FP2GameplayContextStateInfo::ChangedReason' has a wrong offset!");
static_assert(offsetof(FP2GameplayContextStateInfo, CompletedCount) == 0x000004, "Member 'FP2GameplayContextStateInfo::CompletedCount' has a wrong offset!");
static_assert(offsetof(FP2GameplayContextStateInfo, FailedCount) == 0x000008, "Member 'FP2GameplayContextStateInfo::FailedCount' has a wrong offset!");

// ScriptStruct Game.P2ResearchClothingUpgradeDisplayInfo
// 0x0050 (0x0050 - 0x0000)
struct FP2ResearchClothingUpgradeDisplayInfo final
{
public:
	class FText                                   DisplayName;                                       // 0x0000(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, EditConst, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UTexture2D>              DisplayIcon;                                       // 0x0018(0x0030)(Edit, BlueprintVisible, BlueprintReadOnly, EditConst, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         DisplayLevel;                                      // 0x0048(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4C[0x4];                                       // 0x004C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FP2ResearchClothingUpgradeDisplayInfo) == 0x000008, "Wrong alignment on FP2ResearchClothingUpgradeDisplayInfo");
static_assert(sizeof(FP2ResearchClothingUpgradeDisplayInfo) == 0x000050, "Wrong size on FP2ResearchClothingUpgradeDisplayInfo");
static_assert(offsetof(FP2ResearchClothingUpgradeDisplayInfo, DisplayName) == 0x000000, "Member 'FP2ResearchClothingUpgradeDisplayInfo::DisplayName' has a wrong offset!");
static_assert(offsetof(FP2ResearchClothingUpgradeDisplayInfo, DisplayIcon) == 0x000018, "Member 'FP2ResearchClothingUpgradeDisplayInfo::DisplayIcon' has a wrong offset!");
static_assert(offsetof(FP2ResearchClothingUpgradeDisplayInfo, DisplayLevel) == 0x000048, "Member 'FP2ResearchClothingUpgradeDisplayInfo::DisplayLevel' has a wrong offset!");

// ScriptStruct Game.P2OnlineServiceNewsItem
// 0x00A0 (0x00A0 - 0x0000)
struct FP2OnlineServiceNewsItem final
{
public:
	class FString                                 ID;                                                // 0x0000(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Title;                                             // 0x0010(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 URL;                                               // 0x0020(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsExternalURL;                                    // 0x0030(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_31[0x7];                                       // 0x0031(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 Author;                                            // 0x0038(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Contents;                                          // 0x0048(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 FeedLabel;                                         // 0x0058(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 FeedName;                                          // 0x0068(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         FeedType;                                          // 0x0078(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_7C[0x4];                                       // 0x007C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	int64                                         Date;                                              // 0x0080(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FDateTime                              DateTime;                                          // 0x0088(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class FString>                         ImgURLs;                                           // 0x0090(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FP2OnlineServiceNewsItem) == 0x000008, "Wrong alignment on FP2OnlineServiceNewsItem");
static_assert(sizeof(FP2OnlineServiceNewsItem) == 0x0000A0, "Wrong size on FP2OnlineServiceNewsItem");
static_assert(offsetof(FP2OnlineServiceNewsItem, ID) == 0x000000, "Member 'FP2OnlineServiceNewsItem::ID' has a wrong offset!");
static_assert(offsetof(FP2OnlineServiceNewsItem, Title) == 0x000010, "Member 'FP2OnlineServiceNewsItem::Title' has a wrong offset!");
static_assert(offsetof(FP2OnlineServiceNewsItem, URL) == 0x000020, "Member 'FP2OnlineServiceNewsItem::URL' has a wrong offset!");
static_assert(offsetof(FP2OnlineServiceNewsItem, bIsExternalURL) == 0x000030, "Member 'FP2OnlineServiceNewsItem::bIsExternalURL' has a wrong offset!");
static_assert(offsetof(FP2OnlineServiceNewsItem, Author) == 0x000038, "Member 'FP2OnlineServiceNewsItem::Author' has a wrong offset!");
static_assert(offsetof(FP2OnlineServiceNewsItem, Contents) == 0x000048, "Member 'FP2OnlineServiceNewsItem::Contents' has a wrong offset!");
static_assert(offsetof(FP2OnlineServiceNewsItem, FeedLabel) == 0x000058, "Member 'FP2OnlineServiceNewsItem::FeedLabel' has a wrong offset!");
static_assert(offsetof(FP2OnlineServiceNewsItem, FeedName) == 0x000068, "Member 'FP2OnlineServiceNewsItem::FeedName' has a wrong offset!");
static_assert(offsetof(FP2OnlineServiceNewsItem, FeedType) == 0x000078, "Member 'FP2OnlineServiceNewsItem::FeedType' has a wrong offset!");
static_assert(offsetof(FP2OnlineServiceNewsItem, Date) == 0x000080, "Member 'FP2OnlineServiceNewsItem::Date' has a wrong offset!");
static_assert(offsetof(FP2OnlineServiceNewsItem, DateTime) == 0x000088, "Member 'FP2OnlineServiceNewsItem::DateTime' has a wrong offset!");
static_assert(offsetof(FP2OnlineServiceNewsItem, ImgURLs) == 0x000090, "Member 'FP2OnlineServiceNewsItem::ImgURLs' has a wrong offset!");

// ScriptStruct Game.P2ContainerBlockedState
// 0x0002 (0x0002 - 0x0000)
struct FP2ContainerBlockedState final
{
public:
	bool                                          bBlocked;                                          // 0x0000(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bEmptyItemWhenBlocked;                             // 0x0001(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FP2ContainerBlockedState) == 0x000001, "Wrong alignment on FP2ContainerBlockedState");
static_assert(sizeof(FP2ContainerBlockedState) == 0x000002, "Wrong size on FP2ContainerBlockedState");
static_assert(offsetof(FP2ContainerBlockedState, bBlocked) == 0x000000, "Member 'FP2ContainerBlockedState::bBlocked' has a wrong offset!");
static_assert(offsetof(FP2ContainerBlockedState, bEmptyItemWhenBlocked) == 0x000001, "Member 'FP2ContainerBlockedState::bEmptyItemWhenBlocked' has a wrong offset!");

// ScriptStruct Game.HeadTrackingSetup
// 0x00D0 (0x00D0 - 0x0000)
struct FHeadTrackingSetup final
{
public:
	struct FVector                                HeadTrackingLocationScale;                         // 0x0000(0x0018)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                OffsetCS;                                          // 0x0018(0x0018)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                OffsetLocal;                                       // 0x0030(0x0018)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bForceMoveToHead;                                  // 0x0048(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bRotationTrack;                                    // 0x0049(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4A[0x2];                                       // 0x004A(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         RotInterpSpeed;                                    // 0x004C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   TrackBoneName;                                     // 0x0050(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_58[0x8];                                       // 0x0058(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             HeadTrackBoneToCameraOffset;                       // 0x0060(0x0060)(Edit, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         InterpSpeedScale;                                  // 0x00C0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MinStateTimeToActivate;                            // 0x00C4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C8[0x8];                                       // 0x00C8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FHeadTrackingSetup) == 0x000010, "Wrong alignment on FHeadTrackingSetup");
static_assert(sizeof(FHeadTrackingSetup) == 0x0000D0, "Wrong size on FHeadTrackingSetup");
static_assert(offsetof(FHeadTrackingSetup, HeadTrackingLocationScale) == 0x000000, "Member 'FHeadTrackingSetup::HeadTrackingLocationScale' has a wrong offset!");
static_assert(offsetof(FHeadTrackingSetup, OffsetCS) == 0x000018, "Member 'FHeadTrackingSetup::OffsetCS' has a wrong offset!");
static_assert(offsetof(FHeadTrackingSetup, OffsetLocal) == 0x000030, "Member 'FHeadTrackingSetup::OffsetLocal' has a wrong offset!");
static_assert(offsetof(FHeadTrackingSetup, bForceMoveToHead) == 0x000048, "Member 'FHeadTrackingSetup::bForceMoveToHead' has a wrong offset!");
static_assert(offsetof(FHeadTrackingSetup, bRotationTrack) == 0x000049, "Member 'FHeadTrackingSetup::bRotationTrack' has a wrong offset!");
static_assert(offsetof(FHeadTrackingSetup, RotInterpSpeed) == 0x00004C, "Member 'FHeadTrackingSetup::RotInterpSpeed' has a wrong offset!");
static_assert(offsetof(FHeadTrackingSetup, TrackBoneName) == 0x000050, "Member 'FHeadTrackingSetup::TrackBoneName' has a wrong offset!");
static_assert(offsetof(FHeadTrackingSetup, HeadTrackBoneToCameraOffset) == 0x000060, "Member 'FHeadTrackingSetup::HeadTrackBoneToCameraOffset' has a wrong offset!");
static_assert(offsetof(FHeadTrackingSetup, InterpSpeedScale) == 0x0000C0, "Member 'FHeadTrackingSetup::InterpSpeedScale' has a wrong offset!");
static_assert(offsetof(FHeadTrackingSetup, MinStateTimeToActivate) == 0x0000C4, "Member 'FHeadTrackingSetup::MinStateTimeToActivate' has a wrong offset!");

// ScriptStruct Game.CameraHeadTrackConfig
// 0x0078 (0x0078 - 0x0000)
struct FCameraHeadTrackConfig final
{
public:
	class FName                                   BoneName;                                          // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         StaticLocationPull;                                // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         StaticRotationPull;                                // 0x000C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                AxisInterpSpeed;                                   // 0x0010(0x0018)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TMap<struct FGameplayTag, struct FHeadTrackingSetup> TagHeadTrackingMap;                         // 0x0028(0x0050)(Edit, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCameraHeadTrackConfig) == 0x000008, "Wrong alignment on FCameraHeadTrackConfig");
static_assert(sizeof(FCameraHeadTrackConfig) == 0x000078, "Wrong size on FCameraHeadTrackConfig");
static_assert(offsetof(FCameraHeadTrackConfig, BoneName) == 0x000000, "Member 'FCameraHeadTrackConfig::BoneName' has a wrong offset!");
static_assert(offsetof(FCameraHeadTrackConfig, StaticLocationPull) == 0x000008, "Member 'FCameraHeadTrackConfig::StaticLocationPull' has a wrong offset!");
static_assert(offsetof(FCameraHeadTrackConfig, StaticRotationPull) == 0x00000C, "Member 'FCameraHeadTrackConfig::StaticRotationPull' has a wrong offset!");
static_assert(offsetof(FCameraHeadTrackConfig, AxisInterpSpeed) == 0x000010, "Member 'FCameraHeadTrackConfig::AxisInterpSpeed' has a wrong offset!");
static_assert(offsetof(FCameraHeadTrackConfig, TagHeadTrackingMap) == 0x000028, "Member 'FCameraHeadTrackConfig::TagHeadTrackingMap' has a wrong offset!");

// ScriptStruct Game.P2MailCreateParamExtraItemData
// 0x0018 (0x0018 - 0x0000)
struct FP2MailCreateParamExtraItemData final
{
public:
	class FString                                 ItemTagString;                                     // 0x0000(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         StackCount;                                        // 0x0010(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FP2MailCreateParamExtraItemData) == 0x000008, "Wrong alignment on FP2MailCreateParamExtraItemData");
static_assert(sizeof(FP2MailCreateParamExtraItemData) == 0x000018, "Wrong size on FP2MailCreateParamExtraItemData");
static_assert(offsetof(FP2MailCreateParamExtraItemData, ItemTagString) == 0x000000, "Member 'FP2MailCreateParamExtraItemData::ItemTagString' has a wrong offset!");
static_assert(offsetof(FP2MailCreateParamExtraItemData, StackCount) == 0x000010, "Member 'FP2MailCreateParamExtraItemData::StackCount' has a wrong offset!");

// ScriptStruct Game.P2RentalStatusInfo
// 0x001C (0x001C - 0x0000)
struct FP2RentalStatusInfo final
{
public:
	bool                                          bIsRenting;                                        // 0x0000(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsRentingExpired;                                 // 0x0001(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2[0x2];                                        // 0x0002(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTag                           RentingFaction;                                    // 0x0004(0x0008)(BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RentalDuration;                                    // 0x000C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ReputationPenalty;                                 // 0x0010(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   RentalItemsKeyName;                                // 0x0014(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FP2RentalStatusInfo) == 0x000004, "Wrong alignment on FP2RentalStatusInfo");
static_assert(sizeof(FP2RentalStatusInfo) == 0x00001C, "Wrong size on FP2RentalStatusInfo");
static_assert(offsetof(FP2RentalStatusInfo, bIsRenting) == 0x000000, "Member 'FP2RentalStatusInfo::bIsRenting' has a wrong offset!");
static_assert(offsetof(FP2RentalStatusInfo, bIsRentingExpired) == 0x000001, "Member 'FP2RentalStatusInfo::bIsRentingExpired' has a wrong offset!");
static_assert(offsetof(FP2RentalStatusInfo, RentingFaction) == 0x000004, "Member 'FP2RentalStatusInfo::RentingFaction' has a wrong offset!");
static_assert(offsetof(FP2RentalStatusInfo, RentalDuration) == 0x00000C, "Member 'FP2RentalStatusInfo::RentalDuration' has a wrong offset!");
static_assert(offsetof(FP2RentalStatusInfo, ReputationPenalty) == 0x000010, "Member 'FP2RentalStatusInfo::ReputationPenalty' has a wrong offset!");
static_assert(offsetof(FP2RentalStatusInfo, RentalItemsKeyName) == 0x000014, "Member 'FP2RentalStatusInfo::RentalItemsKeyName' has a wrong offset!");

// ScriptStruct Game.P2MeleeTraceConfig
// 0x0070 (0x0070 - 0x0000)
struct FP2MeleeTraceConfig final
{
public:
	struct FTransform                             OffsetTM;                                          // 0x0000(0x0060)(Edit, BlueprintVisible, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECollisionChannel                             TraceChannel;                                      // 0x0060(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_61[0xF];                                       // 0x0061(0x000F)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FP2MeleeTraceConfig) == 0x000010, "Wrong alignment on FP2MeleeTraceConfig");
static_assert(sizeof(FP2MeleeTraceConfig) == 0x000070, "Wrong size on FP2MeleeTraceConfig");
static_assert(offsetof(FP2MeleeTraceConfig, OffsetTM) == 0x000000, "Member 'FP2MeleeTraceConfig::OffsetTM' has a wrong offset!");
static_assert(offsetof(FP2MeleeTraceConfig, TraceChannel) == 0x000060, "Member 'FP2MeleeTraceConfig::TraceChannel' has a wrong offset!");

// ScriptStruct Game.P2ConsumptionModeType
// 0x0010 (0x0018 - 0x0008)
struct FP2ConsumptionModeType final : public FTableRowBase
{
public:
	struct FGameplayTag                           TypeTag;                                           // 0x0008(0x0008)(Edit, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Priority;                                          // 0x0010(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FP2ConsumptionModeType) == 0x000008, "Wrong alignment on FP2ConsumptionModeType");
static_assert(sizeof(FP2ConsumptionModeType) == 0x000018, "Wrong size on FP2ConsumptionModeType");
static_assert(offsetof(FP2ConsumptionModeType, TypeTag) == 0x000008, "Member 'FP2ConsumptionModeType::TypeTag' has a wrong offset!");
static_assert(offsetof(FP2ConsumptionModeType, Priority) == 0x000010, "Member 'FP2ConsumptionModeType::Priority' has a wrong offset!");

// ScriptStruct Game.P2UVValue
// 0x0008 (0x0008 - 0x0000)
struct FP2UVValue final
{
public:
	float                                         R;                                                 // 0x0000(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         G;                                                 // 0x0004(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FP2UVValue) == 0x000004, "Wrong alignment on FP2UVValue");
static_assert(sizeof(FP2UVValue) == 0x000008, "Wrong size on FP2UVValue");
static_assert(offsetof(FP2UVValue, R) == 0x000000, "Member 'FP2UVValue::R' has a wrong offset!");
static_assert(offsetof(FP2UVValue, G) == 0x000004, "Member 'FP2UVValue::G' has a wrong offset!");

// ScriptStruct Game.P2DestructibleVFXHitInfo
// 0x0020 (0x0020 - 0x0000)
struct FP2DestructibleVFXHitInfo final
{
public:
	EP2HitType                                    HitType;                                           // 0x0000(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector_NetQuantize                    ImpactNormalAndDamage;                             // 0x0008(0x0018)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FP2DestructibleVFXHitInfo) == 0x000008, "Wrong alignment on FP2DestructibleVFXHitInfo");
static_assert(sizeof(FP2DestructibleVFXHitInfo) == 0x000020, "Wrong size on FP2DestructibleVFXHitInfo");
static_assert(offsetof(FP2DestructibleVFXHitInfo, HitType) == 0x000000, "Member 'FP2DestructibleVFXHitInfo::HitType' has a wrong offset!");
static_assert(offsetof(FP2DestructibleVFXHitInfo, ImpactNormalAndDamage) == 0x000008, "Member 'FP2DestructibleVFXHitInfo::ImpactNormalAndDamage' has a wrong offset!");

// ScriptStruct Game.P2WeaponObstructionContext
// 0x0008 (0x0008 - 0x0000)
struct FP2WeaponObstructionContext final
{
public:
	EWeaponObstructionType                        Type;                                              // 0x0000(0x0001)(Edit, ZeroConstructor, Transient, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Distance;                                          // 0x0004(0x0004)(Edit, ZeroConstructor, Transient, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FP2WeaponObstructionContext) == 0x000004, "Wrong alignment on FP2WeaponObstructionContext");
static_assert(sizeof(FP2WeaponObstructionContext) == 0x000008, "Wrong size on FP2WeaponObstructionContext");
static_assert(offsetof(FP2WeaponObstructionContext, Type) == 0x000000, "Member 'FP2WeaponObstructionContext::Type' has a wrong offset!");
static_assert(offsetof(FP2WeaponObstructionContext, Distance) == 0x000004, "Member 'FP2WeaponObstructionContext::Distance' has a wrong offset!");

// ScriptStruct Game.P2TargetData_PlaceablePreview
// 0x0018 (0x0020 - 0x0008)
struct FP2TargetData_PlaceablePreview final : public FGameplayAbilityTargetData
{
public:
	class UP2PlaceableData*                       PlaceableData;                                     // 0x0008(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TWeakObjectPtr<class UObject>                 SourceObject;                                      // 0x0010(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_18[0x8];                                       // 0x0018(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FP2TargetData_PlaceablePreview) == 0x000008, "Wrong alignment on FP2TargetData_PlaceablePreview");
static_assert(sizeof(FP2TargetData_PlaceablePreview) == 0x000020, "Wrong size on FP2TargetData_PlaceablePreview");
static_assert(offsetof(FP2TargetData_PlaceablePreview, PlaceableData) == 0x000008, "Member 'FP2TargetData_PlaceablePreview::PlaceableData' has a wrong offset!");
static_assert(offsetof(FP2TargetData_PlaceablePreview, SourceObject) == 0x000010, "Member 'FP2TargetData_PlaceablePreview::SourceObject' has a wrong offset!");

// ScriptStruct Game.AkEventSlotConfig
// 0x0030 (0x0030 - 0x0000)
struct FAkEventSlotConfig final
{
public:
	EP2AkEventLocality                            EventLocality;                                     // 0x0000(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UAkAudioEvent*                          Event;                                             // 0x0008(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAkAudioEvent*                          LocalEvent;                                        // 0x0010(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAkAudioEvent*                          RemoteEvent;                                       // 0x0018(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAkAudioEvent*                          RemoteAlliedEvent;                                 // 0x0020(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAkAudioEvent*                          RemoteEnemyEvent;                                  // 0x0028(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAkEventSlotConfig) == 0x000008, "Wrong alignment on FAkEventSlotConfig");
static_assert(sizeof(FAkEventSlotConfig) == 0x000030, "Wrong size on FAkEventSlotConfig");
static_assert(offsetof(FAkEventSlotConfig, EventLocality) == 0x000000, "Member 'FAkEventSlotConfig::EventLocality' has a wrong offset!");
static_assert(offsetof(FAkEventSlotConfig, Event) == 0x000008, "Member 'FAkEventSlotConfig::Event' has a wrong offset!");
static_assert(offsetof(FAkEventSlotConfig, LocalEvent) == 0x000010, "Member 'FAkEventSlotConfig::LocalEvent' has a wrong offset!");
static_assert(offsetof(FAkEventSlotConfig, RemoteEvent) == 0x000018, "Member 'FAkEventSlotConfig::RemoteEvent' has a wrong offset!");
static_assert(offsetof(FAkEventSlotConfig, RemoteAlliedEvent) == 0x000020, "Member 'FAkEventSlotConfig::RemoteAlliedEvent' has a wrong offset!");
static_assert(offsetof(FAkEventSlotConfig, RemoteEnemyEvent) == 0x000028, "Member 'FAkEventSlotConfig::RemoteEnemyEvent' has a wrong offset!");

// ScriptStruct Game.P2GameplayCueNotify_AkEventVariation
// 0x0080 (0x0080 - 0x0000)
struct FP2GameplayCueNotify_AkEventVariation final
{
public:
	struct FAkEventSlotConfig                     Value;                                             // 0x0000(0x0030)(Edit, BlueprintVisible, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
	TMap<struct FGameplayTag, struct FAkEventSlotConfig> Variations;                                 // 0x0030(0x0050)(Edit, BlueprintVisible, DisableEditOnInstance, NativeAccessSpecifierPublic)
};
static_assert(alignof(FP2GameplayCueNotify_AkEventVariation) == 0x000008, "Wrong alignment on FP2GameplayCueNotify_AkEventVariation");
static_assert(sizeof(FP2GameplayCueNotify_AkEventVariation) == 0x000080, "Wrong size on FP2GameplayCueNotify_AkEventVariation");
static_assert(offsetof(FP2GameplayCueNotify_AkEventVariation, Value) == 0x000000, "Member 'FP2GameplayCueNotify_AkEventVariation::Value' has a wrong offset!");
static_assert(offsetof(FP2GameplayCueNotify_AkEventVariation, Variations) == 0x000030, "Member 'FP2GameplayCueNotify_AkEventVariation::Variations' has a wrong offset!");

// ScriptStruct Game.P2SkinCustomizationData
// 0x0018 (0x0018 - 0x0000)
struct FP2SkinCustomizationData final
{
public:
	class UP2ItemSkinContainer*                   ItemSkinContainer;                                 // 0x0000(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class UP2SkinSlotPreset*>              SkinSlotPresets;                                   // 0x0008(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FP2SkinCustomizationData) == 0x000008, "Wrong alignment on FP2SkinCustomizationData");
static_assert(sizeof(FP2SkinCustomizationData) == 0x000018, "Wrong size on FP2SkinCustomizationData");
static_assert(offsetof(FP2SkinCustomizationData, ItemSkinContainer) == 0x000000, "Member 'FP2SkinCustomizationData::ItemSkinContainer' has a wrong offset!");
static_assert(offsetof(FP2SkinCustomizationData, SkinSlotPresets) == 0x000008, "Member 'FP2SkinCustomizationData::SkinSlotPresets' has a wrong offset!");

// ScriptStruct Game.P2CameraAxisLimit
// 0x0008 (0x0008 - 0x0000)
struct FP2CameraAxisLimit final
{
public:
	float                                         Min;                                               // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Max;                                               // 0x0004(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FP2CameraAxisLimit) == 0x000004, "Wrong alignment on FP2CameraAxisLimit");
static_assert(sizeof(FP2CameraAxisLimit) == 0x000008, "Wrong size on FP2CameraAxisLimit");
static_assert(offsetof(FP2CameraAxisLimit, Min) == 0x000000, "Member 'FP2CameraAxisLimit::Min' has a wrong offset!");
static_assert(offsetof(FP2CameraAxisLimit, Max) == 0x000004, "Member 'FP2CameraAxisLimit::Max' has a wrong offset!");

// ScriptStruct Game.P2CameraViewLimit
// 0x0010 (0x0010 - 0x0000)
struct FP2CameraViewLimit final
{
public:
	struct FP2CameraAxisLimit                     Pitch;                                             // 0x0000(0x0008)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FP2CameraAxisLimit                     Yaw;                                               // 0x0008(0x0008)(Edit, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FP2CameraViewLimit) == 0x000004, "Wrong alignment on FP2CameraViewLimit");
static_assert(sizeof(FP2CameraViewLimit) == 0x000010, "Wrong size on FP2CameraViewLimit");
static_assert(offsetof(FP2CameraViewLimit, Pitch) == 0x000000, "Member 'FP2CameraViewLimit::Pitch' has a wrong offset!");
static_assert(offsetof(FP2CameraViewLimit, Yaw) == 0x000008, "Member 'FP2CameraViewLimit::Yaw' has a wrong offset!");

// ScriptStruct Game.P2CameraLimitConfig
// 0x0020 (0x0020 - 0x0000)
struct FP2CameraLimitConfig final
{
public:
	struct FP2CameraViewLimit                     Soft;                                              // 0x0000(0x0010)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FP2CameraViewLimit                     Hard;                                              // 0x0010(0x0010)(Edit, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FP2CameraLimitConfig) == 0x000004, "Wrong alignment on FP2CameraLimitConfig");
static_assert(sizeof(FP2CameraLimitConfig) == 0x000020, "Wrong size on FP2CameraLimitConfig");
static_assert(offsetof(FP2CameraLimitConfig, Soft) == 0x000000, "Member 'FP2CameraLimitConfig::Soft' has a wrong offset!");
static_assert(offsetof(FP2CameraLimitConfig, Hard) == 0x000010, "Member 'FP2CameraLimitConfig::Hard' has a wrong offset!");

// ScriptStruct Game.P2ExchangeDataRow
// 0x0090 (0x0098 - 0x0008)
struct FP2ExchangeDataRow : public FTableRowBase
{
public:
	TArray<struct FP2ExchangeInfo>                ListItems;                                         // 0x0008(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	struct FGameplayTag                           Tag;                                               // 0x0018(0x0008)(Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FText                                   DisplayText;                                       // 0x0020(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	class FText                                   Description;                                       // 0x0038(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UTexture2D>              DisplayTexture;                                    // 0x0050(0x0030)(Edit, BlueprintVisible, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Price;                                             // 0x0080(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         DefaultAmount;                                     // 0x0084(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FP2ExchangeInfo>                ListExchangeItems;                                 // 0x0088(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FP2ExchangeDataRow) == 0x000008, "Wrong alignment on FP2ExchangeDataRow");
static_assert(sizeof(FP2ExchangeDataRow) == 0x000098, "Wrong size on FP2ExchangeDataRow");
static_assert(offsetof(FP2ExchangeDataRow, ListItems) == 0x000008, "Member 'FP2ExchangeDataRow::ListItems' has a wrong offset!");
static_assert(offsetof(FP2ExchangeDataRow, Tag) == 0x000018, "Member 'FP2ExchangeDataRow::Tag' has a wrong offset!");
static_assert(offsetof(FP2ExchangeDataRow, DisplayText) == 0x000020, "Member 'FP2ExchangeDataRow::DisplayText' has a wrong offset!");
static_assert(offsetof(FP2ExchangeDataRow, Description) == 0x000038, "Member 'FP2ExchangeDataRow::Description' has a wrong offset!");
static_assert(offsetof(FP2ExchangeDataRow, DisplayTexture) == 0x000050, "Member 'FP2ExchangeDataRow::DisplayTexture' has a wrong offset!");
static_assert(offsetof(FP2ExchangeDataRow, Price) == 0x000080, "Member 'FP2ExchangeDataRow::Price' has a wrong offset!");
static_assert(offsetof(FP2ExchangeDataRow, DefaultAmount) == 0x000084, "Member 'FP2ExchangeDataRow::DefaultAmount' has a wrong offset!");
static_assert(offsetof(FP2ExchangeDataRow, ListExchangeItems) == 0x000088, "Member 'FP2ExchangeDataRow::ListExchangeItems' has a wrong offset!");

// ScriptStruct Game.ItemEntry
// 0x0010 (0x0010 - 0x0000)
struct FItemEntry final
{
public:
	class UP2Item*                                Item;                                              // 0x0000(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FPositionInfo                          PositionInfo;                                      // 0x0008(0x0008)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FItemEntry) == 0x000008, "Wrong alignment on FItemEntry");
static_assert(sizeof(FItemEntry) == 0x000010, "Wrong size on FItemEntry");
static_assert(offsetof(FItemEntry, Item) == 0x000000, "Member 'FItemEntry::Item' has a wrong offset!");
static_assert(offsetof(FItemEntry, PositionInfo) == 0x000008, "Member 'FItemEntry::PositionInfo' has a wrong offset!");

// ScriptStruct Game.P2EquipmentMessage
// 0x0008 (0x0008 - 0x0000)
struct FP2EquipmentMessage
{
public:
	class UP2EquipmentManagerComponent*           EquipmentManagerComponent;                         // 0x0000(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FP2EquipmentMessage) == 0x000008, "Wrong alignment on FP2EquipmentMessage");
static_assert(sizeof(FP2EquipmentMessage) == 0x000008, "Wrong size on FP2EquipmentMessage");
static_assert(offsetof(FP2EquipmentMessage, EquipmentManagerComponent) == 0x000000, "Member 'FP2EquipmentMessage::EquipmentManagerComponent' has a wrong offset!");

// ScriptStruct Game.P2ContainerExtraData
// 0x0008 (0x0008 - 0x0000)
struct FP2ContainerExtraData final
{
public:
	struct FIntPoint                              Size;                                              // 0x0000(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FP2ContainerExtraData) == 0x000004, "Wrong alignment on FP2ContainerExtraData");
static_assert(sizeof(FP2ContainerExtraData) == 0x000008, "Wrong size on FP2ContainerExtraData");
static_assert(offsetof(FP2ContainerExtraData, Size) == 0x000000, "Member 'FP2ContainerExtraData::Size' has a wrong offset!");

// ScriptStruct Game.P2DamageCalculationContext
// 0x00C0 (0x00C0 - 0x0000)
struct FP2DamageCalculationContext final
{
public:
	TMap<struct FGameplayTag, float>              DamageParameters;                                  // 0x0000(0x0050)(BlueprintVisible, NativeAccessSpecifierPublic)
	class UObject*                                SourceObject;                                      // 0x0050(0x0008)(BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 Instigator;                                        // 0x0058(0x0008)(BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 Victim;                                            // 0x0060(0x0008)(BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTagContainer                  RelevantSourceTags;                                // 0x0068(0x0020)(BlueprintVisible, NativeAccessSpecifierPublic)
	struct FGameplayTagContainer                  RelevantTargetTags;                                // 0x0088(0x0020)(BlueprintVisible, NativeAccessSpecifierPublic)
	class UP2GameplayEffect_Damage*               GameplayEffect;                                    // 0x00A8(0x0008)(BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAllowStatusEffects;                               // 0x00B0(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_B1[0xF];                                       // 0x00B1(0x000F)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FP2DamageCalculationContext) == 0x000008, "Wrong alignment on FP2DamageCalculationContext");
static_assert(sizeof(FP2DamageCalculationContext) == 0x0000C0, "Wrong size on FP2DamageCalculationContext");
static_assert(offsetof(FP2DamageCalculationContext, DamageParameters) == 0x000000, "Member 'FP2DamageCalculationContext::DamageParameters' has a wrong offset!");
static_assert(offsetof(FP2DamageCalculationContext, SourceObject) == 0x000050, "Member 'FP2DamageCalculationContext::SourceObject' has a wrong offset!");
static_assert(offsetof(FP2DamageCalculationContext, Instigator) == 0x000058, "Member 'FP2DamageCalculationContext::Instigator' has a wrong offset!");
static_assert(offsetof(FP2DamageCalculationContext, Victim) == 0x000060, "Member 'FP2DamageCalculationContext::Victim' has a wrong offset!");
static_assert(offsetof(FP2DamageCalculationContext, RelevantSourceTags) == 0x000068, "Member 'FP2DamageCalculationContext::RelevantSourceTags' has a wrong offset!");
static_assert(offsetof(FP2DamageCalculationContext, RelevantTargetTags) == 0x000088, "Member 'FP2DamageCalculationContext::RelevantTargetTags' has a wrong offset!");
static_assert(offsetof(FP2DamageCalculationContext, GameplayEffect) == 0x0000A8, "Member 'FP2DamageCalculationContext::GameplayEffect' has a wrong offset!");
static_assert(offsetof(FP2DamageCalculationContext, bAllowStatusEffects) == 0x0000B0, "Member 'FP2DamageCalculationContext::bAllowStatusEffects' has a wrong offset!");

// ScriptStruct Game.P2Firemode
// 0x0040 (0x0040 - 0x0000)
struct alignas(0x04) FP2Firemode final
{
public:
	uint8                                         Pad_0[0x40];                                       // 0x0000(0x0040)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FP2Firemode) == 0x000004, "Wrong alignment on FP2Firemode");
static_assert(sizeof(FP2Firemode) == 0x000040, "Wrong size on FP2Firemode");

// ScriptStruct Game.P2KeybindContextState
// 0x0010 (0x0010 - 0x0000)
struct FP2KeybindContextState final
{
public:
	class UInputMappingContext*                   InputMappingContext;                               // 0x0000(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         InputPriority;                                     // 0x0008(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsChangedBind;                                     // 0x000C(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D[0x3];                                        // 0x000D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FP2KeybindContextState) == 0x000008, "Wrong alignment on FP2KeybindContextState");
static_assert(sizeof(FP2KeybindContextState) == 0x000010, "Wrong size on FP2KeybindContextState");
static_assert(offsetof(FP2KeybindContextState, InputMappingContext) == 0x000000, "Member 'FP2KeybindContextState::InputMappingContext' has a wrong offset!");
static_assert(offsetof(FP2KeybindContextState, InputPriority) == 0x000008, "Member 'FP2KeybindContextState::InputPriority' has a wrong offset!");
static_assert(offsetof(FP2KeybindContextState, IsChangedBind) == 0x00000C, "Member 'FP2KeybindContextState::IsChangedBind' has a wrong offset!");

// ScriptStruct Game.P2AttributeMetaData
// 0x0018 (0x0020 - 0x0008)
struct FP2AttributeMetaData final : public FTableRowBase
{
public:
	float                                         DefaultValue;                                      // 0x0008(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BaseValueMin;                                      // 0x000C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BaseValueMax;                                      // 0x0010(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CurrentValueMin;                                   // 0x0014(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CurrentValueMax;                                   // 0x0018(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bClampMinBaseValue;                                // 0x001C(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bClampMaxBaseValue;                                // 0x001D(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bClampMinCurrentValue;                             // 0x001E(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bClampMaxCurrentValue;                             // 0x001F(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FP2AttributeMetaData) == 0x000008, "Wrong alignment on FP2AttributeMetaData");
static_assert(sizeof(FP2AttributeMetaData) == 0x000020, "Wrong size on FP2AttributeMetaData");
static_assert(offsetof(FP2AttributeMetaData, DefaultValue) == 0x000008, "Member 'FP2AttributeMetaData::DefaultValue' has a wrong offset!");
static_assert(offsetof(FP2AttributeMetaData, BaseValueMin) == 0x00000C, "Member 'FP2AttributeMetaData::BaseValueMin' has a wrong offset!");
static_assert(offsetof(FP2AttributeMetaData, BaseValueMax) == 0x000010, "Member 'FP2AttributeMetaData::BaseValueMax' has a wrong offset!");
static_assert(offsetof(FP2AttributeMetaData, CurrentValueMin) == 0x000014, "Member 'FP2AttributeMetaData::CurrentValueMin' has a wrong offset!");
static_assert(offsetof(FP2AttributeMetaData, CurrentValueMax) == 0x000018, "Member 'FP2AttributeMetaData::CurrentValueMax' has a wrong offset!");
static_assert(offsetof(FP2AttributeMetaData, bClampMinBaseValue) == 0x00001C, "Member 'FP2AttributeMetaData::bClampMinBaseValue' has a wrong offset!");
static_assert(offsetof(FP2AttributeMetaData, bClampMaxBaseValue) == 0x00001D, "Member 'FP2AttributeMetaData::bClampMaxBaseValue' has a wrong offset!");
static_assert(offsetof(FP2AttributeMetaData, bClampMinCurrentValue) == 0x00001E, "Member 'FP2AttributeMetaData::bClampMinCurrentValue' has a wrong offset!");
static_assert(offsetof(FP2AttributeMetaData, bClampMaxCurrentValue) == 0x00001F, "Member 'FP2AttributeMetaData::bClampMaxCurrentValue' has a wrong offset!");

// ScriptStruct Game.P2CustomizationItemDataWithSkin
// 0x0020 (0x0020 - 0x0000)
struct FP2CustomizationItemDataWithSkin final
{
public:
	class UP2WearableData*                        WearableData;                                      // 0x0000(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FP2SkinCustomizationData               SkinDataOverride;                                  // 0x0008(0x0018)(NativeAccessSpecifierPublic)
};
static_assert(alignof(FP2CustomizationItemDataWithSkin) == 0x000008, "Wrong alignment on FP2CustomizationItemDataWithSkin");
static_assert(sizeof(FP2CustomizationItemDataWithSkin) == 0x000020, "Wrong size on FP2CustomizationItemDataWithSkin");
static_assert(offsetof(FP2CustomizationItemDataWithSkin, WearableData) == 0x000000, "Member 'FP2CustomizationItemDataWithSkin::WearableData' has a wrong offset!");
static_assert(offsetof(FP2CustomizationItemDataWithSkin, SkinDataOverride) == 0x000008, "Member 'FP2CustomizationItemDataWithSkin::SkinDataOverride' has a wrong offset!");

// ScriptStruct Game.P2ContractDataFinder
// 0x0008 (0x0010 - 0x0008)
struct FP2ContractDataFinder final : public FTableRowBase
{
public:
	class UP2ContractData*                        ContractData;                                      // 0x0008(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FP2ContractDataFinder) == 0x000008, "Wrong alignment on FP2ContractDataFinder");
static_assert(sizeof(FP2ContractDataFinder) == 0x000010, "Wrong size on FP2ContractDataFinder");
static_assert(offsetof(FP2ContractDataFinder, ContractData) == 0x000008, "Member 'FP2ContractDataFinder::ContractData' has a wrong offset!");

// ScriptStruct Game.AnimSpringModifierVars
// 0x0040 (0x0040 - 0x0000)
struct alignas(0x08) FAnimSpringModifierVars final
{
public:
	uint8                                         Pad_0[0x40];                                       // 0x0000(0x0040)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FAnimSpringModifierVars) == 0x000008, "Wrong alignment on FAnimSpringModifierVars");
static_assert(sizeof(FAnimSpringModifierVars) == 0x000040, "Wrong size on FAnimSpringModifierVars");

// ScriptStruct Game.P2OptionSubGroup
// 0x0028 (0x0028 - 0x0000)
struct FP2OptionSubGroup final
{
public:
	class FText                                   OptionSubGroupName;                                // 0x0000(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TArray<class UP2GameOptionItemFunction*>      OptionFunctions;                                   // 0x0018(0x0010)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, ContainsInstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(FP2OptionSubGroup) == 0x000008, "Wrong alignment on FP2OptionSubGroup");
static_assert(sizeof(FP2OptionSubGroup) == 0x000028, "Wrong size on FP2OptionSubGroup");
static_assert(offsetof(FP2OptionSubGroup, OptionSubGroupName) == 0x000000, "Member 'FP2OptionSubGroup::OptionSubGroupName' has a wrong offset!");
static_assert(offsetof(FP2OptionSubGroup, OptionFunctions) == 0x000018, "Member 'FP2OptionSubGroup::OptionFunctions' has a wrong offset!");

// ScriptStruct Game.P2FiremodeData
// 0x0030 (0x0030 - 0x0000)
struct FP2FiremodeData final
{
public:
	EP2Firemode                                   Type;                                              // 0x0000(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ShotDelay;                                         // 0x0004(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TriggerDelay;                                      // 0x0008(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PointOfNoReturnThreshold;                          // 0x000C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         OverchargeDelay;                                   // 0x0010(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCancelShotDelayOnTriggerRelease;                  // 0x0014(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAutoShootAfterTriggerDelay;                       // 0x0015(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bChargeEveryShot;                                  // 0x0016(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bSkipCooldown;                                     // 0x0017(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAutoShootAfterOvercharge;                         // 0x0018(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19[0x3];                                       // 0x0019(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         RateOfFire;                                        // 0x001C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ShotsInBurst;                                      // 0x0020(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCancelBurstOnTriggerRelease;                      // 0x0024(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_25[0x3];                                       // 0x0025(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Cooldown;                                          // 0x0028(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         OverchargeCooldown;                                // 0x002C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FP2FiremodeData) == 0x000004, "Wrong alignment on FP2FiremodeData");
static_assert(sizeof(FP2FiremodeData) == 0x000030, "Wrong size on FP2FiremodeData");
static_assert(offsetof(FP2FiremodeData, Type) == 0x000000, "Member 'FP2FiremodeData::Type' has a wrong offset!");
static_assert(offsetof(FP2FiremodeData, ShotDelay) == 0x000004, "Member 'FP2FiremodeData::ShotDelay' has a wrong offset!");
static_assert(offsetof(FP2FiremodeData, TriggerDelay) == 0x000008, "Member 'FP2FiremodeData::TriggerDelay' has a wrong offset!");
static_assert(offsetof(FP2FiremodeData, PointOfNoReturnThreshold) == 0x00000C, "Member 'FP2FiremodeData::PointOfNoReturnThreshold' has a wrong offset!");
static_assert(offsetof(FP2FiremodeData, OverchargeDelay) == 0x000010, "Member 'FP2FiremodeData::OverchargeDelay' has a wrong offset!");
static_assert(offsetof(FP2FiremodeData, bCancelShotDelayOnTriggerRelease) == 0x000014, "Member 'FP2FiremodeData::bCancelShotDelayOnTriggerRelease' has a wrong offset!");
static_assert(offsetof(FP2FiremodeData, bAutoShootAfterTriggerDelay) == 0x000015, "Member 'FP2FiremodeData::bAutoShootAfterTriggerDelay' has a wrong offset!");
static_assert(offsetof(FP2FiremodeData, bChargeEveryShot) == 0x000016, "Member 'FP2FiremodeData::bChargeEveryShot' has a wrong offset!");
static_assert(offsetof(FP2FiremodeData, bSkipCooldown) == 0x000017, "Member 'FP2FiremodeData::bSkipCooldown' has a wrong offset!");
static_assert(offsetof(FP2FiremodeData, bAutoShootAfterOvercharge) == 0x000018, "Member 'FP2FiremodeData::bAutoShootAfterOvercharge' has a wrong offset!");
static_assert(offsetof(FP2FiremodeData, RateOfFire) == 0x00001C, "Member 'FP2FiremodeData::RateOfFire' has a wrong offset!");
static_assert(offsetof(FP2FiremodeData, ShotsInBurst) == 0x000020, "Member 'FP2FiremodeData::ShotsInBurst' has a wrong offset!");
static_assert(offsetof(FP2FiremodeData, bCancelBurstOnTriggerRelease) == 0x000024, "Member 'FP2FiremodeData::bCancelBurstOnTriggerRelease' has a wrong offset!");
static_assert(offsetof(FP2FiremodeData, Cooldown) == 0x000028, "Member 'FP2FiremodeData::Cooldown' has a wrong offset!");
static_assert(offsetof(FP2FiremodeData, OverchargeCooldown) == 0x00002C, "Member 'FP2FiremodeData::OverchargeCooldown' has a wrong offset!");

// ScriptStruct Game.P2FireSurfacePointData
// 0x0038 (0x0038 - 0x0000)
struct alignas(0x08) FP2FireSurfacePointData final
{
public:
	uint8                                         Pad_0[0x38];                                       // 0x0000(0x0038)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FP2FireSurfacePointData) == 0x000008, "Wrong alignment on FP2FireSurfacePointData");
static_assert(sizeof(FP2FireSurfacePointData) == 0x000038, "Wrong size on FP2FireSurfacePointData");

// ScriptStruct Game.P2RadioButtonParams
// 0x00B8 (0x00B8 - 0x0000)
struct FP2RadioButtonParams
{
public:
	TSubclassOf<class UP2RadioButton>             RadioButtonClass;                                  // 0x0000(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FText                                   DisplayText;                                       // 0x0008(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FGameplayTag                           Tag;                                               // 0x0020(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UTexture2D>              DisplayTexture;                                    // 0x0028(0x0030)(Edit, BlueprintVisible, BlueprintReadOnly, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 UniqueButtonID;                                    // 0x0058(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TMap<EP2ButtonActionAudioType, struct FP2SoundInfo> OvrrideButtonActionAudioMap;                 // 0x0068(0x0050)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
};
static_assert(alignof(FP2RadioButtonParams) == 0x000008, "Wrong alignment on FP2RadioButtonParams");
static_assert(sizeof(FP2RadioButtonParams) == 0x0000B8, "Wrong size on FP2RadioButtonParams");
static_assert(offsetof(FP2RadioButtonParams, RadioButtonClass) == 0x000000, "Member 'FP2RadioButtonParams::RadioButtonClass' has a wrong offset!");
static_assert(offsetof(FP2RadioButtonParams, DisplayText) == 0x000008, "Member 'FP2RadioButtonParams::DisplayText' has a wrong offset!");
static_assert(offsetof(FP2RadioButtonParams, Tag) == 0x000020, "Member 'FP2RadioButtonParams::Tag' has a wrong offset!");
static_assert(offsetof(FP2RadioButtonParams, DisplayTexture) == 0x000028, "Member 'FP2RadioButtonParams::DisplayTexture' has a wrong offset!");
static_assert(offsetof(FP2RadioButtonParams, UniqueButtonID) == 0x000058, "Member 'FP2RadioButtonParams::UniqueButtonID' has a wrong offset!");
static_assert(offsetof(FP2RadioButtonParams, OvrrideButtonActionAudioMap) == 0x000068, "Member 'FP2RadioButtonParams::OvrrideButtonActionAudioMap' has a wrong offset!");

// ScriptStruct Game.P2ContextualHelperMessage
// 0x0058 (0x0058 - 0x0000)
struct FP2ContextualHelperMessage final
{
public:
	uint8                                         Pad_0[0x8];                                        // 0x0000(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	EP2GameplayContextMessageType                 MessageType;                                       // 0x0008(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   Title;                                             // 0x0010(0x0018)(NativeAccessSpecifierPublic)
	EP2ContextualHelperWidgetIconType             IconType;                                          // 0x0028(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_29[0x7];                                       // 0x0029(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   Text;                                              // 0x0030(0x0018)(NativeAccessSpecifierPublic)
	float                                         Duration;                                          // 0x0048(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4C[0x4];                                       // 0x004C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UP2ItemData*                            IconItemData;                                      // 0x0050(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FP2ContextualHelperMessage) == 0x000008, "Wrong alignment on FP2ContextualHelperMessage");
static_assert(sizeof(FP2ContextualHelperMessage) == 0x000058, "Wrong size on FP2ContextualHelperMessage");
static_assert(offsetof(FP2ContextualHelperMessage, MessageType) == 0x000008, "Member 'FP2ContextualHelperMessage::MessageType' has a wrong offset!");
static_assert(offsetof(FP2ContextualHelperMessage, Title) == 0x000010, "Member 'FP2ContextualHelperMessage::Title' has a wrong offset!");
static_assert(offsetof(FP2ContextualHelperMessage, IconType) == 0x000028, "Member 'FP2ContextualHelperMessage::IconType' has a wrong offset!");
static_assert(offsetof(FP2ContextualHelperMessage, Text) == 0x000030, "Member 'FP2ContextualHelperMessage::Text' has a wrong offset!");
static_assert(offsetof(FP2ContextualHelperMessage, Duration) == 0x000048, "Member 'FP2ContextualHelperMessage::Duration' has a wrong offset!");
static_assert(offsetof(FP2ContextualHelperMessage, IconItemData) == 0x000050, "Member 'FP2ContextualHelperMessage::IconItemData' has a wrong offset!");

// ScriptStruct Game.P2CSOFastArray
// 0x0018 (0x0120 - 0x0108)
struct FP2CSOFastArray final : public FFastArraySerializer
{
public:
	uint8                                         Pad_108[0x8];                                      // 0x0108(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FP2CSOData>                     Items;                                             // 0x0110(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
};
static_assert(alignof(FP2CSOFastArray) == 0x000008, "Wrong alignment on FP2CSOFastArray");
static_assert(sizeof(FP2CSOFastArray) == 0x000120, "Wrong size on FP2CSOFastArray");
static_assert(offsetof(FP2CSOFastArray, Items) == 0x000110, "Member 'FP2CSOFastArray::Items' has a wrong offset!");

// ScriptStruct Game.ComponentRoleConfig
// 0x0003 (0x0003 - 0x0000)
struct FComponentRoleConfig final
{
public:
	bool                                          bCreateOnServer;                                   // 0x0000(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCreateOnLocal;                                    // 0x0001(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCreateOnRemote;                                   // 0x0002(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FComponentRoleConfig) == 0x000001, "Wrong alignment on FComponentRoleConfig");
static_assert(sizeof(FComponentRoleConfig) == 0x000003, "Wrong size on FComponentRoleConfig");
static_assert(offsetof(FComponentRoleConfig, bCreateOnServer) == 0x000000, "Member 'FComponentRoleConfig::bCreateOnServer' has a wrong offset!");
static_assert(offsetof(FComponentRoleConfig, bCreateOnLocal) == 0x000001, "Member 'FComponentRoleConfig::bCreateOnLocal' has a wrong offset!");
static_assert(offsetof(FComponentRoleConfig, bCreateOnRemote) == 0x000002, "Member 'FComponentRoleConfig::bCreateOnRemote' has a wrong offset!");

// ScriptStruct Game.P2SkillUpgradeCompleted
// 0x0028 (0x0028 - 0x0000)
struct FP2SkillUpgradeCompleted final
{
public:
	class FName                                   EventTitle;                                        // 0x0000(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UObject*                                Instigator;                                        // 0x0008(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           SkillTag;                                          // 0x0010(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Level;                                             // 0x0018(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         PreviousLevel;                                     // 0x001C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FDateTime                              LevelUpTime;                                       // 0x0020(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FP2SkillUpgradeCompleted) == 0x000008, "Wrong alignment on FP2SkillUpgradeCompleted");
static_assert(sizeof(FP2SkillUpgradeCompleted) == 0x000028, "Wrong size on FP2SkillUpgradeCompleted");
static_assert(offsetof(FP2SkillUpgradeCompleted, EventTitle) == 0x000000, "Member 'FP2SkillUpgradeCompleted::EventTitle' has a wrong offset!");
static_assert(offsetof(FP2SkillUpgradeCompleted, Instigator) == 0x000008, "Member 'FP2SkillUpgradeCompleted::Instigator' has a wrong offset!");
static_assert(offsetof(FP2SkillUpgradeCompleted, SkillTag) == 0x000010, "Member 'FP2SkillUpgradeCompleted::SkillTag' has a wrong offset!");
static_assert(offsetof(FP2SkillUpgradeCompleted, Level) == 0x000018, "Member 'FP2SkillUpgradeCompleted::Level' has a wrong offset!");
static_assert(offsetof(FP2SkillUpgradeCompleted, PreviousLevel) == 0x00001C, "Member 'FP2SkillUpgradeCompleted::PreviousLevel' has a wrong offset!");
static_assert(offsetof(FP2SkillUpgradeCompleted, LevelUpTime) == 0x000020, "Member 'FP2SkillUpgradeCompleted::LevelUpTime' has a wrong offset!");

// ScriptStruct Game.MapMarkerItem
// 0x0044 (0x0050 - 0x000C)
struct FMapMarkerItem final : public FFastArraySerializerItem
{
public:
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class UP2MapMarkerComponent>      MarkerComponent;                                   // 0x0010(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Location;                                          // 0x0018(0x0018)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CreationTime;                                      // 0x0030(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_34[0x4];                                       // 0x0034(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class AActor*                                 MarkerActor;                                       // 0x0038(0x0008)(ZeroConstructor, RepSkip, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 Instigator;                                        // 0x0040(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EP2MarkerType                                 MarkerType;                                        // 0x0048(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_49[0x3];                                       // 0x0049(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         SquadIndex;                                        // 0x004C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMapMarkerItem) == 0x000008, "Wrong alignment on FMapMarkerItem");
static_assert(sizeof(FMapMarkerItem) == 0x000050, "Wrong size on FMapMarkerItem");
static_assert(offsetof(FMapMarkerItem, MarkerComponent) == 0x000010, "Member 'FMapMarkerItem::MarkerComponent' has a wrong offset!");
static_assert(offsetof(FMapMarkerItem, Location) == 0x000018, "Member 'FMapMarkerItem::Location' has a wrong offset!");
static_assert(offsetof(FMapMarkerItem, CreationTime) == 0x000030, "Member 'FMapMarkerItem::CreationTime' has a wrong offset!");
static_assert(offsetof(FMapMarkerItem, MarkerActor) == 0x000038, "Member 'FMapMarkerItem::MarkerActor' has a wrong offset!");
static_assert(offsetof(FMapMarkerItem, Instigator) == 0x000040, "Member 'FMapMarkerItem::Instigator' has a wrong offset!");
static_assert(offsetof(FMapMarkerItem, MarkerType) == 0x000048, "Member 'FMapMarkerItem::MarkerType' has a wrong offset!");
static_assert(offsetof(FMapMarkerItem, SquadIndex) == 0x00004C, "Member 'FMapMarkerItem::SquadIndex' has a wrong offset!");

// ScriptStruct Game.P2InputPenalty
// 0x001C (0x001C - 0x0000)
struct FP2InputPenalty final
{
public:
	struct FGameplayTag                           StatusTag;                                         // 0x0000(0x0008)(Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         StartTime;                                         // 0x0008(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Duration;                                          // 0x000C(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bRemoved;                                          // 0x0010(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x3];                                       // 0x0011(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MovementRemovedAtValue;                            // 0x0014(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LookRemovedAtValue;                                // 0x0018(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FP2InputPenalty) == 0x000004, "Wrong alignment on FP2InputPenalty");
static_assert(sizeof(FP2InputPenalty) == 0x00001C, "Wrong size on FP2InputPenalty");
static_assert(offsetof(FP2InputPenalty, StatusTag) == 0x000000, "Member 'FP2InputPenalty::StatusTag' has a wrong offset!");
static_assert(offsetof(FP2InputPenalty, StartTime) == 0x000008, "Member 'FP2InputPenalty::StartTime' has a wrong offset!");
static_assert(offsetof(FP2InputPenalty, Duration) == 0x00000C, "Member 'FP2InputPenalty::Duration' has a wrong offset!");
static_assert(offsetof(FP2InputPenalty, bRemoved) == 0x000010, "Member 'FP2InputPenalty::bRemoved' has a wrong offset!");
static_assert(offsetof(FP2InputPenalty, MovementRemovedAtValue) == 0x000014, "Member 'FP2InputPenalty::MovementRemovedAtValue' has a wrong offset!");
static_assert(offsetof(FP2InputPenalty, LookRemovedAtValue) == 0x000018, "Member 'FP2InputPenalty::LookRemovedAtValue' has a wrong offset!");

// ScriptStruct Game.AnimSpringBlendConfig
// 0x0010 (0x0010 - 0x0000)
struct FAnimSpringBlendConfig final
{
public:
	float                                         BlendTime;                                         // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EAlphaBlendOption                             BlendProfile;                                      // 0x0004(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5[0x3];                                        // 0x0005(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class UCurveFloat*                            BlendCurve;                                        // 0x0008(0x0008)(Edit, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAnimSpringBlendConfig) == 0x000008, "Wrong alignment on FAnimSpringBlendConfig");
static_assert(sizeof(FAnimSpringBlendConfig) == 0x000010, "Wrong size on FAnimSpringBlendConfig");
static_assert(offsetof(FAnimSpringBlendConfig, BlendTime) == 0x000000, "Member 'FAnimSpringBlendConfig::BlendTime' has a wrong offset!");
static_assert(offsetof(FAnimSpringBlendConfig, BlendProfile) == 0x000004, "Member 'FAnimSpringBlendConfig::BlendProfile' has a wrong offset!");
static_assert(offsetof(FAnimSpringBlendConfig, BlendCurve) == 0x000008, "Member 'FAnimSpringBlendConfig::BlendCurve' has a wrong offset!");

// ScriptStruct Game.P2DestructibleMaterialSwapInfo
// 0x0008 (0x0008 - 0x0000)
struct FP2DestructibleMaterialSwapInfo final
{
public:
	class UMaterialInterface*                     Material;                                          // 0x0000(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FP2DestructibleMaterialSwapInfo) == 0x000008, "Wrong alignment on FP2DestructibleMaterialSwapInfo");
static_assert(sizeof(FP2DestructibleMaterialSwapInfo) == 0x000008, "Wrong size on FP2DestructibleMaterialSwapInfo");
static_assert(offsetof(FP2DestructibleMaterialSwapInfo, Material) == 0x000000, "Member 'FP2DestructibleMaterialSwapInfo::Material' has a wrong offset!");

// ScriptStruct Game.P2DestructibleEffectInfo
// 0x0070 (0x0070 - 0x0000)
struct FP2DestructibleEffectInfo final
{
public:
	class UNiagaraSystem*                         Effect;                                            // 0x0000(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           SoundGameplayCue;                                  // 0x0008(0x0008)(Edit, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FTransform                             RelativeTransform;                                 // 0x0010(0x0060)(Edit, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FP2DestructibleEffectInfo) == 0x000010, "Wrong alignment on FP2DestructibleEffectInfo");
static_assert(sizeof(FP2DestructibleEffectInfo) == 0x000070, "Wrong size on FP2DestructibleEffectInfo");
static_assert(offsetof(FP2DestructibleEffectInfo, Effect) == 0x000000, "Member 'FP2DestructibleEffectInfo::Effect' has a wrong offset!");
static_assert(offsetof(FP2DestructibleEffectInfo, SoundGameplayCue) == 0x000008, "Member 'FP2DestructibleEffectInfo::SoundGameplayCue' has a wrong offset!");
static_assert(offsetof(FP2DestructibleEffectInfo, RelativeTransform) == 0x000010, "Member 'FP2DestructibleEffectInfo::RelativeTransform' has a wrong offset!");

// ScriptStruct Game.P2DestructibleStateParameters
// 0x0070 (0x0070 - 0x0000)
struct FP2DestructibleStateParameters final
{
public:
	class UStaticMesh*                            OverrideMesh;                                      // 0x0000(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TMap<int32, struct FP2DestructibleMaterialSwapInfo> MaterialsSwap;                               // 0x0008(0x0050)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	bool                                          bOverrideCollision;                                // 0x0058(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECollisionEnabled                             OverrideCollision;                                 // 0x0059(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5A[0x6];                                       // 0x005A(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FP2DestructibleEffectInfo>      EffectsToSpawn;                                    // 0x0060(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
};
static_assert(alignof(FP2DestructibleStateParameters) == 0x000008, "Wrong alignment on FP2DestructibleStateParameters");
static_assert(sizeof(FP2DestructibleStateParameters) == 0x000070, "Wrong size on FP2DestructibleStateParameters");
static_assert(offsetof(FP2DestructibleStateParameters, OverrideMesh) == 0x000000, "Member 'FP2DestructibleStateParameters::OverrideMesh' has a wrong offset!");
static_assert(offsetof(FP2DestructibleStateParameters, MaterialsSwap) == 0x000008, "Member 'FP2DestructibleStateParameters::MaterialsSwap' has a wrong offset!");
static_assert(offsetof(FP2DestructibleStateParameters, bOverrideCollision) == 0x000058, "Member 'FP2DestructibleStateParameters::bOverrideCollision' has a wrong offset!");
static_assert(offsetof(FP2DestructibleStateParameters, OverrideCollision) == 0x000059, "Member 'FP2DestructibleStateParameters::OverrideCollision' has a wrong offset!");
static_assert(offsetof(FP2DestructibleStateParameters, EffectsToSpawn) == 0x000060, "Member 'FP2DestructibleStateParameters::EffectsToSpawn' has a wrong offset!");

// ScriptStruct Game.P2MeshDestructibleData
// 0x0110 (0x0110 - 0x0000)
struct FP2MeshDestructibleData final
{
public:
	float                                         Health;                                            // 0x0000(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTagContainer                  DamageImmuneTags;                                  // 0x0008(0x0020)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	EP2DestructibleState                          State;                                             // 0x0028(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_29[0x7];                                       // 0x0029(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FP2DestructibleStateParameters         DamagedStateParameters;                            // 0x0030(0x0070)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FP2DestructibleStateParameters         DestroyedStateParameters;                          // 0x00A0(0x0070)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
};
static_assert(alignof(FP2MeshDestructibleData) == 0x000008, "Wrong alignment on FP2MeshDestructibleData");
static_assert(sizeof(FP2MeshDestructibleData) == 0x000110, "Wrong size on FP2MeshDestructibleData");
static_assert(offsetof(FP2MeshDestructibleData, Health) == 0x000000, "Member 'FP2MeshDestructibleData::Health' has a wrong offset!");
static_assert(offsetof(FP2MeshDestructibleData, DamageImmuneTags) == 0x000008, "Member 'FP2MeshDestructibleData::DamageImmuneTags' has a wrong offset!");
static_assert(offsetof(FP2MeshDestructibleData, State) == 0x000028, "Member 'FP2MeshDestructibleData::State' has a wrong offset!");
static_assert(offsetof(FP2MeshDestructibleData, DamagedStateParameters) == 0x000030, "Member 'FP2MeshDestructibleData::DamagedStateParameters' has a wrong offset!");
static_assert(offsetof(FP2MeshDestructibleData, DestroyedStateParameters) == 0x0000A0, "Member 'FP2MeshDestructibleData::DestroyedStateParameters' has a wrong offset!");

// ScriptStruct Game.P2ContainerItemEntries
// 0x0018 (0x0018 - 0x0000)
struct FP2ContainerItemEntries final
{
public:
	class UP2Container*                           Container;                                         // 0x0000(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FItemEntry>                     ItemEntries;                                       // 0x0008(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FP2ContainerItemEntries) == 0x000008, "Wrong alignment on FP2ContainerItemEntries");
static_assert(sizeof(FP2ContainerItemEntries) == 0x000018, "Wrong size on FP2ContainerItemEntries");
static_assert(offsetof(FP2ContainerItemEntries, Container) == 0x000000, "Member 'FP2ContainerItemEntries::Container' has a wrong offset!");
static_assert(offsetof(FP2ContainerItemEntries, ItemEntries) == 0x000008, "Member 'FP2ContainerItemEntries::ItemEntries' has a wrong offset!");

// ScriptStruct Game.P2ItemUpdateInfo
// 0x0028 (0x0028 - 0x0000)
struct FP2ItemUpdateInfo final
{
public:
	class FString                                 TargetId;                                          // 0x0000(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 InstigatorId;                                      // 0x0010(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         UpdateCount;                                       // 0x0020(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_24[0x4];                                       // 0x0024(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FP2ItemUpdateInfo) == 0x000008, "Wrong alignment on FP2ItemUpdateInfo");
static_assert(sizeof(FP2ItemUpdateInfo) == 0x000028, "Wrong size on FP2ItemUpdateInfo");
static_assert(offsetof(FP2ItemUpdateInfo, TargetId) == 0x000000, "Member 'FP2ItemUpdateInfo::TargetId' has a wrong offset!");
static_assert(offsetof(FP2ItemUpdateInfo, InstigatorId) == 0x000010, "Member 'FP2ItemUpdateInfo::InstigatorId' has a wrong offset!");
static_assert(offsetof(FP2ItemUpdateInfo, UpdateCount) == 0x000020, "Member 'FP2ItemUpdateInfo::UpdateCount' has a wrong offset!");

// ScriptStruct Game.WeaponAimDownSightConfig
// 0x0120 (0x0120 - 0x0000)
struct FWeaponAimDownSightConfig final
{
public:
	struct FTransform                             AimDownSightTransform;                             // 0x0000(0x0060)(Edit, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FTransform                             SightRailStartTransform;                           // 0x0060(0x0060)(Edit, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AimDownSightTransitionTime;                        // 0x00C0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUseAdditiveAimAnimation;                          // 0x00C4(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C5[0x3];                                       // 0x00C5(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FP2Remap                               StateTimeSpeedScale;                               // 0x00C8(0x0028)(Edit, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          bUseAccelerationAtFullState;                       // 0x00F0(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_F1[0x7];                                       // 0x00F1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FP2Remap                               AimDownSightAnimRemap;                             // 0x00F8(0x0028)(Edit, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FWeaponAimDownSightConfig) == 0x000010, "Wrong alignment on FWeaponAimDownSightConfig");
static_assert(sizeof(FWeaponAimDownSightConfig) == 0x000120, "Wrong size on FWeaponAimDownSightConfig");
static_assert(offsetof(FWeaponAimDownSightConfig, AimDownSightTransform) == 0x000000, "Member 'FWeaponAimDownSightConfig::AimDownSightTransform' has a wrong offset!");
static_assert(offsetof(FWeaponAimDownSightConfig, SightRailStartTransform) == 0x000060, "Member 'FWeaponAimDownSightConfig::SightRailStartTransform' has a wrong offset!");
static_assert(offsetof(FWeaponAimDownSightConfig, AimDownSightTransitionTime) == 0x0000C0, "Member 'FWeaponAimDownSightConfig::AimDownSightTransitionTime' has a wrong offset!");
static_assert(offsetof(FWeaponAimDownSightConfig, bUseAdditiveAimAnimation) == 0x0000C4, "Member 'FWeaponAimDownSightConfig::bUseAdditiveAimAnimation' has a wrong offset!");
static_assert(offsetof(FWeaponAimDownSightConfig, StateTimeSpeedScale) == 0x0000C8, "Member 'FWeaponAimDownSightConfig::StateTimeSpeedScale' has a wrong offset!");
static_assert(offsetof(FWeaponAimDownSightConfig, bUseAccelerationAtFullState) == 0x0000F0, "Member 'FWeaponAimDownSightConfig::bUseAccelerationAtFullState' has a wrong offset!");
static_assert(offsetof(FWeaponAimDownSightConfig, AimDownSightAnimRemap) == 0x0000F8, "Member 'FWeaponAimDownSightConfig::AimDownSightAnimRemap' has a wrong offset!");

// ScriptStruct Game.WeaponAnimConfig1P
// 0x01A0 (0x01A0 - 0x0000)
struct FWeaponAnimConfig1P final
{
public:
	TSubclassOf<class UAnimInstance>              AnimLayer;                                         // 0x0000(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_8[0x8];                                        // 0x0008(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FWeaponAimDownSightConfig              AimDownSightConfig;                                // 0x0010(0x0120)(Edit, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
	struct FVector                                ControlRecoilAdditiveRotationScale;                // 0x0130(0x0018)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ControlRecoilAdditiveRiseSpeed;                    // 0x0148(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ControlRecoilAdditiveFallSpeed;                    // 0x014C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UWeaponInertiaData*                     InertiaData;                                       // 0x0150(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUseRecoilPivot;                                   // 0x0158(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_159[0x7];                                      // 0x0159(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                RecoilPivot;                                       // 0x0160(0x0018)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RecoilCameraCompensationScaleInADS;                // 0x0178(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_17C[0x4];                                      // 0x017C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                HipfireControlRecoilAdditivePivot;                 // 0x0180(0x0018)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_198[0x8];                                      // 0x0198(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FWeaponAnimConfig1P) == 0x000010, "Wrong alignment on FWeaponAnimConfig1P");
static_assert(sizeof(FWeaponAnimConfig1P) == 0x0001A0, "Wrong size on FWeaponAnimConfig1P");
static_assert(offsetof(FWeaponAnimConfig1P, AnimLayer) == 0x000000, "Member 'FWeaponAnimConfig1P::AnimLayer' has a wrong offset!");
static_assert(offsetof(FWeaponAnimConfig1P, AimDownSightConfig) == 0x000010, "Member 'FWeaponAnimConfig1P::AimDownSightConfig' has a wrong offset!");
static_assert(offsetof(FWeaponAnimConfig1P, ControlRecoilAdditiveRotationScale) == 0x000130, "Member 'FWeaponAnimConfig1P::ControlRecoilAdditiveRotationScale' has a wrong offset!");
static_assert(offsetof(FWeaponAnimConfig1P, ControlRecoilAdditiveRiseSpeed) == 0x000148, "Member 'FWeaponAnimConfig1P::ControlRecoilAdditiveRiseSpeed' has a wrong offset!");
static_assert(offsetof(FWeaponAnimConfig1P, ControlRecoilAdditiveFallSpeed) == 0x00014C, "Member 'FWeaponAnimConfig1P::ControlRecoilAdditiveFallSpeed' has a wrong offset!");
static_assert(offsetof(FWeaponAnimConfig1P, InertiaData) == 0x000150, "Member 'FWeaponAnimConfig1P::InertiaData' has a wrong offset!");
static_assert(offsetof(FWeaponAnimConfig1P, bUseRecoilPivot) == 0x000158, "Member 'FWeaponAnimConfig1P::bUseRecoilPivot' has a wrong offset!");
static_assert(offsetof(FWeaponAnimConfig1P, RecoilPivot) == 0x000160, "Member 'FWeaponAnimConfig1P::RecoilPivot' has a wrong offset!");
static_assert(offsetof(FWeaponAnimConfig1P, RecoilCameraCompensationScaleInADS) == 0x000178, "Member 'FWeaponAnimConfig1P::RecoilCameraCompensationScaleInADS' has a wrong offset!");
static_assert(offsetof(FWeaponAnimConfig1P, HipfireControlRecoilAdditivePivot) == 0x000180, "Member 'FWeaponAnimConfig1P::HipfireControlRecoilAdditivePivot' has a wrong offset!");

// ScriptStruct Game.P2LootSpawnBrushSettings
// 0x0010 (0x0010 - 0x0000)
struct FP2LootSpawnBrushSettings
{
public:
	struct FLinearColor                           Color;                                             // 0x0000(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FP2LootSpawnBrushSettings) == 0x000004, "Wrong alignment on FP2LootSpawnBrushSettings");
static_assert(sizeof(FP2LootSpawnBrushSettings) == 0x000010, "Wrong size on FP2LootSpawnBrushSettings");
static_assert(offsetof(FP2LootSpawnBrushSettings, Color) == 0x000000, "Member 'FP2LootSpawnBrushSettings::Color' has a wrong offset!");

// ScriptStruct Game.P2LootSpawnContextSettings
// 0x0080 (0x0090 - 0x0010)
struct FP2LootSpawnContextSettings final : public FP2LootSpawnBrushSettings
{
public:
	struct FGameplayTagContainer                  AvailableItemContextTag;                           // 0x0010(0x0020)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FGameplayTagContainer                  AvailableCrateContextTag;                          // 0x0030(0x0020)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FGameplayTagContainer                  FilterItemTag;                                     // 0x0050(0x0020)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FGameplayTagContainer                  FilterCrateTag;                                    // 0x0070(0x0020)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
};
static_assert(alignof(FP2LootSpawnContextSettings) == 0x000008, "Wrong alignment on FP2LootSpawnContextSettings");
static_assert(sizeof(FP2LootSpawnContextSettings) == 0x000090, "Wrong size on FP2LootSpawnContextSettings");
static_assert(offsetof(FP2LootSpawnContextSettings, AvailableItemContextTag) == 0x000010, "Member 'FP2LootSpawnContextSettings::AvailableItemContextTag' has a wrong offset!");
static_assert(offsetof(FP2LootSpawnContextSettings, AvailableCrateContextTag) == 0x000030, "Member 'FP2LootSpawnContextSettings::AvailableCrateContextTag' has a wrong offset!");
static_assert(offsetof(FP2LootSpawnContextSettings, FilterItemTag) == 0x000050, "Member 'FP2LootSpawnContextSettings::FilterItemTag' has a wrong offset!");
static_assert(offsetof(FP2LootSpawnContextSettings, FilterCrateTag) == 0x000070, "Member 'FP2LootSpawnContextSettings::FilterCrateTag' has a wrong offset!");

// ScriptStruct Game.P2ItemUpdateData
// 0x0058 (0x0058 - 0x0000)
struct FP2ItemUpdateData final
{
public:
	TMap<class FString, int32>                    UpdateInstigatorCountMap;                          // 0x0000(0x0050)(NativeAccessSpecifierPublic)
	bool                                          bIsCheck;                                          // 0x0050(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_51[0x7];                                       // 0x0051(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FP2ItemUpdateData) == 0x000008, "Wrong alignment on FP2ItemUpdateData");
static_assert(sizeof(FP2ItemUpdateData) == 0x000058, "Wrong size on FP2ItemUpdateData");
static_assert(offsetof(FP2ItemUpdateData, UpdateInstigatorCountMap) == 0x000000, "Member 'FP2ItemUpdateData::UpdateInstigatorCountMap' has a wrong offset!");
static_assert(offsetof(FP2ItemUpdateData, bIsCheck) == 0x000050, "Member 'FP2ItemUpdateData::bIsCheck' has a wrong offset!");

// ScriptStruct Game.P2ItemIconParams
// 0x0030 (0x0030 - 0x0000)
struct FP2ItemIconParams final
{
public:
	EP2ItemIconFitType                            FitType;                                           // 0x0000(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         IconWidth;                                         // 0x0004(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         IconHeight;                                        // 0x0008(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ItemIconWidth;                                     // 0x000C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ItemIconHeight;                                    // 0x0010(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bHideItemCount;                                    // 0x0014(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bHideItemQuantity;                                 // 0x0015(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bShouldUpdateItemCount;                            // 0x0016(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bShowTooltip;                                      // 0x0017(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bInHideQuickPurchaseIcon;                          // 0x0018(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bInitItemCount;                                    // 0x0019(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1A[0x2];                                       // 0x001A(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         ItemCount;                                         // 0x001C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bInitItemQuantity;                                 // 0x0020(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_21[0x3];                                       // 0x0021(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         ItemQuantity;                                      // 0x0024(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsRequiringItem;                                  // 0x0028(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_29[0x3];                                       // 0x0029(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         RequireItemAmount;                                 // 0x002C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FP2ItemIconParams) == 0x000004, "Wrong alignment on FP2ItemIconParams");
static_assert(sizeof(FP2ItemIconParams) == 0x000030, "Wrong size on FP2ItemIconParams");
static_assert(offsetof(FP2ItemIconParams, FitType) == 0x000000, "Member 'FP2ItemIconParams::FitType' has a wrong offset!");
static_assert(offsetof(FP2ItemIconParams, IconWidth) == 0x000004, "Member 'FP2ItemIconParams::IconWidth' has a wrong offset!");
static_assert(offsetof(FP2ItemIconParams, IconHeight) == 0x000008, "Member 'FP2ItemIconParams::IconHeight' has a wrong offset!");
static_assert(offsetof(FP2ItemIconParams, ItemIconWidth) == 0x00000C, "Member 'FP2ItemIconParams::ItemIconWidth' has a wrong offset!");
static_assert(offsetof(FP2ItemIconParams, ItemIconHeight) == 0x000010, "Member 'FP2ItemIconParams::ItemIconHeight' has a wrong offset!");
static_assert(offsetof(FP2ItemIconParams, bHideItemCount) == 0x000014, "Member 'FP2ItemIconParams::bHideItemCount' has a wrong offset!");
static_assert(offsetof(FP2ItemIconParams, bHideItemQuantity) == 0x000015, "Member 'FP2ItemIconParams::bHideItemQuantity' has a wrong offset!");
static_assert(offsetof(FP2ItemIconParams, bShouldUpdateItemCount) == 0x000016, "Member 'FP2ItemIconParams::bShouldUpdateItemCount' has a wrong offset!");
static_assert(offsetof(FP2ItemIconParams, bShowTooltip) == 0x000017, "Member 'FP2ItemIconParams::bShowTooltip' has a wrong offset!");
static_assert(offsetof(FP2ItemIconParams, bInHideQuickPurchaseIcon) == 0x000018, "Member 'FP2ItemIconParams::bInHideQuickPurchaseIcon' has a wrong offset!");
static_assert(offsetof(FP2ItemIconParams, bInitItemCount) == 0x000019, "Member 'FP2ItemIconParams::bInitItemCount' has a wrong offset!");
static_assert(offsetof(FP2ItemIconParams, ItemCount) == 0x00001C, "Member 'FP2ItemIconParams::ItemCount' has a wrong offset!");
static_assert(offsetof(FP2ItemIconParams, bInitItemQuantity) == 0x000020, "Member 'FP2ItemIconParams::bInitItemQuantity' has a wrong offset!");
static_assert(offsetof(FP2ItemIconParams, ItemQuantity) == 0x000024, "Member 'FP2ItemIconParams::ItemQuantity' has a wrong offset!");
static_assert(offsetof(FP2ItemIconParams, bIsRequiringItem) == 0x000028, "Member 'FP2ItemIconParams::bIsRequiringItem' has a wrong offset!");
static_assert(offsetof(FP2ItemIconParams, RequireItemAmount) == 0x00002C, "Member 'FP2ItemIconParams::RequireItemAmount' has a wrong offset!");

// ScriptStruct Game.P2ItemCountColorInfo
// 0x0040 (0x0040 - 0x0000)
struct FP2ItemCountColorInfo final
{
public:
	struct FLinearColor                           RequiredItemsCompleteTxtColor;                     // 0x0000(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           RequireditemsIncompleteTxtColor;                   // 0x0010(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           RequiredItemsCompleteBorderColor;                  // 0x0020(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           RequireditemsIncompleteBorderColor;                // 0x0030(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FP2ItemCountColorInfo) == 0x000004, "Wrong alignment on FP2ItemCountColorInfo");
static_assert(sizeof(FP2ItemCountColorInfo) == 0x000040, "Wrong size on FP2ItemCountColorInfo");
static_assert(offsetof(FP2ItemCountColorInfo, RequiredItemsCompleteTxtColor) == 0x000000, "Member 'FP2ItemCountColorInfo::RequiredItemsCompleteTxtColor' has a wrong offset!");
static_assert(offsetof(FP2ItemCountColorInfo, RequireditemsIncompleteTxtColor) == 0x000010, "Member 'FP2ItemCountColorInfo::RequireditemsIncompleteTxtColor' has a wrong offset!");
static_assert(offsetof(FP2ItemCountColorInfo, RequiredItemsCompleteBorderColor) == 0x000020, "Member 'FP2ItemCountColorInfo::RequiredItemsCompleteBorderColor' has a wrong offset!");
static_assert(offsetof(FP2ItemCountColorInfo, RequireditemsIncompleteBorderColor) == 0x000030, "Member 'FP2ItemCountColorInfo::RequireditemsIncompleteBorderColor' has a wrong offset!");

// ScriptStruct Game.SecondaryStateEntry
// 0x0008 (0x0008 - 0x0000)
struct FSecondaryStateEntry final
{
public:
	int32                                         Priority;                                          // 0x0000(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ESecondaryState                               State;                                             // 0x0004(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5[0x3];                                        // 0x0005(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FSecondaryStateEntry) == 0x000004, "Wrong alignment on FSecondaryStateEntry");
static_assert(sizeof(FSecondaryStateEntry) == 0x000008, "Wrong size on FSecondaryStateEntry");
static_assert(offsetof(FSecondaryStateEntry, Priority) == 0x000000, "Member 'FSecondaryStateEntry::Priority' has a wrong offset!");
static_assert(offsetof(FSecondaryStateEntry, State) == 0x000004, "Member 'FSecondaryStateEntry::State' has a wrong offset!");

// ScriptStruct Game.P2VerbMessage
// 0x0098 (0x0098 - 0x0000)
struct FP2VerbMessage final
{
public:
	struct FGameplayTag                           Verb;                                              // 0x0000(0x0008)(Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UObject*                                Instigator;                                        // 0x0008(0x0008)(BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UObject*                                Target;                                            // 0x0010(0x0008)(BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTagContainer                  InstigatorTags;                                    // 0x0018(0x0020)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	struct FGameplayTagContainer                  TargetTags;                                        // 0x0038(0x0020)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	struct FGameplayTagContainer                  ContextTags;                                       // 0x0058(0x0020)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	double                                        Magnitude;                                         // 0x0078(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Quantity;                                          // 0x0080(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_84[0x4];                                       // 0x0084(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<double>                                ContextValues;                                     // 0x0088(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FP2VerbMessage) == 0x000008, "Wrong alignment on FP2VerbMessage");
static_assert(sizeof(FP2VerbMessage) == 0x000098, "Wrong size on FP2VerbMessage");
static_assert(offsetof(FP2VerbMessage, Verb) == 0x000000, "Member 'FP2VerbMessage::Verb' has a wrong offset!");
static_assert(offsetof(FP2VerbMessage, Instigator) == 0x000008, "Member 'FP2VerbMessage::Instigator' has a wrong offset!");
static_assert(offsetof(FP2VerbMessage, Target) == 0x000010, "Member 'FP2VerbMessage::Target' has a wrong offset!");
static_assert(offsetof(FP2VerbMessage, InstigatorTags) == 0x000018, "Member 'FP2VerbMessage::InstigatorTags' has a wrong offset!");
static_assert(offsetof(FP2VerbMessage, TargetTags) == 0x000038, "Member 'FP2VerbMessage::TargetTags' has a wrong offset!");
static_assert(offsetof(FP2VerbMessage, ContextTags) == 0x000058, "Member 'FP2VerbMessage::ContextTags' has a wrong offset!");
static_assert(offsetof(FP2VerbMessage, Magnitude) == 0x000078, "Member 'FP2VerbMessage::Magnitude' has a wrong offset!");
static_assert(offsetof(FP2VerbMessage, Quantity) == 0x000080, "Member 'FP2VerbMessage::Quantity' has a wrong offset!");
static_assert(offsetof(FP2VerbMessage, ContextValues) == 0x000088, "Member 'FP2VerbMessage::ContextValues' has a wrong offset!");

// ScriptStruct Game.CameraSmoothingConfig
// 0x0028 (0x0028 - 0x0000)
struct FCameraSmoothingConfig final
{
public:
	struct FVector                                InputScale;                                        // 0x0000(0x0018)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxDistance;                                       // 0x0018(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxVelocity;                                       // 0x001C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SpringStiffness;                                   // 0x0020(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SpringDamping;                                     // 0x0024(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCameraSmoothingConfig) == 0x000008, "Wrong alignment on FCameraSmoothingConfig");
static_assert(sizeof(FCameraSmoothingConfig) == 0x000028, "Wrong size on FCameraSmoothingConfig");
static_assert(offsetof(FCameraSmoothingConfig, InputScale) == 0x000000, "Member 'FCameraSmoothingConfig::InputScale' has a wrong offset!");
static_assert(offsetof(FCameraSmoothingConfig, MaxDistance) == 0x000018, "Member 'FCameraSmoothingConfig::MaxDistance' has a wrong offset!");
static_assert(offsetof(FCameraSmoothingConfig, MaxVelocity) == 0x00001C, "Member 'FCameraSmoothingConfig::MaxVelocity' has a wrong offset!");
static_assert(offsetof(FCameraSmoothingConfig, SpringStiffness) == 0x000020, "Member 'FCameraSmoothingConfig::SpringStiffness' has a wrong offset!");
static_assert(offsetof(FCameraSmoothingConfig, SpringDamping) == 0x000024, "Member 'FCameraSmoothingConfig::SpringDamping' has a wrong offset!");

// ScriptStruct Game.P2DbnoDamageSourceEntry
// 0x0048 (0x0048 - 0x0000)
struct FP2DbnoDamageSourceEntry final
{
public:
	class AActor*                                 Instigator;                                        // 0x0000(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_8[0x40];                                       // 0x0008(0x0040)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FP2DbnoDamageSourceEntry) == 0x000008, "Wrong alignment on FP2DbnoDamageSourceEntry");
static_assert(sizeof(FP2DbnoDamageSourceEntry) == 0x000048, "Wrong size on FP2DbnoDamageSourceEntry");
static_assert(offsetof(FP2DbnoDamageSourceEntry, Instigator) == 0x000000, "Member 'FP2DbnoDamageSourceEntry::Instigator' has a wrong offset!");

// ScriptStruct Game.P2AssistsEntry
// 0x0010 (0x0010 - 0x0000)
struct FP2AssistsEntry final
{
public:
	TArray<struct FP2DbnoDamageSourceEntry>       Assists;                                           // 0x0000(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FP2AssistsEntry) == 0x000008, "Wrong alignment on FP2AssistsEntry");
static_assert(sizeof(FP2AssistsEntry) == 0x000010, "Wrong size on FP2AssistsEntry");
static_assert(offsetof(FP2AssistsEntry, Assists) == 0x000000, "Member 'FP2AssistsEntry::Assists' has a wrong offset!");

// ScriptStruct Game.ProductionFailureRate
// 0x0030 (0x0030 - 0x0000)
struct FProductionFailureRate final
{
public:
	int32                                         MinRatePercentage;                                 // 0x0000(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   ToolTipText;                                       // 0x0008(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FLinearColor                           RateColor;                                         // 0x0020(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FProductionFailureRate) == 0x000008, "Wrong alignment on FProductionFailureRate");
static_assert(sizeof(FProductionFailureRate) == 0x000030, "Wrong size on FProductionFailureRate");
static_assert(offsetof(FProductionFailureRate, MinRatePercentage) == 0x000000, "Member 'FProductionFailureRate::MinRatePercentage' has a wrong offset!");
static_assert(offsetof(FProductionFailureRate, ToolTipText) == 0x000008, "Member 'FProductionFailureRate::ToolTipText' has a wrong offset!");
static_assert(offsetof(FProductionFailureRate, RateColor) == 0x000020, "Member 'FProductionFailureRate::RateColor' has a wrong offset!");

// ScriptStruct Game.P2RewardedPlayersEntry
// 0x0010 (0x0010 - 0x0000)
struct FP2RewardedPlayersEntry final
{
public:
	TArray<class AActor*>                         Players;                                           // 0x0000(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FP2RewardedPlayersEntry) == 0x000008, "Wrong alignment on FP2RewardedPlayersEntry");
static_assert(sizeof(FP2RewardedPlayersEntry) == 0x000010, "Wrong size on FP2RewardedPlayersEntry");
static_assert(offsetof(FP2RewardedPlayersEntry, Players) == 0x000000, "Member 'FP2RewardedPlayersEntry::Players' has a wrong offset!");

// ScriptStruct Game.P2RagdollControllerConfig
// 0x0014 (0x0014 - 0x0000)
struct FP2RagdollControllerConfig final
{
public:
	float                                         SphereRadius;                                      // 0x0000(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HorizontalLeash;                                   // 0x0004(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAllowClosestBodyConstraint;                       // 0x0008(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bForceConstraintBone;                              // 0x0009(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A[0x2];                                        // 0x000A(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   ForceConstraintBoneName;                           // 0x000C(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FP2RagdollControllerConfig) == 0x000004, "Wrong alignment on FP2RagdollControllerConfig");
static_assert(sizeof(FP2RagdollControllerConfig) == 0x000014, "Wrong size on FP2RagdollControllerConfig");
static_assert(offsetof(FP2RagdollControllerConfig, SphereRadius) == 0x000000, "Member 'FP2RagdollControllerConfig::SphereRadius' has a wrong offset!");
static_assert(offsetof(FP2RagdollControllerConfig, HorizontalLeash) == 0x000004, "Member 'FP2RagdollControllerConfig::HorizontalLeash' has a wrong offset!");
static_assert(offsetof(FP2RagdollControllerConfig, bAllowClosestBodyConstraint) == 0x000008, "Member 'FP2RagdollControllerConfig::bAllowClosestBodyConstraint' has a wrong offset!");
static_assert(offsetof(FP2RagdollControllerConfig, bForceConstraintBone) == 0x000009, "Member 'FP2RagdollControllerConfig::bForceConstraintBone' has a wrong offset!");
static_assert(offsetof(FP2RagdollControllerConfig, ForceConstraintBoneName) == 0x00000C, "Member 'FP2RagdollControllerConfig::ForceConstraintBoneName' has a wrong offset!");

// ScriptStruct Game.P2InputPenaltyRow
// 0x0020 (0x0028 - 0x0008)
struct FP2InputPenaltyRow final : public FTableRowBase
{
public:
	struct FGameplayTag                           StatusTag;                                         // 0x0008(0x0008)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCurveFloat*                            MovementPenaltyCurve;                              // 0x0010(0x0008)(Edit, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCurveFloat*                            LookPenaltyCurve;                                  // 0x0018(0x0008)(Edit, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bNormalized;                                       // 0x0020(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_21[0x3];                                       // 0x0021(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         RemovedInterpSpeedPerSecond;                       // 0x0024(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FP2InputPenaltyRow) == 0x000008, "Wrong alignment on FP2InputPenaltyRow");
static_assert(sizeof(FP2InputPenaltyRow) == 0x000028, "Wrong size on FP2InputPenaltyRow");
static_assert(offsetof(FP2InputPenaltyRow, StatusTag) == 0x000008, "Member 'FP2InputPenaltyRow::StatusTag' has a wrong offset!");
static_assert(offsetof(FP2InputPenaltyRow, MovementPenaltyCurve) == 0x000010, "Member 'FP2InputPenaltyRow::MovementPenaltyCurve' has a wrong offset!");
static_assert(offsetof(FP2InputPenaltyRow, LookPenaltyCurve) == 0x000018, "Member 'FP2InputPenaltyRow::LookPenaltyCurve' has a wrong offset!");
static_assert(offsetof(FP2InputPenaltyRow, bNormalized) == 0x000020, "Member 'FP2InputPenaltyRow::bNormalized' has a wrong offset!");
static_assert(offsetof(FP2InputPenaltyRow, RemovedInterpSpeedPerSecond) == 0x000024, "Member 'FP2InputPenaltyRow::RemovedInterpSpeedPerSecond' has a wrong offset!");

// ScriptStruct Game.SpreadRemapConfig
// 0x0020 (0x0020 - 0x0000)
struct FSpreadRemapConfig final
{
public:
	class UCurveFloat*                            DistributionRemapCurve;                            // 0x0000(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCurveFloat*                            DistributionProgressiveRemapCurve;                 // 0x0008(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUseProgressiveSpread;                             // 0x0010(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x3];                                       // 0x0011(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ProgressiveSpreadShotTimeout;                      // 0x0014(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ProgressiveSpreadRandomScale;                      // 0x0018(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C[0x4];                                       // 0x001C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FSpreadRemapConfig) == 0x000008, "Wrong alignment on FSpreadRemapConfig");
static_assert(sizeof(FSpreadRemapConfig) == 0x000020, "Wrong size on FSpreadRemapConfig");
static_assert(offsetof(FSpreadRemapConfig, DistributionRemapCurve) == 0x000000, "Member 'FSpreadRemapConfig::DistributionRemapCurve' has a wrong offset!");
static_assert(offsetof(FSpreadRemapConfig, DistributionProgressiveRemapCurve) == 0x000008, "Member 'FSpreadRemapConfig::DistributionProgressiveRemapCurve' has a wrong offset!");
static_assert(offsetof(FSpreadRemapConfig, bUseProgressiveSpread) == 0x000010, "Member 'FSpreadRemapConfig::bUseProgressiveSpread' has a wrong offset!");
static_assert(offsetof(FSpreadRemapConfig, ProgressiveSpreadShotTimeout) == 0x000014, "Member 'FSpreadRemapConfig::ProgressiveSpreadShotTimeout' has a wrong offset!");
static_assert(offsetof(FSpreadRemapConfig, ProgressiveSpreadRandomScale) == 0x000018, "Member 'FSpreadRemapConfig::ProgressiveSpreadRandomScale' has a wrong offset!");

// ScriptStruct Game.SwayTrackConfig
// 0x0020 (0x0020 - 0x0000)
struct FSwayTrackConfig final
{
public:
	bool                                          bIsMuted;                                          // 0x0000(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector2D                              FrequencyRange;                                    // 0x0008(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSpringSimData*                     SwaySpring;                                        // 0x0018(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSwayTrackConfig) == 0x000008, "Wrong alignment on FSwayTrackConfig");
static_assert(sizeof(FSwayTrackConfig) == 0x000020, "Wrong size on FSwayTrackConfig");
static_assert(offsetof(FSwayTrackConfig, bIsMuted) == 0x000000, "Member 'FSwayTrackConfig::bIsMuted' has a wrong offset!");
static_assert(offsetof(FSwayTrackConfig, FrequencyRange) == 0x000008, "Member 'FSwayTrackConfig::FrequencyRange' has a wrong offset!");
static_assert(offsetof(FSwayTrackConfig, SwaySpring) == 0x000018, "Member 'FSwayTrackConfig::SwaySpring' has a wrong offset!");

// ScriptStruct Game.P2LootSpawnPointSettings
// 0x0078 (0x0078 - 0x0000)
struct FP2LootSpawnPointSettings final
{
public:
	EP2LootSpawnPointType                         Type;                                              // 0x0000(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTagContainer                  ExclusiveObjectsTag;                               // 0x0008(0x0020)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	uint8                                         bAllowRandomYaw : 1;                               // 0x0028(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bAllowRandomOffset : 1;                            // 0x0028(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bOffsetFromRoot : 1;                               // 0x0028(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_29[0x7];                                       // 0x0029(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                Offset;                                            // 0x0030(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Size;                                              // 0x0048(0x0018)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector                                SizeMax;                                           // 0x0060(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
};
static_assert(alignof(FP2LootSpawnPointSettings) == 0x000008, "Wrong alignment on FP2LootSpawnPointSettings");
static_assert(sizeof(FP2LootSpawnPointSettings) == 0x000078, "Wrong size on FP2LootSpawnPointSettings");
static_assert(offsetof(FP2LootSpawnPointSettings, Type) == 0x000000, "Member 'FP2LootSpawnPointSettings::Type' has a wrong offset!");
static_assert(offsetof(FP2LootSpawnPointSettings, ExclusiveObjectsTag) == 0x000008, "Member 'FP2LootSpawnPointSettings::ExclusiveObjectsTag' has a wrong offset!");
static_assert(offsetof(FP2LootSpawnPointSettings, Offset) == 0x000030, "Member 'FP2LootSpawnPointSettings::Offset' has a wrong offset!");
static_assert(offsetof(FP2LootSpawnPointSettings, Size) == 0x000048, "Member 'FP2LootSpawnPointSettings::Size' has a wrong offset!");
static_assert(offsetof(FP2LootSpawnPointSettings, SizeMax) == 0x000060, "Member 'FP2LootSpawnPointSettings::SizeMax' has a wrong offset!");

// ScriptStruct Game.P2LootSpawnPoint
// 0x0140 (0x0140 - 0x0000)
struct FP2LootSpawnPoint final
{
public:
	struct FTransform                             Transform;                                         // 0x0000(0x0060)(Edit, BlueprintVisible, BlueprintReadOnly, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   AttachComponent;                                   // 0x0060(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   AttachSocket;                                      // 0x0068(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UP2LootSpawnPointData*                  Data;                                              // 0x0070(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FP2LootSpawnPointSettings              Settings;                                          // 0x0078(0x0078)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FGameplayTagContainer                  OptionalObjectTags;                                // 0x00F0(0x0020)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	uint8                                         bFixedOnly : 1;                                    // 0x0110(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bOverride_AllowRandomYaw : 1;                      // 0x0110(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bAllowRandomYaw : 1;                               // 0x0110(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bOverride_AllowRandomOffset : 1;                   // 0x0110(0x0001)(BitIndex: 0x03, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bAllowRandomOffset : 1;                            // 0x0110(0x0001)(BitIndex: 0x04, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_111[0x7];                                      // 0x0111(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UStaticMesh*                            FallbackStaticMesh;                                // 0x0118(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EP2LootSpawnBias                              Bias;                                              // 0x0120(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_121[0x7];                                      // 0x0121(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FGameplayTagContainer>          Filters;                                           // 0x0128(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_138[0x8];                                      // 0x0138(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FP2LootSpawnPoint) == 0x000010, "Wrong alignment on FP2LootSpawnPoint");
static_assert(sizeof(FP2LootSpawnPoint) == 0x000140, "Wrong size on FP2LootSpawnPoint");
static_assert(offsetof(FP2LootSpawnPoint, Transform) == 0x000000, "Member 'FP2LootSpawnPoint::Transform' has a wrong offset!");
static_assert(offsetof(FP2LootSpawnPoint, AttachComponent) == 0x000060, "Member 'FP2LootSpawnPoint::AttachComponent' has a wrong offset!");
static_assert(offsetof(FP2LootSpawnPoint, AttachSocket) == 0x000068, "Member 'FP2LootSpawnPoint::AttachSocket' has a wrong offset!");
static_assert(offsetof(FP2LootSpawnPoint, Data) == 0x000070, "Member 'FP2LootSpawnPoint::Data' has a wrong offset!");
static_assert(offsetof(FP2LootSpawnPoint, Settings) == 0x000078, "Member 'FP2LootSpawnPoint::Settings' has a wrong offset!");
static_assert(offsetof(FP2LootSpawnPoint, OptionalObjectTags) == 0x0000F0, "Member 'FP2LootSpawnPoint::OptionalObjectTags' has a wrong offset!");
static_assert(offsetof(FP2LootSpawnPoint, FallbackStaticMesh) == 0x000118, "Member 'FP2LootSpawnPoint::FallbackStaticMesh' has a wrong offset!");
static_assert(offsetof(FP2LootSpawnPoint, Bias) == 0x000120, "Member 'FP2LootSpawnPoint::Bias' has a wrong offset!");
static_assert(offsetof(FP2LootSpawnPoint, Filters) == 0x000128, "Member 'FP2LootSpawnPoint::Filters' has a wrong offset!");

// ScriptStruct Game.P2GameUserSettingInfoMember
// 0x0010 (0x0010 - 0x0000)
struct FP2GameUserSettingInfoMember final
{
public:
	class FName                                   MemberTitle;                                       // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   MemberValue;                                       // 0x0008(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FP2GameUserSettingInfoMember) == 0x000004, "Wrong alignment on FP2GameUserSettingInfoMember");
static_assert(sizeof(FP2GameUserSettingInfoMember) == 0x000010, "Wrong size on FP2GameUserSettingInfoMember");
static_assert(offsetof(FP2GameUserSettingInfoMember, MemberTitle) == 0x000000, "Member 'FP2GameUserSettingInfoMember::MemberTitle' has a wrong offset!");
static_assert(offsetof(FP2GameUserSettingInfoMember, MemberValue) == 0x000008, "Member 'FP2GameUserSettingInfoMember::MemberValue' has a wrong offset!");

// ScriptStruct Game.P2GameUserSettingInfo
// 0x0038 (0x0038 - 0x0000)
struct FP2GameUserSettingInfo final
{
public:
	class UObject*                                Instigator;                                        // 0x0000(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FP2GameUserSettingInfoMember>   GameUserInfoMembers;                               // 0x0008(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FP2GameUserSettingInfoMember>   GameUserInfoMembers_GraphicSetting;                // 0x0018(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FP2GameUserSettingInfoMember>   GameUserInfoMembers_KeySetting;                    // 0x0028(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FP2GameUserSettingInfo) == 0x000008, "Wrong alignment on FP2GameUserSettingInfo");
static_assert(sizeof(FP2GameUserSettingInfo) == 0x000038, "Wrong size on FP2GameUserSettingInfo");
static_assert(offsetof(FP2GameUserSettingInfo, Instigator) == 0x000000, "Member 'FP2GameUserSettingInfo::Instigator' has a wrong offset!");
static_assert(offsetof(FP2GameUserSettingInfo, GameUserInfoMembers) == 0x000008, "Member 'FP2GameUserSettingInfo::GameUserInfoMembers' has a wrong offset!");
static_assert(offsetof(FP2GameUserSettingInfo, GameUserInfoMembers_GraphicSetting) == 0x000018, "Member 'FP2GameUserSettingInfo::GameUserInfoMembers_GraphicSetting' has a wrong offset!");
static_assert(offsetof(FP2GameUserSettingInfo, GameUserInfoMembers_KeySetting) == 0x000028, "Member 'FP2GameUserSettingInfo::GameUserInfoMembers_KeySetting' has a wrong offset!");

// ScriptStruct Game.P2CategoryDisplayInfo
// 0x0028 (0x0028 - 0x0000)
struct FP2CategoryDisplayInfo final
{
public:
	struct FGameplayTag                           CategoryTag;                                       // 0x0000(0x0008)(Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FText                                   TxtTitle;                                          // 0x0008(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	int32                                         SortIndex;                                         // 0x0020(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_24[0x4];                                       // 0x0024(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FP2CategoryDisplayInfo) == 0x000008, "Wrong alignment on FP2CategoryDisplayInfo");
static_assert(sizeof(FP2CategoryDisplayInfo) == 0x000028, "Wrong size on FP2CategoryDisplayInfo");
static_assert(offsetof(FP2CategoryDisplayInfo, CategoryTag) == 0x000000, "Member 'FP2CategoryDisplayInfo::CategoryTag' has a wrong offset!");
static_assert(offsetof(FP2CategoryDisplayInfo, TxtTitle) == 0x000008, "Member 'FP2CategoryDisplayInfo::TxtTitle' has a wrong offset!");
static_assert(offsetof(FP2CategoryDisplayInfo, SortIndex) == 0x000020, "Member 'FP2CategoryDisplayInfo::SortIndex' has a wrong offset!");

// ScriptStruct Game.P2ReplicatedProperty
// 0x0004 (0x0004 - 0x0000)
struct FP2ReplicatedProperty
{
public:
	int32                                         Num;                                               // 0x0000(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FP2ReplicatedProperty) == 0x000004, "Wrong alignment on FP2ReplicatedProperty");
static_assert(sizeof(FP2ReplicatedProperty) == 0x000004, "Wrong size on FP2ReplicatedProperty");
static_assert(offsetof(FP2ReplicatedProperty, Num) == 0x000000, "Member 'FP2ReplicatedProperty::Num' has a wrong offset!");

// ScriptStruct Game.P2AttributeModFilter
// 0x0078 (0x0078 - 0x0000)
struct FP2AttributeModFilter final
{
public:
	struct FGameplayAttribute                     Attribute;                                         // 0x0000(0x0038)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTagContainer                  SourceTags;                                        // 0x0038(0x0020)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FGameplayTagContainer                  TargetTags;                                        // 0x0058(0x0020)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
};
static_assert(alignof(FP2AttributeModFilter) == 0x000008, "Wrong alignment on FP2AttributeModFilter");
static_assert(sizeof(FP2AttributeModFilter) == 0x000078, "Wrong size on FP2AttributeModFilter");
static_assert(offsetof(FP2AttributeModFilter, Attribute) == 0x000000, "Member 'FP2AttributeModFilter::Attribute' has a wrong offset!");
static_assert(offsetof(FP2AttributeModFilter, SourceTags) == 0x000038, "Member 'FP2AttributeModFilter::SourceTags' has a wrong offset!");
static_assert(offsetof(FP2AttributeModFilter, TargetTags) == 0x000058, "Member 'FP2AttributeModFilter::TargetTags' has a wrong offset!");

// ScriptStruct Game.P2AmmoDescriptor
// 0x0014 (0x0018 - 0x0004)
struct FP2AmmoDescriptor final : public FP2ReplicatedProperty
{
public:
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UP2AmmoData*                            AmmoData;                                          // 0x0008(0x0008)(BlueprintVisible, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsTracer;                                         // 0x0010(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x7];                                       // 0x0011(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FP2AmmoDescriptor) == 0x000008, "Wrong alignment on FP2AmmoDescriptor");
static_assert(sizeof(FP2AmmoDescriptor) == 0x000018, "Wrong size on FP2AmmoDescriptor");
static_assert(offsetof(FP2AmmoDescriptor, AmmoData) == 0x000008, "Member 'FP2AmmoDescriptor::AmmoData' has a wrong offset!");
static_assert(offsetof(FP2AmmoDescriptor, bIsTracer) == 0x000010, "Member 'FP2AmmoDescriptor::bIsTracer' has a wrong offset!");

// ScriptStruct Game.P2ReputationReward
// 0x000C (0x000C - 0x0000)
struct FP2ReputationReward final
{
public:
	struct FGameplayTag                           FactionTag;                                        // 0x0000(0x0008)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ReputationAmount;                                  // 0x0008(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FP2ReputationReward) == 0x000004, "Wrong alignment on FP2ReputationReward");
static_assert(sizeof(FP2ReputationReward) == 0x00000C, "Wrong size on FP2ReputationReward");
static_assert(offsetof(FP2ReputationReward, FactionTag) == 0x000000, "Member 'FP2ReputationReward::FactionTag' has a wrong offset!");
static_assert(offsetof(FP2ReputationReward, ReputationAmount) == 0x000008, "Member 'FP2ReputationReward::ReputationAmount' has a wrong offset!");

// ScriptStruct Game.P2UpsellingStoreData
// 0x0018 (0x0018 - 0x0000)
struct FP2UpsellingStoreData final
{
public:
	EP2UpsellingStoreType                         StoreType;                                         // 0x0000(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         SalePrice;                                         // 0x0004(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FP2ReputationReward>            ReputationRewards;                                 // 0x0008(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
};
static_assert(alignof(FP2UpsellingStoreData) == 0x000008, "Wrong alignment on FP2UpsellingStoreData");
static_assert(sizeof(FP2UpsellingStoreData) == 0x000018, "Wrong size on FP2UpsellingStoreData");
static_assert(offsetof(FP2UpsellingStoreData, StoreType) == 0x000000, "Member 'FP2UpsellingStoreData::StoreType' has a wrong offset!");
static_assert(offsetof(FP2UpsellingStoreData, SalePrice) == 0x000004, "Member 'FP2UpsellingStoreData::SalePrice' has a wrong offset!");
static_assert(offsetof(FP2UpsellingStoreData, ReputationRewards) == 0x000008, "Member 'FP2UpsellingStoreData::ReputationRewards' has a wrong offset!");

// ScriptStruct Game.P2SellingDataRow
// 0x0008 (0x00A0 - 0x0098)
struct FP2SellingDataRow : public FP2ExchangeDataRow
{
public:
	bool                                          bCanUpsell;                                        // 0x0098(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_99[0x7];                                       // 0x0099(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FP2SellingDataRow) == 0x000008, "Wrong alignment on FP2SellingDataRow");
static_assert(sizeof(FP2SellingDataRow) == 0x0000A0, "Wrong size on FP2SellingDataRow");
static_assert(offsetof(FP2SellingDataRow, bCanUpsell) == 0x000098, "Member 'FP2SellingDataRow::bCanUpsell' has a wrong offset!");

// ScriptStruct Game.P2UpsellingDataRow
// 0x0010 (0x00B0 - 0x00A0)
struct FP2UpsellingDataRow final : public FP2SellingDataRow
{
public:
	TArray<struct FP2UpsellingStoreData>          UpsellingStoreDataList;                            // 0x00A0(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
};
static_assert(alignof(FP2UpsellingDataRow) == 0x000008, "Wrong alignment on FP2UpsellingDataRow");
static_assert(sizeof(FP2UpsellingDataRow) == 0x0000B0, "Wrong size on FP2UpsellingDataRow");
static_assert(offsetof(FP2UpsellingDataRow, UpsellingStoreDataList) == 0x0000A0, "Member 'FP2UpsellingDataRow::UpsellingStoreDataList' has a wrong offset!");

// ScriptStruct Game.PawnDefaultAkComponentConfig
// 0x0010 (0x0010 - 0x0000)
struct FPawnDefaultAkComponentConfig final
{
public:
	struct FGameplayTag                           LocalReverbSettingsTag;                            // 0x0000(0x0008)(Edit, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           RemoteReverbSettingsTag;                           // 0x0008(0x0008)(Edit, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FPawnDefaultAkComponentConfig) == 0x000004, "Wrong alignment on FPawnDefaultAkComponentConfig");
static_assert(sizeof(FPawnDefaultAkComponentConfig) == 0x000010, "Wrong size on FPawnDefaultAkComponentConfig");
static_assert(offsetof(FPawnDefaultAkComponentConfig, LocalReverbSettingsTag) == 0x000000, "Member 'FPawnDefaultAkComponentConfig::LocalReverbSettingsTag' has a wrong offset!");
static_assert(offsetof(FPawnDefaultAkComponentConfig, RemoteReverbSettingsTag) == 0x000008, "Member 'FPawnDefaultAkComponentConfig::RemoteReverbSettingsTag' has a wrong offset!");

// ScriptStruct Game.StaticRecoilProcessor
// 0x0080 (0x0080 - 0x0000)
struct alignas(0x10) FStaticRecoilProcessor final
{
public:
	uint8                                         Pad_0[0x70];                                       // 0x0000(0x0070)(Fixing Size After Last Property [ Dumper-7 ])
	class UWeaponStaticRecoilData*                LastStaticRecoilData;                              // 0x0070(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_78[0x8];                                       // 0x0078(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FStaticRecoilProcessor) == 0x000010, "Wrong alignment on FStaticRecoilProcessor");
static_assert(sizeof(FStaticRecoilProcessor) == 0x000080, "Wrong size on FStaticRecoilProcessor");
static_assert(offsetof(FStaticRecoilProcessor, LastStaticRecoilData) == 0x000070, "Member 'FStaticRecoilProcessor::LastStaticRecoilData' has a wrong offset!");

// ScriptStruct Game.P2GameStateReplicatedTimer
// 0x0010 (0x0010 - 0x0000)
struct FP2GameStateReplicatedTimer final
{
public:
	float                                         Duration;                                          // 0x0000(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         PauseServerTime;                                   // 0x0004(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         TotalTimerPauseDuration;                           // 0x0008(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         ServerTimeTimerStart;                              // 0x000C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
};
static_assert(alignof(FP2GameStateReplicatedTimer) == 0x000004, "Wrong alignment on FP2GameStateReplicatedTimer");
static_assert(sizeof(FP2GameStateReplicatedTimer) == 0x000010, "Wrong size on FP2GameStateReplicatedTimer");
static_assert(offsetof(FP2GameStateReplicatedTimer, Duration) == 0x000000, "Member 'FP2GameStateReplicatedTimer::Duration' has a wrong offset!");
static_assert(offsetof(FP2GameStateReplicatedTimer, PauseServerTime) == 0x000004, "Member 'FP2GameStateReplicatedTimer::PauseServerTime' has a wrong offset!");
static_assert(offsetof(FP2GameStateReplicatedTimer, TotalTimerPauseDuration) == 0x000008, "Member 'FP2GameStateReplicatedTimer::TotalTimerPauseDuration' has a wrong offset!");
static_assert(offsetof(FP2GameStateReplicatedTimer, ServerTimeTimerStart) == 0x00000C, "Member 'FP2GameStateReplicatedTimer::ServerTimeTimerStart' has a wrong offset!");

// ScriptStruct Game.P2MatchStartInfo
// 0x0014 (0x0014 - 0x0000)
struct FP2MatchStartInfo final
{
public:
	struct FP2GameStateReplicatedTimer            Countdown;                                         // 0x0000(0x0010)(NoDestructor, NativeAccessSpecifierPublic)
	EP2MatchCountdownState                        CountdownState;                                    // 0x0010(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x3];                                       // 0x0011(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FP2MatchStartInfo) == 0x000004, "Wrong alignment on FP2MatchStartInfo");
static_assert(sizeof(FP2MatchStartInfo) == 0x000014, "Wrong size on FP2MatchStartInfo");
static_assert(offsetof(FP2MatchStartInfo, Countdown) == 0x000000, "Member 'FP2MatchStartInfo::Countdown' has a wrong offset!");
static_assert(offsetof(FP2MatchStartInfo, CountdownState) == 0x000010, "Member 'FP2MatchStartInfo::CountdownState' has a wrong offset!");

// ScriptStruct Game.P2ReplicatedProperty_Int32
// 0x0004 (0x0008 - 0x0004)
struct FP2ReplicatedProperty_Int32 final : public FP2ReplicatedProperty
{
public:
	int32                                         Value;                                             // 0x0004(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FP2ReplicatedProperty_Int32) == 0x000004, "Wrong alignment on FP2ReplicatedProperty_Int32");
static_assert(sizeof(FP2ReplicatedProperty_Int32) == 0x000008, "Wrong size on FP2ReplicatedProperty_Int32");
static_assert(offsetof(FP2ReplicatedProperty_Int32, Value) == 0x000004, "Member 'FP2ReplicatedProperty_Int32::Value' has a wrong offset!");

// ScriptStruct Game.P2ShutdownPhaseSetup
// 0x0008 (0x0008 - 0x0000)
struct FP2ShutdownPhaseSetup final
{
public:
	float                                         PhaseStartTime;                                    // 0x0000(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PhaseDuration;                                     // 0x0004(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FP2ShutdownPhaseSetup) == 0x000004, "Wrong alignment on FP2ShutdownPhaseSetup");
static_assert(sizeof(FP2ShutdownPhaseSetup) == 0x000008, "Wrong size on FP2ShutdownPhaseSetup");
static_assert(offsetof(FP2ShutdownPhaseSetup, PhaseStartTime) == 0x000000, "Member 'FP2ShutdownPhaseSetup::PhaseStartTime' has a wrong offset!");
static_assert(offsetof(FP2ShutdownPhaseSetup, PhaseDuration) == 0x000004, "Member 'FP2ShutdownPhaseSetup::PhaseDuration' has a wrong offset!");

// ScriptStruct Game.P2MultiWorldAccess_LoadParameters
// 0x0020 (0x0020 - 0x0000)
struct alignas(0x08) FP2MultiWorldAccess_LoadParameters final
{
public:
	class FName                                   WorldName;                                         // 0x0000(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAutoInitializeWorld;                              // 0x0008(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bStartWithTickEnabled;                             // 0x0009(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAutoHandleWidgets;                                // 0x000A(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCreateDedicatedAudioDevice;                       // 0x000B(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAddNavigationSystem;                              // 0x000C(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bManageLocalPlayers;                               // 0x000D(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_E[0x12];                                       // 0x000E(0x0012)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FP2MultiWorldAccess_LoadParameters) == 0x000008, "Wrong alignment on FP2MultiWorldAccess_LoadParameters");
static_assert(sizeof(FP2MultiWorldAccess_LoadParameters) == 0x000020, "Wrong size on FP2MultiWorldAccess_LoadParameters");
static_assert(offsetof(FP2MultiWorldAccess_LoadParameters, WorldName) == 0x000000, "Member 'FP2MultiWorldAccess_LoadParameters::WorldName' has a wrong offset!");
static_assert(offsetof(FP2MultiWorldAccess_LoadParameters, bAutoInitializeWorld) == 0x000008, "Member 'FP2MultiWorldAccess_LoadParameters::bAutoInitializeWorld' has a wrong offset!");
static_assert(offsetof(FP2MultiWorldAccess_LoadParameters, bStartWithTickEnabled) == 0x000009, "Member 'FP2MultiWorldAccess_LoadParameters::bStartWithTickEnabled' has a wrong offset!");
static_assert(offsetof(FP2MultiWorldAccess_LoadParameters, bAutoHandleWidgets) == 0x00000A, "Member 'FP2MultiWorldAccess_LoadParameters::bAutoHandleWidgets' has a wrong offset!");
static_assert(offsetof(FP2MultiWorldAccess_LoadParameters, bCreateDedicatedAudioDevice) == 0x00000B, "Member 'FP2MultiWorldAccess_LoadParameters::bCreateDedicatedAudioDevice' has a wrong offset!");
static_assert(offsetof(FP2MultiWorldAccess_LoadParameters, bAddNavigationSystem) == 0x00000C, "Member 'FP2MultiWorldAccess_LoadParameters::bAddNavigationSystem' has a wrong offset!");
static_assert(offsetof(FP2MultiWorldAccess_LoadParameters, bManageLocalPlayers) == 0x00000D, "Member 'FP2MultiWorldAccess_LoadParameters::bManageLocalPlayers' has a wrong offset!");

// ScriptStruct Game.P2MoveActionRequirements_Vaulting
// 0x0060 (0x0060 - 0x0000)
struct FP2MoveActionRequirements_Vaulting final
{
public:
	struct FGameplayTag                           Category;                                          // 0x0000(0x0008)(Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FFloatRange                            HeightRange;                                       // 0x0008(0x0010)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FFloatRange                            SpeedRange;                                        // 0x0018(0x0010)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EMoveActionEndStance                          EndStance;                                         // 0x0028(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUseRequiredStartMovementMode;                     // 0x0029(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2A[0x6];                                       // 0x002A(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<EMovementMode>                         RequiredStartMovementModes;                        // 0x0030(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	bool                                          bUseBlockedStartMovementMode;                      // 0x0040(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_41[0x7];                                       // 0x0041(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<EMovementMode>                         BlockedStartMovementModes;                         // 0x0048(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	EMovementMode                                 EndMovementMode;                                   // 0x0058(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_59[0x7];                                       // 0x0059(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FP2MoveActionRequirements_Vaulting) == 0x000008, "Wrong alignment on FP2MoveActionRequirements_Vaulting");
static_assert(sizeof(FP2MoveActionRequirements_Vaulting) == 0x000060, "Wrong size on FP2MoveActionRequirements_Vaulting");
static_assert(offsetof(FP2MoveActionRequirements_Vaulting, Category) == 0x000000, "Member 'FP2MoveActionRequirements_Vaulting::Category' has a wrong offset!");
static_assert(offsetof(FP2MoveActionRequirements_Vaulting, HeightRange) == 0x000008, "Member 'FP2MoveActionRequirements_Vaulting::HeightRange' has a wrong offset!");
static_assert(offsetof(FP2MoveActionRequirements_Vaulting, SpeedRange) == 0x000018, "Member 'FP2MoveActionRequirements_Vaulting::SpeedRange' has a wrong offset!");
static_assert(offsetof(FP2MoveActionRequirements_Vaulting, EndStance) == 0x000028, "Member 'FP2MoveActionRequirements_Vaulting::EndStance' has a wrong offset!");
static_assert(offsetof(FP2MoveActionRequirements_Vaulting, bUseRequiredStartMovementMode) == 0x000029, "Member 'FP2MoveActionRequirements_Vaulting::bUseRequiredStartMovementMode' has a wrong offset!");
static_assert(offsetof(FP2MoveActionRequirements_Vaulting, RequiredStartMovementModes) == 0x000030, "Member 'FP2MoveActionRequirements_Vaulting::RequiredStartMovementModes' has a wrong offset!");
static_assert(offsetof(FP2MoveActionRequirements_Vaulting, bUseBlockedStartMovementMode) == 0x000040, "Member 'FP2MoveActionRequirements_Vaulting::bUseBlockedStartMovementMode' has a wrong offset!");
static_assert(offsetof(FP2MoveActionRequirements_Vaulting, BlockedStartMovementModes) == 0x000048, "Member 'FP2MoveActionRequirements_Vaulting::BlockedStartMovementModes' has a wrong offset!");
static_assert(offsetof(FP2MoveActionRequirements_Vaulting, EndMovementMode) == 0x000058, "Member 'FP2MoveActionRequirements_Vaulting::EndMovementMode' has a wrong offset!");

// ScriptStruct Game.P2AnimSpringEditorSettings
// 0x0030 (0x0030 - 0x0000)
struct FP2AnimSpringEditorSettings final
{
public:
	TSoftClassPtr<class UClass>                   SceneActor;                                        // 0x0000(0x0030)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FP2AnimSpringEditorSettings) == 0x000008, "Wrong alignment on FP2AnimSpringEditorSettings");
static_assert(sizeof(FP2AnimSpringEditorSettings) == 0x000030, "Wrong size on FP2AnimSpringEditorSettings");
static_assert(offsetof(FP2AnimSpringEditorSettings, SceneActor) == 0x000000, "Member 'FP2AnimSpringEditorSettings::SceneActor' has a wrong offset!");

// ScriptStruct Game.P2TagIntPair
// 0x000C (0x000C - 0x0000)
struct FP2TagIntPair final
{
public:
	struct FGameplayTag                           Tag;                                               // 0x0000(0x0008)(BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Value;                                             // 0x0008(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FP2TagIntPair) == 0x000004, "Wrong alignment on FP2TagIntPair");
static_assert(sizeof(FP2TagIntPair) == 0x00000C, "Wrong size on FP2TagIntPair");
static_assert(offsetof(FP2TagIntPair, Tag) == 0x000000, "Member 'FP2TagIntPair::Tag' has a wrong offset!");
static_assert(offsetof(FP2TagIntPair, Value) == 0x000008, "Member 'FP2TagIntPair::Value' has a wrong offset!");

// ScriptStruct Game.P2ItemIdAmountPair
// 0x0014 (0x0014 - 0x0000)
struct FP2ItemIdAmountPair final
{
public:
	struct FPrimaryAssetId                        ItemId;                                            // 0x0000(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Amount;                                            // 0x0010(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FP2ItemIdAmountPair) == 0x000004, "Wrong alignment on FP2ItemIdAmountPair");
static_assert(sizeof(FP2ItemIdAmountPair) == 0x000014, "Wrong size on FP2ItemIdAmountPair");
static_assert(offsetof(FP2ItemIdAmountPair, ItemId) == 0x000000, "Member 'FP2ItemIdAmountPair::ItemId' has a wrong offset!");
static_assert(offsetof(FP2ItemIdAmountPair, Amount) == 0x000010, "Member 'FP2ItemIdAmountPair::Amount' has a wrong offset!");

// ScriptStruct Game.P2RaidResultStateSnapshot
// 0x0048 (0x0048 - 0x0000)
struct FP2RaidResultStateSnapshot final
{
public:
	float                                         TotalEquipmentValue;                               // 0x0000(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ArtifactItemsCount;                                // 0x0004(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Level;                                             // 0x0008(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Experience;                                        // 0x000C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	double                                        NextLevelProgression;                              // 0x0010(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FP2TagIntPair>                  SkillLevels;                                       // 0x0018(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FP2ItemIdAmountPair>            AllItemList;                                       // 0x0028(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FP2ItemIdAmountPair>            InternalItemList;                                  // 0x0038(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FP2RaidResultStateSnapshot) == 0x000008, "Wrong alignment on FP2RaidResultStateSnapshot");
static_assert(sizeof(FP2RaidResultStateSnapshot) == 0x000048, "Wrong size on FP2RaidResultStateSnapshot");
static_assert(offsetof(FP2RaidResultStateSnapshot, TotalEquipmentValue) == 0x000000, "Member 'FP2RaidResultStateSnapshot::TotalEquipmentValue' has a wrong offset!");
static_assert(offsetof(FP2RaidResultStateSnapshot, ArtifactItemsCount) == 0x000004, "Member 'FP2RaidResultStateSnapshot::ArtifactItemsCount' has a wrong offset!");
static_assert(offsetof(FP2RaidResultStateSnapshot, Level) == 0x000008, "Member 'FP2RaidResultStateSnapshot::Level' has a wrong offset!");
static_assert(offsetof(FP2RaidResultStateSnapshot, Experience) == 0x00000C, "Member 'FP2RaidResultStateSnapshot::Experience' has a wrong offset!");
static_assert(offsetof(FP2RaidResultStateSnapshot, NextLevelProgression) == 0x000010, "Member 'FP2RaidResultStateSnapshot::NextLevelProgression' has a wrong offset!");
static_assert(offsetof(FP2RaidResultStateSnapshot, SkillLevels) == 0x000018, "Member 'FP2RaidResultStateSnapshot::SkillLevels' has a wrong offset!");
static_assert(offsetof(FP2RaidResultStateSnapshot, AllItemList) == 0x000028, "Member 'FP2RaidResultStateSnapshot::AllItemList' has a wrong offset!");
static_assert(offsetof(FP2RaidResultStateSnapshot, InternalItemList) == 0x000038, "Member 'FP2RaidResultStateSnapshot::InternalItemList' has a wrong offset!");

// ScriptStruct Game.P2RaidResultNPCKillInfo
// 0x0040 (0x0040 - 0x0000)
struct FP2RaidResultNPCKillInfo final
{
public:
	class FText                                   TargetName;                                        // 0x0000(0x0018)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	class FText                                   TargetLocalKey;                                    // 0x0018(0x0018)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FGameplayTag                           TargetTag;                                         // 0x0030(0x0008)(BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         KillCount;                                         // 0x0038(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3C[0x4];                                       // 0x003C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FP2RaidResultNPCKillInfo) == 0x000008, "Wrong alignment on FP2RaidResultNPCKillInfo");
static_assert(sizeof(FP2RaidResultNPCKillInfo) == 0x000040, "Wrong size on FP2RaidResultNPCKillInfo");
static_assert(offsetof(FP2RaidResultNPCKillInfo, TargetName) == 0x000000, "Member 'FP2RaidResultNPCKillInfo::TargetName' has a wrong offset!");
static_assert(offsetof(FP2RaidResultNPCKillInfo, TargetLocalKey) == 0x000018, "Member 'FP2RaidResultNPCKillInfo::TargetLocalKey' has a wrong offset!");
static_assert(offsetof(FP2RaidResultNPCKillInfo, TargetTag) == 0x000030, "Member 'FP2RaidResultNPCKillInfo::TargetTag' has a wrong offset!");
static_assert(offsetof(FP2RaidResultNPCKillInfo, KillCount) == 0x000038, "Member 'FP2RaidResultNPCKillInfo::KillCount' has a wrong offset!");

// ScriptStruct Game.P2NpcLogInfo
// 0x000C (0x000C - 0x0000)
struct FP2NpcLogInfo final
{
public:
	struct FGameplayTag                           PawnTag;                                           // 0x0000(0x0008)(BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Exp;                                               // 0x0008(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FP2NpcLogInfo) == 0x000004, "Wrong alignment on FP2NpcLogInfo");
static_assert(sizeof(FP2NpcLogInfo) == 0x00000C, "Wrong size on FP2NpcLogInfo");
static_assert(offsetof(FP2NpcLogInfo, PawnTag) == 0x000000, "Member 'FP2NpcLogInfo::PawnTag' has a wrong offset!");
static_assert(offsetof(FP2NpcLogInfo, Exp) == 0x000008, "Member 'FP2NpcLogInfo::Exp' has a wrong offset!");

// ScriptStruct Game.P2RaidResultNPCKillStatistics
// 0x0028 (0x0028 - 0x0000)
struct FP2RaidResultNPCKillStatistics final
{
public:
	int32                                         KillCount;                                         // 0x0000(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         AssistCount;                                       // 0x0004(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FP2RaidResultNPCKillInfo>       KillList;                                          // 0x0008(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FP2NpcLogInfo>                  NpcLogList;                                        // 0x0018(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FP2RaidResultNPCKillStatistics) == 0x000008, "Wrong alignment on FP2RaidResultNPCKillStatistics");
static_assert(sizeof(FP2RaidResultNPCKillStatistics) == 0x000028, "Wrong size on FP2RaidResultNPCKillStatistics");
static_assert(offsetof(FP2RaidResultNPCKillStatistics, KillCount) == 0x000000, "Member 'FP2RaidResultNPCKillStatistics::KillCount' has a wrong offset!");
static_assert(offsetof(FP2RaidResultNPCKillStatistics, AssistCount) == 0x000004, "Member 'FP2RaidResultNPCKillStatistics::AssistCount' has a wrong offset!");
static_assert(offsetof(FP2RaidResultNPCKillStatistics, KillList) == 0x000008, "Member 'FP2RaidResultNPCKillStatistics::KillList' has a wrong offset!");
static_assert(offsetof(FP2RaidResultNPCKillStatistics, NpcLogList) == 0x000018, "Member 'FP2RaidResultNPCKillStatistics::NpcLogList' has a wrong offset!");

// ScriptStruct Game.P2RaidResultKillInfo
// 0x0100 (0x0100 - 0x0000)
struct FP2RaidResultKillInfo final
{
public:
	class FText                                   InstigatorName;                                    // 0x0000(0x0018)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FGameplayTag                           InstigatorType;                                    // 0x0018(0x0008)(BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         InstigatorLevel;                                   // 0x0020(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_24[0x4];                                       // 0x0024(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   TargetName;                                        // 0x0028(0x0018)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FGameplayTag                           WeaponTag;                                         // 0x0040(0x0008)(BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTagContainer                  AttachableTags;                                    // 0x0048(0x0020)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FGameplayTag                           AmmoTag;                                           // 0x0068(0x0008)(BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           TargetWeaponTag;                                   // 0x0070(0x0008)(BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTagContainer                  TargetAttachableTags;                              // 0x0078(0x0020)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FGameplayTag                           TargetAmmoTag;                                     // 0x0098(0x0008)(BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           DamageZoneTag;                                     // 0x00A0(0x0008)(BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           HitMapZoneTag;                                     // 0x00A8(0x0008)(BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           InjuryZoneTag;                                     // 0x00B0(0x0008)(BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           DamageTypeTag;                                     // 0x00B8(0x0008)(BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FinalDamage;                                       // 0x00C0(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DamageArmorAbsorbed;                               // 0x00C4(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FGameplayTag>                   ArmorTagList;                                      // 0x00C8(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FGameplayTagContainer>          ArmorAttachableList;                               // 0x00D8(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<int32>                                 DurabilityList;                                    // 0x00E8(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	int32                                         TimeInRaidSec;                                     // 0x00F8(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         TargetLevel;                                       // 0x00FC(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FP2RaidResultKillInfo) == 0x000008, "Wrong alignment on FP2RaidResultKillInfo");
static_assert(sizeof(FP2RaidResultKillInfo) == 0x000100, "Wrong size on FP2RaidResultKillInfo");
static_assert(offsetof(FP2RaidResultKillInfo, InstigatorName) == 0x000000, "Member 'FP2RaidResultKillInfo::InstigatorName' has a wrong offset!");
static_assert(offsetof(FP2RaidResultKillInfo, InstigatorType) == 0x000018, "Member 'FP2RaidResultKillInfo::InstigatorType' has a wrong offset!");
static_assert(offsetof(FP2RaidResultKillInfo, InstigatorLevel) == 0x000020, "Member 'FP2RaidResultKillInfo::InstigatorLevel' has a wrong offset!");
static_assert(offsetof(FP2RaidResultKillInfo, TargetName) == 0x000028, "Member 'FP2RaidResultKillInfo::TargetName' has a wrong offset!");
static_assert(offsetof(FP2RaidResultKillInfo, WeaponTag) == 0x000040, "Member 'FP2RaidResultKillInfo::WeaponTag' has a wrong offset!");
static_assert(offsetof(FP2RaidResultKillInfo, AttachableTags) == 0x000048, "Member 'FP2RaidResultKillInfo::AttachableTags' has a wrong offset!");
static_assert(offsetof(FP2RaidResultKillInfo, AmmoTag) == 0x000068, "Member 'FP2RaidResultKillInfo::AmmoTag' has a wrong offset!");
static_assert(offsetof(FP2RaidResultKillInfo, TargetWeaponTag) == 0x000070, "Member 'FP2RaidResultKillInfo::TargetWeaponTag' has a wrong offset!");
static_assert(offsetof(FP2RaidResultKillInfo, TargetAttachableTags) == 0x000078, "Member 'FP2RaidResultKillInfo::TargetAttachableTags' has a wrong offset!");
static_assert(offsetof(FP2RaidResultKillInfo, TargetAmmoTag) == 0x000098, "Member 'FP2RaidResultKillInfo::TargetAmmoTag' has a wrong offset!");
static_assert(offsetof(FP2RaidResultKillInfo, DamageZoneTag) == 0x0000A0, "Member 'FP2RaidResultKillInfo::DamageZoneTag' has a wrong offset!");
static_assert(offsetof(FP2RaidResultKillInfo, HitMapZoneTag) == 0x0000A8, "Member 'FP2RaidResultKillInfo::HitMapZoneTag' has a wrong offset!");
static_assert(offsetof(FP2RaidResultKillInfo, InjuryZoneTag) == 0x0000B0, "Member 'FP2RaidResultKillInfo::InjuryZoneTag' has a wrong offset!");
static_assert(offsetof(FP2RaidResultKillInfo, DamageTypeTag) == 0x0000B8, "Member 'FP2RaidResultKillInfo::DamageTypeTag' has a wrong offset!");
static_assert(offsetof(FP2RaidResultKillInfo, FinalDamage) == 0x0000C0, "Member 'FP2RaidResultKillInfo::FinalDamage' has a wrong offset!");
static_assert(offsetof(FP2RaidResultKillInfo, DamageArmorAbsorbed) == 0x0000C4, "Member 'FP2RaidResultKillInfo::DamageArmorAbsorbed' has a wrong offset!");
static_assert(offsetof(FP2RaidResultKillInfo, ArmorTagList) == 0x0000C8, "Member 'FP2RaidResultKillInfo::ArmorTagList' has a wrong offset!");
static_assert(offsetof(FP2RaidResultKillInfo, ArmorAttachableList) == 0x0000D8, "Member 'FP2RaidResultKillInfo::ArmorAttachableList' has a wrong offset!");
static_assert(offsetof(FP2RaidResultKillInfo, DurabilityList) == 0x0000E8, "Member 'FP2RaidResultKillInfo::DurabilityList' has a wrong offset!");
static_assert(offsetof(FP2RaidResultKillInfo, TimeInRaidSec) == 0x0000F8, "Member 'FP2RaidResultKillInfo::TimeInRaidSec' has a wrong offset!");
static_assert(offsetof(FP2RaidResultKillInfo, TargetLevel) == 0x0000FC, "Member 'FP2RaidResultKillInfo::TargetLevel' has a wrong offset!");

// ScriptStruct Game.P2RaidResultPMCKillStatistics
// 0x0028 (0x0028 - 0x0000)
struct FP2RaidResultPMCKillStatistics final
{
public:
	int32                                         KillCount;                                         // 0x0000(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         AssistCount;                                       // 0x0004(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         PlayerBotKillCount;                                // 0x0008(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         PlayerBotAssistCount;                              // 0x000C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         HeadshotKillCount;                                 // 0x0010(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FP2RaidResultKillInfo>          KillList;                                          // 0x0018(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FP2RaidResultPMCKillStatistics) == 0x000008, "Wrong alignment on FP2RaidResultPMCKillStatistics");
static_assert(sizeof(FP2RaidResultPMCKillStatistics) == 0x000028, "Wrong size on FP2RaidResultPMCKillStatistics");
static_assert(offsetof(FP2RaidResultPMCKillStatistics, KillCount) == 0x000000, "Member 'FP2RaidResultPMCKillStatistics::KillCount' has a wrong offset!");
static_assert(offsetof(FP2RaidResultPMCKillStatistics, AssistCount) == 0x000004, "Member 'FP2RaidResultPMCKillStatistics::AssistCount' has a wrong offset!");
static_assert(offsetof(FP2RaidResultPMCKillStatistics, PlayerBotKillCount) == 0x000008, "Member 'FP2RaidResultPMCKillStatistics::PlayerBotKillCount' has a wrong offset!");
static_assert(offsetof(FP2RaidResultPMCKillStatistics, PlayerBotAssistCount) == 0x00000C, "Member 'FP2RaidResultPMCKillStatistics::PlayerBotAssistCount' has a wrong offset!");
static_assert(offsetof(FP2RaidResultPMCKillStatistics, HeadshotKillCount) == 0x000010, "Member 'FP2RaidResultPMCKillStatistics::HeadshotKillCount' has a wrong offset!");
static_assert(offsetof(FP2RaidResultPMCKillStatistics, KillList) == 0x000018, "Member 'FP2RaidResultPMCKillStatistics::KillList' has a wrong offset!");

// ScriptStruct Game.P2RaidResultDamageDetailInfo
// 0x0068 (0x0068 - 0x0000)
struct FP2RaidResultDamageDetailInfo final
{
public:
	class FText                                   InstigatorName;                                    // 0x0000(0x0018)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	class FText                                   TargetName;                                        // 0x0018(0x0018)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FGameplayTag                           HitMapZoneTag;                                     // 0x0030(0x0008)(BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           DamageZoneTag;                                     // 0x0038(0x0008)(BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FinalDamage;                                       // 0x0040(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DamageArmorAbsorbed;                               // 0x0044(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           InjuryZoneTag;                                     // 0x0048(0x0008)(BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           DamageTypeTag;                                     // 0x0050(0x0008)(BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FDateTime                              Time;                                              // 0x0058(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bWasDamageApplied;                                 // 0x0060(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_61[0x7];                                       // 0x0061(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FP2RaidResultDamageDetailInfo) == 0x000008, "Wrong alignment on FP2RaidResultDamageDetailInfo");
static_assert(sizeof(FP2RaidResultDamageDetailInfo) == 0x000068, "Wrong size on FP2RaidResultDamageDetailInfo");
static_assert(offsetof(FP2RaidResultDamageDetailInfo, InstigatorName) == 0x000000, "Member 'FP2RaidResultDamageDetailInfo::InstigatorName' has a wrong offset!");
static_assert(offsetof(FP2RaidResultDamageDetailInfo, TargetName) == 0x000018, "Member 'FP2RaidResultDamageDetailInfo::TargetName' has a wrong offset!");
static_assert(offsetof(FP2RaidResultDamageDetailInfo, HitMapZoneTag) == 0x000030, "Member 'FP2RaidResultDamageDetailInfo::HitMapZoneTag' has a wrong offset!");
static_assert(offsetof(FP2RaidResultDamageDetailInfo, DamageZoneTag) == 0x000038, "Member 'FP2RaidResultDamageDetailInfo::DamageZoneTag' has a wrong offset!");
static_assert(offsetof(FP2RaidResultDamageDetailInfo, FinalDamage) == 0x000040, "Member 'FP2RaidResultDamageDetailInfo::FinalDamage' has a wrong offset!");
static_assert(offsetof(FP2RaidResultDamageDetailInfo, DamageArmorAbsorbed) == 0x000044, "Member 'FP2RaidResultDamageDetailInfo::DamageArmorAbsorbed' has a wrong offset!");
static_assert(offsetof(FP2RaidResultDamageDetailInfo, InjuryZoneTag) == 0x000048, "Member 'FP2RaidResultDamageDetailInfo::InjuryZoneTag' has a wrong offset!");
static_assert(offsetof(FP2RaidResultDamageDetailInfo, DamageTypeTag) == 0x000050, "Member 'FP2RaidResultDamageDetailInfo::DamageTypeTag' has a wrong offset!");
static_assert(offsetof(FP2RaidResultDamageDetailInfo, Time) == 0x000058, "Member 'FP2RaidResultDamageDetailInfo::Time' has a wrong offset!");
static_assert(offsetof(FP2RaidResultDamageDetailInfo, bWasDamageApplied) == 0x000060, "Member 'FP2RaidResultDamageDetailInfo::bWasDamageApplied' has a wrong offset!");

// ScriptStruct Game.P2RaidResultStatistics
// 0x0240 (0x0240 - 0x0000)
struct FP2RaidResultStatistics final
{
public:
	float                                         DistanceTraveled;                                  // 0x0000(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FP2RaidResultNPCKillStatistics         NPCKillStatistics;                                 // 0x0008(0x0028)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FP2RaidResultPMCKillStatistics         PMCKillStatistics;                                 // 0x0030(0x0028)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	int32                                         NPCBossKillCount;                                  // 0x0058(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ConfirmedFinalLevel;                               // 0x005C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         LootExperienceGained;                              // 0x0060(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         PMCKillExperienceGained;                           // 0x0064(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         NPCKillExperienceGained;                           // 0x0068(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ExtractedExperienceGained;                         // 0x006C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         DBNORevivedExperienceGained;                       // 0x0070(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         VisitLocationExperienceGained;                     // 0x0074(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         TimeSpentExperienceGained;                         // 0x0078(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         PMCWeaknessKillExperienceGained;                   // 0x007C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         NPCWeaknessKillExperienceGained;                   // 0x0080(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PMCDealtDamage;                                    // 0x0084(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PlayerBotDealtDamage;                              // 0x0088(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         NPCDealtDamage;                                    // 0x008C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         UsedAmmo;                                          // 0x0090(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         SpectateTime;                                      // 0x0094(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FP2RaidResultKillInfo                  InstigatorInfo;                                    // 0x0098(0x0100)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	TArray<struct FP2RaidResultDamageDetailInfo>  MyDamageDetailList;                                // 0x0198(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FP2RaidResultDamageDetailInfo>  PMCDamageDetailList;                               // 0x01A8(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	float                                         TimeInRaidSec;                                     // 0x01B8(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ContractsCompleted;                                // 0x01BC(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ReviveTeamMemberCount;                             // 0x01C0(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         RevivedCount;                                      // 0x01C4(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         DBNOCount;                                         // 0x01C8(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1CC[0x4];                                      // 0x01CC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FGameplayTag>                   ArmorTagList;                                      // 0x01D0(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FGameplayTagContainer>          ArmorAttachableList;                               // 0x01E0(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<int32>                                 DurabilityList;                                    // 0x01F0(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	bool                                          bExfiltrated;                                      // 0x0200(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_201[0x7];                                      // 0x0201(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   DeathReason;                                       // 0x0208(0x0018)(BlueprintVisible, BlueprintReadOnly, Transient, NativeAccessSpecifierPublic)
	struct FGameplayTag                           DeathReasonTag;                                    // 0x0220(0x0008)(BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   DeathReasonStringTableId;                          // 0x0228(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 DeathReasonStringTableKey;                         // 0x0230(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FP2RaidResultStatistics) == 0x000008, "Wrong alignment on FP2RaidResultStatistics");
static_assert(sizeof(FP2RaidResultStatistics) == 0x000240, "Wrong size on FP2RaidResultStatistics");
static_assert(offsetof(FP2RaidResultStatistics, DistanceTraveled) == 0x000000, "Member 'FP2RaidResultStatistics::DistanceTraveled' has a wrong offset!");
static_assert(offsetof(FP2RaidResultStatistics, NPCKillStatistics) == 0x000008, "Member 'FP2RaidResultStatistics::NPCKillStatistics' has a wrong offset!");
static_assert(offsetof(FP2RaidResultStatistics, PMCKillStatistics) == 0x000030, "Member 'FP2RaidResultStatistics::PMCKillStatistics' has a wrong offset!");
static_assert(offsetof(FP2RaidResultStatistics, NPCBossKillCount) == 0x000058, "Member 'FP2RaidResultStatistics::NPCBossKillCount' has a wrong offset!");
static_assert(offsetof(FP2RaidResultStatistics, ConfirmedFinalLevel) == 0x00005C, "Member 'FP2RaidResultStatistics::ConfirmedFinalLevel' has a wrong offset!");
static_assert(offsetof(FP2RaidResultStatistics, LootExperienceGained) == 0x000060, "Member 'FP2RaidResultStatistics::LootExperienceGained' has a wrong offset!");
static_assert(offsetof(FP2RaidResultStatistics, PMCKillExperienceGained) == 0x000064, "Member 'FP2RaidResultStatistics::PMCKillExperienceGained' has a wrong offset!");
static_assert(offsetof(FP2RaidResultStatistics, NPCKillExperienceGained) == 0x000068, "Member 'FP2RaidResultStatistics::NPCKillExperienceGained' has a wrong offset!");
static_assert(offsetof(FP2RaidResultStatistics, ExtractedExperienceGained) == 0x00006C, "Member 'FP2RaidResultStatistics::ExtractedExperienceGained' has a wrong offset!");
static_assert(offsetof(FP2RaidResultStatistics, DBNORevivedExperienceGained) == 0x000070, "Member 'FP2RaidResultStatistics::DBNORevivedExperienceGained' has a wrong offset!");
static_assert(offsetof(FP2RaidResultStatistics, VisitLocationExperienceGained) == 0x000074, "Member 'FP2RaidResultStatistics::VisitLocationExperienceGained' has a wrong offset!");
static_assert(offsetof(FP2RaidResultStatistics, TimeSpentExperienceGained) == 0x000078, "Member 'FP2RaidResultStatistics::TimeSpentExperienceGained' has a wrong offset!");
static_assert(offsetof(FP2RaidResultStatistics, PMCWeaknessKillExperienceGained) == 0x00007C, "Member 'FP2RaidResultStatistics::PMCWeaknessKillExperienceGained' has a wrong offset!");
static_assert(offsetof(FP2RaidResultStatistics, NPCWeaknessKillExperienceGained) == 0x000080, "Member 'FP2RaidResultStatistics::NPCWeaknessKillExperienceGained' has a wrong offset!");
static_assert(offsetof(FP2RaidResultStatistics, PMCDealtDamage) == 0x000084, "Member 'FP2RaidResultStatistics::PMCDealtDamage' has a wrong offset!");
static_assert(offsetof(FP2RaidResultStatistics, PlayerBotDealtDamage) == 0x000088, "Member 'FP2RaidResultStatistics::PlayerBotDealtDamage' has a wrong offset!");
static_assert(offsetof(FP2RaidResultStatistics, NPCDealtDamage) == 0x00008C, "Member 'FP2RaidResultStatistics::NPCDealtDamage' has a wrong offset!");
static_assert(offsetof(FP2RaidResultStatistics, UsedAmmo) == 0x000090, "Member 'FP2RaidResultStatistics::UsedAmmo' has a wrong offset!");
static_assert(offsetof(FP2RaidResultStatistics, SpectateTime) == 0x000094, "Member 'FP2RaidResultStatistics::SpectateTime' has a wrong offset!");
static_assert(offsetof(FP2RaidResultStatistics, InstigatorInfo) == 0x000098, "Member 'FP2RaidResultStatistics::InstigatorInfo' has a wrong offset!");
static_assert(offsetof(FP2RaidResultStatistics, MyDamageDetailList) == 0x000198, "Member 'FP2RaidResultStatistics::MyDamageDetailList' has a wrong offset!");
static_assert(offsetof(FP2RaidResultStatistics, PMCDamageDetailList) == 0x0001A8, "Member 'FP2RaidResultStatistics::PMCDamageDetailList' has a wrong offset!");
static_assert(offsetof(FP2RaidResultStatistics, TimeInRaidSec) == 0x0001B8, "Member 'FP2RaidResultStatistics::TimeInRaidSec' has a wrong offset!");
static_assert(offsetof(FP2RaidResultStatistics, ContractsCompleted) == 0x0001BC, "Member 'FP2RaidResultStatistics::ContractsCompleted' has a wrong offset!");
static_assert(offsetof(FP2RaidResultStatistics, ReviveTeamMemberCount) == 0x0001C0, "Member 'FP2RaidResultStatistics::ReviveTeamMemberCount' has a wrong offset!");
static_assert(offsetof(FP2RaidResultStatistics, RevivedCount) == 0x0001C4, "Member 'FP2RaidResultStatistics::RevivedCount' has a wrong offset!");
static_assert(offsetof(FP2RaidResultStatistics, DBNOCount) == 0x0001C8, "Member 'FP2RaidResultStatistics::DBNOCount' has a wrong offset!");
static_assert(offsetof(FP2RaidResultStatistics, ArmorTagList) == 0x0001D0, "Member 'FP2RaidResultStatistics::ArmorTagList' has a wrong offset!");
static_assert(offsetof(FP2RaidResultStatistics, ArmorAttachableList) == 0x0001E0, "Member 'FP2RaidResultStatistics::ArmorAttachableList' has a wrong offset!");
static_assert(offsetof(FP2RaidResultStatistics, DurabilityList) == 0x0001F0, "Member 'FP2RaidResultStatistics::DurabilityList' has a wrong offset!");
static_assert(offsetof(FP2RaidResultStatistics, bExfiltrated) == 0x000200, "Member 'FP2RaidResultStatistics::bExfiltrated' has a wrong offset!");
static_assert(offsetof(FP2RaidResultStatistics, DeathReason) == 0x000208, "Member 'FP2RaidResultStatistics::DeathReason' has a wrong offset!");
static_assert(offsetof(FP2RaidResultStatistics, DeathReasonTag) == 0x000220, "Member 'FP2RaidResultStatistics::DeathReasonTag' has a wrong offset!");
static_assert(offsetof(FP2RaidResultStatistics, DeathReasonStringTableId) == 0x000228, "Member 'FP2RaidResultStatistics::DeathReasonStringTableId' has a wrong offset!");
static_assert(offsetof(FP2RaidResultStatistics, DeathReasonStringTableKey) == 0x000230, "Member 'FP2RaidResultStatistics::DeathReasonStringTableKey' has a wrong offset!");

// ScriptStruct Game.P2RaidResultRecord
// 0x02F8 (0x02F8 - 0x0000)
struct FP2RaidResultRecord final
{
public:
	struct FDateTime                              Start;                                             // 0x0000(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FDateTime                              End;                                               // 0x0008(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         TeamMemberCount;                                   // 0x0010(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FP2RaidResultStateSnapshot             BaseSnapshot;                                      // 0x0018(0x0048)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FP2RaidResultStateSnapshot             FinalSnapshot;                                     // 0x0060(0x0048)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FP2RaidResultStatistics                Stats;                                             // 0x00A8(0x0240)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	TArray<struct FP2RaidResultChallenge>         Challenges;                                        // 0x02E8(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FP2RaidResultRecord) == 0x000008, "Wrong alignment on FP2RaidResultRecord");
static_assert(sizeof(FP2RaidResultRecord) == 0x0002F8, "Wrong size on FP2RaidResultRecord");
static_assert(offsetof(FP2RaidResultRecord, Start) == 0x000000, "Member 'FP2RaidResultRecord::Start' has a wrong offset!");
static_assert(offsetof(FP2RaidResultRecord, End) == 0x000008, "Member 'FP2RaidResultRecord::End' has a wrong offset!");
static_assert(offsetof(FP2RaidResultRecord, TeamMemberCount) == 0x000010, "Member 'FP2RaidResultRecord::TeamMemberCount' has a wrong offset!");
static_assert(offsetof(FP2RaidResultRecord, BaseSnapshot) == 0x000018, "Member 'FP2RaidResultRecord::BaseSnapshot' has a wrong offset!");
static_assert(offsetof(FP2RaidResultRecord, FinalSnapshot) == 0x000060, "Member 'FP2RaidResultRecord::FinalSnapshot' has a wrong offset!");
static_assert(offsetof(FP2RaidResultRecord, Stats) == 0x0000A8, "Member 'FP2RaidResultRecord::Stats' has a wrong offset!");
static_assert(offsetof(FP2RaidResultRecord, Challenges) == 0x0002E8, "Member 'FP2RaidResultRecord::Challenges' has a wrong offset!");

// ScriptStruct Game.P2GameplayCueNotify_SpawnCondition
// 0x0048 (0x0048 - 0x0000)
struct FP2GameplayCueNotify_SpawnCondition final
{
public:
	EP2GameplayCueNotify_LocallyControlledSource  LocallyControlledSource;                           // 0x0000(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EP2GameplayCueNotify_LocallyControlledPolicy  LocallyControlledPolicy;                           // 0x0001(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2[0x2];                                        // 0x0002(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ChanceToPlay;                                      // 0x0004(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTagContainer                  AllowedSurfaceTags;                                // 0x0008(0x0020)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FGameplayTagContainer                  RejectedSurfaceTags;                               // 0x0028(0x0020)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
};
static_assert(alignof(FP2GameplayCueNotify_SpawnCondition) == 0x000008, "Wrong alignment on FP2GameplayCueNotify_SpawnCondition");
static_assert(sizeof(FP2GameplayCueNotify_SpawnCondition) == 0x000048, "Wrong size on FP2GameplayCueNotify_SpawnCondition");
static_assert(offsetof(FP2GameplayCueNotify_SpawnCondition, LocallyControlledSource) == 0x000000, "Member 'FP2GameplayCueNotify_SpawnCondition::LocallyControlledSource' has a wrong offset!");
static_assert(offsetof(FP2GameplayCueNotify_SpawnCondition, LocallyControlledPolicy) == 0x000001, "Member 'FP2GameplayCueNotify_SpawnCondition::LocallyControlledPolicy' has a wrong offset!");
static_assert(offsetof(FP2GameplayCueNotify_SpawnCondition, ChanceToPlay) == 0x000004, "Member 'FP2GameplayCueNotify_SpawnCondition::ChanceToPlay' has a wrong offset!");
static_assert(offsetof(FP2GameplayCueNotify_SpawnCondition, AllowedSurfaceTags) == 0x000008, "Member 'FP2GameplayCueNotify_SpawnCondition::AllowedSurfaceTags' has a wrong offset!");
static_assert(offsetof(FP2GameplayCueNotify_SpawnCondition, RejectedSurfaceTags) == 0x000028, "Member 'FP2GameplayCueNotify_SpawnCondition::RejectedSurfaceTags' has a wrong offset!");

// ScriptStruct Game.P2GameplayCueNotify_PlacementInfo
// 0x0040 (0x0040 - 0x0000)
struct FP2GameplayCueNotify_PlacementInfo final
{
public:
	class FName                                   SocketName;                                        // 0x0000(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EP2GameplayCueNotify_AttachPolicy             AttachPolicy;                                      // 0x0008(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EAttachmentRule                               AttachmentRule;                                    // 0x0009(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A[0x2];                                        // 0x000A(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	uint8                                         bOverrideRotation : 1;                             // 0x000C(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bOverrideScale : 1;                                // 0x000C(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_D[0x3];                                        // 0x000D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRotator                               RotationOverride;                                  // 0x0010(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FVector                                ScaleOverride;                                     // 0x0028(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FP2GameplayCueNotify_PlacementInfo) == 0x000008, "Wrong alignment on FP2GameplayCueNotify_PlacementInfo");
static_assert(sizeof(FP2GameplayCueNotify_PlacementInfo) == 0x000040, "Wrong size on FP2GameplayCueNotify_PlacementInfo");
static_assert(offsetof(FP2GameplayCueNotify_PlacementInfo, SocketName) == 0x000000, "Member 'FP2GameplayCueNotify_PlacementInfo::SocketName' has a wrong offset!");
static_assert(offsetof(FP2GameplayCueNotify_PlacementInfo, AttachPolicy) == 0x000008, "Member 'FP2GameplayCueNotify_PlacementInfo::AttachPolicy' has a wrong offset!");
static_assert(offsetof(FP2GameplayCueNotify_PlacementInfo, AttachmentRule) == 0x000009, "Member 'FP2GameplayCueNotify_PlacementInfo::AttachmentRule' has a wrong offset!");
static_assert(offsetof(FP2GameplayCueNotify_PlacementInfo, RotationOverride) == 0x000010, "Member 'FP2GameplayCueNotify_PlacementInfo::RotationOverride' has a wrong offset!");
static_assert(offsetof(FP2GameplayCueNotify_PlacementInfo, ScaleOverride) == 0x000028, "Member 'FP2GameplayCueNotify_PlacementInfo::ScaleOverride' has a wrong offset!");

// ScriptStruct Game.P2GameplayCueNotify_NiagaraVariation
// 0x0058 (0x0058 - 0x0000)
struct FP2GameplayCueNotify_NiagaraVariation final
{
public:
	class UNiagaraSystem*                         Value;                                             // 0x0000(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TMap<struct FGameplayTag, class UNiagaraSystem*> Variations;                                     // 0x0008(0x0050)(Edit, BlueprintVisible, DisableEditOnInstance, UObjectWrapper, NativeAccessSpecifierPublic)
};
static_assert(alignof(FP2GameplayCueNotify_NiagaraVariation) == 0x000008, "Wrong alignment on FP2GameplayCueNotify_NiagaraVariation");
static_assert(sizeof(FP2GameplayCueNotify_NiagaraVariation) == 0x000058, "Wrong size on FP2GameplayCueNotify_NiagaraVariation");
static_assert(offsetof(FP2GameplayCueNotify_NiagaraVariation, Value) == 0x000000, "Member 'FP2GameplayCueNotify_NiagaraVariation::Value' has a wrong offset!");
static_assert(offsetof(FP2GameplayCueNotify_NiagaraVariation, Variations) == 0x000008, "Member 'FP2GameplayCueNotify_NiagaraVariation::Variations' has a wrong offset!");

// ScriptStruct Game.P2GameplayCueNotify_NiagaraSet
// 0x0058 (0x0058 - 0x0000)
struct FP2GameplayCueNotify_NiagaraSet final
{
public:
	class UNiagaraSystem*                         Default;                                           // 0x0000(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TMap<struct FGameplayTag, struct FP2GameplayCueNotify_NiagaraVariation> NiagaraSystemMap;        // 0x0008(0x0050)(Edit, BlueprintVisible, DisableEditOnInstance, NativeAccessSpecifierPublic)
};
static_assert(alignof(FP2GameplayCueNotify_NiagaraSet) == 0x000008, "Wrong alignment on FP2GameplayCueNotify_NiagaraSet");
static_assert(sizeof(FP2GameplayCueNotify_NiagaraSet) == 0x000058, "Wrong size on FP2GameplayCueNotify_NiagaraSet");
static_assert(offsetof(FP2GameplayCueNotify_NiagaraSet, Default) == 0x000000, "Member 'FP2GameplayCueNotify_NiagaraSet::Default' has a wrong offset!");
static_assert(offsetof(FP2GameplayCueNotify_NiagaraSet, NiagaraSystemMap) == 0x000008, "Member 'FP2GameplayCueNotify_NiagaraSet::NiagaraSystemMap' has a wrong offset!");

// ScriptStruct Game.P2GameplayCueNotify_ParticleInfo
// 0x00F8 (0x00F8 - 0x0000)
struct FP2GameplayCueNotify_ParticleInfo final
{
public:
	struct FP2GameplayCueNotify_SpawnCondition    SpawnConditionOverride;                            // 0x0000(0x0048)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FP2GameplayCueNotify_PlacementInfo     PlacementInfoOverride;                             // 0x0048(0x0040)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
	struct FP2GameplayCueNotify_NiagaraSet        NiagaraSystem;                                     // 0x0088(0x0058)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FDataRegistryId                        NiagaraSystemInDataRegistry;                       // 0x00E0(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverrideSpawnCondition : 1;                       // 0x00F0(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bOverridePlacementInfo : 1;                        // 0x00F0(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bUseDataRegistry : 1;                              // 0x00F0(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bCastShadow : 1;                                   // 0x00F0(0x0001)(BitIndex: 0x03, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_F1[0x7];                                       // 0x00F1(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FP2GameplayCueNotify_ParticleInfo) == 0x000008, "Wrong alignment on FP2GameplayCueNotify_ParticleInfo");
static_assert(sizeof(FP2GameplayCueNotify_ParticleInfo) == 0x0000F8, "Wrong size on FP2GameplayCueNotify_ParticleInfo");
static_assert(offsetof(FP2GameplayCueNotify_ParticleInfo, SpawnConditionOverride) == 0x000000, "Member 'FP2GameplayCueNotify_ParticleInfo::SpawnConditionOverride' has a wrong offset!");
static_assert(offsetof(FP2GameplayCueNotify_ParticleInfo, PlacementInfoOverride) == 0x000048, "Member 'FP2GameplayCueNotify_ParticleInfo::PlacementInfoOverride' has a wrong offset!");
static_assert(offsetof(FP2GameplayCueNotify_ParticleInfo, NiagaraSystem) == 0x000088, "Member 'FP2GameplayCueNotify_ParticleInfo::NiagaraSystem' has a wrong offset!");
static_assert(offsetof(FP2GameplayCueNotify_ParticleInfo, NiagaraSystemInDataRegistry) == 0x0000E0, "Member 'FP2GameplayCueNotify_ParticleInfo::NiagaraSystemInDataRegistry' has a wrong offset!");

// ScriptStruct Game.P2GameplayContextRequirementItemRequirements
// 0x0003 (0x0003 - 0x0000)
struct FP2GameplayContextRequirementItemRequirements final
{
public:
	bool                                          ShouldCraftMaterial;                               // 0x0000(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ShouldResearchMaterial;                            // 0x0001(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ShouldUpsellable;                                  // 0x0002(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FP2GameplayContextRequirementItemRequirements) == 0x000001, "Wrong alignment on FP2GameplayContextRequirementItemRequirements");
static_assert(sizeof(FP2GameplayContextRequirementItemRequirements) == 0x000003, "Wrong size on FP2GameplayContextRequirementItemRequirements");
static_assert(offsetof(FP2GameplayContextRequirementItemRequirements, ShouldCraftMaterial) == 0x000000, "Member 'FP2GameplayContextRequirementItemRequirements::ShouldCraftMaterial' has a wrong offset!");
static_assert(offsetof(FP2GameplayContextRequirementItemRequirements, ShouldResearchMaterial) == 0x000001, "Member 'FP2GameplayContextRequirementItemRequirements::ShouldResearchMaterial' has a wrong offset!");
static_assert(offsetof(FP2GameplayContextRequirementItemRequirements, ShouldUpsellable) == 0x000002, "Member 'FP2GameplayContextRequirementItemRequirements::ShouldUpsellable' has a wrong offset!");

// ScriptStruct Game.P2ItemIconSubscriber
// 0x0010 (0x0010 - 0x0000)
struct alignas(0x08) FP2ItemIconSubscriber final
{
public:
	uint8                                         Pad_0[0x10];                                       // 0x0000(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FP2ItemIconSubscriber) == 0x000008, "Wrong alignment on FP2ItemIconSubscriber");
static_assert(sizeof(FP2ItemIconSubscriber) == 0x000010, "Wrong size on FP2ItemIconSubscriber");

// ScriptStruct Game.P2AUVComponentState
// 0x00A0 (0x00A0 - 0x0000)
struct FP2AUVComponentState final
{
public:
	class USceneComponent*                        AttachScene;                                       // 0x0000(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           Stage;                                             // 0x0008(0x0008)(Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                RelativeOffset;                                    // 0x0010(0x0018)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_28[0x8];                                       // 0x0028(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             IdleTM;                                            // 0x0030(0x0060)(Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUnarm;                                            // 0x0090(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_91[0xF];                                       // 0x0091(0x000F)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FP2AUVComponentState) == 0x000010, "Wrong alignment on FP2AUVComponentState");
static_assert(sizeof(FP2AUVComponentState) == 0x0000A0, "Wrong size on FP2AUVComponentState");
static_assert(offsetof(FP2AUVComponentState, AttachScene) == 0x000000, "Member 'FP2AUVComponentState::AttachScene' has a wrong offset!");
static_assert(offsetof(FP2AUVComponentState, Stage) == 0x000008, "Member 'FP2AUVComponentState::Stage' has a wrong offset!");
static_assert(offsetof(FP2AUVComponentState, RelativeOffset) == 0x000010, "Member 'FP2AUVComponentState::RelativeOffset' has a wrong offset!");
static_assert(offsetof(FP2AUVComponentState, IdleTM) == 0x000030, "Member 'FP2AUVComponentState::IdleTM' has a wrong offset!");
static_assert(offsetof(FP2AUVComponentState, bUnarm) == 0x000090, "Member 'FP2AUVComponentState::bUnarm' has a wrong offset!");

// ScriptStruct Game.P2ReplicatedProperty_Float
// 0x0004 (0x0008 - 0x0004)
struct FP2ReplicatedProperty_Float final : public FP2ReplicatedProperty
{
public:
	float                                         Value;                                             // 0x0004(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FP2ReplicatedProperty_Float) == 0x000004, "Wrong alignment on FP2ReplicatedProperty_Float");
static_assert(sizeof(FP2ReplicatedProperty_Float) == 0x000008, "Wrong size on FP2ReplicatedProperty_Float");
static_assert(offsetof(FP2ReplicatedProperty_Float, Value) == 0x000004, "Member 'FP2ReplicatedProperty_Float::Value' has a wrong offset!");

// ScriptStruct Game.P2InputActionKeyTriggerName
// 0x0030 (0x0030 - 0x0000)
struct FP2InputActionKeyTriggerName final
{
public:
	class FText                                   KeyName;                                           // 0x0000(0x0018)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	class FText                                   InputTriggerName;                                  // 0x0018(0x0018)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
};
static_assert(alignof(FP2InputActionKeyTriggerName) == 0x000008, "Wrong alignment on FP2InputActionKeyTriggerName");
static_assert(sizeof(FP2InputActionKeyTriggerName) == 0x000030, "Wrong size on FP2InputActionKeyTriggerName");
static_assert(offsetof(FP2InputActionKeyTriggerName, KeyName) == 0x000000, "Member 'FP2InputActionKeyTriggerName::KeyName' has a wrong offset!");
static_assert(offsetof(FP2InputActionKeyTriggerName, InputTriggerName) == 0x000018, "Member 'FP2InputActionKeyTriggerName::InputTriggerName' has a wrong offset!");

// ScriptStruct Game.P2LootSpawnRatioBase
// 0x0004 (0x0004 - 0x0000)
struct FP2LootSpawnRatioBase
{
public:
	float                                         Ratio;                                             // 0x0000(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FP2LootSpawnRatioBase) == 0x000004, "Wrong alignment on FP2LootSpawnRatioBase");
static_assert(sizeof(FP2LootSpawnRatioBase) == 0x000004, "Wrong size on FP2LootSpawnRatioBase");
static_assert(offsetof(FP2LootSpawnRatioBase, Ratio) == 0x000000, "Member 'FP2LootSpawnRatioBase::Ratio' has a wrong offset!");

// ScriptStruct Game.P2StatusEffectSoundPrioritySettings
// 0x0038 (0x0038 - 0x0000)
struct FP2StatusEffectSoundPrioritySettings final
{
public:
	uint32                                        TransitionPriority;                                // 0x0000(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          AlwaysAllowTransitions;                            // 0x0004(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5[0x3];                                        // 0x0005(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	uint32                                        ContinuousPriority;                                // 0x0008(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint32                                        RecurringPriority;                                 // 0x000C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint32                                        BusEffectPriority;                                 // 0x0010(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTagContainer                  AllowedStatusEffects;                              // 0x0018(0x0020)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
};
static_assert(alignof(FP2StatusEffectSoundPrioritySettings) == 0x000008, "Wrong alignment on FP2StatusEffectSoundPrioritySettings");
static_assert(sizeof(FP2StatusEffectSoundPrioritySettings) == 0x000038, "Wrong size on FP2StatusEffectSoundPrioritySettings");
static_assert(offsetof(FP2StatusEffectSoundPrioritySettings, TransitionPriority) == 0x000000, "Member 'FP2StatusEffectSoundPrioritySettings::TransitionPriority' has a wrong offset!");
static_assert(offsetof(FP2StatusEffectSoundPrioritySettings, AlwaysAllowTransitions) == 0x000004, "Member 'FP2StatusEffectSoundPrioritySettings::AlwaysAllowTransitions' has a wrong offset!");
static_assert(offsetof(FP2StatusEffectSoundPrioritySettings, ContinuousPriority) == 0x000008, "Member 'FP2StatusEffectSoundPrioritySettings::ContinuousPriority' has a wrong offset!");
static_assert(offsetof(FP2StatusEffectSoundPrioritySettings, RecurringPriority) == 0x00000C, "Member 'FP2StatusEffectSoundPrioritySettings::RecurringPriority' has a wrong offset!");
static_assert(offsetof(FP2StatusEffectSoundPrioritySettings, BusEffectPriority) == 0x000010, "Member 'FP2StatusEffectSoundPrioritySettings::BusEffectPriority' has a wrong offset!");
static_assert(offsetof(FP2StatusEffectSoundPrioritySettings, AllowedStatusEffects) == 0x000018, "Member 'FP2StatusEffectSoundPrioritySettings::AllowedStatusEffects' has a wrong offset!");

// ScriptStruct Game.P2TargetData_ChangeWeapon
// 0x0028 (0x0030 - 0x0008)
struct FP2TargetData_ChangeWeapon final : public FGameplayAbilityTargetData
{
public:
	uint8                                         Pad_8[0x28];                                       // 0x0008(0x0028)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FP2TargetData_ChangeWeapon) == 0x000008, "Wrong alignment on FP2TargetData_ChangeWeapon");
static_assert(sizeof(FP2TargetData_ChangeWeapon) == 0x000030, "Wrong size on FP2TargetData_ChangeWeapon");

// ScriptStruct Game.RuntimeControlRecoilCurve
// 0x0188 (0x0188 - 0x0000)
struct FRuntimeControlRecoilCurve final
{
public:
	struct FRichCurve                             RecoilCurves[0x3];                                 // 0x0000(0x0080)(NativeAccessSpecifierPublic)
	class UP2ControlRecoilCurve*                  ExternalCurve;                                     // 0x0180(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRuntimeControlRecoilCurve) == 0x000008, "Wrong alignment on FRuntimeControlRecoilCurve");
static_assert(sizeof(FRuntimeControlRecoilCurve) == 0x000188, "Wrong size on FRuntimeControlRecoilCurve");
static_assert(offsetof(FRuntimeControlRecoilCurve, RecoilCurves) == 0x000000, "Member 'FRuntimeControlRecoilCurve::RecoilCurves' has a wrong offset!");
static_assert(offsetof(FRuntimeControlRecoilCurve, ExternalCurve) == 0x000180, "Member 'FRuntimeControlRecoilCurve::ExternalCurve' has a wrong offset!");

// ScriptStruct Game.P2AkPlayingEventInfo
// 0x0030 (0x0030 - 0x0000)
struct FP2AkPlayingEventInfo final
{
public:
	int32                                         PlayingID;                                         // 0x0000(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           UsedTag;                                           // 0x0004(0x0008)(BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class AActor*                                 Target;                                            // 0x0010(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAkAudioEvent*                          StopEvent;                                         // 0x0018(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           ComponentTag;                                      // 0x0020(0x0008)(BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_28[0x8];                                       // 0x0028(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FP2AkPlayingEventInfo) == 0x000008, "Wrong alignment on FP2AkPlayingEventInfo");
static_assert(sizeof(FP2AkPlayingEventInfo) == 0x000030, "Wrong size on FP2AkPlayingEventInfo");
static_assert(offsetof(FP2AkPlayingEventInfo, PlayingID) == 0x000000, "Member 'FP2AkPlayingEventInfo::PlayingID' has a wrong offset!");
static_assert(offsetof(FP2AkPlayingEventInfo, UsedTag) == 0x000004, "Member 'FP2AkPlayingEventInfo::UsedTag' has a wrong offset!");
static_assert(offsetof(FP2AkPlayingEventInfo, Target) == 0x000010, "Member 'FP2AkPlayingEventInfo::Target' has a wrong offset!");
static_assert(offsetof(FP2AkPlayingEventInfo, StopEvent) == 0x000018, "Member 'FP2AkPlayingEventInfo::StopEvent' has a wrong offset!");
static_assert(offsetof(FP2AkPlayingEventInfo, ComponentTag) == 0x000020, "Member 'FP2AkPlayingEventInfo::ComponentTag' has a wrong offset!");

// ScriptStruct Game.P2ActiveContinuousSoundData
// 0x0030 (0x0030 - 0x0000)
struct FP2ActiveContinuousSoundData final
{
public:
	class UAkAudioEvent*                          StopEvent;                                         // 0x0000(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_8[0x28];                                       // 0x0008(0x0028)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FP2ActiveContinuousSoundData) == 0x000008, "Wrong alignment on FP2ActiveContinuousSoundData");
static_assert(sizeof(FP2ActiveContinuousSoundData) == 0x000030, "Wrong size on FP2ActiveContinuousSoundData");
static_assert(offsetof(FP2ActiveContinuousSoundData, StopEvent) == 0x000000, "Member 'FP2ActiveContinuousSoundData::StopEvent' has a wrong offset!");

// ScriptStruct Game.P2RaidResultAccumulatedInfo
// 0x0040 (0x0040 - 0x0000)
struct FP2RaidResultAccumulatedInfo final
{
public:
	struct FDateTime                              LastRaidEnd;                                       // 0x0000(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FP2RaidResultPMCKillStatistics         KillInfo;                                          // 0x0008(0x0028)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	int32                                         RaidNum;                                           // 0x0030(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ExtractedNum;                                      // 0x0034(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DistanceTraveled;                                  // 0x0038(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TimeInRaidSec;                                     // 0x003C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FP2RaidResultAccumulatedInfo) == 0x000008, "Wrong alignment on FP2RaidResultAccumulatedInfo");
static_assert(sizeof(FP2RaidResultAccumulatedInfo) == 0x000040, "Wrong size on FP2RaidResultAccumulatedInfo");
static_assert(offsetof(FP2RaidResultAccumulatedInfo, LastRaidEnd) == 0x000000, "Member 'FP2RaidResultAccumulatedInfo::LastRaidEnd' has a wrong offset!");
static_assert(offsetof(FP2RaidResultAccumulatedInfo, KillInfo) == 0x000008, "Member 'FP2RaidResultAccumulatedInfo::KillInfo' has a wrong offset!");
static_assert(offsetof(FP2RaidResultAccumulatedInfo, RaidNum) == 0x000030, "Member 'FP2RaidResultAccumulatedInfo::RaidNum' has a wrong offset!");
static_assert(offsetof(FP2RaidResultAccumulatedInfo, ExtractedNum) == 0x000034, "Member 'FP2RaidResultAccumulatedInfo::ExtractedNum' has a wrong offset!");
static_assert(offsetof(FP2RaidResultAccumulatedInfo, DistanceTraveled) == 0x000038, "Member 'FP2RaidResultAccumulatedInfo::DistanceTraveled' has a wrong offset!");
static_assert(offsetof(FP2RaidResultAccumulatedInfo, TimeInRaidSec) == 0x00003C, "Member 'FP2RaidResultAccumulatedInfo::TimeInRaidSec' has a wrong offset!");

// ScriptStruct Game.P2CustomizationCategoryInfo
// 0x0020 (0x0020 - 0x0000)
struct FP2CustomizationCategoryInfo final
{
public:
	class UTexture2D*                             Icon;                                              // 0x0000(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FText                                   Name;                                              // 0x0008(0x0018)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
};
static_assert(alignof(FP2CustomizationCategoryInfo) == 0x000008, "Wrong alignment on FP2CustomizationCategoryInfo");
static_assert(sizeof(FP2CustomizationCategoryInfo) == 0x000020, "Wrong size on FP2CustomizationCategoryInfo");
static_assert(offsetof(FP2CustomizationCategoryInfo, Icon) == 0x000000, "Member 'FP2CustomizationCategoryInfo::Icon' has a wrong offset!");
static_assert(offsetof(FP2CustomizationCategoryInfo, Name) == 0x000008, "Member 'FP2CustomizationCategoryInfo::Name' has a wrong offset!");

// ScriptStruct Game.P2RenderActorSpawnRequest
// 0x0008 (0x0008 - 0x0000)
struct FP2RenderActorSpawnRequest final
{
public:
	class UObject*                                ItemOrItemData;                                    // 0x0000(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FP2RenderActorSpawnRequest) == 0x000008, "Wrong alignment on FP2RenderActorSpawnRequest");
static_assert(sizeof(FP2RenderActorSpawnRequest) == 0x000008, "Wrong size on FP2RenderActorSpawnRequest");
static_assert(offsetof(FP2RenderActorSpawnRequest, ItemOrItemData) == 0x000000, "Member 'FP2RenderActorSpawnRequest::ItemOrItemData' has a wrong offset!");

// ScriptStruct Game.P2MoreInfoDataRow
// 0x0040 (0x0048 - 0x0008)
struct FP2MoreInfoDataRow final : public FTableRowBase
{
public:
	struct FGameplayTag                           InfoTypeTag;                                       // 0x0008(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UP2BaseTooltipWidget>       TooltipWidgetClass;                                // 0x0010(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FText                                   TitleText;                                         // 0x0018(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	class FText                                   BodyText;                                          // 0x0030(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
};
static_assert(alignof(FP2MoreInfoDataRow) == 0x000008, "Wrong alignment on FP2MoreInfoDataRow");
static_assert(sizeof(FP2MoreInfoDataRow) == 0x000048, "Wrong size on FP2MoreInfoDataRow");
static_assert(offsetof(FP2MoreInfoDataRow, InfoTypeTag) == 0x000008, "Member 'FP2MoreInfoDataRow::InfoTypeTag' has a wrong offset!");
static_assert(offsetof(FP2MoreInfoDataRow, TooltipWidgetClass) == 0x000010, "Member 'FP2MoreInfoDataRow::TooltipWidgetClass' has a wrong offset!");
static_assert(offsetof(FP2MoreInfoDataRow, TitleText) == 0x000018, "Member 'FP2MoreInfoDataRow::TitleText' has a wrong offset!");
static_assert(offsetof(FP2MoreInfoDataRow, BodyText) == 0x000030, "Member 'FP2MoreInfoDataRow::BodyText' has a wrong offset!");

// ScriptStruct Game.P2SlotBlockedState
// 0x0002 (0x0002 - 0x0000)
struct FP2SlotBlockedState final
{
public:
	bool                                          bBlocked;                                          // 0x0000(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bEmptyItemWhenBlocked;                             // 0x0001(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FP2SlotBlockedState) == 0x000001, "Wrong alignment on FP2SlotBlockedState");
static_assert(sizeof(FP2SlotBlockedState) == 0x000002, "Wrong size on FP2SlotBlockedState");
static_assert(offsetof(FP2SlotBlockedState, bBlocked) == 0x000000, "Member 'FP2SlotBlockedState::bBlocked' has a wrong offset!");
static_assert(offsetof(FP2SlotBlockedState, bEmptyItemWhenBlocked) == 0x000001, "Member 'FP2SlotBlockedState::bEmptyItemWhenBlocked' has a wrong offset!");

// ScriptStruct Game.LocalPreset
// 0x0080 (0x0080 - 0x0000)
struct FLocalPreset final
{
public:
	bool                                          bApplied;                                          // 0x0000(0x0001)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UP2CustomizationBodyData*               Body;                                              // 0x0008(0x0008)(Edit, ZeroConstructor, EditConst, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TMap<class FName, class UP2CustomizationObjectData*> CustomizationObjects;                       // 0x0010(0x0050)(Edit, EditConst, NativeAccessSpecifierPublic)
	TArray<class UP2WearableData*>                WearableItems;                                     // 0x0060(0x0010)(Edit, ZeroConstructor, EditConst, NativeAccessSpecifierPublic)
	class UP2WeaponData*                          WeaponData;                                        // 0x0070(0x0008)(Edit, ZeroConstructor, EditConst, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ForcedLOD;                                         // 0x0078(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_7C[0x4];                                       // 0x007C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FLocalPreset) == 0x000008, "Wrong alignment on FLocalPreset");
static_assert(sizeof(FLocalPreset) == 0x000080, "Wrong size on FLocalPreset");
static_assert(offsetof(FLocalPreset, bApplied) == 0x000000, "Member 'FLocalPreset::bApplied' has a wrong offset!");
static_assert(offsetof(FLocalPreset, Body) == 0x000008, "Member 'FLocalPreset::Body' has a wrong offset!");
static_assert(offsetof(FLocalPreset, CustomizationObjects) == 0x000010, "Member 'FLocalPreset::CustomizationObjects' has a wrong offset!");
static_assert(offsetof(FLocalPreset, WearableItems) == 0x000060, "Member 'FLocalPreset::WearableItems' has a wrong offset!");
static_assert(offsetof(FLocalPreset, WeaponData) == 0x000070, "Member 'FLocalPreset::WeaponData' has a wrong offset!");
static_assert(offsetof(FLocalPreset, ForcedLOD) == 0x000078, "Member 'FLocalPreset::ForcedLOD' has a wrong offset!");

// ScriptStruct Game.PawnMovementOverrideData
// 0x0028 (0x0028 - 0x0000)
struct FPawnMovementOverrideData final
{
public:
	bool                                          bDisableVelocityRotation;                          // 0x0000(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bOverrideTrajectoryVelocity;                       // 0x0001(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2[0x6];                                        // 0x0002(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                TrajectoryVelocity;                                // 0x0008(0x0018)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bZeroPastTrajectory;                               // 0x0020(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_21[0x7];                                       // 0x0021(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FPawnMovementOverrideData) == 0x000008, "Wrong alignment on FPawnMovementOverrideData");
static_assert(sizeof(FPawnMovementOverrideData) == 0x000028, "Wrong size on FPawnMovementOverrideData");
static_assert(offsetof(FPawnMovementOverrideData, bDisableVelocityRotation) == 0x000000, "Member 'FPawnMovementOverrideData::bDisableVelocityRotation' has a wrong offset!");
static_assert(offsetof(FPawnMovementOverrideData, bOverrideTrajectoryVelocity) == 0x000001, "Member 'FPawnMovementOverrideData::bOverrideTrajectoryVelocity' has a wrong offset!");
static_assert(offsetof(FPawnMovementOverrideData, TrajectoryVelocity) == 0x000008, "Member 'FPawnMovementOverrideData::TrajectoryVelocity' has a wrong offset!");
static_assert(offsetof(FPawnMovementOverrideData, bZeroPastTrajectory) == 0x000020, "Member 'FPawnMovementOverrideData::bZeroPastTrajectory' has a wrong offset!");

// ScriptStruct Game.P2CharacterConnectionInfo
// 0x0028 (0x0028 - 0x0000)
struct FP2CharacterConnectionInfo final
{
public:
	class FString                                 CharacterId;                                       // 0x0000(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 NickName;                                          // 0x0010(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EP2CharacterConnectionStatus                  Status;                                            // 0x0020(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_21[0x7];                                       // 0x0021(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FP2CharacterConnectionInfo) == 0x000008, "Wrong alignment on FP2CharacterConnectionInfo");
static_assert(sizeof(FP2CharacterConnectionInfo) == 0x000028, "Wrong size on FP2CharacterConnectionInfo");
static_assert(offsetof(FP2CharacterConnectionInfo, CharacterId) == 0x000000, "Member 'FP2CharacterConnectionInfo::CharacterId' has a wrong offset!");
static_assert(offsetof(FP2CharacterConnectionInfo, NickName) == 0x000010, "Member 'FP2CharacterConnectionInfo::NickName' has a wrong offset!");
static_assert(offsetof(FP2CharacterConnectionInfo, Status) == 0x000020, "Member 'FP2CharacterConnectionInfo::Status' has a wrong offset!");

// ScriptStruct Game.P2ScopePostProcessingEffectConfiguration
// 0x0028 (0x0028 - 0x0000)
struct FP2ScopePostProcessingEffectConfiguration final
{
public:
	struct FGameplayTag                           ItemStateTag;                                      // 0x0000(0x0008)(Edit, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMaterialInterface*                     PostProcessMaterial;                               // 0x0008(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMaterialInstanceDynamic*               DynamicPPMaterial;                                 // 0x0010(0x0008)(ZeroConstructor, Transient, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTexture2D*                             ScopeCutoutMask;                                   // 0x0018(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_20[0x8];                                       // 0x0020(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FP2ScopePostProcessingEffectConfiguration) == 0x000008, "Wrong alignment on FP2ScopePostProcessingEffectConfiguration");
static_assert(sizeof(FP2ScopePostProcessingEffectConfiguration) == 0x000028, "Wrong size on FP2ScopePostProcessingEffectConfiguration");
static_assert(offsetof(FP2ScopePostProcessingEffectConfiguration, ItemStateTag) == 0x000000, "Member 'FP2ScopePostProcessingEffectConfiguration::ItemStateTag' has a wrong offset!");
static_assert(offsetof(FP2ScopePostProcessingEffectConfiguration, PostProcessMaterial) == 0x000008, "Member 'FP2ScopePostProcessingEffectConfiguration::PostProcessMaterial' has a wrong offset!");
static_assert(offsetof(FP2ScopePostProcessingEffectConfiguration, DynamicPPMaterial) == 0x000010, "Member 'FP2ScopePostProcessingEffectConfiguration::DynamicPPMaterial' has a wrong offset!");
static_assert(offsetof(FP2ScopePostProcessingEffectConfiguration, ScopeCutoutMask) == 0x000018, "Member 'FP2ScopePostProcessingEffectConfiguration::ScopeCutoutMask' has a wrong offset!");

// ScriptStruct Game.P2AUVStageConfig
// 0x0030 (0x0030 - 0x0000)
struct FP2AUVStageConfig final
{
public:
	class UAnimSequence*                          AnimSequence;                                      // 0x0000(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Duration;                                          // 0x0008(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UP2TransformCurve*                      TransformCurve;                                    // 0x0010(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           NextStage;                                         // 0x0018(0x0008)(Edit, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BlendInTime;                                       // 0x0020(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BlendOutTime;                                      // 0x0024(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BlendOutStartTime;                                 // 0x0028(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          InverseTransformCurve;                             // 0x002C(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDetachOnStateEnd;                                 // 0x002D(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bShouldUpdateTransform;                            // 0x002E(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2F[0x1];                                       // 0x002F(0x0001)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FP2AUVStageConfig) == 0x000008, "Wrong alignment on FP2AUVStageConfig");
static_assert(sizeof(FP2AUVStageConfig) == 0x000030, "Wrong size on FP2AUVStageConfig");
static_assert(offsetof(FP2AUVStageConfig, AnimSequence) == 0x000000, "Member 'FP2AUVStageConfig::AnimSequence' has a wrong offset!");
static_assert(offsetof(FP2AUVStageConfig, Duration) == 0x000008, "Member 'FP2AUVStageConfig::Duration' has a wrong offset!");
static_assert(offsetof(FP2AUVStageConfig, TransformCurve) == 0x000010, "Member 'FP2AUVStageConfig::TransformCurve' has a wrong offset!");
static_assert(offsetof(FP2AUVStageConfig, NextStage) == 0x000018, "Member 'FP2AUVStageConfig::NextStage' has a wrong offset!");
static_assert(offsetof(FP2AUVStageConfig, BlendInTime) == 0x000020, "Member 'FP2AUVStageConfig::BlendInTime' has a wrong offset!");
static_assert(offsetof(FP2AUVStageConfig, BlendOutTime) == 0x000024, "Member 'FP2AUVStageConfig::BlendOutTime' has a wrong offset!");
static_assert(offsetof(FP2AUVStageConfig, BlendOutStartTime) == 0x000028, "Member 'FP2AUVStageConfig::BlendOutStartTime' has a wrong offset!");
static_assert(offsetof(FP2AUVStageConfig, InverseTransformCurve) == 0x00002C, "Member 'FP2AUVStageConfig::InverseTransformCurve' has a wrong offset!");
static_assert(offsetof(FP2AUVStageConfig, bDetachOnStateEnd) == 0x00002D, "Member 'FP2AUVStageConfig::bDetachOnStateEnd' has a wrong offset!");
static_assert(offsetof(FP2AUVStageConfig, bShouldUpdateTransform) == 0x00002E, "Member 'FP2AUVStageConfig::bShouldUpdateTransform' has a wrong offset!");

// ScriptStruct Game.P2AUVComponentConfig
// 0x0060 (0x0060 - 0x0000)
struct FP2AUVComponentConfig final
{
public:
	TSubclassOf<class UAnimInstance>              AnimLayer;                                         // 0x0000(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TMap<struct FGameplayTag, struct FP2AUVStageConfig> StageConfigMap;                              // 0x0008(0x0050)(Edit, NativeAccessSpecifierPublic)
	TSubclassOf<class UGameplayEffect>            GameplayEffect;                                    // 0x0058(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FP2AUVComponentConfig) == 0x000008, "Wrong alignment on FP2AUVComponentConfig");
static_assert(sizeof(FP2AUVComponentConfig) == 0x000060, "Wrong size on FP2AUVComponentConfig");
static_assert(offsetof(FP2AUVComponentConfig, AnimLayer) == 0x000000, "Member 'FP2AUVComponentConfig::AnimLayer' has a wrong offset!");
static_assert(offsetof(FP2AUVComponentConfig, StageConfigMap) == 0x000008, "Member 'FP2AUVComponentConfig::StageConfigMap' has a wrong offset!");
static_assert(offsetof(FP2AUVComponentConfig, GameplayEffect) == 0x000058, "Member 'FP2AUVComponentConfig::GameplayEffect' has a wrong offset!");

// ScriptStruct Game.P2ProductionBonusInfo
// 0x0018 (0x0018 - 0x0000)
struct FP2ProductionBonusInfo final
{
public:
	TArray<struct FP2ExchangeInfo>                ListItems;                                         // 0x0000(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	float                                         Weight;                                            // 0x0010(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FP2ProductionBonusInfo) == 0x000008, "Wrong alignment on FP2ProductionBonusInfo");
static_assert(sizeof(FP2ProductionBonusInfo) == 0x000018, "Wrong size on FP2ProductionBonusInfo");
static_assert(offsetof(FP2ProductionBonusInfo, ListItems) == 0x000000, "Member 'FP2ProductionBonusInfo::ListItems' has a wrong offset!");
static_assert(offsetof(FP2ProductionBonusInfo, Weight) == 0x000010, "Member 'FP2ProductionBonusInfo::Weight' has a wrong offset!");

// ScriptStruct Game.P2ProductionDataRow
// 0x0020 (0x00B8 - 0x0098)
struct FP2ProductionDataRow : public FP2ExchangeDataRow
{
public:
	float                                         ProductionTime;                                    // 0x0098(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9C[0x4];                                       // 0x009C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FP2ProductionBonusInfo>         BonusInfos;                                        // 0x00A0(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	int32                                         GroupIndex;                                        // 0x00B0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         SortIndex;                                         // 0x00B4(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FP2ProductionDataRow) == 0x000008, "Wrong alignment on FP2ProductionDataRow");
static_assert(sizeof(FP2ProductionDataRow) == 0x0000B8, "Wrong size on FP2ProductionDataRow");
static_assert(offsetof(FP2ProductionDataRow, ProductionTime) == 0x000098, "Member 'FP2ProductionDataRow::ProductionTime' has a wrong offset!");
static_assert(offsetof(FP2ProductionDataRow, BonusInfos) == 0x0000A0, "Member 'FP2ProductionDataRow::BonusInfos' has a wrong offset!");
static_assert(offsetof(FP2ProductionDataRow, GroupIndex) == 0x0000B0, "Member 'FP2ProductionDataRow::GroupIndex' has a wrong offset!");
static_assert(offsetof(FP2ProductionDataRow, SortIndex) == 0x0000B4, "Member 'FP2ProductionDataRow::SortIndex' has a wrong offset!");

// ScriptStruct Game.P2ProtectionDisplayData
// 0x000C (0x000C - 0x0000)
struct FP2ProtectionDisplayData final
{
public:
	struct FGameplayTag                           DamageZoneTag;                                     // 0x0000(0x0008)(Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ProtectionValue;                                   // 0x0008(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FP2ProtectionDisplayData) == 0x000004, "Wrong alignment on FP2ProtectionDisplayData");
static_assert(sizeof(FP2ProtectionDisplayData) == 0x00000C, "Wrong size on FP2ProtectionDisplayData");
static_assert(offsetof(FP2ProtectionDisplayData, DamageZoneTag) == 0x000000, "Member 'FP2ProtectionDisplayData::DamageZoneTag' has a wrong offset!");
static_assert(offsetof(FP2ProtectionDisplayData, ProtectionValue) == 0x000008, "Member 'FP2ProtectionDisplayData::ProtectionValue' has a wrong offset!");

// ScriptStruct Game.P2DoorState
// 0x0018 (0x0018 - 0x0000)
struct FP2DoorState final
{
public:
	EDoorState                                    DoorState;                                         // 0x0000(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         TargetAlpha;                                       // 0x0004(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	double                                        StateTime;                                         // 0x0008(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bIsInitial : 1;                                    // 0x0010(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bIsReversedMovement : 1;                           // 0x0010(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_11[0x7];                                       // 0x0011(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FP2DoorState) == 0x000008, "Wrong alignment on FP2DoorState");
static_assert(sizeof(FP2DoorState) == 0x000018, "Wrong size on FP2DoorState");
static_assert(offsetof(FP2DoorState, DoorState) == 0x000000, "Member 'FP2DoorState::DoorState' has a wrong offset!");
static_assert(offsetof(FP2DoorState, TargetAlpha) == 0x000004, "Member 'FP2DoorState::TargetAlpha' has a wrong offset!");
static_assert(offsetof(FP2DoorState, StateTime) == 0x000008, "Member 'FP2DoorState::StateTime' has a wrong offset!");

// ScriptStruct Game.P2AnimContainer_CardinalDirections
// 0x0020 (0x0020 - 0x0000)
struct FP2AnimContainer_CardinalDirections final
{
public:
	class UAnimSequence*                          Forward;                                           // 0x0000(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          Backward;                                          // 0x0008(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          Left;                                              // 0x0010(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          Right;                                             // 0x0018(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FP2AnimContainer_CardinalDirections) == 0x000008, "Wrong alignment on FP2AnimContainer_CardinalDirections");
static_assert(sizeof(FP2AnimContainer_CardinalDirections) == 0x000020, "Wrong size on FP2AnimContainer_CardinalDirections");
static_assert(offsetof(FP2AnimContainer_CardinalDirections, Forward) == 0x000000, "Member 'FP2AnimContainer_CardinalDirections::Forward' has a wrong offset!");
static_assert(offsetof(FP2AnimContainer_CardinalDirections, Backward) == 0x000008, "Member 'FP2AnimContainer_CardinalDirections::Backward' has a wrong offset!");
static_assert(offsetof(FP2AnimContainer_CardinalDirections, Left) == 0x000010, "Member 'FP2AnimContainer_CardinalDirections::Left' has a wrong offset!");
static_assert(offsetof(FP2AnimContainer_CardinalDirections, Right) == 0x000018, "Member 'FP2AnimContainer_CardinalDirections::Right' has a wrong offset!");

// ScriptStruct Game.P2CraftingDataRow
// 0x0008 (0x00C0 - 0x00B8)
struct FP2CraftingDataRow : public FP2ProductionDataRow
{
public:
	class UP2CraftItemRuntimeData*                CraftItemRuntimeData;                              // 0x00B8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FP2CraftingDataRow) == 0x000008, "Wrong alignment on FP2CraftingDataRow");
static_assert(sizeof(FP2CraftingDataRow) == 0x0000C0, "Wrong size on FP2CraftingDataRow");
static_assert(offsetof(FP2CraftingDataRow, CraftItemRuntimeData) == 0x0000B8, "Member 'FP2CraftingDataRow::CraftItemRuntimeData' has a wrong offset!");

// ScriptStruct Game.P2SpawnPointSearchFilter
// 0x0010 (0x0010 - 0x0000)
struct alignas(0x08) FP2SpawnPointSearchFilter final
{
public:
	uint8                                         Pad_0[0x10];                                       // 0x0000(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FP2SpawnPointSearchFilter) == 0x000008, "Wrong alignment on FP2SpawnPointSearchFilter");
static_assert(sizeof(FP2SpawnPointSearchFilter) == 0x000010, "Wrong size on FP2SpawnPointSearchFilter");

// ScriptStruct Game.InertiaVelocityOffsetConfig
// 0x00A8 (0x00A8 - 0x0000)
struct FInertiaVelocityOffsetConfig final
{
public:
	float                                         InputSensitivity;                                  // 0x0000(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         VelocityMax;                                       // 0x0004(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Stiffness;                                         // 0x0008(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Damping;                                           // 0x000C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Pivot;                                             // 0x0010(0x0018)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FP2Remap                               YawRateRemap;                                      // 0x0028(0x0028)(Edit, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
	struct FP2Remap                               PitchRateRemap;                                    // 0x0050(0x0028)(Edit, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
	struct FP2Remap                               YawRateStiffnessRemap;                             // 0x0078(0x0028)(Edit, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
	float                                         RotationScale;                                     // 0x00A0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A4[0x4];                                       // 0x00A4(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FInertiaVelocityOffsetConfig) == 0x000008, "Wrong alignment on FInertiaVelocityOffsetConfig");
static_assert(sizeof(FInertiaVelocityOffsetConfig) == 0x0000A8, "Wrong size on FInertiaVelocityOffsetConfig");
static_assert(offsetof(FInertiaVelocityOffsetConfig, InputSensitivity) == 0x000000, "Member 'FInertiaVelocityOffsetConfig::InputSensitivity' has a wrong offset!");
static_assert(offsetof(FInertiaVelocityOffsetConfig, VelocityMax) == 0x000004, "Member 'FInertiaVelocityOffsetConfig::VelocityMax' has a wrong offset!");
static_assert(offsetof(FInertiaVelocityOffsetConfig, Stiffness) == 0x000008, "Member 'FInertiaVelocityOffsetConfig::Stiffness' has a wrong offset!");
static_assert(offsetof(FInertiaVelocityOffsetConfig, Damping) == 0x00000C, "Member 'FInertiaVelocityOffsetConfig::Damping' has a wrong offset!");
static_assert(offsetof(FInertiaVelocityOffsetConfig, Pivot) == 0x000010, "Member 'FInertiaVelocityOffsetConfig::Pivot' has a wrong offset!");
static_assert(offsetof(FInertiaVelocityOffsetConfig, YawRateRemap) == 0x000028, "Member 'FInertiaVelocityOffsetConfig::YawRateRemap' has a wrong offset!");
static_assert(offsetof(FInertiaVelocityOffsetConfig, PitchRateRemap) == 0x000050, "Member 'FInertiaVelocityOffsetConfig::PitchRateRemap' has a wrong offset!");
static_assert(offsetof(FInertiaVelocityOffsetConfig, YawRateStiffnessRemap) == 0x000078, "Member 'FInertiaVelocityOffsetConfig::YawRateStiffnessRemap' has a wrong offset!");
static_assert(offsetof(FInertiaVelocityOffsetConfig, RotationScale) == 0x0000A0, "Member 'FInertiaVelocityOffsetConfig::RotationScale' has a wrong offset!");

// ScriptStruct Game.P2LootSpawnFixedBase
// 0x00B0 (0x00B0 - 0x0000)
struct FP2LootSpawnFixedBase
{
public:
	class UP2LootSpawnSessionDifficultyProbabilityData* SessionDifficultyToProbability;              // 0x0000(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TMap<int32, float>                            SessionDifficultyProbabilities;                    // 0x0008(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FP2LootSpawnMinMax                     Amount;                                            // 0x0058(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, NativeAccessSpecifierPublic)
	EP2LootSpawnFixedPointType                    Type;                                              // 0x0060(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_61[0x7];                                       // 0x0061(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<TSoftObjectPtr<class AP2LootSpawnPointActor>> PointActors;                                // 0x0068(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class AP2LootSpawnContext>     Context;                                           // 0x0078(0x0030)(Edit, BlueprintVisible, BlueprintReadOnly, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         PointIndex;                                        // 0x00A8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bShowFixedItem;                                    // 0x00AC(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_AD[0x3];                                       // 0x00AD(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FP2LootSpawnFixedBase) == 0x000008, "Wrong alignment on FP2LootSpawnFixedBase");
static_assert(sizeof(FP2LootSpawnFixedBase) == 0x0000B0, "Wrong size on FP2LootSpawnFixedBase");
static_assert(offsetof(FP2LootSpawnFixedBase, SessionDifficultyToProbability) == 0x000000, "Member 'FP2LootSpawnFixedBase::SessionDifficultyToProbability' has a wrong offset!");
static_assert(offsetof(FP2LootSpawnFixedBase, SessionDifficultyProbabilities) == 0x000008, "Member 'FP2LootSpawnFixedBase::SessionDifficultyProbabilities' has a wrong offset!");
static_assert(offsetof(FP2LootSpawnFixedBase, Amount) == 0x000058, "Member 'FP2LootSpawnFixedBase::Amount' has a wrong offset!");
static_assert(offsetof(FP2LootSpawnFixedBase, Type) == 0x000060, "Member 'FP2LootSpawnFixedBase::Type' has a wrong offset!");
static_assert(offsetof(FP2LootSpawnFixedBase, PointActors) == 0x000068, "Member 'FP2LootSpawnFixedBase::PointActors' has a wrong offset!");
static_assert(offsetof(FP2LootSpawnFixedBase, Context) == 0x000078, "Member 'FP2LootSpawnFixedBase::Context' has a wrong offset!");
static_assert(offsetof(FP2LootSpawnFixedBase, PointIndex) == 0x0000A8, "Member 'FP2LootSpawnFixedBase::PointIndex' has a wrong offset!");
static_assert(offsetof(FP2LootSpawnFixedBase, bShowFixedItem) == 0x0000AC, "Member 'FP2LootSpawnFixedBase::bShowFixedItem' has a wrong offset!");

// ScriptStruct Game.P2LootSpawnFixedCrate
// 0x0020 (0x00D0 - 0x00B0)
struct FP2LootSpawnFixedCrate final : public FP2LootSpawnFixedBase
{
public:
	class UP2CrateData*                           Object;                                            // 0x00B0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_B8[0x18];                                      // 0x00B8(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FP2LootSpawnFixedCrate) == 0x000008, "Wrong alignment on FP2LootSpawnFixedCrate");
static_assert(sizeof(FP2LootSpawnFixedCrate) == 0x0000D0, "Wrong size on FP2LootSpawnFixedCrate");
static_assert(offsetof(FP2LootSpawnFixedCrate, Object) == 0x0000B0, "Member 'FP2LootSpawnFixedCrate::Object' has a wrong offset!");

// ScriptStruct Game.P2MailCreateParam
// 0x0090 (0x0090 - 0x0000)
struct FP2MailCreateParam final
{
public:
	EP2InGameMailCategory                         MailCategory;                                      // 0x0000(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 TitleStrKey;                                       // 0x0008(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 BodyStrKey;                                        // 0x0018(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FText                                   TitleText;                                         // 0x0028(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	class FText                                   BodyText;                                          // 0x0040(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	TArray<class FString>                         TextPayloads;                                      // 0x0058(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FDateTime                              ExpireDate;                                        // 0x0068(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class UP2Item*>                        AttachedItems;                                     // 0x0070(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FP2MailCreateParamExtraItemData> AttachedExtraItems;                               // 0x0080(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FP2MailCreateParam) == 0x000008, "Wrong alignment on FP2MailCreateParam");
static_assert(sizeof(FP2MailCreateParam) == 0x000090, "Wrong size on FP2MailCreateParam");
static_assert(offsetof(FP2MailCreateParam, MailCategory) == 0x000000, "Member 'FP2MailCreateParam::MailCategory' has a wrong offset!");
static_assert(offsetof(FP2MailCreateParam, TitleStrKey) == 0x000008, "Member 'FP2MailCreateParam::TitleStrKey' has a wrong offset!");
static_assert(offsetof(FP2MailCreateParam, BodyStrKey) == 0x000018, "Member 'FP2MailCreateParam::BodyStrKey' has a wrong offset!");
static_assert(offsetof(FP2MailCreateParam, TitleText) == 0x000028, "Member 'FP2MailCreateParam::TitleText' has a wrong offset!");
static_assert(offsetof(FP2MailCreateParam, BodyText) == 0x000040, "Member 'FP2MailCreateParam::BodyText' has a wrong offset!");
static_assert(offsetof(FP2MailCreateParam, TextPayloads) == 0x000058, "Member 'FP2MailCreateParam::TextPayloads' has a wrong offset!");
static_assert(offsetof(FP2MailCreateParam, ExpireDate) == 0x000068, "Member 'FP2MailCreateParam::ExpireDate' has a wrong offset!");
static_assert(offsetof(FP2MailCreateParam, AttachedItems) == 0x000070, "Member 'FP2MailCreateParam::AttachedItems' has a wrong offset!");
static_assert(offsetof(FP2MailCreateParam, AttachedExtraItems) == 0x000080, "Member 'FP2MailCreateParam::AttachedExtraItems' has a wrong offset!");

// ScriptStruct Game.P2StatusEffectSpec
// 0x0038 (0x0038 - 0x0000)
struct FP2StatusEffectSpec final
{
public:
	struct FGameplayTag                           Tag;                                               // 0x0000(0x0008)(Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Chance;                                            // 0x0008(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Stacks;                                            // 0x000C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         LevelLimit;                                        // 0x0010(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         StackLimit;                                        // 0x0014(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTagContainer                  AdditionalSourceTags;                              // 0x0018(0x0020)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
};
static_assert(alignof(FP2StatusEffectSpec) == 0x000008, "Wrong alignment on FP2StatusEffectSpec");
static_assert(sizeof(FP2StatusEffectSpec) == 0x000038, "Wrong size on FP2StatusEffectSpec");
static_assert(offsetof(FP2StatusEffectSpec, Tag) == 0x000000, "Member 'FP2StatusEffectSpec::Tag' has a wrong offset!");
static_assert(offsetof(FP2StatusEffectSpec, Chance) == 0x000008, "Member 'FP2StatusEffectSpec::Chance' has a wrong offset!");
static_assert(offsetof(FP2StatusEffectSpec, Stacks) == 0x00000C, "Member 'FP2StatusEffectSpec::Stacks' has a wrong offset!");
static_assert(offsetof(FP2StatusEffectSpec, LevelLimit) == 0x000010, "Member 'FP2StatusEffectSpec::LevelLimit' has a wrong offset!");
static_assert(offsetof(FP2StatusEffectSpec, StackLimit) == 0x000014, "Member 'FP2StatusEffectSpec::StackLimit' has a wrong offset!");
static_assert(offsetof(FP2StatusEffectSpec, AdditionalSourceTags) == 0x000018, "Member 'FP2StatusEffectSpec::AdditionalSourceTags' has a wrong offset!");

// ScriptStruct Game.P2GrenadeUsageModeData
// 0x0058 (0x0058 - 0x0000)
struct FP2GrenadeUsageModeData final
{
public:
	struct FGameplayCueTag                        DurationElapsedCueTag;                             // 0x0000(0x0008)(Edit, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
	TSubclassOf<class UGameplayEffect>            DamageEffectClass;                                 // 0x0008(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FP2StatusEffectSpec                    StatusEffect;                                      // 0x0010(0x0038)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	class UCurveFloat*                            WaterDistanceDamageCurve;                          // 0x0048(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Radius;                                            // 0x0050(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Penetration;                                       // 0x0054(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FP2GrenadeUsageModeData) == 0x000008, "Wrong alignment on FP2GrenadeUsageModeData");
static_assert(sizeof(FP2GrenadeUsageModeData) == 0x000058, "Wrong size on FP2GrenadeUsageModeData");
static_assert(offsetof(FP2GrenadeUsageModeData, DurationElapsedCueTag) == 0x000000, "Member 'FP2GrenadeUsageModeData::DurationElapsedCueTag' has a wrong offset!");
static_assert(offsetof(FP2GrenadeUsageModeData, DamageEffectClass) == 0x000008, "Member 'FP2GrenadeUsageModeData::DamageEffectClass' has a wrong offset!");
static_assert(offsetof(FP2GrenadeUsageModeData, StatusEffect) == 0x000010, "Member 'FP2GrenadeUsageModeData::StatusEffect' has a wrong offset!");
static_assert(offsetof(FP2GrenadeUsageModeData, WaterDistanceDamageCurve) == 0x000048, "Member 'FP2GrenadeUsageModeData::WaterDistanceDamageCurve' has a wrong offset!");
static_assert(offsetof(FP2GrenadeUsageModeData, Radius) == 0x000050, "Member 'FP2GrenadeUsageModeData::Radius' has a wrong offset!");
static_assert(offsetof(FP2GrenadeUsageModeData, Penetration) == 0x000054, "Member 'FP2GrenadeUsageModeData::Penetration' has a wrong offset!");

// ScriptStruct Game.P2HardwareSurvey
// 0x00E0 (0x00E0 - 0x0000)
struct FP2HardwareSurvey final
{
public:
	class FString                                 CPU;                                               // 0x0000(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 GPU;                                               // 0x0010(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 GPUDriver;                                         // 0x0020(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         GPURAM;                                            // 0x0030(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         RAM;                                               // 0x0034(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FIntVector2                            DisplayResolution;                                 // 0x0038(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FIntVector2                            ViewportResolution;                                // 0x0040(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 OSVersion;                                         // 0x0048(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 OSLanguage;                                        // 0x0058(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 GameLanguage;                                      // 0x0068(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 CountryCode;                                       // 0x0078(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 DiskInfo;                                          // 0x0088(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 MonitorInfo;                                       // 0x0098(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 BaseBoardInfo;                                     // 0x00A8(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 RamGBInfo;                                         // 0x00B8(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 EventAt;                                           // 0x00C8(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AP2PlayerState*                         InstigatorPlayerState;                             // 0x00D8(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FP2HardwareSurvey) == 0x000008, "Wrong alignment on FP2HardwareSurvey");
static_assert(sizeof(FP2HardwareSurvey) == 0x0000E0, "Wrong size on FP2HardwareSurvey");
static_assert(offsetof(FP2HardwareSurvey, CPU) == 0x000000, "Member 'FP2HardwareSurvey::CPU' has a wrong offset!");
static_assert(offsetof(FP2HardwareSurvey, GPU) == 0x000010, "Member 'FP2HardwareSurvey::GPU' has a wrong offset!");
static_assert(offsetof(FP2HardwareSurvey, GPUDriver) == 0x000020, "Member 'FP2HardwareSurvey::GPUDriver' has a wrong offset!");
static_assert(offsetof(FP2HardwareSurvey, GPURAM) == 0x000030, "Member 'FP2HardwareSurvey::GPURAM' has a wrong offset!");
static_assert(offsetof(FP2HardwareSurvey, RAM) == 0x000034, "Member 'FP2HardwareSurvey::RAM' has a wrong offset!");
static_assert(offsetof(FP2HardwareSurvey, DisplayResolution) == 0x000038, "Member 'FP2HardwareSurvey::DisplayResolution' has a wrong offset!");
static_assert(offsetof(FP2HardwareSurvey, ViewportResolution) == 0x000040, "Member 'FP2HardwareSurvey::ViewportResolution' has a wrong offset!");
static_assert(offsetof(FP2HardwareSurvey, OSVersion) == 0x000048, "Member 'FP2HardwareSurvey::OSVersion' has a wrong offset!");
static_assert(offsetof(FP2HardwareSurvey, OSLanguage) == 0x000058, "Member 'FP2HardwareSurvey::OSLanguage' has a wrong offset!");
static_assert(offsetof(FP2HardwareSurvey, GameLanguage) == 0x000068, "Member 'FP2HardwareSurvey::GameLanguage' has a wrong offset!");
static_assert(offsetof(FP2HardwareSurvey, CountryCode) == 0x000078, "Member 'FP2HardwareSurvey::CountryCode' has a wrong offset!");
static_assert(offsetof(FP2HardwareSurvey, DiskInfo) == 0x000088, "Member 'FP2HardwareSurvey::DiskInfo' has a wrong offset!");
static_assert(offsetof(FP2HardwareSurvey, MonitorInfo) == 0x000098, "Member 'FP2HardwareSurvey::MonitorInfo' has a wrong offset!");
static_assert(offsetof(FP2HardwareSurvey, BaseBoardInfo) == 0x0000A8, "Member 'FP2HardwareSurvey::BaseBoardInfo' has a wrong offset!");
static_assert(offsetof(FP2HardwareSurvey, RamGBInfo) == 0x0000B8, "Member 'FP2HardwareSurvey::RamGBInfo' has a wrong offset!");
static_assert(offsetof(FP2HardwareSurvey, EventAt) == 0x0000C8, "Member 'FP2HardwareSurvey::EventAt' has a wrong offset!");
static_assert(offsetof(FP2HardwareSurvey, InstigatorPlayerState) == 0x0000D8, "Member 'FP2HardwareSurvey::InstigatorPlayerState' has a wrong offset!");

// ScriptStruct Game.P2OnlineServiceFriendsInfo
// 0x0030 (0x0030 - 0x0000)
struct FP2OnlineServiceFriendsInfo final
{
public:
	class FString                                 OSSId;                                             // 0x0000(0x0010)(ZeroConstructor, Transient, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 OSSNickName;                                       // 0x0010(0x0010)(ZeroConstructor, Transient, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 CharacterNickName;                                 // 0x0020(0x0010)(ZeroConstructor, Transient, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FP2OnlineServiceFriendsInfo) == 0x000008, "Wrong alignment on FP2OnlineServiceFriendsInfo");
static_assert(sizeof(FP2OnlineServiceFriendsInfo) == 0x000030, "Wrong size on FP2OnlineServiceFriendsInfo");
static_assert(offsetof(FP2OnlineServiceFriendsInfo, OSSId) == 0x000000, "Member 'FP2OnlineServiceFriendsInfo::OSSId' has a wrong offset!");
static_assert(offsetof(FP2OnlineServiceFriendsInfo, OSSNickName) == 0x000010, "Member 'FP2OnlineServiceFriendsInfo::OSSNickName' has a wrong offset!");
static_assert(offsetof(FP2OnlineServiceFriendsInfo, CharacterNickName) == 0x000020, "Member 'FP2OnlineServiceFriendsInfo::CharacterNickName' has a wrong offset!");

// ScriptStruct Game.KeyBindingLinkData
// 0x0040 (0x0040 - 0x0000)
struct FKeyBindingLinkData final
{
public:
	TSoftObjectPtr<class UInputAction>            SourceAction;                                      // 0x0000(0x0030)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<TSoftObjectPtr<class UInputAction>>    LinkedActions;                                     // 0x0030(0x0010)(Edit, ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
};
static_assert(alignof(FKeyBindingLinkData) == 0x000008, "Wrong alignment on FKeyBindingLinkData");
static_assert(sizeof(FKeyBindingLinkData) == 0x000040, "Wrong size on FKeyBindingLinkData");
static_assert(offsetof(FKeyBindingLinkData, SourceAction) == 0x000000, "Member 'FKeyBindingLinkData::SourceAction' has a wrong offset!");
static_assert(offsetof(FKeyBindingLinkData, LinkedActions) == 0x000030, "Member 'FKeyBindingLinkData::LinkedActions' has a wrong offset!");

// ScriptStruct Game.P2ActionRequiredItems
// 0x0010 (0x0010 - 0x0000)
struct FP2ActionRequiredItems final
{
public:
	class UP2ItemData*                            ItemData;                                          // 0x0000(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Amount;                                            // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         AmountToConsume;                                   // 0x000C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FP2ActionRequiredItems) == 0x000008, "Wrong alignment on FP2ActionRequiredItems");
static_assert(sizeof(FP2ActionRequiredItems) == 0x000010, "Wrong size on FP2ActionRequiredItems");
static_assert(offsetof(FP2ActionRequiredItems, ItemData) == 0x000000, "Member 'FP2ActionRequiredItems::ItemData' has a wrong offset!");
static_assert(offsetof(FP2ActionRequiredItems, Amount) == 0x000008, "Member 'FP2ActionRequiredItems::Amount' has a wrong offset!");
static_assert(offsetof(FP2ActionRequiredItems, AmountToConsume) == 0x00000C, "Member 'FP2ActionRequiredItems::AmountToConsume' has a wrong offset!");

// ScriptStruct Game.P2FastTag
// 0x0008 (0x0014 - 0x000C)
struct FP2FastTag final : public FFastArraySerializerItem
{
public:
	struct FGameplayTag                           Tag;                                               // 0x000C(0x0008)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FP2FastTag) == 0x000004, "Wrong alignment on FP2FastTag");
static_assert(sizeof(FP2FastTag) == 0x000014, "Wrong size on FP2FastTag");
static_assert(offsetof(FP2FastTag, Tag) == 0x00000C, "Member 'FP2FastTag::Tag' has a wrong offset!");

// ScriptStruct Game.P2FastTagArray
// 0x0030 (0x0138 - 0x0108)
struct FP2FastTagArray final : public FFastArraySerializer
{
public:
	TArray<struct FP2FastTag>                     Items;                                             // 0x0108(0x0010)(ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	struct FGameplayTagContainer                  TagContainer;                                      // 0x0118(0x0020)(Protected, NativeAccessSpecifierProtected)
};
static_assert(alignof(FP2FastTagArray) == 0x000008, "Wrong alignment on FP2FastTagArray");
static_assert(sizeof(FP2FastTagArray) == 0x000138, "Wrong size on FP2FastTagArray");
static_assert(offsetof(FP2FastTagArray, Items) == 0x000108, "Member 'FP2FastTagArray::Items' has a wrong offset!");
static_assert(offsetof(FP2FastTagArray, TagContainer) == 0x000118, "Member 'FP2FastTagArray::TagContainer' has a wrong offset!");

// ScriptStruct Game.AkOcclusionConfig
// 0x0004 (0x0004 - 0x0000)
struct FAkOcclusionConfig final
{
public:
	float                                         OcclusionRefreshInterval;                          // 0x0000(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAkOcclusionConfig) == 0x000004, "Wrong alignment on FAkOcclusionConfig");
static_assert(sizeof(FAkOcclusionConfig) == 0x000004, "Wrong size on FAkOcclusionConfig");
static_assert(offsetof(FAkOcclusionConfig, OcclusionRefreshInterval) == 0x000000, "Member 'FAkOcclusionConfig::OcclusionRefreshInterval' has a wrong offset!");

// ScriptStruct Game.P2TimedEventHandle
// 0x0008 (0x0008 - 0x0000)
struct FP2TimedEventHandle final
{
public:
	uint64                                        ID;                                                // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
};
static_assert(alignof(FP2TimedEventHandle) == 0x000008, "Wrong alignment on FP2TimedEventHandle");
static_assert(sizeof(FP2TimedEventHandle) == 0x000008, "Wrong size on FP2TimedEventHandle");
static_assert(offsetof(FP2TimedEventHandle, ID) == 0x000000, "Member 'FP2TimedEventHandle::ID' has a wrong offset!");

// ScriptStruct Game.P2LoadedAcquireLevelEventConfig
// 0x0010 (0x0010 - 0x0000)
struct FP2LoadedAcquireLevelEventConfig final
{
public:
	struct FGameplayTag                           PlayerSkill;                                       // 0x0000(0x0008)(Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UP2PlayerAcquireLevelEventsConfig*      InstancedAcquireLevelEventConfigs;                 // 0x0008(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FP2LoadedAcquireLevelEventConfig) == 0x000008, "Wrong alignment on FP2LoadedAcquireLevelEventConfig");
static_assert(sizeof(FP2LoadedAcquireLevelEventConfig) == 0x000010, "Wrong size on FP2LoadedAcquireLevelEventConfig");
static_assert(offsetof(FP2LoadedAcquireLevelEventConfig, PlayerSkill) == 0x000000, "Member 'FP2LoadedAcquireLevelEventConfig::PlayerSkill' has a wrong offset!");
static_assert(offsetof(FP2LoadedAcquireLevelEventConfig, InstancedAcquireLevelEventConfigs) == 0x000008, "Member 'FP2LoadedAcquireLevelEventConfig::InstancedAcquireLevelEventConfigs' has a wrong offset!");

// ScriptStruct Game.P2ClassReplicationPolicyPreset
// 0x0010 (0x0010 - 0x0000)
struct FP2ClassReplicationPolicyPreset final
{
public:
	TSubclassOf<class AActor>                     Class;                                             // 0x0000(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EP2ClassRepNodeMapping                        Policy;                                            // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FP2ClassReplicationPolicyPreset) == 0x000008, "Wrong alignment on FP2ClassReplicationPolicyPreset");
static_assert(sizeof(FP2ClassReplicationPolicyPreset) == 0x000010, "Wrong size on FP2ClassReplicationPolicyPreset");
static_assert(offsetof(FP2ClassReplicationPolicyPreset, Class) == 0x000000, "Member 'FP2ClassReplicationPolicyPreset::Class' has a wrong offset!");
static_assert(offsetof(FP2ClassReplicationPolicyPreset, Policy) == 0x000008, "Member 'FP2ClassReplicationPolicyPreset::Policy' has a wrong offset!");

// ScriptStruct Game.P2DamageInfoValue
// 0x0030 (0x0030 - 0x0000)
struct alignas(0x08) FP2DamageInfoValue final
{
public:
	uint8                                         Pad_0[0x30];                                       // 0x0000(0x0030)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FP2DamageInfoValue) == 0x000008, "Wrong alignment on FP2DamageInfoValue");
static_assert(sizeof(FP2DamageInfoValue) == 0x000030, "Wrong size on FP2DamageInfoValue");

// ScriptStruct Game.P2DamageInfoCategory
// 0x0018 (0x0018 - 0x0000)
struct FP2DamageInfoCategory final
{
public:
	class FName                                   Category;                                          // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FP2DamageInfoValue>             Values;                                            // 0x0008(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FP2DamageInfoCategory) == 0x000008, "Wrong alignment on FP2DamageInfoCategory");
static_assert(sizeof(FP2DamageInfoCategory) == 0x000018, "Wrong size on FP2DamageInfoCategory");
static_assert(offsetof(FP2DamageInfoCategory, Category) == 0x000000, "Member 'FP2DamageInfoCategory::Category' has a wrong offset!");
static_assert(offsetof(FP2DamageInfoCategory, Values) == 0x000008, "Member 'FP2DamageInfoCategory::Values' has a wrong offset!");

// ScriptStruct Game.P2DamageInfo
// 0x0010 (0x0010 - 0x0000)
struct FP2DamageInfo final
{
public:
	TArray<struct FP2DamageInfoCategory>          Categories;                                        // 0x0000(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FP2DamageInfo) == 0x000008, "Wrong alignment on FP2DamageInfo");
static_assert(sizeof(FP2DamageInfo) == 0x000010, "Wrong size on FP2DamageInfo");
static_assert(offsetof(FP2DamageInfo, Categories) == 0x000000, "Member 'FP2DamageInfo::Categories' has a wrong offset!");

// ScriptStruct Game.P2FiremodeDisplayData
// 0x000C (0x000C - 0x0000)
struct FP2FiremodeDisplayData final
{
public:
	EP2Firemode                                   Firemode;                                          // 0x0000(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         RoundsPerMinute;                                   // 0x0004(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ShotsInBurst;                                      // 0x0008(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FP2FiremodeDisplayData) == 0x000004, "Wrong alignment on FP2FiremodeDisplayData");
static_assert(sizeof(FP2FiremodeDisplayData) == 0x00000C, "Wrong size on FP2FiremodeDisplayData");
static_assert(offsetof(FP2FiremodeDisplayData, Firemode) == 0x000000, "Member 'FP2FiremodeDisplayData::Firemode' has a wrong offset!");
static_assert(offsetof(FP2FiremodeDisplayData, RoundsPerMinute) == 0x000004, "Member 'FP2FiremodeDisplayData::RoundsPerMinute' has a wrong offset!");
static_assert(offsetof(FP2FiremodeDisplayData, ShotsInBurst) == 0x000008, "Member 'FP2FiremodeDisplayData::ShotsInBurst' has a wrong offset!");

// ScriptStruct Game.P2WeaponAttribute
// 0x000C (0x000C - 0x0000)
struct FP2WeaponAttribute final
{
public:
	struct FGameplayTag                           AttributeTag;                                      // 0x0000(0x0008)(Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AttributeValue;                                    // 0x0008(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FP2WeaponAttribute) == 0x000004, "Wrong alignment on FP2WeaponAttribute");
static_assert(sizeof(FP2WeaponAttribute) == 0x00000C, "Wrong size on FP2WeaponAttribute");
static_assert(offsetof(FP2WeaponAttribute, AttributeTag) == 0x000000, "Member 'FP2WeaponAttribute::AttributeTag' has a wrong offset!");
static_assert(offsetof(FP2WeaponAttribute, AttributeValue) == 0x000008, "Member 'FP2WeaponAttribute::AttributeValue' has a wrong offset!");

// ScriptStruct Game.P2WeaponAttributeSet
// 0x0018 (0x0018 - 0x0000)
struct FP2WeaponAttributeSet final
{
public:
	struct FGameplayTag                           WeaponTag;                                         // 0x0000(0x0008)(Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FP2WeaponAttribute>             Attributes;                                        // 0x0008(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPublic)
};
static_assert(alignof(FP2WeaponAttributeSet) == 0x000008, "Wrong alignment on FP2WeaponAttributeSet");
static_assert(sizeof(FP2WeaponAttributeSet) == 0x000018, "Wrong size on FP2WeaponAttributeSet");
static_assert(offsetof(FP2WeaponAttributeSet, WeaponTag) == 0x000000, "Member 'FP2WeaponAttributeSet::WeaponTag' has a wrong offset!");
static_assert(offsetof(FP2WeaponAttributeSet, Attributes) == 0x000008, "Member 'FP2WeaponAttributeSet::Attributes' has a wrong offset!");

// ScriptStruct Game.MoveInputRemapConfig
// 0x0018 (0x0018 - 0x0000)
struct FMoveInputRemapConfig final
{
public:
	struct FVector2D                              InputRange;                                        // 0x0000(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TargetInputValue;                                  // 0x0010(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FMoveInputRemapConfig) == 0x000008, "Wrong alignment on FMoveInputRemapConfig");
static_assert(sizeof(FMoveInputRemapConfig) == 0x000018, "Wrong size on FMoveInputRemapConfig");
static_assert(offsetof(FMoveInputRemapConfig, InputRange) == 0x000000, "Member 'FMoveInputRemapConfig::InputRange' has a wrong offset!");
static_assert(offsetof(FMoveInputRemapConfig, TargetInputValue) == 0x000010, "Member 'FMoveInputRemapConfig::TargetInputValue' has a wrong offset!");

// ScriptStruct Game.P2TeamMemberArrayItem
// 0x0044 (0x0050 - 0x000C)
struct FP2TeamMemberArrayItem final : public FFastArraySerializerItem
{
public:
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 CharacterId;                                       // 0x0010(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, RepSkip, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 CharacterName;                                     // 0x0020(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EP2SquadUserStatus                            Status;                                            // 0x0030(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EP2SquadUserJoinState                         JoinState;                                         // 0x0031(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EP2VisitHideoutStatus                         VisitStatus;                                       // 0x0032(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EP2InRaidStatus                               InRaidStatus;                                      // 0x0033(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsSquadLeader;                                    // 0x0034(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_35[0x3];                                       // 0x0035(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         Level;                                             // 0x0038(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3C[0x4];                                       // 0x003C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class AP2PlayerState*                         PlayerState;                                       // 0x0040(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MemberIndex;                                       // 0x0048(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Ping;                                              // 0x004C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FP2TeamMemberArrayItem) == 0x000008, "Wrong alignment on FP2TeamMemberArrayItem");
static_assert(sizeof(FP2TeamMemberArrayItem) == 0x000050, "Wrong size on FP2TeamMemberArrayItem");
static_assert(offsetof(FP2TeamMemberArrayItem, CharacterId) == 0x000010, "Member 'FP2TeamMemberArrayItem::CharacterId' has a wrong offset!");
static_assert(offsetof(FP2TeamMemberArrayItem, CharacterName) == 0x000020, "Member 'FP2TeamMemberArrayItem::CharacterName' has a wrong offset!");
static_assert(offsetof(FP2TeamMemberArrayItem, Status) == 0x000030, "Member 'FP2TeamMemberArrayItem::Status' has a wrong offset!");
static_assert(offsetof(FP2TeamMemberArrayItem, JoinState) == 0x000031, "Member 'FP2TeamMemberArrayItem::JoinState' has a wrong offset!");
static_assert(offsetof(FP2TeamMemberArrayItem, VisitStatus) == 0x000032, "Member 'FP2TeamMemberArrayItem::VisitStatus' has a wrong offset!");
static_assert(offsetof(FP2TeamMemberArrayItem, InRaidStatus) == 0x000033, "Member 'FP2TeamMemberArrayItem::InRaidStatus' has a wrong offset!");
static_assert(offsetof(FP2TeamMemberArrayItem, bIsSquadLeader) == 0x000034, "Member 'FP2TeamMemberArrayItem::bIsSquadLeader' has a wrong offset!");
static_assert(offsetof(FP2TeamMemberArrayItem, Level) == 0x000038, "Member 'FP2TeamMemberArrayItem::Level' has a wrong offset!");
static_assert(offsetof(FP2TeamMemberArrayItem, PlayerState) == 0x000040, "Member 'FP2TeamMemberArrayItem::PlayerState' has a wrong offset!");
static_assert(offsetof(FP2TeamMemberArrayItem, MemberIndex) == 0x000048, "Member 'FP2TeamMemberArrayItem::MemberIndex' has a wrong offset!");
static_assert(offsetof(FP2TeamMemberArrayItem, Ping) == 0x00004C, "Member 'FP2TeamMemberArrayItem::Ping' has a wrong offset!");

// ScriptStruct Game.P2TeamMemberArray
// 0x0018 (0x0120 - 0x0108)
struct FP2TeamMemberArray final : public FFastArraySerializer
{
public:
	TArray<struct FP2TeamMemberArrayItem>         Members;                                           // 0x0108(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_118[0x8];                                      // 0x0118(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FP2TeamMemberArray) == 0x000008, "Wrong alignment on FP2TeamMemberArray");
static_assert(sizeof(FP2TeamMemberArray) == 0x000120, "Wrong size on FP2TeamMemberArray");
static_assert(offsetof(FP2TeamMemberArray, Members) == 0x000108, "Member 'FP2TeamMemberArray::Members' has a wrong offset!");

// ScriptStruct Game.P2AllowContractGameMode
// 0x0004 (0x0004 - 0x0000)
struct FP2AllowContractGameMode final
{
public:
	bool                                          bAllowInHideout;                                   // 0x0000(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAllowInRaid;                                      // 0x0001(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAllowInTutorial;                                  // 0x0002(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAllowInDeathmatch;                                // 0x0003(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FP2AllowContractGameMode) == 0x000001, "Wrong alignment on FP2AllowContractGameMode");
static_assert(sizeof(FP2AllowContractGameMode) == 0x000004, "Wrong size on FP2AllowContractGameMode");
static_assert(offsetof(FP2AllowContractGameMode, bAllowInHideout) == 0x000000, "Member 'FP2AllowContractGameMode::bAllowInHideout' has a wrong offset!");
static_assert(offsetof(FP2AllowContractGameMode, bAllowInRaid) == 0x000001, "Member 'FP2AllowContractGameMode::bAllowInRaid' has a wrong offset!");
static_assert(offsetof(FP2AllowContractGameMode, bAllowInTutorial) == 0x000002, "Member 'FP2AllowContractGameMode::bAllowInTutorial' has a wrong offset!");
static_assert(offsetof(FP2AllowContractGameMode, bAllowInDeathmatch) == 0x000003, "Member 'FP2AllowContractGameMode::bAllowInDeathmatch' has a wrong offset!");

// ScriptStruct Game.P2ContractReward
// 0x0048 (0x0048 - 0x0000)
struct FP2ContractReward final
{
public:
	TArray<struct FP2ReputationReward>            ReputationRewards;                                 // 0x0000(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FP2ExchangeInfo>                ItemRewards;                                       // 0x0010(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	float                                         GameMoneyReward;                                   // 0x0020(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ExperienceReward;                                  // 0x0024(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class UP2ItemSkinContainer*>           SkinsRewards;                                      // 0x0028(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<class UP2SkinSlotPreset*>              ColorsRewards;                                     // 0x0038(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FP2ContractReward) == 0x000008, "Wrong alignment on FP2ContractReward");
static_assert(sizeof(FP2ContractReward) == 0x000048, "Wrong size on FP2ContractReward");
static_assert(offsetof(FP2ContractReward, ReputationRewards) == 0x000000, "Member 'FP2ContractReward::ReputationRewards' has a wrong offset!");
static_assert(offsetof(FP2ContractReward, ItemRewards) == 0x000010, "Member 'FP2ContractReward::ItemRewards' has a wrong offset!");
static_assert(offsetof(FP2ContractReward, GameMoneyReward) == 0x000020, "Member 'FP2ContractReward::GameMoneyReward' has a wrong offset!");
static_assert(offsetof(FP2ContractReward, ExperienceReward) == 0x000024, "Member 'FP2ContractReward::ExperienceReward' has a wrong offset!");
static_assert(offsetof(FP2ContractReward, SkinsRewards) == 0x000028, "Member 'FP2ContractReward::SkinsRewards' has a wrong offset!");
static_assert(offsetof(FP2ContractReward, ColorsRewards) == 0x000038, "Member 'FP2ContractReward::ColorsRewards' has a wrong offset!");

// ScriptStruct Game.P2ContractDataInfo
// 0x01A8 (0x01A8 - 0x0000)
struct FP2ContractDataInfo final
{
public:
	EP2ContractType                               ContractType;                                      // 0x0000(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsRepeatable;                                     // 0x0001(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsEmergentRaidTask;                               // 0x0002(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3[0x1];                                        // 0x0003(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         EmergentRaidTaskActivationTime;                    // 0x0004(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           ResetTypeTag;                                      // 0x0008(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           CategoryTag;                                       // 0x0010(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           FactionTag;                                        // 0x0018(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FText                                   DisplayName;                                       // 0x0020(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	class FText                                   ContractDescription;                               // 0x0038(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UTexture2D>              ContractImage;                                     // 0x0050(0x0030)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UMediaSource>            ContractVideo;                                     // 0x0080(0x0030)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EP2ContractDifficulty                         ContractDifficulty;                                // 0x00B0(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_B1[0x7];                                       // 0x00B1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FP2ContractReward                      ContractReward;                                    // 0x00B8(0x0048)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	bool                                          bHideItemIconBeforeCompletion;                     // 0x0100(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_101[0x7];                                      // 0x0101(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FP2ContractReward                      ContractOptionalReward;                            // 0x0108(0x0048)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TArray<class UP2ContractStaticCondition*>     ContractStaticConditions;                          // 0x0150(0x0010)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, ContainsInstancedReference, NativeAccessSpecifierPublic)
	TArray<class UP2ContractRequirement*>         ContractAcceptanceRequirements;                    // 0x0160(0x0010)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, ContainsInstancedReference, NativeAccessSpecifierPublic)
	TArray<class UP2ContractRequirement*>         ContractCompletionRequirements;                    // 0x0170(0x0010)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, ContainsInstancedReference, NativeAccessSpecifierPublic)
	TArray<class UP2ContractRequirement*>         ContractOptionalRequirements;                      // 0x0180(0x0010)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, ContainsInstancedReference, NativeAccessSpecifierPublic)
	bool                                          bAutoComplete;                                     // 0x0190(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FP2AllowContractGameMode               DisplayInGameModes;                                // 0x0191(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_195[0x3];                                      // 0x0195(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UP2ContractScript*>              ContractScripts;                                   // 0x0198(0x0010)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, ContainsInstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(FP2ContractDataInfo) == 0x000008, "Wrong alignment on FP2ContractDataInfo");
static_assert(sizeof(FP2ContractDataInfo) == 0x0001A8, "Wrong size on FP2ContractDataInfo");
static_assert(offsetof(FP2ContractDataInfo, ContractType) == 0x000000, "Member 'FP2ContractDataInfo::ContractType' has a wrong offset!");
static_assert(offsetof(FP2ContractDataInfo, bIsRepeatable) == 0x000001, "Member 'FP2ContractDataInfo::bIsRepeatable' has a wrong offset!");
static_assert(offsetof(FP2ContractDataInfo, bIsEmergentRaidTask) == 0x000002, "Member 'FP2ContractDataInfo::bIsEmergentRaidTask' has a wrong offset!");
static_assert(offsetof(FP2ContractDataInfo, EmergentRaidTaskActivationTime) == 0x000004, "Member 'FP2ContractDataInfo::EmergentRaidTaskActivationTime' has a wrong offset!");
static_assert(offsetof(FP2ContractDataInfo, ResetTypeTag) == 0x000008, "Member 'FP2ContractDataInfo::ResetTypeTag' has a wrong offset!");
static_assert(offsetof(FP2ContractDataInfo, CategoryTag) == 0x000010, "Member 'FP2ContractDataInfo::CategoryTag' has a wrong offset!");
static_assert(offsetof(FP2ContractDataInfo, FactionTag) == 0x000018, "Member 'FP2ContractDataInfo::FactionTag' has a wrong offset!");
static_assert(offsetof(FP2ContractDataInfo, DisplayName) == 0x000020, "Member 'FP2ContractDataInfo::DisplayName' has a wrong offset!");
static_assert(offsetof(FP2ContractDataInfo, ContractDescription) == 0x000038, "Member 'FP2ContractDataInfo::ContractDescription' has a wrong offset!");
static_assert(offsetof(FP2ContractDataInfo, ContractImage) == 0x000050, "Member 'FP2ContractDataInfo::ContractImage' has a wrong offset!");
static_assert(offsetof(FP2ContractDataInfo, ContractVideo) == 0x000080, "Member 'FP2ContractDataInfo::ContractVideo' has a wrong offset!");
static_assert(offsetof(FP2ContractDataInfo, ContractDifficulty) == 0x0000B0, "Member 'FP2ContractDataInfo::ContractDifficulty' has a wrong offset!");
static_assert(offsetof(FP2ContractDataInfo, ContractReward) == 0x0000B8, "Member 'FP2ContractDataInfo::ContractReward' has a wrong offset!");
static_assert(offsetof(FP2ContractDataInfo, bHideItemIconBeforeCompletion) == 0x000100, "Member 'FP2ContractDataInfo::bHideItemIconBeforeCompletion' has a wrong offset!");
static_assert(offsetof(FP2ContractDataInfo, ContractOptionalReward) == 0x000108, "Member 'FP2ContractDataInfo::ContractOptionalReward' has a wrong offset!");
static_assert(offsetof(FP2ContractDataInfo, ContractStaticConditions) == 0x000150, "Member 'FP2ContractDataInfo::ContractStaticConditions' has a wrong offset!");
static_assert(offsetof(FP2ContractDataInfo, ContractAcceptanceRequirements) == 0x000160, "Member 'FP2ContractDataInfo::ContractAcceptanceRequirements' has a wrong offset!");
static_assert(offsetof(FP2ContractDataInfo, ContractCompletionRequirements) == 0x000170, "Member 'FP2ContractDataInfo::ContractCompletionRequirements' has a wrong offset!");
static_assert(offsetof(FP2ContractDataInfo, ContractOptionalRequirements) == 0x000180, "Member 'FP2ContractDataInfo::ContractOptionalRequirements' has a wrong offset!");
static_assert(offsetof(FP2ContractDataInfo, bAutoComplete) == 0x000190, "Member 'FP2ContractDataInfo::bAutoComplete' has a wrong offset!");
static_assert(offsetof(FP2ContractDataInfo, DisplayInGameModes) == 0x000191, "Member 'FP2ContractDataInfo::DisplayInGameModes' has a wrong offset!");
static_assert(offsetof(FP2ContractDataInfo, ContractScripts) == 0x000198, "Member 'FP2ContractDataInfo::ContractScripts' has a wrong offset!");

// ScriptStruct Game.P2VoiceChannelParicipantUpdatedMessage
// 0x0018 (0x0018 - 0x0000)
struct FP2VoiceChannelParicipantUpdatedMessage final
{
public:
	bool                                          bIsSpeaking;                                       // 0x0000(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 ParticipantId;                                     // 0x0008(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FP2VoiceChannelParicipantUpdatedMessage) == 0x000008, "Wrong alignment on FP2VoiceChannelParicipantUpdatedMessage");
static_assert(sizeof(FP2VoiceChannelParicipantUpdatedMessage) == 0x000018, "Wrong size on FP2VoiceChannelParicipantUpdatedMessage");
static_assert(offsetof(FP2VoiceChannelParicipantUpdatedMessage, bIsSpeaking) == 0x000000, "Member 'FP2VoiceChannelParicipantUpdatedMessage::bIsSpeaking' has a wrong offset!");
static_assert(offsetof(FP2VoiceChannelParicipantUpdatedMessage, ParticipantId) == 0x000008, "Member 'FP2VoiceChannelParicipantUpdatedMessage::ParticipantId' has a wrong offset!");

// ScriptStruct Game.P2StashDefaultItemEntry
// 0x0018 (0x0018 - 0x0000)
struct FP2StashDefaultItemEntry final
{
public:
	struct FGameplayTag                           StashTag;                                          // 0x0000(0x0008)(Edit, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FP2InitialItemEntry>            ItemEntrys;                                        // 0x0008(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
};
static_assert(alignof(FP2StashDefaultItemEntry) == 0x000008, "Wrong alignment on FP2StashDefaultItemEntry");
static_assert(sizeof(FP2StashDefaultItemEntry) == 0x000018, "Wrong size on FP2StashDefaultItemEntry");
static_assert(offsetof(FP2StashDefaultItemEntry, StashTag) == 0x000000, "Member 'FP2StashDefaultItemEntry::StashTag' has a wrong offset!");
static_assert(offsetof(FP2StashDefaultItemEntry, ItemEntrys) == 0x000008, "Member 'FP2StashDefaultItemEntry::ItemEntrys' has a wrong offset!");

// ScriptStruct Game.P2StashDefaultFactionEntry
// 0x0018 (0x0018 - 0x0000)
struct FP2StashDefaultFactionEntry final
{
public:
	struct FGameplayTag                           FactionTag;                                        // 0x0000(0x0008)(Edit, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FP2StashDefaultItemEntry>       FactionEntries;                                    // 0x0008(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
};
static_assert(alignof(FP2StashDefaultFactionEntry) == 0x000008, "Wrong alignment on FP2StashDefaultFactionEntry");
static_assert(sizeof(FP2StashDefaultFactionEntry) == 0x000018, "Wrong size on FP2StashDefaultFactionEntry");
static_assert(offsetof(FP2StashDefaultFactionEntry, FactionTag) == 0x000000, "Member 'FP2StashDefaultFactionEntry::FactionTag' has a wrong offset!");
static_assert(offsetof(FP2StashDefaultFactionEntry, FactionEntries) == 0x000008, "Member 'FP2StashDefaultFactionEntry::FactionEntries' has a wrong offset!");

// ScriptStruct Game.P2RequirementDataInfo
// 0x0000 (0x0008 - 0x0008)
struct FP2RequirementDataInfo : public FTableRowBase
{
};
static_assert(alignof(FP2RequirementDataInfo) == 0x000008, "Wrong alignment on FP2RequirementDataInfo");
static_assert(sizeof(FP2RequirementDataInfo) == 0x000008, "Wrong size on FP2RequirementDataInfo");

// ScriptStruct Game.P2GameplayCueNotify_CameraLensEffectInfo
// 0x00A0 (0x00A0 - 0x0000)
struct FP2GameplayCueNotify_CameraLensEffectInfo final
{
public:
	struct FP2GameplayCueNotify_SpawnCondition    SpawnConditionOverride;                            // 0x0000(0x0048)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FP2GameplayCueNotify_PlacementInfo     PlacementInfoOverride;                             // 0x0048(0x0040)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
	TSubclassOf<class AActor>                     CameraLensEffect;                                  // 0x0088(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverrideSpawnCondition : 1;                       // 0x0090(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bOverridePlacementInfo : 1;                        // 0x0090(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bPlayInWorld : 1;                                  // 0x0090(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_91[0x3];                                       // 0x0091(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         WorldInnerRadius;                                  // 0x0094(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         WorldOuterRadius;                                  // 0x0098(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9C[0x4];                                       // 0x009C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FP2GameplayCueNotify_CameraLensEffectInfo) == 0x000008, "Wrong alignment on FP2GameplayCueNotify_CameraLensEffectInfo");
static_assert(sizeof(FP2GameplayCueNotify_CameraLensEffectInfo) == 0x0000A0, "Wrong size on FP2GameplayCueNotify_CameraLensEffectInfo");
static_assert(offsetof(FP2GameplayCueNotify_CameraLensEffectInfo, SpawnConditionOverride) == 0x000000, "Member 'FP2GameplayCueNotify_CameraLensEffectInfo::SpawnConditionOverride' has a wrong offset!");
static_assert(offsetof(FP2GameplayCueNotify_CameraLensEffectInfo, PlacementInfoOverride) == 0x000048, "Member 'FP2GameplayCueNotify_CameraLensEffectInfo::PlacementInfoOverride' has a wrong offset!");
static_assert(offsetof(FP2GameplayCueNotify_CameraLensEffectInfo, CameraLensEffect) == 0x000088, "Member 'FP2GameplayCueNotify_CameraLensEffectInfo::CameraLensEffect' has a wrong offset!");
static_assert(offsetof(FP2GameplayCueNotify_CameraLensEffectInfo, WorldInnerRadius) == 0x000094, "Member 'FP2GameplayCueNotify_CameraLensEffectInfo::WorldInnerRadius' has a wrong offset!");
static_assert(offsetof(FP2GameplayCueNotify_CameraLensEffectInfo, WorldOuterRadius) == 0x000098, "Member 'FP2GameplayCueNotify_CameraLensEffectInfo::WorldOuterRadius' has a wrong offset!");

// ScriptStruct Game.P2TargetData_Action
// 0x0018 (0x0020 - 0x0008)
struct FP2TargetData_Action : public FGameplayAbilityTargetData
{
public:
	uint8                                         Pad_8[0x18];                                       // 0x0008(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FP2TargetData_Action) == 0x000008, "Wrong alignment on FP2TargetData_Action");
static_assert(sizeof(FP2TargetData_Action) == 0x000020, "Wrong size on FP2TargetData_Action");

// ScriptStruct Game.AdaptiveLeanState
// 0x01E0 (0x01E0 - 0x0000)
struct alignas(0x10) FAdaptiveLeanState final
{
public:
	uint8                                         Pad_0[0x1E0];                                      // 0x0000(0x01E0)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FAdaptiveLeanState) == 0x000010, "Wrong alignment on FAdaptiveLeanState");
static_assert(sizeof(FAdaptiveLeanState) == 0x0001E0, "Wrong size on FAdaptiveLeanState");

// ScriptStruct Game.AdaptiveLeanProcessor
// 0x02E0 (0x02E0 - 0x0000)
struct alignas(0x10) FAdaptiveLeanProcessor final
{
public:
	class UAdaptiveLeanSettingsData*              SettingsData;                                      // 0x0000(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_8[0x2D8];                                      // 0x0008(0x02D8)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FAdaptiveLeanProcessor) == 0x000010, "Wrong alignment on FAdaptiveLeanProcessor");
static_assert(sizeof(FAdaptiveLeanProcessor) == 0x0002E0, "Wrong size on FAdaptiveLeanProcessor");
static_assert(offsetof(FAdaptiveLeanProcessor, SettingsData) == 0x000000, "Member 'FAdaptiveLeanProcessor::SettingsData' has a wrong offset!");

// ScriptStruct Game.P2SpeedSteps
// 0x00A8 (0x00A8 - 0x0000)
struct FP2SpeedSteps final
{
public:
	TMap<int32, class UCurveFloat*>               SpeedStepsInputScaleMap;                           // 0x0000(0x0050)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	bool                                          bUseFloatScale;                                    // 0x0050(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_51[0x7];                                       // 0x0051(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<int32, float>                            SpeedStepsFloatScaleMap;                           // 0x0058(0x0050)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
};
static_assert(alignof(FP2SpeedSteps) == 0x000008, "Wrong alignment on FP2SpeedSteps");
static_assert(sizeof(FP2SpeedSteps) == 0x0000A8, "Wrong size on FP2SpeedSteps");
static_assert(offsetof(FP2SpeedSteps, SpeedStepsInputScaleMap) == 0x000000, "Member 'FP2SpeedSteps::SpeedStepsInputScaleMap' has a wrong offset!");
static_assert(offsetof(FP2SpeedSteps, bUseFloatScale) == 0x000050, "Member 'FP2SpeedSteps::bUseFloatScale' has a wrong offset!");
static_assert(offsetof(FP2SpeedSteps, SpeedStepsFloatScaleMap) == 0x000058, "Member 'FP2SpeedSteps::SpeedStepsFloatScaleMap' has a wrong offset!");

// ScriptStruct Game.P2AbilitySet_GameplayAbility
// 0x0018 (0x0018 - 0x0000)
struct FP2AbilitySet_GameplayAbility final
{
public:
	TSubclassOf<class UP2Ability>                 Ability;                                           // 0x0000(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         AbilityLevel;                                      // 0x0008(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           InputTag;                                          // 0x000C(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FP2AbilitySet_GameplayAbility) == 0x000008, "Wrong alignment on FP2AbilitySet_GameplayAbility");
static_assert(sizeof(FP2AbilitySet_GameplayAbility) == 0x000018, "Wrong size on FP2AbilitySet_GameplayAbility");
static_assert(offsetof(FP2AbilitySet_GameplayAbility, Ability) == 0x000000, "Member 'FP2AbilitySet_GameplayAbility::Ability' has a wrong offset!");
static_assert(offsetof(FP2AbilitySet_GameplayAbility, AbilityLevel) == 0x000008, "Member 'FP2AbilitySet_GameplayAbility::AbilityLevel' has a wrong offset!");
static_assert(offsetof(FP2AbilitySet_GameplayAbility, InputTag) == 0x00000C, "Member 'FP2AbilitySet_GameplayAbility::InputTag' has a wrong offset!");

// ScriptStruct Game.P2AbilitySet_GameplayEffect
// 0x0020 (0x0020 - 0x0000)
struct FP2AbilitySet_GameplayEffect final
{
public:
	TSubclassOf<class UGameplayEffect>            GameplayEffect;                                    // 0x0000(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         EffectLevel;                                       // 0x0008(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UP2AbilitySet_StackCalculation*         StackCalculation;                                  // 0x0010(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, PersistentInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Stacks;                                            // 0x0018(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C[0x4];                                       // 0x001C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FP2AbilitySet_GameplayEffect) == 0x000008, "Wrong alignment on FP2AbilitySet_GameplayEffect");
static_assert(sizeof(FP2AbilitySet_GameplayEffect) == 0x000020, "Wrong size on FP2AbilitySet_GameplayEffect");
static_assert(offsetof(FP2AbilitySet_GameplayEffect, GameplayEffect) == 0x000000, "Member 'FP2AbilitySet_GameplayEffect::GameplayEffect' has a wrong offset!");
static_assert(offsetof(FP2AbilitySet_GameplayEffect, EffectLevel) == 0x000008, "Member 'FP2AbilitySet_GameplayEffect::EffectLevel' has a wrong offset!");
static_assert(offsetof(FP2AbilitySet_GameplayEffect, StackCalculation) == 0x000010, "Member 'FP2AbilitySet_GameplayEffect::StackCalculation' has a wrong offset!");
static_assert(offsetof(FP2AbilitySet_GameplayEffect, Stacks) == 0x000018, "Member 'FP2AbilitySet_GameplayEffect::Stacks' has a wrong offset!");

// ScriptStruct Game.P2AbilitySet_GrantedHandles
// 0x0020 (0x0020 - 0x0000)
struct FP2AbilitySet_GrantedHandles final
{
public:
	TArray<struct FGameplayAbilitySpecHandle>     AbilitySpecHandles;                                // 0x0000(0x0010)(ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	TArray<struct FActiveGameplayEffectHandle>    GameplayEffectHandles;                             // 0x0010(0x0010)(ZeroConstructor, Protected, NativeAccessSpecifierProtected)
};
static_assert(alignof(FP2AbilitySet_GrantedHandles) == 0x000008, "Wrong alignment on FP2AbilitySet_GrantedHandles");
static_assert(sizeof(FP2AbilitySet_GrantedHandles) == 0x000020, "Wrong size on FP2AbilitySet_GrantedHandles");
static_assert(offsetof(FP2AbilitySet_GrantedHandles, AbilitySpecHandles) == 0x000000, "Member 'FP2AbilitySet_GrantedHandles::AbilitySpecHandles' has a wrong offset!");
static_assert(offsetof(FP2AbilitySet_GrantedHandles, GameplayEffectHandles) == 0x000010, "Member 'FP2AbilitySet_GrantedHandles::GameplayEffectHandles' has a wrong offset!");

// ScriptStruct Game.P2ReplicatedMontageData
// 0x002C (0x0038 - 0x000C)
struct FP2ReplicatedMontageData final : public FFastArraySerializerItem
{
public:
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UP2ItemData*                            ContextItemData;                                   // 0x0010(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           MontageTag;                                        // 0x0018(0x0008)(Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         SectionIndex;                                      // 0x0020(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         NextSectionIndex;                                  // 0x0024(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PlayRate;                                          // 0x0028(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ServerStartTime;                                   // 0x002C(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bSkipMontageStopOnRemove;                          // 0x0030(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_31[0x7];                                       // 0x0031(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FP2ReplicatedMontageData) == 0x000008, "Wrong alignment on FP2ReplicatedMontageData");
static_assert(sizeof(FP2ReplicatedMontageData) == 0x000038, "Wrong size on FP2ReplicatedMontageData");
static_assert(offsetof(FP2ReplicatedMontageData, ContextItemData) == 0x000010, "Member 'FP2ReplicatedMontageData::ContextItemData' has a wrong offset!");
static_assert(offsetof(FP2ReplicatedMontageData, MontageTag) == 0x000018, "Member 'FP2ReplicatedMontageData::MontageTag' has a wrong offset!");
static_assert(offsetof(FP2ReplicatedMontageData, SectionIndex) == 0x000020, "Member 'FP2ReplicatedMontageData::SectionIndex' has a wrong offset!");
static_assert(offsetof(FP2ReplicatedMontageData, NextSectionIndex) == 0x000024, "Member 'FP2ReplicatedMontageData::NextSectionIndex' has a wrong offset!");
static_assert(offsetof(FP2ReplicatedMontageData, PlayRate) == 0x000028, "Member 'FP2ReplicatedMontageData::PlayRate' has a wrong offset!");
static_assert(offsetof(FP2ReplicatedMontageData, ServerStartTime) == 0x00002C, "Member 'FP2ReplicatedMontageData::ServerStartTime' has a wrong offset!");
static_assert(offsetof(FP2ReplicatedMontageData, bSkipMontageStopOnRemove) == 0x000030, "Member 'FP2ReplicatedMontageData::bSkipMontageStopOnRemove' has a wrong offset!");

// ScriptStruct Game.P2ActiveMontageData
// 0x0098 (0x0098 - 0x0000)
struct FP2ActiveMontageData final
{
public:
	struct FP2ReplicatedMontageData               StartData;                                         // 0x0000(0x0038)(Transient, NoDestructor, NativeAccessSpecifierPublic)
	class UP2Ability*                             InstigatorAbility;                                 // 0x0038(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimMontage*                           MontageFPP;                                        // 0x0040(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimInstance*                          AnimInstanceFPP;                                   // 0x0048(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimMontage*                           MontageTPP;                                        // 0x0050(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimInstance*                          AnimInstanceTPP;                                   // 0x0058(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimMontage*                           MontageItem;                                       // 0x0060(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimInstance*                          AnimInstanceItemTPP;                               // 0x0068(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimInstance*                          AnimInstanceItemFPP;                               // 0x0070(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_78[0x20];                                      // 0x0078(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FP2ActiveMontageData) == 0x000008, "Wrong alignment on FP2ActiveMontageData");
static_assert(sizeof(FP2ActiveMontageData) == 0x000098, "Wrong size on FP2ActiveMontageData");
static_assert(offsetof(FP2ActiveMontageData, StartData) == 0x000000, "Member 'FP2ActiveMontageData::StartData' has a wrong offset!");
static_assert(offsetof(FP2ActiveMontageData, InstigatorAbility) == 0x000038, "Member 'FP2ActiveMontageData::InstigatorAbility' has a wrong offset!");
static_assert(offsetof(FP2ActiveMontageData, MontageFPP) == 0x000040, "Member 'FP2ActiveMontageData::MontageFPP' has a wrong offset!");
static_assert(offsetof(FP2ActiveMontageData, AnimInstanceFPP) == 0x000048, "Member 'FP2ActiveMontageData::AnimInstanceFPP' has a wrong offset!");
static_assert(offsetof(FP2ActiveMontageData, MontageTPP) == 0x000050, "Member 'FP2ActiveMontageData::MontageTPP' has a wrong offset!");
static_assert(offsetof(FP2ActiveMontageData, AnimInstanceTPP) == 0x000058, "Member 'FP2ActiveMontageData::AnimInstanceTPP' has a wrong offset!");
static_assert(offsetof(FP2ActiveMontageData, MontageItem) == 0x000060, "Member 'FP2ActiveMontageData::MontageItem' has a wrong offset!");
static_assert(offsetof(FP2ActiveMontageData, AnimInstanceItemTPP) == 0x000068, "Member 'FP2ActiveMontageData::AnimInstanceItemTPP' has a wrong offset!");
static_assert(offsetof(FP2ActiveMontageData, AnimInstanceItemFPP) == 0x000070, "Member 'FP2ActiveMontageData::AnimInstanceItemFPP' has a wrong offset!");

// ScriptStruct Game.P2ReplicatedMontageArray
// 0x0018 (0x0120 - 0x0108)
struct FP2ReplicatedMontageArray final : public FFastArraySerializer
{
public:
	TArray<struct FP2ReplicatedMontageData>       ReplicatedMontages;                                // 0x0108(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_118[0x8];                                      // 0x0118(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FP2ReplicatedMontageArray) == 0x000008, "Wrong alignment on FP2ReplicatedMontageArray");
static_assert(sizeof(FP2ReplicatedMontageArray) == 0x000120, "Wrong size on FP2ReplicatedMontageArray");
static_assert(offsetof(FP2ReplicatedMontageArray, ReplicatedMontages) == 0x000108, "Member 'FP2ReplicatedMontageArray::ReplicatedMontages' has a wrong offset!");

// ScriptStruct Game.P2AbilityQueue
// 0x0018 (0x0018 - 0x0000)
struct alignas(0x08) FP2AbilityQueue final
{
public:
	uint8                                         Pad_0[0x18];                                       // 0x0000(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FP2AbilityQueue) == 0x000008, "Wrong alignment on FP2AbilityQueue");
static_assert(sizeof(FP2AbilityQueue) == 0x000018, "Wrong size on FP2AbilityQueue");

// ScriptStruct Game.P2AbilityControl
// 0x0158 (0x0158 - 0x0000)
struct FP2AbilityControl final
{
public:
	struct FGameplayTag                           ControlTag;                                        // 0x0000(0x0008)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTagContainer                  AbilityTagsToBlock;                                // 0x0008(0x0020)(Edit, NativeAccessSpecifierPublic)
	struct FGameplayTagQuery                      AbilityQueryToBlock;                               // 0x0028(0x0048)(Edit, NativeAccessSpecifierPublic)
	uint8                                         Pad_70[0x20];                                      // 0x0070(0x0020)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTagContainer                  AbilityTagsToCancel;                               // 0x0090(0x0020)(Edit, NativeAccessSpecifierPublic)
	struct FGameplayTagQuery                      AbilityQueryToCancel;                              // 0x00B0(0x0048)(Edit, NativeAccessSpecifierPublic)
	uint8                                         Pad_F8[0x20];                                      // 0x00F8(0x0020)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTagContainer                  ActivationRequiredTags;                            // 0x0118(0x0020)(Edit, NativeAccessSpecifierPublic)
	struct FGameplayTagContainer                  ActivationBlockedTags;                             // 0x0138(0x0020)(Edit, NativeAccessSpecifierPublic)
};
static_assert(alignof(FP2AbilityControl) == 0x000008, "Wrong alignment on FP2AbilityControl");
static_assert(sizeof(FP2AbilityControl) == 0x000158, "Wrong size on FP2AbilityControl");
static_assert(offsetof(FP2AbilityControl, ControlTag) == 0x000000, "Member 'FP2AbilityControl::ControlTag' has a wrong offset!");
static_assert(offsetof(FP2AbilityControl, AbilityTagsToBlock) == 0x000008, "Member 'FP2AbilityControl::AbilityTagsToBlock' has a wrong offset!");
static_assert(offsetof(FP2AbilityControl, AbilityQueryToBlock) == 0x000028, "Member 'FP2AbilityControl::AbilityQueryToBlock' has a wrong offset!");
static_assert(offsetof(FP2AbilityControl, AbilityTagsToCancel) == 0x000090, "Member 'FP2AbilityControl::AbilityTagsToCancel' has a wrong offset!");
static_assert(offsetof(FP2AbilityControl, AbilityQueryToCancel) == 0x0000B0, "Member 'FP2AbilityControl::AbilityQueryToCancel' has a wrong offset!");
static_assert(offsetof(FP2AbilityControl, ActivationRequiredTags) == 0x000118, "Member 'FP2AbilityControl::ActivationRequiredTags' has a wrong offset!");
static_assert(offsetof(FP2AbilityControl, ActivationBlockedTags) == 0x000138, "Member 'FP2AbilityControl::ActivationBlockedTags' has a wrong offset!");

// ScriptStruct Game.P2DrawTrajectoryParameters
// 0x0020 (0x0020 - 0x0000)
struct FP2DrawTrajectoryParameters final
{
public:
	class AP2HeroCharacter*                       Character;                                         // 0x0000(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UNiagaraSystem*                         TrajectorySystem;                                  // 0x0008(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         NumSteps;                                          // 0x0010(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LookForwardTime;                                   // 0x0014(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsOverhand;                                       // 0x0018(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19[0x7];                                       // 0x0019(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FP2DrawTrajectoryParameters) == 0x000008, "Wrong alignment on FP2DrawTrajectoryParameters");
static_assert(sizeof(FP2DrawTrajectoryParameters) == 0x000020, "Wrong size on FP2DrawTrajectoryParameters");
static_assert(offsetof(FP2DrawTrajectoryParameters, Character) == 0x000000, "Member 'FP2DrawTrajectoryParameters::Character' has a wrong offset!");
static_assert(offsetof(FP2DrawTrajectoryParameters, TrajectorySystem) == 0x000008, "Member 'FP2DrawTrajectoryParameters::TrajectorySystem' has a wrong offset!");
static_assert(offsetof(FP2DrawTrajectoryParameters, NumSteps) == 0x000010, "Member 'FP2DrawTrajectoryParameters::NumSteps' has a wrong offset!");
static_assert(offsetof(FP2DrawTrajectoryParameters, LookForwardTime) == 0x000014, "Member 'FP2DrawTrajectoryParameters::LookForwardTime' has a wrong offset!");
static_assert(offsetof(FP2DrawTrajectoryParameters, bIsOverhand) == 0x000018, "Member 'FP2DrawTrajectoryParameters::bIsOverhand' has a wrong offset!");

// ScriptStruct Game.P2BoneSimulationSettings
// 0x000C (0x000C - 0x0000)
struct FP2BoneSimulationSettings final
{
public:
	bool                                          bIncludeSelf;                                      // 0x0000(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   BoneName;                                          // 0x0004(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FP2BoneSimulationSettings) == 0x000004, "Wrong alignment on FP2BoneSimulationSettings");
static_assert(sizeof(FP2BoneSimulationSettings) == 0x00000C, "Wrong size on FP2BoneSimulationSettings");
static_assert(offsetof(FP2BoneSimulationSettings, bIncludeSelf) == 0x000000, "Member 'FP2BoneSimulationSettings::bIncludeSelf' has a wrong offset!");
static_assert(offsetof(FP2BoneSimulationSettings, BoneName) == 0x000004, "Member 'FP2BoneSimulationSettings::BoneName' has a wrong offset!");

// ScriptStruct Game.P2RagdolizeParameters
// 0x0048 (0x0048 - 0x0000)
struct FP2RagdolizeParameters final
{
public:
	bool                                          bRestoreOnFinish;                                  // 0x0000(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDisableControlRotationInMovementComp;             // 0x0001(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDisableControlRotationInCharacter;                // 0x0002(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3[0x1];                                        // 0x0003(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   RagdollCollisionProfile;                           // 0x0004(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   AnimCollisionProfile;                              // 0x000C(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class AP2RagdollController>       RagdollControllerActorClass;                       // 0x0018(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FP2RagdollControllerConfig             RagdollControllerConfig;                           // 0x0020(0x0014)(Edit, BlueprintVisible, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
	class FName                                   CapsuleCollisionProfile;                           // 0x0034(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   CapsuleDbnoCollisionProfile;                       // 0x003C(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDisableCollision;                                 // 0x0044(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_45[0x3];                                       // 0x0045(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FP2RagdolizeParameters) == 0x000008, "Wrong alignment on FP2RagdolizeParameters");
static_assert(sizeof(FP2RagdolizeParameters) == 0x000048, "Wrong size on FP2RagdolizeParameters");
static_assert(offsetof(FP2RagdolizeParameters, bRestoreOnFinish) == 0x000000, "Member 'FP2RagdolizeParameters::bRestoreOnFinish' has a wrong offset!");
static_assert(offsetof(FP2RagdolizeParameters, bDisableControlRotationInMovementComp) == 0x000001, "Member 'FP2RagdolizeParameters::bDisableControlRotationInMovementComp' has a wrong offset!");
static_assert(offsetof(FP2RagdolizeParameters, bDisableControlRotationInCharacter) == 0x000002, "Member 'FP2RagdolizeParameters::bDisableControlRotationInCharacter' has a wrong offset!");
static_assert(offsetof(FP2RagdolizeParameters, RagdollCollisionProfile) == 0x000004, "Member 'FP2RagdolizeParameters::RagdollCollisionProfile' has a wrong offset!");
static_assert(offsetof(FP2RagdolizeParameters, AnimCollisionProfile) == 0x00000C, "Member 'FP2RagdolizeParameters::AnimCollisionProfile' has a wrong offset!");
static_assert(offsetof(FP2RagdolizeParameters, RagdollControllerActorClass) == 0x000018, "Member 'FP2RagdolizeParameters::RagdollControllerActorClass' has a wrong offset!");
static_assert(offsetof(FP2RagdolizeParameters, RagdollControllerConfig) == 0x000020, "Member 'FP2RagdolizeParameters::RagdollControllerConfig' has a wrong offset!");
static_assert(offsetof(FP2RagdolizeParameters, CapsuleCollisionProfile) == 0x000034, "Member 'FP2RagdolizeParameters::CapsuleCollisionProfile' has a wrong offset!");
static_assert(offsetof(FP2RagdolizeParameters, CapsuleDbnoCollisionProfile) == 0x00003C, "Member 'FP2RagdolizeParameters::CapsuleDbnoCollisionProfile' has a wrong offset!");
static_assert(offsetof(FP2RagdolizeParameters, bDisableCollision) == 0x000044, "Member 'FP2RagdolizeParameters::bDisableCollision' has a wrong offset!");

// ScriptStruct Game.P2RootMotionForceData
// 0x00D0 (0x00D0 - 0x0000)
struct FP2RootMotionForceData final
{
public:
	struct FTransform                             StartTransform;                                    // 0x0000(0x0060)(Edit, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FTransform                             TargetTransform;                                   // 0x0060(0x0060)(Edit, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Duration;                                          // 0x00C0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsRelative;                                       // 0x00C4(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C5[0x3];                                       // 0x00C5(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class UCurveFloat*                            MotionCurve;                                       // 0x00C8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FP2RootMotionForceData) == 0x000010, "Wrong alignment on FP2RootMotionForceData");
static_assert(sizeof(FP2RootMotionForceData) == 0x0000D0, "Wrong size on FP2RootMotionForceData");
static_assert(offsetof(FP2RootMotionForceData, StartTransform) == 0x000000, "Member 'FP2RootMotionForceData::StartTransform' has a wrong offset!");
static_assert(offsetof(FP2RootMotionForceData, TargetTransform) == 0x000060, "Member 'FP2RootMotionForceData::TargetTransform' has a wrong offset!");
static_assert(offsetof(FP2RootMotionForceData, Duration) == 0x0000C0, "Member 'FP2RootMotionForceData::Duration' has a wrong offset!");
static_assert(offsetof(FP2RootMotionForceData, bIsRelative) == 0x0000C4, "Member 'FP2RootMotionForceData::bIsRelative' has a wrong offset!");
static_assert(offsetof(FP2RootMotionForceData, MotionCurve) == 0x0000C8, "Member 'FP2RootMotionForceData::MotionCurve' has a wrong offset!");

// ScriptStruct Game.P2RootMotionSource_RootMotionWarping
// 0x0000 (0x00E0 - 0x00E0)
struct FP2RootMotionSource_RootMotionWarping final : public FRootMotionSource
{
public:
	class UAnimMontage*                           Montage;                                           // 0x00D8(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FP2RootMotionSource_RootMotionWarping) == 0x000010, "Wrong alignment on FP2RootMotionSource_RootMotionWarping");
static_assert(sizeof(FP2RootMotionSource_RootMotionWarping) == 0x0000E0, "Wrong size on FP2RootMotionSource_RootMotionWarping");
static_assert(offsetof(FP2RootMotionSource_RootMotionWarping, Montage) == 0x0000D8, "Member 'FP2RootMotionSource_RootMotionWarping::Montage' has a wrong offset!");

// ScriptStruct Game.P2ChangeWeaponQueueData
// 0x000C (0x000C - 0x0000)
struct alignas(0x04) FP2ChangeWeaponQueueData final
{
public:
	uint8                                         Pad_0[0xC];                                        // 0x0000(0x000C)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FP2ChangeWeaponQueueData) == 0x000004, "Wrong alignment on FP2ChangeWeaponQueueData");
static_assert(sizeof(FP2ChangeWeaponQueueData) == 0x00000C, "Wrong size on FP2ChangeWeaponQueueData");

// ScriptStruct Game.MeleeSwingState
// 0x00E0 (0x00E0 - 0x0000)
struct FMeleeSwingState final
{
public:
	float                                         SwingStartGT;                                      // 0x0000(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bImpactAbortActive;                                // 0x0004(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bHasQueuedAttack;                                  // 0x0005(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_6[0x2];                                        // 0x0006(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayEventData                     QueuedPayload;                                     // 0x0008(0x00B0)(Transient, NativeAccessSpecifierPublic)
	bool                                          bHasCosmeticStart;                                 // 0x00B8(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_B9[0x7];                                       // 0x00B9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UNiagaraComponent*                      CosmeticHitComponent;                              // 0x00C0(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                CosmeticLocation;                                  // 0x00C8(0x0018)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMeleeSwingState) == 0x000008, "Wrong alignment on FMeleeSwingState");
static_assert(sizeof(FMeleeSwingState) == 0x0000E0, "Wrong size on FMeleeSwingState");
static_assert(offsetof(FMeleeSwingState, SwingStartGT) == 0x000000, "Member 'FMeleeSwingState::SwingStartGT' has a wrong offset!");
static_assert(offsetof(FMeleeSwingState, bImpactAbortActive) == 0x000004, "Member 'FMeleeSwingState::bImpactAbortActive' has a wrong offset!");
static_assert(offsetof(FMeleeSwingState, bHasQueuedAttack) == 0x000005, "Member 'FMeleeSwingState::bHasQueuedAttack' has a wrong offset!");
static_assert(offsetof(FMeleeSwingState, QueuedPayload) == 0x000008, "Member 'FMeleeSwingState::QueuedPayload' has a wrong offset!");
static_assert(offsetof(FMeleeSwingState, bHasCosmeticStart) == 0x0000B8, "Member 'FMeleeSwingState::bHasCosmeticStart' has a wrong offset!");
static_assert(offsetof(FMeleeSwingState, CosmeticHitComponent) == 0x0000C0, "Member 'FMeleeSwingState::CosmeticHitComponent' has a wrong offset!");
static_assert(offsetof(FMeleeSwingState, CosmeticLocation) == 0x0000C8, "Member 'FMeleeSwingState::CosmeticLocation' has a wrong offset!");

// ScriptStruct Game.P2PLSDNotificationConfig
// 0x0030 (0x0030 - 0x0000)
struct FP2PLSDNotificationConfig final
{
public:
	bool                                          bEnable;                                           // 0x0000(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsInstant;                                        // 0x0001(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bShowImportantMessage;                             // 0x0002(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3[0x5];                                        // 0x0003(0x0005)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   ImportantMessage;                                  // 0x0008(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	float                                         MessageDuration;                                   // 0x0020(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bPlayPLSDVoice;                                    // 0x0024(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_25[0x3];                                       // 0x0025(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTag                           PLSDVoiceTag;                                      // 0x0028(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FP2PLSDNotificationConfig) == 0x000008, "Wrong alignment on FP2PLSDNotificationConfig");
static_assert(sizeof(FP2PLSDNotificationConfig) == 0x000030, "Wrong size on FP2PLSDNotificationConfig");
static_assert(offsetof(FP2PLSDNotificationConfig, bEnable) == 0x000000, "Member 'FP2PLSDNotificationConfig::bEnable' has a wrong offset!");
static_assert(offsetof(FP2PLSDNotificationConfig, bIsInstant) == 0x000001, "Member 'FP2PLSDNotificationConfig::bIsInstant' has a wrong offset!");
static_assert(offsetof(FP2PLSDNotificationConfig, bShowImportantMessage) == 0x000002, "Member 'FP2PLSDNotificationConfig::bShowImportantMessage' has a wrong offset!");
static_assert(offsetof(FP2PLSDNotificationConfig, ImportantMessage) == 0x000008, "Member 'FP2PLSDNotificationConfig::ImportantMessage' has a wrong offset!");
static_assert(offsetof(FP2PLSDNotificationConfig, MessageDuration) == 0x000020, "Member 'FP2PLSDNotificationConfig::MessageDuration' has a wrong offset!");
static_assert(offsetof(FP2PLSDNotificationConfig, bPlayPLSDVoice) == 0x000024, "Member 'FP2PLSDNotificationConfig::bPlayPLSDVoice' has a wrong offset!");
static_assert(offsetof(FP2PLSDNotificationConfig, PLSDVoiceTag) == 0x000028, "Member 'FP2PLSDNotificationConfig::PLSDVoiceTag' has a wrong offset!");

// ScriptStruct Game.MultiWorldAccess_TransferActorParameters
// 0x0080 (0x0080 - 0x0000)
struct FMultiWorldAccess_TransferActorParameters final
{
public:
	bool                                          bSetPhysicsActorTransform;                         // 0x0000(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0xF];                                        // 0x0001(0x000F)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             Transform;                                         // 0x0010(0x0060)(Edit, BlueprintVisible, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETeleportType                                 Teleport;                                          // 0x0070(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_71[0xF];                                       // 0x0071(0x000F)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FMultiWorldAccess_TransferActorParameters) == 0x000010, "Wrong alignment on FMultiWorldAccess_TransferActorParameters");
static_assert(sizeof(FMultiWorldAccess_TransferActorParameters) == 0x000080, "Wrong size on FMultiWorldAccess_TransferActorParameters");
static_assert(offsetof(FMultiWorldAccess_TransferActorParameters, bSetPhysicsActorTransform) == 0x000000, "Member 'FMultiWorldAccess_TransferActorParameters::bSetPhysicsActorTransform' has a wrong offset!");
static_assert(offsetof(FMultiWorldAccess_TransferActorParameters, Transform) == 0x000010, "Member 'FMultiWorldAccess_TransferActorParameters::Transform' has a wrong offset!");
static_assert(offsetof(FMultiWorldAccess_TransferActorParameters, Teleport) == 0x000070, "Member 'FMultiWorldAccess_TransferActorParameters::Teleport' has a wrong offset!");

// ScriptStruct Game.P2PLSDNotificationConfig_RaidTimer
// 0x0040 (0x0040 - 0x0000)
struct FP2PLSDNotificationConfig_RaidTimer final
{
public:
	float                                         RemainingRaidTimeInSeconds;                        // 0x0000(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MinSessionDifficulty;                              // 0x0004(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FP2PLSDNotificationConfig              Config;                                            // 0x0008(0x0030)(Edit, BlueprintVisible, DisableEditOnInstance, NativeAccessSpecifierPublic)
	bool                                          bNotified;                                         // 0x0038(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_39[0x7];                                       // 0x0039(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FP2PLSDNotificationConfig_RaidTimer) == 0x000008, "Wrong alignment on FP2PLSDNotificationConfig_RaidTimer");
static_assert(sizeof(FP2PLSDNotificationConfig_RaidTimer) == 0x000040, "Wrong size on FP2PLSDNotificationConfig_RaidTimer");
static_assert(offsetof(FP2PLSDNotificationConfig_RaidTimer, RemainingRaidTimeInSeconds) == 0x000000, "Member 'FP2PLSDNotificationConfig_RaidTimer::RemainingRaidTimeInSeconds' has a wrong offset!");
static_assert(offsetof(FP2PLSDNotificationConfig_RaidTimer, MinSessionDifficulty) == 0x000004, "Member 'FP2PLSDNotificationConfig_RaidTimer::MinSessionDifficulty' has a wrong offset!");
static_assert(offsetof(FP2PLSDNotificationConfig_RaidTimer, Config) == 0x000008, "Member 'FP2PLSDNotificationConfig_RaidTimer::Config' has a wrong offset!");
static_assert(offsetof(FP2PLSDNotificationConfig_RaidTimer, bNotified) == 0x000038, "Member 'FP2PLSDNotificationConfig_RaidTimer::bNotified' has a wrong offset!");

// ScriptStruct Game.P2AmmoSelection
// 0x0010 (0x0010 - 0x0000)
struct FP2AmmoSelection final
{
public:
	class UP2AmmoData*                            AmmoData;                                          // 0x0000(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         NumRoundsToLoad;                                   // 0x0008(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FP2AmmoSelection) == 0x000008, "Wrong alignment on FP2AmmoSelection");
static_assert(sizeof(FP2AmmoSelection) == 0x000010, "Wrong size on FP2AmmoSelection");
static_assert(offsetof(FP2AmmoSelection, AmmoData) == 0x000000, "Member 'FP2AmmoSelection::AmmoData' has a wrong offset!");
static_assert(offsetof(FP2AmmoSelection, NumRoundsToLoad) == 0x000008, "Member 'FP2AmmoSelection::NumRoundsToLoad' has a wrong offset!");

// ScriptStruct Game.P2MapContractRequirementInfo
// 0x0080 (0x0080 - 0x0000)
struct FP2MapContractRequirementInfo final
{
public:
	struct FGameplayTagContainer                  Locations;                                         // 0x0000(0x0020)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FGameplayTagContainer                  Areas;                                             // 0x0020(0x0020)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FGameplayTagContainer                  Meshes;                                            // 0x0040(0x0020)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FGameplayTagContainer                  Layers;                                            // 0x0060(0x0020)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
};
static_assert(alignof(FP2MapContractRequirementInfo) == 0x000008, "Wrong alignment on FP2MapContractRequirementInfo");
static_assert(sizeof(FP2MapContractRequirementInfo) == 0x000080, "Wrong size on FP2MapContractRequirementInfo");
static_assert(offsetof(FP2MapContractRequirementInfo, Locations) == 0x000000, "Member 'FP2MapContractRequirementInfo::Locations' has a wrong offset!");
static_assert(offsetof(FP2MapContractRequirementInfo, Areas) == 0x000020, "Member 'FP2MapContractRequirementInfo::Areas' has a wrong offset!");
static_assert(offsetof(FP2MapContractRequirementInfo, Meshes) == 0x000040, "Member 'FP2MapContractRequirementInfo::Meshes' has a wrong offset!");
static_assert(offsetof(FP2MapContractRequirementInfo, Layers) == 0x000060, "Member 'FP2MapContractRequirementInfo::Layers' has a wrong offset!");

// ScriptStruct Game.P2ReloadCueParams
// 0x0038 (0x0038 - 0x0000)
struct FP2ReloadCueParams final
{
public:
	TArray<struct FP2AmmoSelection>               AmmoSelection;                                     // 0x0000(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	class UP2MagazineData*                        OldMagazineData;                                   // 0x0010(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UP2Container*                           OldMagazineContainer;                              // 0x0018(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UP2MagazineData*                        NewMagazineData;                                   // 0x0020(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UP2Container*                           NewMagazineContainer;                              // 0x0028(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EP2ReloadType                                 ReloadType;                                        // 0x0030(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_31[0x7];                                       // 0x0031(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FP2ReloadCueParams) == 0x000008, "Wrong alignment on FP2ReloadCueParams");
static_assert(sizeof(FP2ReloadCueParams) == 0x000038, "Wrong size on FP2ReloadCueParams");
static_assert(offsetof(FP2ReloadCueParams, AmmoSelection) == 0x000000, "Member 'FP2ReloadCueParams::AmmoSelection' has a wrong offset!");
static_assert(offsetof(FP2ReloadCueParams, OldMagazineData) == 0x000010, "Member 'FP2ReloadCueParams::OldMagazineData' has a wrong offset!");
static_assert(offsetof(FP2ReloadCueParams, OldMagazineContainer) == 0x000018, "Member 'FP2ReloadCueParams::OldMagazineContainer' has a wrong offset!");
static_assert(offsetof(FP2ReloadCueParams, NewMagazineData) == 0x000020, "Member 'FP2ReloadCueParams::NewMagazineData' has a wrong offset!");
static_assert(offsetof(FP2ReloadCueParams, NewMagazineContainer) == 0x000028, "Member 'FP2ReloadCueParams::NewMagazineContainer' has a wrong offset!");
static_assert(offsetof(FP2ReloadCueParams, ReloadType) == 0x000030, "Member 'FP2ReloadCueParams::ReloadType' has a wrong offset!");

// ScriptStruct Game.P2ActionMontageTagPair
// 0x0010 (0x0010 - 0x0000)
struct FP2ActionMontageTagPair final
{
public:
	struct FGameplayTag                           UnarmedMontageTag;                                 // 0x0000(0x0008)(Edit, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           ItemMontageTag;                                    // 0x0008(0x0008)(Edit, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FP2ActionMontageTagPair) == 0x000004, "Wrong alignment on FP2ActionMontageTagPair");
static_assert(sizeof(FP2ActionMontageTagPair) == 0x000010, "Wrong size on FP2ActionMontageTagPair");
static_assert(offsetof(FP2ActionMontageTagPair, UnarmedMontageTag) == 0x000000, "Member 'FP2ActionMontageTagPair::UnarmedMontageTag' has a wrong offset!");
static_assert(offsetof(FP2ActionMontageTagPair, ItemMontageTag) == 0x000008, "Member 'FP2ActionMontageTagPair::ItemMontageTag' has a wrong offset!");

// ScriptStruct Game.P2InteractionParameters
// 0x0020 (0x0020 - 0x0000)
struct alignas(0x08) FP2InteractionParameters final
{
public:
	uint8                                         Pad_0[0x20];                                       // 0x0000(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FP2InteractionParameters) == 0x000008, "Wrong alignment on FP2InteractionParameters");
static_assert(sizeof(FP2InteractionParameters) == 0x000020, "Wrong size on FP2InteractionParameters");

// ScriptStruct Game.P2MeshComponentState
// 0x01A8 (0x01A8 - 0x0000)
struct alignas(0x08) FP2MeshComponentState final
{
public:
	uint8                                         Pad_0[0x1A8];                                      // 0x0000(0x01A8)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FP2MeshComponentState) == 0x000008, "Wrong alignment on FP2MeshComponentState");
static_assert(sizeof(FP2MeshComponentState) == 0x0001A8, "Wrong size on FP2MeshComponentState");

// ScriptStruct Game.P2ActionRequiredTransformationItems
// 0x0028 (0x0028 - 0x0000)
struct FP2ActionRequiredTransformationItems final
{
public:
	TArray<struct FP2ExchangeInfo>                OriginalItems;                                     // 0x0000(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TArray<struct FP2ExchangeInfo>                ResultingItems;                                    // 0x0010(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	bool                                          bTransformOnceOnly;                                // 0x0020(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_21[0x7];                                       // 0x0021(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FP2ActionRequiredTransformationItems) == 0x000008, "Wrong alignment on FP2ActionRequiredTransformationItems");
static_assert(sizeof(FP2ActionRequiredTransformationItems) == 0x000028, "Wrong size on FP2ActionRequiredTransformationItems");
static_assert(offsetof(FP2ActionRequiredTransformationItems, OriginalItems) == 0x000000, "Member 'FP2ActionRequiredTransformationItems::OriginalItems' has a wrong offset!");
static_assert(offsetof(FP2ActionRequiredTransformationItems, ResultingItems) == 0x000010, "Member 'FP2ActionRequiredTransformationItems::ResultingItems' has a wrong offset!");
static_assert(offsetof(FP2ActionRequiredTransformationItems, bTransformOnceOnly) == 0x000020, "Member 'FP2ActionRequiredTransformationItems::bTransformOnceOnly' has a wrong offset!");

// ScriptStruct Game.P2ActionEquippedItem
// 0x0018 (0x0018 - 0x0000)
struct FP2ActionEquippedItem final
{
public:
	class UP2ItemData*                            Item;                                              // 0x0000(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           SlotTag;                                           // 0x0008(0x0008)(Edit, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bConsumeOnInteraction;                             // 0x0010(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x7];                                       // 0x0011(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FP2ActionEquippedItem) == 0x000008, "Wrong alignment on FP2ActionEquippedItem");
static_assert(sizeof(FP2ActionEquippedItem) == 0x000018, "Wrong size on FP2ActionEquippedItem");
static_assert(offsetof(FP2ActionEquippedItem, Item) == 0x000000, "Member 'FP2ActionEquippedItem::Item' has a wrong offset!");
static_assert(offsetof(FP2ActionEquippedItem, SlotTag) == 0x000008, "Member 'FP2ActionEquippedItem::SlotTag' has a wrong offset!");
static_assert(offsetof(FP2ActionEquippedItem, bConsumeOnInteraction) == 0x000010, "Member 'FP2ActionEquippedItem::bConsumeOnInteraction' has a wrong offset!");

// ScriptStruct Game.P2AvailableForInteractionResult
// 0x000C (0x000C - 0x0000)
struct alignas(0x04) FP2AvailableForInteractionResult final
{
public:
	bool                                          bInteractable;                                     // 0x0000(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bInteractionAvailableNow;                          // 0x0001(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2[0xA];                                        // 0x0002(0x000A)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FP2AvailableForInteractionResult) == 0x000004, "Wrong alignment on FP2AvailableForInteractionResult");
static_assert(sizeof(FP2AvailableForInteractionResult) == 0x00000C, "Wrong size on FP2AvailableForInteractionResult");
static_assert(offsetof(FP2AvailableForInteractionResult, bInteractable) == 0x000000, "Member 'FP2AvailableForInteractionResult::bInteractable' has a wrong offset!");
static_assert(offsetof(FP2AvailableForInteractionResult, bInteractionAvailableNow) == 0x000001, "Member 'FP2AvailableForInteractionResult::bInteractionAvailableNow' has a wrong offset!");

// ScriptStruct Game.P2WaterDepthInfo
// 0x0048 (0x0048 - 0x0000)
struct FP2WaterDepthInfo final
{
public:
	bool                                          IsNearbyWater;                                     // 0x0000(0x0001)(Edit, ZeroConstructor, DisableEditOnTemplate, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	TWeakObjectPtr<class UWaterBodyComponent>     WaterBodyComponent;                                // 0x0004(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnTemplate, EditConst, InstancedReference, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                Surface;                                           // 0x0010(0x0018)(Edit, ZeroConstructor, DisableEditOnTemplate, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Normal;                                            // 0x0028(0x0018)(Edit, ZeroConstructor, DisableEditOnTemplate, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ImmersionDepth;                                    // 0x0040(0x0004)(Edit, ZeroConstructor, DisableEditOnTemplate, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EP2WaterPositionType                          WaterPositionType;                                 // 0x0044(0x0001)(Edit, ZeroConstructor, DisableEditOnTemplate, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_45[0x3];                                       // 0x0045(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FP2WaterDepthInfo) == 0x000008, "Wrong alignment on FP2WaterDepthInfo");
static_assert(sizeof(FP2WaterDepthInfo) == 0x000048, "Wrong size on FP2WaterDepthInfo");
static_assert(offsetof(FP2WaterDepthInfo, IsNearbyWater) == 0x000000, "Member 'FP2WaterDepthInfo::IsNearbyWater' has a wrong offset!");
static_assert(offsetof(FP2WaterDepthInfo, WaterBodyComponent) == 0x000004, "Member 'FP2WaterDepthInfo::WaterBodyComponent' has a wrong offset!");
static_assert(offsetof(FP2WaterDepthInfo, Surface) == 0x000010, "Member 'FP2WaterDepthInfo::Surface' has a wrong offset!");
static_assert(offsetof(FP2WaterDepthInfo, Normal) == 0x000028, "Member 'FP2WaterDepthInfo::Normal' has a wrong offset!");
static_assert(offsetof(FP2WaterDepthInfo, ImmersionDepth) == 0x000040, "Member 'FP2WaterDepthInfo::ImmersionDepth' has a wrong offset!");
static_assert(offsetof(FP2WaterDepthInfo, WaterPositionType) == 0x000044, "Member 'FP2WaterDepthInfo::WaterPositionType' has a wrong offset!");

// ScriptStruct Game.P2InteractionDistanceSettings
// 0x0024 (0x0024 - 0x0000)
struct FP2InteractionDistanceSettings final
{
public:
	float                                         MaxDistanceVisible;                                // 0x0000(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxDistanceFocus;                                  // 0x0004(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxDistanceInteractable;                           // 0x0008(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxDistanceActiveInteraction;                      // 0x000C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ConeAngleVisible;                                  // 0x0010(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ConeAngleFocus;                                    // 0x0014(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ConeAngleInteractable;                             // 0x0018(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bOverrideActiveConeAngleInteractable;              // 0x001C(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1D[0x3];                                       // 0x001D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ConeAngleActiveInteractable;                       // 0x0020(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FP2InteractionDistanceSettings) == 0x000004, "Wrong alignment on FP2InteractionDistanceSettings");
static_assert(sizeof(FP2InteractionDistanceSettings) == 0x000024, "Wrong size on FP2InteractionDistanceSettings");
static_assert(offsetof(FP2InteractionDistanceSettings, MaxDistanceVisible) == 0x000000, "Member 'FP2InteractionDistanceSettings::MaxDistanceVisible' has a wrong offset!");
static_assert(offsetof(FP2InteractionDistanceSettings, MaxDistanceFocus) == 0x000004, "Member 'FP2InteractionDistanceSettings::MaxDistanceFocus' has a wrong offset!");
static_assert(offsetof(FP2InteractionDistanceSettings, MaxDistanceInteractable) == 0x000008, "Member 'FP2InteractionDistanceSettings::MaxDistanceInteractable' has a wrong offset!");
static_assert(offsetof(FP2InteractionDistanceSettings, MaxDistanceActiveInteraction) == 0x00000C, "Member 'FP2InteractionDistanceSettings::MaxDistanceActiveInteraction' has a wrong offset!");
static_assert(offsetof(FP2InteractionDistanceSettings, ConeAngleVisible) == 0x000010, "Member 'FP2InteractionDistanceSettings::ConeAngleVisible' has a wrong offset!");
static_assert(offsetof(FP2InteractionDistanceSettings, ConeAngleFocus) == 0x000014, "Member 'FP2InteractionDistanceSettings::ConeAngleFocus' has a wrong offset!");
static_assert(offsetof(FP2InteractionDistanceSettings, ConeAngleInteractable) == 0x000018, "Member 'FP2InteractionDistanceSettings::ConeAngleInteractable' has a wrong offset!");
static_assert(offsetof(FP2InteractionDistanceSettings, bOverrideActiveConeAngleInteractable) == 0x00001C, "Member 'FP2InteractionDistanceSettings::bOverrideActiveConeAngleInteractable' has a wrong offset!");
static_assert(offsetof(FP2InteractionDistanceSettings, ConeAngleActiveInteractable) == 0x000020, "Member 'FP2InteractionDistanceSettings::ConeAngleActiveInteractable' has a wrong offset!");

// ScriptStruct Game.P2ActiveStatusEffectRepInfo
// 0x0010 (0x001C - 0x000C)
struct FP2ActiveStatusEffectRepInfo final : public FFastArraySerializerItem
{
public:
	struct FGameplayTag                           EffectTag;                                         // 0x000C(0x0008)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         StackCount;                                        // 0x0014(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Level;                                             // 0x0018(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FP2ActiveStatusEffectRepInfo) == 0x000004, "Wrong alignment on FP2ActiveStatusEffectRepInfo");
static_assert(sizeof(FP2ActiveStatusEffectRepInfo) == 0x00001C, "Wrong size on FP2ActiveStatusEffectRepInfo");
static_assert(offsetof(FP2ActiveStatusEffectRepInfo, EffectTag) == 0x00000C, "Member 'FP2ActiveStatusEffectRepInfo::EffectTag' has a wrong offset!");
static_assert(offsetof(FP2ActiveStatusEffectRepInfo, StackCount) == 0x000014, "Member 'FP2ActiveStatusEffectRepInfo::StackCount' has a wrong offset!");
static_assert(offsetof(FP2ActiveStatusEffectRepInfo, Level) == 0x000018, "Member 'FP2ActiveStatusEffectRepInfo::Level' has a wrong offset!");

// ScriptStruct Game.P2FloatMultiplier
// 0x0004 (0x0004 - 0x0000)
struct FP2FloatMultiplier final
{
public:
	float                                         Value;                                             // 0x0000(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FP2FloatMultiplier) == 0x000004, "Wrong alignment on FP2FloatMultiplier");
static_assert(sizeof(FP2FloatMultiplier) == 0x000004, "Wrong size on FP2FloatMultiplier");
static_assert(offsetof(FP2FloatMultiplier, Value) == 0x000000, "Member 'FP2FloatMultiplier::Value' has a wrong offset!");

// ScriptStruct Game.P2ArmorConfig
// 0x00A8 (0x00A8 - 0x0000)
struct FP2ArmorConfig final
{
public:
	TMap<struct FGameplayTag, float>              PenetrationProtectionByDamageTypeMap;              // 0x0000(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TMap<struct FGameplayTag, struct FP2FloatMultiplier> DamageMultiplierByDamageTypeMap;            // 0x0050(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	float                                         PenetratedDamageMultiplier;                        // 0x00A0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         UnpenetratedDamageMultiplier;                      // 0x00A4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FP2ArmorConfig) == 0x000008, "Wrong alignment on FP2ArmorConfig");
static_assert(sizeof(FP2ArmorConfig) == 0x0000A8, "Wrong size on FP2ArmorConfig");
static_assert(offsetof(FP2ArmorConfig, PenetrationProtectionByDamageTypeMap) == 0x000000, "Member 'FP2ArmorConfig::PenetrationProtectionByDamageTypeMap' has a wrong offset!");
static_assert(offsetof(FP2ArmorConfig, DamageMultiplierByDamageTypeMap) == 0x000050, "Member 'FP2ArmorConfig::DamageMultiplierByDamageTypeMap' has a wrong offset!");
static_assert(offsetof(FP2ArmorConfig, PenetratedDamageMultiplier) == 0x0000A0, "Member 'FP2ArmorConfig::PenetratedDamageMultiplier' has a wrong offset!");
static_assert(offsetof(FP2ArmorConfig, UnpenetratedDamageMultiplier) == 0x0000A4, "Member 'FP2ArmorConfig::UnpenetratedDamageMultiplier' has a wrong offset!");

// ScriptStruct Game.P2DamageZoneConfig
// 0x00D8 (0x00D8 - 0x0000)
struct FP2DamageZoneConfig final
{
public:
	struct FGameplayTag                           Tag;                                               // 0x0000(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bExactMatch;                                       // 0x0008(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTagContainer                  FXTag;                                             // 0x0010(0x0020)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FP2ArmorConfig                         Armor;                                             // 0x0030(0x00A8)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
};
static_assert(alignof(FP2DamageZoneConfig) == 0x000008, "Wrong alignment on FP2DamageZoneConfig");
static_assert(sizeof(FP2DamageZoneConfig) == 0x0000D8, "Wrong size on FP2DamageZoneConfig");
static_assert(offsetof(FP2DamageZoneConfig, Tag) == 0x000000, "Member 'FP2DamageZoneConfig::Tag' has a wrong offset!");
static_assert(offsetof(FP2DamageZoneConfig, bExactMatch) == 0x000008, "Member 'FP2DamageZoneConfig::bExactMatch' has a wrong offset!");
static_assert(offsetof(FP2DamageZoneConfig, FXTag) == 0x000010, "Member 'FP2DamageZoneConfig::FXTag' has a wrong offset!");
static_assert(offsetof(FP2DamageZoneConfig, Armor) == 0x000030, "Member 'FP2DamageZoneConfig::Armor' has a wrong offset!");

// ScriptStruct Game.P2DamageZoneConfigList
// 0x0010 (0x0010 - 0x0000)
struct FP2DamageZoneConfigList final
{
public:
	TArray<struct FP2DamageZoneConfig>            Configs;                                           // 0x0000(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
};
static_assert(alignof(FP2DamageZoneConfigList) == 0x000008, "Wrong alignment on FP2DamageZoneConfigList");
static_assert(sizeof(FP2DamageZoneConfigList) == 0x000010, "Wrong size on FP2DamageZoneConfigList");
static_assert(offsetof(FP2DamageZoneConfigList, Configs) == 0x000000, "Member 'FP2DamageZoneConfigList::Configs' has a wrong offset!");

// ScriptStruct Game.P2ActiveStatusEffectRepInfoContainer
// 0x0018 (0x0120 - 0x0108)
struct FP2ActiveStatusEffectRepInfoContainer final : public FFastArraySerializer
{
public:
	TArray<struct FP2ActiveStatusEffectRepInfo>   Effects;                                           // 0x0108(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_118[0x8];                                      // 0x0118(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FP2ActiveStatusEffectRepInfoContainer) == 0x000008, "Wrong alignment on FP2ActiveStatusEffectRepInfoContainer");
static_assert(sizeof(FP2ActiveStatusEffectRepInfoContainer) == 0x000120, "Wrong size on FP2ActiveStatusEffectRepInfoContainer");
static_assert(offsetof(FP2ActiveStatusEffectRepInfoContainer, Effects) == 0x000108, "Member 'FP2ActiveStatusEffectRepInfoContainer::Effects' has a wrong offset!");

// ScriptStruct Game.P2PooledActorConfig
// 0x0008 (0x0008 - 0x0000)
struct FP2PooledActorConfig final
{
public:
	uint32                                        PreAllocateCount;                                  // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAllocateOnServer;                                 // 0x0004(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAllocateOnClient;                                 // 0x0005(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_6[0x2];                                        // 0x0006(0x0002)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FP2PooledActorConfig) == 0x000004, "Wrong alignment on FP2PooledActorConfig");
static_assert(sizeof(FP2PooledActorConfig) == 0x000008, "Wrong size on FP2PooledActorConfig");
static_assert(offsetof(FP2PooledActorConfig, PreAllocateCount) == 0x000000, "Member 'FP2PooledActorConfig::PreAllocateCount' has a wrong offset!");
static_assert(offsetof(FP2PooledActorConfig, bAllocateOnServer) == 0x000004, "Member 'FP2PooledActorConfig::bAllocateOnServer' has a wrong offset!");
static_assert(offsetof(FP2PooledActorConfig, bAllocateOnClient) == 0x000005, "Member 'FP2PooledActorConfig::bAllocateOnClient' has a wrong offset!");

// ScriptStruct Game.P2TutorialWidgetInfo
// 0x0018 (0x0018 - 0x0000)
struct FP2TutorialWidgetInfo final
{
public:
	class UWidget*                                Widget;                                            // 0x0000(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EP2WidgetHighlightType                        HighlightType;                                     // 0x0008(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UWidget*                                BorderWidget;                                      // 0x0010(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FP2TutorialWidgetInfo) == 0x000008, "Wrong alignment on FP2TutorialWidgetInfo");
static_assert(sizeof(FP2TutorialWidgetInfo) == 0x000018, "Wrong size on FP2TutorialWidgetInfo");
static_assert(offsetof(FP2TutorialWidgetInfo, Widget) == 0x000000, "Member 'FP2TutorialWidgetInfo::Widget' has a wrong offset!");
static_assert(offsetof(FP2TutorialWidgetInfo, HighlightType) == 0x000008, "Member 'FP2TutorialWidgetInfo::HighlightType' has a wrong offset!");
static_assert(offsetof(FP2TutorialWidgetInfo, BorderWidget) == 0x000010, "Member 'FP2TutorialWidgetInfo::BorderWidget' has a wrong offset!");

// ScriptStruct Game.P2AdsAudioEvent
// 0x0010 (0x0010 - 0x0000)
struct FP2AdsAudioEvent final
{
public:
	class UAkAudioEvent*                          Enter;                                             // 0x0000(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAkAudioEvent*                          Exit;                                              // 0x0008(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FP2AdsAudioEvent) == 0x000008, "Wrong alignment on FP2AdsAudioEvent");
static_assert(sizeof(FP2AdsAudioEvent) == 0x000010, "Wrong size on FP2AdsAudioEvent");
static_assert(offsetof(FP2AdsAudioEvent, Enter) == 0x000000, "Member 'FP2AdsAudioEvent::Enter' has a wrong offset!");
static_assert(offsetof(FP2AdsAudioEvent, Exit) == 0x000008, "Member 'FP2AdsAudioEvent::Exit' has a wrong offset!");

// ScriptStruct Game.P2LazyAkComponent
// 0x0040 (0x0040 - 0x0000)
struct alignas(0x08) FP2LazyAkComponent final
{
public:
	uint8                                         Pad_0[0x40];                                       // 0x0000(0x0040)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FP2LazyAkComponent) == 0x000008, "Wrong alignment on FP2LazyAkComponent");
static_assert(sizeof(FP2LazyAkComponent) == 0x000040, "Wrong size on FP2LazyAkComponent");

// ScriptStruct Game.P2FootstepTraceConfig
// 0x0090 (0x0090 - 0x0000)
struct FP2FootstepTraceConfig final
{
public:
	struct FVector                                TraceVector;                                       // 0x0000(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   TraceSocket;                                       // 0x0018(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FTransform                             TraceResultOffset;                                 // 0x0020(0x0060)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bTraceComplex : 1;                                 // 0x0080(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_81[0xF];                                       // 0x0081(0x000F)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FP2FootstepTraceConfig) == 0x000010, "Wrong alignment on FP2FootstepTraceConfig");
static_assert(sizeof(FP2FootstepTraceConfig) == 0x000090, "Wrong size on FP2FootstepTraceConfig");
static_assert(offsetof(FP2FootstepTraceConfig, TraceVector) == 0x000000, "Member 'FP2FootstepTraceConfig::TraceVector' has a wrong offset!");
static_assert(offsetof(FP2FootstepTraceConfig, TraceSocket) == 0x000018, "Member 'FP2FootstepTraceConfig::TraceSocket' has a wrong offset!");
static_assert(offsetof(FP2FootstepTraceConfig, TraceResultOffset) == 0x000020, "Member 'FP2FootstepTraceConfig::TraceResultOffset' has a wrong offset!");

// ScriptStruct Game.AkEventPlaybackConfig
// 0x0018 (0x0018 - 0x0000)
struct FAkEventPlaybackConfig final
{
public:
	bool                                          bCheckAttenuation;                                 // 0x0000(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EAkEventLocalityType                          LocalityType;                                      // 0x0001(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2[0x2];                                        // 0x0002(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   SocketName;                                        // 0x0004(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EAttachLocation                               AttachLocationType;                                // 0x000C(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D[0x3];                                        // 0x000D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTag                           ActorComponentTag;                                 // 0x0010(0x0008)(Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAkEventPlaybackConfig) == 0x000004, "Wrong alignment on FAkEventPlaybackConfig");
static_assert(sizeof(FAkEventPlaybackConfig) == 0x000018, "Wrong size on FAkEventPlaybackConfig");
static_assert(offsetof(FAkEventPlaybackConfig, bCheckAttenuation) == 0x000000, "Member 'FAkEventPlaybackConfig::bCheckAttenuation' has a wrong offset!");
static_assert(offsetof(FAkEventPlaybackConfig, LocalityType) == 0x000001, "Member 'FAkEventPlaybackConfig::LocalityType' has a wrong offset!");
static_assert(offsetof(FAkEventPlaybackConfig, SocketName) == 0x000004, "Member 'FAkEventPlaybackConfig::SocketName' has a wrong offset!");
static_assert(offsetof(FAkEventPlaybackConfig, AttachLocationType) == 0x00000C, "Member 'FAkEventPlaybackConfig::AttachLocationType' has a wrong offset!");
static_assert(offsetof(FAkEventPlaybackConfig, ActorComponentTag) == 0x000010, "Member 'FAkEventPlaybackConfig::ActorComponentTag' has a wrong offset!");

// ScriptStruct Game.AkRtpcWrapper
// 0x0018 (0x0018 - 0x0000)
struct FAkRtpcWrapper final
{
public:
	class FString                                 Name;                                              // 0x0000(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Value;                                             // 0x0010(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FAkRtpcWrapper) == 0x000008, "Wrong alignment on FAkRtpcWrapper");
static_assert(sizeof(FAkRtpcWrapper) == 0x000018, "Wrong size on FAkRtpcWrapper");
static_assert(offsetof(FAkRtpcWrapper, Name) == 0x000000, "Member 'FAkRtpcWrapper::Name' has a wrong offset!");
static_assert(offsetof(FAkRtpcWrapper, Value) == 0x000010, "Member 'FAkRtpcWrapper::Value' has a wrong offset!");

// ScriptStruct Game.P2FootData
// 0x0018 (0x0018 - 0x0000)
struct FP2FootData final
{
public:
	struct FGameplayTag                           AudioComponentTag;                                 // 0x0000(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayCueTag                        GameplayCueTag;                                    // 0x0008(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, NativeAccessSpecifierPublic)
	struct FGameplayTag                           TraceSocketTag;                                    // 0x0010(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FP2FootData) == 0x000004, "Wrong alignment on FP2FootData");
static_assert(sizeof(FP2FootData) == 0x000018, "Wrong size on FP2FootData");
static_assert(offsetof(FP2FootData, AudioComponentTag) == 0x000000, "Member 'FP2FootData::AudioComponentTag' has a wrong offset!");
static_assert(offsetof(FP2FootData, GameplayCueTag) == 0x000008, "Member 'FP2FootData::GameplayCueTag' has a wrong offset!");
static_assert(offsetof(FP2FootData, TraceSocketTag) == 0x000010, "Member 'FP2FootData::TraceSocketTag' has a wrong offset!");

// ScriptStruct Game.AnimNotifyTraceConfig
// 0x0020 (0x0020 - 0x0000)
struct FAnimNotifyTraceConfig final
{
public:
	class FName                                   SocketName;                                        // 0x0000(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                TraceVector;                                       // 0x0008(0x0018)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAnimNotifyTraceConfig) == 0x000008, "Wrong alignment on FAnimNotifyTraceConfig");
static_assert(sizeof(FAnimNotifyTraceConfig) == 0x000020, "Wrong size on FAnimNotifyTraceConfig");
static_assert(offsetof(FAnimNotifyTraceConfig, SocketName) == 0x000000, "Member 'FAnimNotifyTraceConfig::SocketName' has a wrong offset!");
static_assert(offsetof(FAnimNotifyTraceConfig, TraceVector) == 0x000008, "Member 'FAnimNotifyTraceConfig::TraceVector' has a wrong offset!");

// ScriptStruct Game.P2DeployZoneUnavailableReason
// 0x0018 (0x0018 - 0x0000)
struct FP2DeployZoneUnavailableReason final
{
public:
	EP2DeployZoneUnavailableReason                Reason;                                            // 0x0000(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class AP2PlayerState*>                 PlayersWithoutTicket;                              // 0x0008(0x0010)(BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FP2DeployZoneUnavailableReason) == 0x000008, "Wrong alignment on FP2DeployZoneUnavailableReason");
static_assert(sizeof(FP2DeployZoneUnavailableReason) == 0x000018, "Wrong size on FP2DeployZoneUnavailableReason");
static_assert(offsetof(FP2DeployZoneUnavailableReason, Reason) == 0x000000, "Member 'FP2DeployZoneUnavailableReason::Reason' has a wrong offset!");
static_assert(offsetof(FP2DeployZoneUnavailableReason, PlayersWithoutTicket) == 0x000008, "Member 'FP2DeployZoneUnavailableReason::PlayersWithoutTicket' has a wrong offset!");

// ScriptStruct Game.AnimNotifyPlaybackConfig
// 0x0002 (0x0002 - 0x0000)
struct FAnimNotifyPlaybackConfig final
{
public:
	bool                                          bUseRaytrace;                                      // 0x0000(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bPostEventIfNoHit;                                 // 0x0001(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAnimNotifyPlaybackConfig) == 0x000001, "Wrong alignment on FAnimNotifyPlaybackConfig");
static_assert(sizeof(FAnimNotifyPlaybackConfig) == 0x000002, "Wrong size on FAnimNotifyPlaybackConfig");
static_assert(offsetof(FAnimNotifyPlaybackConfig, bUseRaytrace) == 0x000000, "Member 'FAnimNotifyPlaybackConfig::bUseRaytrace' has a wrong offset!");
static_assert(offsetof(FAnimNotifyPlaybackConfig, bPostEventIfNoHit) == 0x000001, "Member 'FAnimNotifyPlaybackConfig::bPostEventIfNoHit' has a wrong offset!");

// ScriptStruct Game.AnimNotifyTagConfig
// 0x0014 (0x0014 - 0x0000)
struct FAnimNotifyTagConfig final
{
public:
	bool                                          bShowAkEventTag;                                   // 0x0000(0x0001)(Edit, ZeroConstructor, DisableEditOnTemplate, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bShowAkSlotTag;                                    // 0x0001(0x0001)(Edit, ZeroConstructor, DisableEditOnTemplate, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2[0x2];                                        // 0x0002(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTag                           AkEventTag;                                        // 0x0004(0x0008)(Edit, DisableEditOnTemplate, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           SlotTag;                                           // 0x000C(0x0008)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAnimNotifyTagConfig) == 0x000004, "Wrong alignment on FAnimNotifyTagConfig");
static_assert(sizeof(FAnimNotifyTagConfig) == 0x000014, "Wrong size on FAnimNotifyTagConfig");
static_assert(offsetof(FAnimNotifyTagConfig, bShowAkEventTag) == 0x000000, "Member 'FAnimNotifyTagConfig::bShowAkEventTag' has a wrong offset!");
static_assert(offsetof(FAnimNotifyTagConfig, bShowAkSlotTag) == 0x000001, "Member 'FAnimNotifyTagConfig::bShowAkSlotTag' has a wrong offset!");
static_assert(offsetof(FAnimNotifyTagConfig, AkEventTag) == 0x000004, "Member 'FAnimNotifyTagConfig::AkEventTag' has a wrong offset!");
static_assert(offsetof(FAnimNotifyTagConfig, SlotTag) == 0x00000C, "Member 'FAnimNotifyTagConfig::SlotTag' has a wrong offset!");

// ScriptStruct Game.P2DamageZoneCapsuleSection
// 0x00A0 (0x00A0 - 0x0000)
struct FP2DamageZoneCapsuleSection final
{
public:
	bool                                          bCanBeMeleeTarget;                                 // 0x0000(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         RandomSelectionWeight;                             // 0x0004(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           DamageZoneTag;                                     // 0x0008(0x0008)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Min;                                               // 0x0010(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Max;                                               // 0x0028(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTagContainer                  RelatedTagsFromPhysicalMaterial;                   // 0x0040(0x0020)(Edit, NativeAccessSpecifierPublic)
	struct FColor                                 DebugColor;                                        // 0x0060(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_64[0x4];                                       // 0x0064(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FBox                                   Bounds;                                            // 0x0068(0x0038)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FP2DamageZoneCapsuleSection) == 0x000008, "Wrong alignment on FP2DamageZoneCapsuleSection");
static_assert(sizeof(FP2DamageZoneCapsuleSection) == 0x0000A0, "Wrong size on FP2DamageZoneCapsuleSection");
static_assert(offsetof(FP2DamageZoneCapsuleSection, bCanBeMeleeTarget) == 0x000000, "Member 'FP2DamageZoneCapsuleSection::bCanBeMeleeTarget' has a wrong offset!");
static_assert(offsetof(FP2DamageZoneCapsuleSection, RandomSelectionWeight) == 0x000004, "Member 'FP2DamageZoneCapsuleSection::RandomSelectionWeight' has a wrong offset!");
static_assert(offsetof(FP2DamageZoneCapsuleSection, DamageZoneTag) == 0x000008, "Member 'FP2DamageZoneCapsuleSection::DamageZoneTag' has a wrong offset!");
static_assert(offsetof(FP2DamageZoneCapsuleSection, Min) == 0x000010, "Member 'FP2DamageZoneCapsuleSection::Min' has a wrong offset!");
static_assert(offsetof(FP2DamageZoneCapsuleSection, Max) == 0x000028, "Member 'FP2DamageZoneCapsuleSection::Max' has a wrong offset!");
static_assert(offsetof(FP2DamageZoneCapsuleSection, RelatedTagsFromPhysicalMaterial) == 0x000040, "Member 'FP2DamageZoneCapsuleSection::RelatedTagsFromPhysicalMaterial' has a wrong offset!");
static_assert(offsetof(FP2DamageZoneCapsuleSection, DebugColor) == 0x000060, "Member 'FP2DamageZoneCapsuleSection::DebugColor' has a wrong offset!");
static_assert(offsetof(FP2DamageZoneCapsuleSection, Bounds) == 0x000068, "Member 'FP2DamageZoneCapsuleSection::Bounds' has a wrong offset!");

// ScriptStruct Game.RuntimeAnimRecoilCurve
// 0x0308 (0x0308 - 0x0000)
struct FRuntimeAnimRecoilCurve final
{
public:
	struct FRichCurve                             VectorCurves[0x6];                                 // 0x0000(0x0080)(NativeAccessSpecifierPublic)
	class UP2AnimRecoilCurve*                     ExternalCurve;                                     // 0x0300(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRuntimeAnimRecoilCurve) == 0x000008, "Wrong alignment on FRuntimeAnimRecoilCurve");
static_assert(sizeof(FRuntimeAnimRecoilCurve) == 0x000308, "Wrong size on FRuntimeAnimRecoilCurve");
static_assert(offsetof(FRuntimeAnimRecoilCurve, VectorCurves) == 0x000000, "Member 'FRuntimeAnimRecoilCurve::VectorCurves' has a wrong offset!");
static_assert(offsetof(FRuntimeAnimRecoilCurve, ExternalCurve) == 0x000300, "Member 'FRuntimeAnimRecoilCurve::ExternalCurve' has a wrong offset!");

// ScriptStruct Game.AnimSpringPatternTrack
// 0x0018 (0x0018 - 0x0000)
struct FAnimSpringPatternTrack final
{
public:
	class UAnimSpringSimData*                     SimData;                                           // 0x0000(0x0008)(Edit, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class UHeroStateRemapDataAsset*>       RemapDataArray;                                    // 0x0008(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAnimSpringPatternTrack) == 0x000008, "Wrong alignment on FAnimSpringPatternTrack");
static_assert(sizeof(FAnimSpringPatternTrack) == 0x000018, "Wrong size on FAnimSpringPatternTrack");
static_assert(offsetof(FAnimSpringPatternTrack, SimData) == 0x000000, "Member 'FAnimSpringPatternTrack::SimData' has a wrong offset!");
static_assert(offsetof(FAnimSpringPatternTrack, RemapDataArray) == 0x000008, "Member 'FAnimSpringPatternTrack::RemapDataArray' has a wrong offset!");

// ScriptStruct Game.P2DamageToArmorResult
// 0x000C (0x000C - 0x0000)
struct FP2DamageToArmorResult final
{
public:
	struct FGameplayTag                           ZoneTag;                                           // 0x0000(0x0008)(BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DamageToArmor;                                     // 0x0008(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FP2DamageToArmorResult) == 0x000004, "Wrong alignment on FP2DamageToArmorResult");
static_assert(sizeof(FP2DamageToArmorResult) == 0x00000C, "Wrong size on FP2DamageToArmorResult");
static_assert(offsetof(FP2DamageToArmorResult, ZoneTag) == 0x000000, "Member 'FP2DamageToArmorResult::ZoneTag' has a wrong offset!");
static_assert(offsetof(FP2DamageToArmorResult, DamageToArmor) == 0x000008, "Member 'FP2DamageToArmorResult::DamageToArmor' has a wrong offset!");

// ScriptStruct Game.AnimSpringTrackData
// 0x0010 (0x0010 - 0x0000)
struct FAnimSpringTrackData final
{
public:
	TArray<struct FAnimSpringPatternTrack>        AnimSpringTrackArray;                              // 0x0000(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAnimSpringTrackData) == 0x000008, "Wrong alignment on FAnimSpringTrackData");
static_assert(sizeof(FAnimSpringTrackData) == 0x000010, "Wrong size on FAnimSpringTrackData");
static_assert(offsetof(FAnimSpringTrackData, AnimSpringTrackArray) == 0x000000, "Member 'FAnimSpringTrackData::AnimSpringTrackArray' has a wrong offset!");

// ScriptStruct Game.P2IntPerSessionDifficulty
// 0x0018 (0x0018 - 0x0000)
struct FP2IntPerSessionDifficulty final
{
public:
	bool                                          bOverridePerSessionDifficulty;                     // 0x0000(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         Value;                                             // 0x0004(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<int32>                                 Values;                                            // 0x0008(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
};
static_assert(alignof(FP2IntPerSessionDifficulty) == 0x000008, "Wrong alignment on FP2IntPerSessionDifficulty");
static_assert(sizeof(FP2IntPerSessionDifficulty) == 0x000018, "Wrong size on FP2IntPerSessionDifficulty");
static_assert(offsetof(FP2IntPerSessionDifficulty, bOverridePerSessionDifficulty) == 0x000000, "Member 'FP2IntPerSessionDifficulty::bOverridePerSessionDifficulty' has a wrong offset!");
static_assert(offsetof(FP2IntPerSessionDifficulty, Value) == 0x000004, "Member 'FP2IntPerSessionDifficulty::Value' has a wrong offset!");
static_assert(offsetof(FP2IntPerSessionDifficulty, Values) == 0x000008, "Member 'FP2IntPerSessionDifficulty::Values' has a wrong offset!");

// ScriptStruct Game.P2AnimSpringSimulatorActorContext
// 0x00A0 (0x00A0 - 0x0000)
struct alignas(0x08) FP2AnimSpringSimulatorActorContext final
{
public:
	uint8                                         Pad_0[0xA0];                                       // 0x0000(0x00A0)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FP2AnimSpringSimulatorActorContext) == 0x000008, "Wrong alignment on FP2AnimSpringSimulatorActorContext");
static_assert(sizeof(FP2AnimSpringSimulatorActorContext) == 0x0000A0, "Wrong size on FP2AnimSpringSimulatorActorContext");

// ScriptStruct Game.P2AnimSpeedBounds
// 0x000C (0x000C - 0x0000)
struct FP2AnimSpeedBounds final
{
public:
	float                                         Min;                                               // 0x0000(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AnimationSpeed;                                    // 0x0004(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Max;                                               // 0x0008(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FP2AnimSpeedBounds) == 0x000004, "Wrong alignment on FP2AnimSpeedBounds");
static_assert(sizeof(FP2AnimSpeedBounds) == 0x00000C, "Wrong size on FP2AnimSpeedBounds");
static_assert(offsetof(FP2AnimSpeedBounds, Min) == 0x000000, "Member 'FP2AnimSpeedBounds::Min' has a wrong offset!");
static_assert(offsetof(FP2AnimSpeedBounds, AnimationSpeed) == 0x000004, "Member 'FP2AnimSpeedBounds::AnimationSpeed' has a wrong offset!");
static_assert(offsetof(FP2AnimSpeedBounds, Max) == 0x000008, "Member 'FP2AnimSpeedBounds::Max' has a wrong offset!");

// ScriptStruct Game.P2AnimContainer_TurnInPlace
// 0x0030 (0x0030 - 0x0000)
struct FP2AnimContainer_TurnInPlace final
{
public:
	float                                         Angle;                                             // 0x0000(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AngleModifier;                                     // 0x0004(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          AnimSequence_Stand;                                // 0x0008(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          AnimSequence_Crouch;                               // 0x0010(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DelayBeforeTrigger;                                // 0x0018(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C[0x4];                                       // 0x001C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector2D                              AngleRange;                                        // 0x0020(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FP2AnimContainer_TurnInPlace) == 0x000008, "Wrong alignment on FP2AnimContainer_TurnInPlace");
static_assert(sizeof(FP2AnimContainer_TurnInPlace) == 0x000030, "Wrong size on FP2AnimContainer_TurnInPlace");
static_assert(offsetof(FP2AnimContainer_TurnInPlace, Angle) == 0x000000, "Member 'FP2AnimContainer_TurnInPlace::Angle' has a wrong offset!");
static_assert(offsetof(FP2AnimContainer_TurnInPlace, AngleModifier) == 0x000004, "Member 'FP2AnimContainer_TurnInPlace::AngleModifier' has a wrong offset!");
static_assert(offsetof(FP2AnimContainer_TurnInPlace, AnimSequence_Stand) == 0x000008, "Member 'FP2AnimContainer_TurnInPlace::AnimSequence_Stand' has a wrong offset!");
static_assert(offsetof(FP2AnimContainer_TurnInPlace, AnimSequence_Crouch) == 0x000010, "Member 'FP2AnimContainer_TurnInPlace::AnimSequence_Crouch' has a wrong offset!");
static_assert(offsetof(FP2AnimContainer_TurnInPlace, DelayBeforeTrigger) == 0x000018, "Member 'FP2AnimContainer_TurnInPlace::DelayBeforeTrigger' has a wrong offset!");
static_assert(offsetof(FP2AnimContainer_TurnInPlace, AngleRange) == 0x000020, "Member 'FP2AnimContainer_TurnInPlace::AngleRange' has a wrong offset!");

// ScriptStruct Game.DialogueArguments
// 0x0090 (0x0090 - 0x0000)
struct FDialogueArguments final
{
public:
	class FString                                 CharacterVoice;                                    // 0x0000(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Trigger;                                           // 0x0010(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Perspective;                                       // 0x0020(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Team;                                              // 0x0030(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 ActionState;                                       // 0x0040(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Equipment;                                         // 0x0050(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 DamageSeverity;                                    // 0x0060(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 InjuryState;                                       // 0x0070(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 MovementSubType;                                   // 0x0080(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FDialogueArguments) == 0x000008, "Wrong alignment on FDialogueArguments");
static_assert(sizeof(FDialogueArguments) == 0x000090, "Wrong size on FDialogueArguments");
static_assert(offsetof(FDialogueArguments, CharacterVoice) == 0x000000, "Member 'FDialogueArguments::CharacterVoice' has a wrong offset!");
static_assert(offsetof(FDialogueArguments, Trigger) == 0x000010, "Member 'FDialogueArguments::Trigger' has a wrong offset!");
static_assert(offsetof(FDialogueArguments, Perspective) == 0x000020, "Member 'FDialogueArguments::Perspective' has a wrong offset!");
static_assert(offsetof(FDialogueArguments, Team) == 0x000030, "Member 'FDialogueArguments::Team' has a wrong offset!");
static_assert(offsetof(FDialogueArguments, ActionState) == 0x000040, "Member 'FDialogueArguments::ActionState' has a wrong offset!");
static_assert(offsetof(FDialogueArguments, Equipment) == 0x000050, "Member 'FDialogueArguments::Equipment' has a wrong offset!");
static_assert(offsetof(FDialogueArguments, DamageSeverity) == 0x000060, "Member 'FDialogueArguments::DamageSeverity' has a wrong offset!");
static_assert(offsetof(FDialogueArguments, InjuryState) == 0x000070, "Member 'FDialogueArguments::InjuryState' has a wrong offset!");
static_assert(offsetof(FDialogueArguments, MovementSubType) == 0x000080, "Member 'FDialogueArguments::MovementSubType' has a wrong offset!");

// ScriptStruct Game.GunAnimLayerConfig
// 0x0058 (0x0058 - 0x0000)
struct FGunAnimLayerConfig final
{
public:
	class UAnimSequenceBase*                      AimState_Hip;                                      // 0x0000(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequenceBase*                      AimState_Aim;                                      // 0x0008(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequenceBase*                      AimState_ToAim;                                    // 0x0010(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequenceBase*                      AimState_ToHip;                                    // 0x0018(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UBlendSpace1D*                          Move_Hip_BlendSpace1D;                             // 0x0020(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequenceBase*                      Jump;                                              // 0x0028(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequenceBase*                      Fall;                                              // 0x0030(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimMontage*                           LandAdditive;                                      // 0x0038(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequenceBase*                      Grip;                                              // 0x0040(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimMontage*                           TransitionStandToCrouch;                           // 0x0048(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimMontage*                           TransitionCrouchToStand;                           // 0x0050(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGunAnimLayerConfig) == 0x000008, "Wrong alignment on FGunAnimLayerConfig");
static_assert(sizeof(FGunAnimLayerConfig) == 0x000058, "Wrong size on FGunAnimLayerConfig");
static_assert(offsetof(FGunAnimLayerConfig, AimState_Hip) == 0x000000, "Member 'FGunAnimLayerConfig::AimState_Hip' has a wrong offset!");
static_assert(offsetof(FGunAnimLayerConfig, AimState_Aim) == 0x000008, "Member 'FGunAnimLayerConfig::AimState_Aim' has a wrong offset!");
static_assert(offsetof(FGunAnimLayerConfig, AimState_ToAim) == 0x000010, "Member 'FGunAnimLayerConfig::AimState_ToAim' has a wrong offset!");
static_assert(offsetof(FGunAnimLayerConfig, AimState_ToHip) == 0x000018, "Member 'FGunAnimLayerConfig::AimState_ToHip' has a wrong offset!");
static_assert(offsetof(FGunAnimLayerConfig, Move_Hip_BlendSpace1D) == 0x000020, "Member 'FGunAnimLayerConfig::Move_Hip_BlendSpace1D' has a wrong offset!");
static_assert(offsetof(FGunAnimLayerConfig, Jump) == 0x000028, "Member 'FGunAnimLayerConfig::Jump' has a wrong offset!");
static_assert(offsetof(FGunAnimLayerConfig, Fall) == 0x000030, "Member 'FGunAnimLayerConfig::Fall' has a wrong offset!");
static_assert(offsetof(FGunAnimLayerConfig, LandAdditive) == 0x000038, "Member 'FGunAnimLayerConfig::LandAdditive' has a wrong offset!");
static_assert(offsetof(FGunAnimLayerConfig, Grip) == 0x000040, "Member 'FGunAnimLayerConfig::Grip' has a wrong offset!");
static_assert(offsetof(FGunAnimLayerConfig, TransitionStandToCrouch) == 0x000048, "Member 'FGunAnimLayerConfig::TransitionStandToCrouch' has a wrong offset!");
static_assert(offsetof(FGunAnimLayerConfig, TransitionCrouchToStand) == 0x000050, "Member 'FGunAnimLayerConfig::TransitionCrouchToStand' has a wrong offset!");

// ScriptStruct Game.P2StrideInfo
// 0x0014 (0x0014 - 0x0000)
struct alignas(0x04) FP2StrideInfo final
{
public:
	uint8                                         Pad_0[0x14];                                       // 0x0000(0x0014)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FP2StrideInfo) == 0x000004, "Wrong alignment on FP2StrideInfo");
static_assert(sizeof(FP2StrideInfo) == 0x000014, "Wrong size on FP2StrideInfo");

// ScriptStruct Game.DeathImpulseConfig
// 0x0060 (0x0060 - 0x0000)
struct FDeathImpulseConfig final
{
public:
	float                                         ImpulseStrength;                                   // 0x0000(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<class FName, float>                      BoneToImpulseScaleMap;                             // 0x0008(0x0050)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	float                                         DefaultImpulseScale;                               // 0x0058(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RootBodyImpulseScale;                              // 0x005C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FDeathImpulseConfig) == 0x000008, "Wrong alignment on FDeathImpulseConfig");
static_assert(sizeof(FDeathImpulseConfig) == 0x000060, "Wrong size on FDeathImpulseConfig");
static_assert(offsetof(FDeathImpulseConfig, ImpulseStrength) == 0x000000, "Member 'FDeathImpulseConfig::ImpulseStrength' has a wrong offset!");
static_assert(offsetof(FDeathImpulseConfig, BoneToImpulseScaleMap) == 0x000008, "Member 'FDeathImpulseConfig::BoneToImpulseScaleMap' has a wrong offset!");
static_assert(offsetof(FDeathImpulseConfig, DefaultImpulseScale) == 0x000058, "Member 'FDeathImpulseConfig::DefaultImpulseScale' has a wrong offset!");
static_assert(offsetof(FDeathImpulseConfig, RootBodyImpulseScale) == 0x00005C, "Member 'FDeathImpulseConfig::RootBodyImpulseScale' has a wrong offset!");

// ScriptStruct Game.MoveActionHeightConfig
// 0x0008 (0x0008 - 0x0000)
struct FMoveActionHeightConfig final
{
public:
	float                                         MinHeight;                                         // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxHeight;                                         // 0x0004(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMoveActionHeightConfig) == 0x000004, "Wrong alignment on FMoveActionHeightConfig");
static_assert(sizeof(FMoveActionHeightConfig) == 0x000008, "Wrong size on FMoveActionHeightConfig");
static_assert(offsetof(FMoveActionHeightConfig, MinHeight) == 0x000000, "Member 'FMoveActionHeightConfig::MinHeight' has a wrong offset!");
static_assert(offsetof(FMoveActionHeightConfig, MaxHeight) == 0x000004, "Member 'FMoveActionHeightConfig::MaxHeight' has a wrong offset!");

// ScriptStruct Game.MoveActionConfig
// 0x0198 (0x0198 - 0x0000)
struct FMoveActionConfig final
{
public:
	bool                                          bVaultFromCharacterDisabled;                       // 0x0000(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         InitialSweepRadius;                                // 0x0004(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         InitialSweepHeight;                                // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         InitialSweepVerticalOffset;                        // 0x000C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                InitialApexCheckStartOffset;                       // 0x0010(0x0018)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                InitialApexCheckEndOffset;                         // 0x0028(0x0018)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         InitialApexCheckRadius;                            // 0x0040(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         InitialApexCheckHeight;                            // 0x0044(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                FloorFromApexStartOffset;                          // 0x0048(0x0018)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                FloorFromApexEndOffset;                            // 0x0060(0x0018)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FloorFromApexRadiusOffset;                         // 0x0078(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FFloatRange                            WalkHeightRange;                                   // 0x007C(0x0010)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FFloatRange                            FallHeightRange;                                   // 0x008C(0x0010)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FFloatRange                            SwimHeightRange;                                   // 0x009C(0x0010)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         InitialTraceForwardDistance;                       // 0x00AC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         InitialTraceVelocityFraction;                      // 0x00B0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         InitialTraceVelocityMax;                           // 0x00B4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CapsuleRadius;                                     // 0x00B8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CapsuleHalfHeight_Stand;                           // 0x00BC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CapsuleHalfHeight_Crouch;                          // 0x00C0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   OverlapTestProfileName;                            // 0x00C4(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         VaultApexOverlapCapsuleRadius;                     // 0x00CC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         VaultApexOverlapCapsuleHalfHeight;                 // 0x00D0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MinClimbDepth;                                     // 0x00D4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxVaultDepth;                                     // 0x00D8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DepthTestUpDistance;                               // 0x00DC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DepthTestDownDistance;                             // 0x00E0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DepthTestStepLength;                               // 0x00E4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TracedApexShapeRadius;                             // 0x00E8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TracedApexShapeHeight;                             // 0x00EC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                TracedApexStartOffsetLS;                           // 0x00F0(0x0018)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                TracedApexEndOffsetLS;                             // 0x0108(0x0018)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                VaultNoHitEndOffset;                               // 0x0120(0x0018)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                VaultEndUpOffset;                                  // 0x0138(0x0018)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                VaultEndDownOffset;                                // 0x0150(0x0018)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ClimbWidthTestSideDistance;                        // 0x0168(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ClimbWidthTestRadius;                              // 0x016C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ClimbWidthTestHalfHeight;                          // 0x0170(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ClimbSpaceTestOffset_Stand;                        // 0x0174(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ClimbSpaceTestOffset_Crouch;                       // 0x0178(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_17C[0x4];                                      // 0x017C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class UGameplayAbility>           InputAbilityClass;                                 // 0x0180(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UInputAction*                           ForceVaultInputAction;                             // 0x0188(0x0008)(Edit, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   CapsuleOverlapProfileName;                         // 0x0190(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMoveActionConfig) == 0x000008, "Wrong alignment on FMoveActionConfig");
static_assert(sizeof(FMoveActionConfig) == 0x000198, "Wrong size on FMoveActionConfig");
static_assert(offsetof(FMoveActionConfig, bVaultFromCharacterDisabled) == 0x000000, "Member 'FMoveActionConfig::bVaultFromCharacterDisabled' has a wrong offset!");
static_assert(offsetof(FMoveActionConfig, InitialSweepRadius) == 0x000004, "Member 'FMoveActionConfig::InitialSweepRadius' has a wrong offset!");
static_assert(offsetof(FMoveActionConfig, InitialSweepHeight) == 0x000008, "Member 'FMoveActionConfig::InitialSweepHeight' has a wrong offset!");
static_assert(offsetof(FMoveActionConfig, InitialSweepVerticalOffset) == 0x00000C, "Member 'FMoveActionConfig::InitialSweepVerticalOffset' has a wrong offset!");
static_assert(offsetof(FMoveActionConfig, InitialApexCheckStartOffset) == 0x000010, "Member 'FMoveActionConfig::InitialApexCheckStartOffset' has a wrong offset!");
static_assert(offsetof(FMoveActionConfig, InitialApexCheckEndOffset) == 0x000028, "Member 'FMoveActionConfig::InitialApexCheckEndOffset' has a wrong offset!");
static_assert(offsetof(FMoveActionConfig, InitialApexCheckRadius) == 0x000040, "Member 'FMoveActionConfig::InitialApexCheckRadius' has a wrong offset!");
static_assert(offsetof(FMoveActionConfig, InitialApexCheckHeight) == 0x000044, "Member 'FMoveActionConfig::InitialApexCheckHeight' has a wrong offset!");
static_assert(offsetof(FMoveActionConfig, FloorFromApexStartOffset) == 0x000048, "Member 'FMoveActionConfig::FloorFromApexStartOffset' has a wrong offset!");
static_assert(offsetof(FMoveActionConfig, FloorFromApexEndOffset) == 0x000060, "Member 'FMoveActionConfig::FloorFromApexEndOffset' has a wrong offset!");
static_assert(offsetof(FMoveActionConfig, FloorFromApexRadiusOffset) == 0x000078, "Member 'FMoveActionConfig::FloorFromApexRadiusOffset' has a wrong offset!");
static_assert(offsetof(FMoveActionConfig, WalkHeightRange) == 0x00007C, "Member 'FMoveActionConfig::WalkHeightRange' has a wrong offset!");
static_assert(offsetof(FMoveActionConfig, FallHeightRange) == 0x00008C, "Member 'FMoveActionConfig::FallHeightRange' has a wrong offset!");
static_assert(offsetof(FMoveActionConfig, SwimHeightRange) == 0x00009C, "Member 'FMoveActionConfig::SwimHeightRange' has a wrong offset!");
static_assert(offsetof(FMoveActionConfig, InitialTraceForwardDistance) == 0x0000AC, "Member 'FMoveActionConfig::InitialTraceForwardDistance' has a wrong offset!");
static_assert(offsetof(FMoveActionConfig, InitialTraceVelocityFraction) == 0x0000B0, "Member 'FMoveActionConfig::InitialTraceVelocityFraction' has a wrong offset!");
static_assert(offsetof(FMoveActionConfig, InitialTraceVelocityMax) == 0x0000B4, "Member 'FMoveActionConfig::InitialTraceVelocityMax' has a wrong offset!");
static_assert(offsetof(FMoveActionConfig, CapsuleRadius) == 0x0000B8, "Member 'FMoveActionConfig::CapsuleRadius' has a wrong offset!");
static_assert(offsetof(FMoveActionConfig, CapsuleHalfHeight_Stand) == 0x0000BC, "Member 'FMoveActionConfig::CapsuleHalfHeight_Stand' has a wrong offset!");
static_assert(offsetof(FMoveActionConfig, CapsuleHalfHeight_Crouch) == 0x0000C0, "Member 'FMoveActionConfig::CapsuleHalfHeight_Crouch' has a wrong offset!");
static_assert(offsetof(FMoveActionConfig, OverlapTestProfileName) == 0x0000C4, "Member 'FMoveActionConfig::OverlapTestProfileName' has a wrong offset!");
static_assert(offsetof(FMoveActionConfig, VaultApexOverlapCapsuleRadius) == 0x0000CC, "Member 'FMoveActionConfig::VaultApexOverlapCapsuleRadius' has a wrong offset!");
static_assert(offsetof(FMoveActionConfig, VaultApexOverlapCapsuleHalfHeight) == 0x0000D0, "Member 'FMoveActionConfig::VaultApexOverlapCapsuleHalfHeight' has a wrong offset!");
static_assert(offsetof(FMoveActionConfig, MinClimbDepth) == 0x0000D4, "Member 'FMoveActionConfig::MinClimbDepth' has a wrong offset!");
static_assert(offsetof(FMoveActionConfig, MaxVaultDepth) == 0x0000D8, "Member 'FMoveActionConfig::MaxVaultDepth' has a wrong offset!");
static_assert(offsetof(FMoveActionConfig, DepthTestUpDistance) == 0x0000DC, "Member 'FMoveActionConfig::DepthTestUpDistance' has a wrong offset!");
static_assert(offsetof(FMoveActionConfig, DepthTestDownDistance) == 0x0000E0, "Member 'FMoveActionConfig::DepthTestDownDistance' has a wrong offset!");
static_assert(offsetof(FMoveActionConfig, DepthTestStepLength) == 0x0000E4, "Member 'FMoveActionConfig::DepthTestStepLength' has a wrong offset!");
static_assert(offsetof(FMoveActionConfig, TracedApexShapeRadius) == 0x0000E8, "Member 'FMoveActionConfig::TracedApexShapeRadius' has a wrong offset!");
static_assert(offsetof(FMoveActionConfig, TracedApexShapeHeight) == 0x0000EC, "Member 'FMoveActionConfig::TracedApexShapeHeight' has a wrong offset!");
static_assert(offsetof(FMoveActionConfig, TracedApexStartOffsetLS) == 0x0000F0, "Member 'FMoveActionConfig::TracedApexStartOffsetLS' has a wrong offset!");
static_assert(offsetof(FMoveActionConfig, TracedApexEndOffsetLS) == 0x000108, "Member 'FMoveActionConfig::TracedApexEndOffsetLS' has a wrong offset!");
static_assert(offsetof(FMoveActionConfig, VaultNoHitEndOffset) == 0x000120, "Member 'FMoveActionConfig::VaultNoHitEndOffset' has a wrong offset!");
static_assert(offsetof(FMoveActionConfig, VaultEndUpOffset) == 0x000138, "Member 'FMoveActionConfig::VaultEndUpOffset' has a wrong offset!");
static_assert(offsetof(FMoveActionConfig, VaultEndDownOffset) == 0x000150, "Member 'FMoveActionConfig::VaultEndDownOffset' has a wrong offset!");
static_assert(offsetof(FMoveActionConfig, ClimbWidthTestSideDistance) == 0x000168, "Member 'FMoveActionConfig::ClimbWidthTestSideDistance' has a wrong offset!");
static_assert(offsetof(FMoveActionConfig, ClimbWidthTestRadius) == 0x00016C, "Member 'FMoveActionConfig::ClimbWidthTestRadius' has a wrong offset!");
static_assert(offsetof(FMoveActionConfig, ClimbWidthTestHalfHeight) == 0x000170, "Member 'FMoveActionConfig::ClimbWidthTestHalfHeight' has a wrong offset!");
static_assert(offsetof(FMoveActionConfig, ClimbSpaceTestOffset_Stand) == 0x000174, "Member 'FMoveActionConfig::ClimbSpaceTestOffset_Stand' has a wrong offset!");
static_assert(offsetof(FMoveActionConfig, ClimbSpaceTestOffset_Crouch) == 0x000178, "Member 'FMoveActionConfig::ClimbSpaceTestOffset_Crouch' has a wrong offset!");
static_assert(offsetof(FMoveActionConfig, InputAbilityClass) == 0x000180, "Member 'FMoveActionConfig::InputAbilityClass' has a wrong offset!");
static_assert(offsetof(FMoveActionConfig, ForceVaultInputAction) == 0x000188, "Member 'FMoveActionConfig::ForceVaultInputAction' has a wrong offset!");
static_assert(offsetof(FMoveActionConfig, CapsuleOverlapProfileName) == 0x000190, "Member 'FMoveActionConfig::CapsuleOverlapProfileName' has a wrong offset!");

// ScriptStruct Game.P2DistanceTrackerEntry
// 0x0098 (0x0098 - 0x0000)
struct FP2DistanceTrackerEntry final
{
public:
	uint8                                         Pad_0[0x10];                                       // 0x0000(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class AActor*                                 TrackedActor;                                      // 0x0010(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USceneComponent*                        TrackedComponent;                                  // 0x0018(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_20[0x78];                                      // 0x0020(0x0078)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FP2DistanceTrackerEntry) == 0x000008, "Wrong alignment on FP2DistanceTrackerEntry");
static_assert(sizeof(FP2DistanceTrackerEntry) == 0x000098, "Wrong size on FP2DistanceTrackerEntry");
static_assert(offsetof(FP2DistanceTrackerEntry, TrackedActor) == 0x000010, "Member 'FP2DistanceTrackerEntry::TrackedActor' has a wrong offset!");
static_assert(offsetof(FP2DistanceTrackerEntry, TrackedComponent) == 0x000018, "Member 'FP2DistanceTrackerEntry::TrackedComponent' has a wrong offset!");

// ScriptStruct Game.P2MoveActionUIConfig
// 0x0028 (0x0028 - 0x0000)
struct FP2MoveActionUIConfig final
{
public:
	TSubclassOf<class AActor>                     WidgetActor;                                       // 0x0000(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTagContainer                  BlockingTags;                                      // 0x0008(0x0020)(Edit, NativeAccessSpecifierPublic)
};
static_assert(alignof(FP2MoveActionUIConfig) == 0x000008, "Wrong alignment on FP2MoveActionUIConfig");
static_assert(sizeof(FP2MoveActionUIConfig) == 0x000028, "Wrong size on FP2MoveActionUIConfig");
static_assert(offsetof(FP2MoveActionUIConfig, WidgetActor) == 0x000000, "Member 'FP2MoveActionUIConfig::WidgetActor' has a wrong offset!");
static_assert(offsetof(FP2MoveActionUIConfig, BlockingTags) == 0x000008, "Member 'FP2MoveActionUIConfig::BlockingTags' has a wrong offset!");

// ScriptStruct Game.MoveActionInputData
// 0x00F8 (0x00F8 - 0x0000)
struct FMoveActionInputData final
{
public:
	struct FHitResult                             Hit;                                               // 0x0000(0x00E8)(Edit, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	struct FFloatRange                            HeightRange;                                       // 0x00E8(0x0010)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMoveActionInputData) == 0x000008, "Wrong alignment on FMoveActionInputData");
static_assert(sizeof(FMoveActionInputData) == 0x0000F8, "Wrong size on FMoveActionInputData");
static_assert(offsetof(FMoveActionInputData, Hit) == 0x000000, "Member 'FMoveActionInputData::Hit' has a wrong offset!");
static_assert(offsetof(FMoveActionInputData, HeightRange) == 0x0000E8, "Member 'FMoveActionInputData::HeightRange' has a wrong offset!");

// ScriptStruct Game.MoveActionPathData
// 0x0148 (0x0148 - 0x0000)
struct FMoveActionPathData final
{
public:
	bool                                          bIsValid;                                          // 0x0000(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTag                           MoveActionPathTag;                                 // 0x0004(0x0008)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FHitResult                             FloorHit;                                          // 0x0010(0x00E8)(Edit, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	int32                                         FloorIndex;                                        // 0x00F8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_FC[0x4];                                       // 0x00FC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                ApexImpactPointWS;                                 // 0x0100(0x0018)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                InitialContactPointWS;                             // 0x0118(0x0018)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FVector>                        PositionArray;                                     // 0x0130(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	EMovementMode                                 EndMovementMode;                                   // 0x0140(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EMoveActionEndStance                          EndStance;                                         // 0x0141(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_142[0x6];                                      // 0x0142(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FMoveActionPathData) == 0x000008, "Wrong alignment on FMoveActionPathData");
static_assert(sizeof(FMoveActionPathData) == 0x000148, "Wrong size on FMoveActionPathData");
static_assert(offsetof(FMoveActionPathData, bIsValid) == 0x000000, "Member 'FMoveActionPathData::bIsValid' has a wrong offset!");
static_assert(offsetof(FMoveActionPathData, MoveActionPathTag) == 0x000004, "Member 'FMoveActionPathData::MoveActionPathTag' has a wrong offset!");
static_assert(offsetof(FMoveActionPathData, FloorHit) == 0x000010, "Member 'FMoveActionPathData::FloorHit' has a wrong offset!");
static_assert(offsetof(FMoveActionPathData, FloorIndex) == 0x0000F8, "Member 'FMoveActionPathData::FloorIndex' has a wrong offset!");
static_assert(offsetof(FMoveActionPathData, ApexImpactPointWS) == 0x000100, "Member 'FMoveActionPathData::ApexImpactPointWS' has a wrong offset!");
static_assert(offsetof(FMoveActionPathData, InitialContactPointWS) == 0x000118, "Member 'FMoveActionPathData::InitialContactPointWS' has a wrong offset!");
static_assert(offsetof(FMoveActionPathData, PositionArray) == 0x000130, "Member 'FMoveActionPathData::PositionArray' has a wrong offset!");
static_assert(offsetof(FMoveActionPathData, EndMovementMode) == 0x000140, "Member 'FMoveActionPathData::EndMovementMode' has a wrong offset!");
static_assert(offsetof(FMoveActionPathData, EndStance) == 0x000141, "Member 'FMoveActionPathData::EndStance' has a wrong offset!");

// ScriptStruct Game.P2MoveActionRequirementsInput
// 0x0014 (0x0014 - 0x0000)
struct FP2MoveActionRequirementsInput final
{
public:
	struct FGameplayTag                           Category;                                          // 0x0000(0x0008)(Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Height;                                            // 0x0008(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Speed2D;                                           // 0x000C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EMoveActionEndStance                          EndStance;                                         // 0x0010(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EMovementMode                                 StartMovementMode;                                 // 0x0011(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EMovementMode                                 EndMovementMode;                                   // 0x0012(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_13[0x1];                                       // 0x0013(0x0001)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FP2MoveActionRequirementsInput) == 0x000004, "Wrong alignment on FP2MoveActionRequirementsInput");
static_assert(sizeof(FP2MoveActionRequirementsInput) == 0x000014, "Wrong size on FP2MoveActionRequirementsInput");
static_assert(offsetof(FP2MoveActionRequirementsInput, Category) == 0x000000, "Member 'FP2MoveActionRequirementsInput::Category' has a wrong offset!");
static_assert(offsetof(FP2MoveActionRequirementsInput, Height) == 0x000008, "Member 'FP2MoveActionRequirementsInput::Height' has a wrong offset!");
static_assert(offsetof(FP2MoveActionRequirementsInput, Speed2D) == 0x00000C, "Member 'FP2MoveActionRequirementsInput::Speed2D' has a wrong offset!");
static_assert(offsetof(FP2MoveActionRequirementsInput, EndStance) == 0x000010, "Member 'FP2MoveActionRequirementsInput::EndStance' has a wrong offset!");
static_assert(offsetof(FP2MoveActionRequirementsInput, StartMovementMode) == 0x000011, "Member 'FP2MoveActionRequirementsInput::StartMovementMode' has a wrong offset!");
static_assert(offsetof(FP2MoveActionRequirementsInput, EndMovementMode) == 0x000012, "Member 'FP2MoveActionRequirementsInput::EndMovementMode' has a wrong offset!");

// ScriptStruct Game.P2MoveActionEndConfig
// 0x0040 (0x0040 - 0x0000)
struct FP2MoveActionEndConfig final
{
public:
	EMovementMode                                 EndMovementMode;                                   // 0x0000(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EMoveActionEndStance                          EndStance;                                         // 0x0001(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ERootMotionFinishVelocityMode                 FinishVelocityMode;                                // 0x0002(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3[0x5];                                        // 0x0003(0x0005)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                FinishVelocity;                                    // 0x0008(0x0018)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                CalculatedVelocity;                                // 0x0020(0x0018)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UGameplayEffect>            EndGameplayEffect;                                 // 0x0038(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FP2MoveActionEndConfig) == 0x000008, "Wrong alignment on FP2MoveActionEndConfig");
static_assert(sizeof(FP2MoveActionEndConfig) == 0x000040, "Wrong size on FP2MoveActionEndConfig");
static_assert(offsetof(FP2MoveActionEndConfig, EndMovementMode) == 0x000000, "Member 'FP2MoveActionEndConfig::EndMovementMode' has a wrong offset!");
static_assert(offsetof(FP2MoveActionEndConfig, EndStance) == 0x000001, "Member 'FP2MoveActionEndConfig::EndStance' has a wrong offset!");
static_assert(offsetof(FP2MoveActionEndConfig, FinishVelocityMode) == 0x000002, "Member 'FP2MoveActionEndConfig::FinishVelocityMode' has a wrong offset!");
static_assert(offsetof(FP2MoveActionEndConfig, FinishVelocity) == 0x000008, "Member 'FP2MoveActionEndConfig::FinishVelocity' has a wrong offset!");
static_assert(offsetof(FP2MoveActionEndConfig, CalculatedVelocity) == 0x000020, "Member 'FP2MoveActionEndConfig::CalculatedVelocity' has a wrong offset!");
static_assert(offsetof(FP2MoveActionEndConfig, EndGameplayEffect) == 0x000038, "Member 'FP2MoveActionEndConfig::EndGameplayEffect' has a wrong offset!");

// ScriptStruct Game.P2DisableControlRotation
// 0x0007 (0x0007 - 0x0000)
struct FP2DisableControlRotation final
{
public:
	uint8                                         Pad_0[0x7];                                        // 0x0000(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FP2DisableControlRotation) == 0x000001, "Wrong alignment on FP2DisableControlRotation");
static_assert(sizeof(FP2DisableControlRotation) == 0x000007, "Wrong size on FP2DisableControlRotation");

// ScriptStruct Game.P2MoveActionStaticData
// 0x0218 (0x0218 - 0x0000)
struct FP2MoveActionStaticData final
{
public:
	class UP2MoveActionCancelDataBase*            CancelData;                                        // 0x0000(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, PersistentInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FFloatRange                            CancelTimeRange;                                   // 0x0008(0x0010)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Duration;                                          // 0x0018(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         StartInterpolationTime;                            // 0x001C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UP2AnimContainerBase*                   AnimContainer;                                     // 0x0020(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, PersistentInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRuntimeVectorCurve                    LocationCurveInstance;                             // 0x0028(0x0188)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	class UCurveFloat*                            RebaseCurve;                                       // 0x01B0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCurveFloat*                            PlayRateScaleCurve;                                // 0x01B8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FVector>                        BaseLocations;                                     // 0x01C0(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	struct FP2MoveActionEndConfig                 EndConfig;                                         // 0x01D0(0x0040)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	class UMoveActionRequirementsData_Base*       RequirementsData;                                  // 0x0210(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, PersistentInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FP2MoveActionStaticData) == 0x000008, "Wrong alignment on FP2MoveActionStaticData");
static_assert(sizeof(FP2MoveActionStaticData) == 0x000218, "Wrong size on FP2MoveActionStaticData");
static_assert(offsetof(FP2MoveActionStaticData, CancelData) == 0x000000, "Member 'FP2MoveActionStaticData::CancelData' has a wrong offset!");
static_assert(offsetof(FP2MoveActionStaticData, CancelTimeRange) == 0x000008, "Member 'FP2MoveActionStaticData::CancelTimeRange' has a wrong offset!");
static_assert(offsetof(FP2MoveActionStaticData, Duration) == 0x000018, "Member 'FP2MoveActionStaticData::Duration' has a wrong offset!");
static_assert(offsetof(FP2MoveActionStaticData, StartInterpolationTime) == 0x00001C, "Member 'FP2MoveActionStaticData::StartInterpolationTime' has a wrong offset!");
static_assert(offsetof(FP2MoveActionStaticData, AnimContainer) == 0x000020, "Member 'FP2MoveActionStaticData::AnimContainer' has a wrong offset!");
static_assert(offsetof(FP2MoveActionStaticData, LocationCurveInstance) == 0x000028, "Member 'FP2MoveActionStaticData::LocationCurveInstance' has a wrong offset!");
static_assert(offsetof(FP2MoveActionStaticData, RebaseCurve) == 0x0001B0, "Member 'FP2MoveActionStaticData::RebaseCurve' has a wrong offset!");
static_assert(offsetof(FP2MoveActionStaticData, PlayRateScaleCurve) == 0x0001B8, "Member 'FP2MoveActionStaticData::PlayRateScaleCurve' has a wrong offset!");
static_assert(offsetof(FP2MoveActionStaticData, BaseLocations) == 0x0001C0, "Member 'FP2MoveActionStaticData::BaseLocations' has a wrong offset!");
static_assert(offsetof(FP2MoveActionStaticData, EndConfig) == 0x0001D0, "Member 'FP2MoveActionStaticData::EndConfig' has a wrong offset!");
static_assert(offsetof(FP2MoveActionStaticData, RequirementsData) == 0x000210, "Member 'FP2MoveActionStaticData::RequirementsData' has a wrong offset!");

// ScriptStruct Game.P2DynamicFactionRewardData
// 0x0010 (0x0018 - 0x0008)
struct FP2DynamicFactionRewardData final : public FTableRowBase
{
public:
	int32                                         FactionLevelDiff;                                  // 0x0008(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         GameMoneyMultiplier;                               // 0x000C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ReputationMultiplier;                              // 0x0010(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FP2DynamicFactionRewardData) == 0x000008, "Wrong alignment on FP2DynamicFactionRewardData");
static_assert(sizeof(FP2DynamicFactionRewardData) == 0x000018, "Wrong size on FP2DynamicFactionRewardData");
static_assert(offsetof(FP2DynamicFactionRewardData, FactionLevelDiff) == 0x000008, "Member 'FP2DynamicFactionRewardData::FactionLevelDiff' has a wrong offset!");
static_assert(offsetof(FP2DynamicFactionRewardData, GameMoneyMultiplier) == 0x00000C, "Member 'FP2DynamicFactionRewardData::GameMoneyMultiplier' has a wrong offset!");
static_assert(offsetof(FP2DynamicFactionRewardData, ReputationMultiplier) == 0x000010, "Member 'FP2DynamicFactionRewardData::ReputationMultiplier' has a wrong offset!");

// ScriptStruct Game.P2AnomalyExtraPhase
// 0x0090 (0x0090 - 0x0000)
struct FP2AnomalyExtraPhase final
{
public:
	bool                                          bEnabled;                                          // 0x0000(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRuntimeFloatCurve                     SimulationExtraPhase;                              // 0x0008(0x0088)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
};
static_assert(alignof(FP2AnomalyExtraPhase) == 0x000008, "Wrong alignment on FP2AnomalyExtraPhase");
static_assert(sizeof(FP2AnomalyExtraPhase) == 0x000090, "Wrong size on FP2AnomalyExtraPhase");
static_assert(offsetof(FP2AnomalyExtraPhase, bEnabled) == 0x000000, "Member 'FP2AnomalyExtraPhase::bEnabled' has a wrong offset!");
static_assert(offsetof(FP2AnomalyExtraPhase, SimulationExtraPhase) == 0x000008, "Member 'FP2AnomalyExtraPhase::SimulationExtraPhase' has a wrong offset!");

// ScriptStruct Game.P2BubbleInfo
// 0x0588 (0x0588 - 0x0000)
struct FP2BubbleInfo final
{
public:
	struct FVector2D                              DelayToStart;                                      // 0x0000(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              TimeToFrom;                                        // 0x0010(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRuntimeFloatCurve                     TimeToFromSphereCurve;                             // 0x0020(0x0088)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FRuntimeFloatCurve                     TimeToFromCylinderCurve;                           // 0x00A8(0x0088)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FRuntimeVectorCurve                    TimeToFromLocationOffsetCurve;                     // 0x0130(0x0188)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FVector2D                              TimeToStay;                                        // 0x02B8(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              TimeToDisappear;                                   // 0x02C8(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRuntimeFloatCurve                     TimeToDisappearSphereCurve;                        // 0x02D8(0x0088)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FRuntimeFloatCurve                     TimeToDisappearCylinderCurve;                      // 0x0360(0x0088)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FRuntimeVectorCurve                    TimeToDisappearLocationOffsetCurve;                // 0x03E8(0x0188)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FVector2D                              MaxRadius;                                         // 0x0570(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RelativeOffsetRadius;                              // 0x0580(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_584[0x4];                                      // 0x0584(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FP2BubbleInfo) == 0x000008, "Wrong alignment on FP2BubbleInfo");
static_assert(sizeof(FP2BubbleInfo) == 0x000588, "Wrong size on FP2BubbleInfo");
static_assert(offsetof(FP2BubbleInfo, DelayToStart) == 0x000000, "Member 'FP2BubbleInfo::DelayToStart' has a wrong offset!");
static_assert(offsetof(FP2BubbleInfo, TimeToFrom) == 0x000010, "Member 'FP2BubbleInfo::TimeToFrom' has a wrong offset!");
static_assert(offsetof(FP2BubbleInfo, TimeToFromSphereCurve) == 0x000020, "Member 'FP2BubbleInfo::TimeToFromSphereCurve' has a wrong offset!");
static_assert(offsetof(FP2BubbleInfo, TimeToFromCylinderCurve) == 0x0000A8, "Member 'FP2BubbleInfo::TimeToFromCylinderCurve' has a wrong offset!");
static_assert(offsetof(FP2BubbleInfo, TimeToFromLocationOffsetCurve) == 0x000130, "Member 'FP2BubbleInfo::TimeToFromLocationOffsetCurve' has a wrong offset!");
static_assert(offsetof(FP2BubbleInfo, TimeToStay) == 0x0002B8, "Member 'FP2BubbleInfo::TimeToStay' has a wrong offset!");
static_assert(offsetof(FP2BubbleInfo, TimeToDisappear) == 0x0002C8, "Member 'FP2BubbleInfo::TimeToDisappear' has a wrong offset!");
static_assert(offsetof(FP2BubbleInfo, TimeToDisappearSphereCurve) == 0x0002D8, "Member 'FP2BubbleInfo::TimeToDisappearSphereCurve' has a wrong offset!");
static_assert(offsetof(FP2BubbleInfo, TimeToDisappearCylinderCurve) == 0x000360, "Member 'FP2BubbleInfo::TimeToDisappearCylinderCurve' has a wrong offset!");
static_assert(offsetof(FP2BubbleInfo, TimeToDisappearLocationOffsetCurve) == 0x0003E8, "Member 'FP2BubbleInfo::TimeToDisappearLocationOffsetCurve' has a wrong offset!");
static_assert(offsetof(FP2BubbleInfo, MaxRadius) == 0x000570, "Member 'FP2BubbleInfo::MaxRadius' has a wrong offset!");
static_assert(offsetof(FP2BubbleInfo, RelativeOffsetRadius) == 0x000580, "Member 'FP2BubbleInfo::RelativeOffsetRadius' has a wrong offset!");

// ScriptStruct Game.P2SpawnBubbleInfo
// 0x0060 (0x0060 - 0x0000)
struct FP2SpawnBubbleInfo final
{
public:
	int32                                         HeatMapNColumns;                                   // 0x0000(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ScorePerPawn;                                      // 0x0004(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ScorePerTeam;                                      // 0x0008(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ScoreBotMultiplier;                                // 0x000C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ScoreHeatThreshold;                                // 0x0010(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ValueHeatThresholdPerSecond;                       // 0x0014(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	double                                        InitialCooldownToSpawnBubbles;                     // 0x0018(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MaxConcurrentBubbles;                              // 0x0020(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_24[0x4];                                       // 0x0024(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	double                                        CooldownToSpawnNextBubble;                         // 0x0028(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         LayerCellsBockedBubble;                            // 0x0030(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_34[0x4];                                       // 0x0034(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class AP2AnomalyBubble>           BubbleActor;                                       // 0x0038(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTagContainer                  WhitelistedLayerTags;                              // 0x0040(0x0020)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
};
static_assert(alignof(FP2SpawnBubbleInfo) == 0x000008, "Wrong alignment on FP2SpawnBubbleInfo");
static_assert(sizeof(FP2SpawnBubbleInfo) == 0x000060, "Wrong size on FP2SpawnBubbleInfo");
static_assert(offsetof(FP2SpawnBubbleInfo, HeatMapNColumns) == 0x000000, "Member 'FP2SpawnBubbleInfo::HeatMapNColumns' has a wrong offset!");
static_assert(offsetof(FP2SpawnBubbleInfo, ScorePerPawn) == 0x000004, "Member 'FP2SpawnBubbleInfo::ScorePerPawn' has a wrong offset!");
static_assert(offsetof(FP2SpawnBubbleInfo, ScorePerTeam) == 0x000008, "Member 'FP2SpawnBubbleInfo::ScorePerTeam' has a wrong offset!");
static_assert(offsetof(FP2SpawnBubbleInfo, ScoreBotMultiplier) == 0x00000C, "Member 'FP2SpawnBubbleInfo::ScoreBotMultiplier' has a wrong offset!");
static_assert(offsetof(FP2SpawnBubbleInfo, ScoreHeatThreshold) == 0x000010, "Member 'FP2SpawnBubbleInfo::ScoreHeatThreshold' has a wrong offset!");
static_assert(offsetof(FP2SpawnBubbleInfo, ValueHeatThresholdPerSecond) == 0x000014, "Member 'FP2SpawnBubbleInfo::ValueHeatThresholdPerSecond' has a wrong offset!");
static_assert(offsetof(FP2SpawnBubbleInfo, InitialCooldownToSpawnBubbles) == 0x000018, "Member 'FP2SpawnBubbleInfo::InitialCooldownToSpawnBubbles' has a wrong offset!");
static_assert(offsetof(FP2SpawnBubbleInfo, MaxConcurrentBubbles) == 0x000020, "Member 'FP2SpawnBubbleInfo::MaxConcurrentBubbles' has a wrong offset!");
static_assert(offsetof(FP2SpawnBubbleInfo, CooldownToSpawnNextBubble) == 0x000028, "Member 'FP2SpawnBubbleInfo::CooldownToSpawnNextBubble' has a wrong offset!");
static_assert(offsetof(FP2SpawnBubbleInfo, LayerCellsBockedBubble) == 0x000030, "Member 'FP2SpawnBubbleInfo::LayerCellsBockedBubble' has a wrong offset!");
static_assert(offsetof(FP2SpawnBubbleInfo, BubbleActor) == 0x000038, "Member 'FP2SpawnBubbleInfo::BubbleActor' has a wrong offset!");
static_assert(offsetof(FP2SpawnBubbleInfo, WhitelistedLayerTags) == 0x000040, "Member 'FP2SpawnBubbleInfo::WhitelistedLayerTags' has a wrong offset!");

// ScriptStruct Game.P2ExtraBubbleInfo
// 0x0028 (0x0028 - 0x0000)
struct FP2ExtraBubbleInfo final
{
public:
	bool                                          bIsEnabled;                                        // 0x0000(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                SpawnLocation;                                     // 0x0008(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class AP2AnomalyBubble>           BubbleActor;                                       // 0x0020(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FP2ExtraBubbleInfo) == 0x000008, "Wrong alignment on FP2ExtraBubbleInfo");
static_assert(sizeof(FP2ExtraBubbleInfo) == 0x000028, "Wrong size on FP2ExtraBubbleInfo");
static_assert(offsetof(FP2ExtraBubbleInfo, bIsEnabled) == 0x000000, "Member 'FP2ExtraBubbleInfo::bIsEnabled' has a wrong offset!");
static_assert(offsetof(FP2ExtraBubbleInfo, SpawnLocation) == 0x000008, "Member 'FP2ExtraBubbleInfo::SpawnLocation' has a wrong offset!");
static_assert(offsetof(FP2ExtraBubbleInfo, BubbleActor) == 0x000020, "Member 'FP2ExtraBubbleInfo::BubbleActor' has a wrong offset!");

// ScriptStruct Game.P2BubbleReplicatedInfo
// 0x0018 (0x0018 - 0x0000)
struct FP2BubbleReplicatedInfo final
{
public:
	float                                         TimeOfActivation;                                  // 0x0000(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DelayToStart;                                      // 0x0004(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TimeToFrom;                                        // 0x0008(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TimeToStay;                                        // 0x000C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TimeToDisappear;                                   // 0x0010(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxRadius;                                         // 0x0014(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FP2BubbleReplicatedInfo) == 0x000004, "Wrong alignment on FP2BubbleReplicatedInfo");
static_assert(sizeof(FP2BubbleReplicatedInfo) == 0x000018, "Wrong size on FP2BubbleReplicatedInfo");
static_assert(offsetof(FP2BubbleReplicatedInfo, TimeOfActivation) == 0x000000, "Member 'FP2BubbleReplicatedInfo::TimeOfActivation' has a wrong offset!");
static_assert(offsetof(FP2BubbleReplicatedInfo, DelayToStart) == 0x000004, "Member 'FP2BubbleReplicatedInfo::DelayToStart' has a wrong offset!");
static_assert(offsetof(FP2BubbleReplicatedInfo, TimeToFrom) == 0x000008, "Member 'FP2BubbleReplicatedInfo::TimeToFrom' has a wrong offset!");
static_assert(offsetof(FP2BubbleReplicatedInfo, TimeToStay) == 0x00000C, "Member 'FP2BubbleReplicatedInfo::TimeToStay' has a wrong offset!");
static_assert(offsetof(FP2BubbleReplicatedInfo, TimeToDisappear) == 0x000010, "Member 'FP2BubbleReplicatedInfo::TimeToDisappear' has a wrong offset!");
static_assert(offsetof(FP2BubbleReplicatedInfo, MaxRadius) == 0x000014, "Member 'FP2BubbleReplicatedInfo::MaxRadius' has a wrong offset!");

// ScriptStruct Game.P2AnomalyZoneInfo
// 0x0020 (0x0020 - 0x0000)
struct FP2AnomalyZoneInfo final
{
public:
	struct FGameplayTag                           Tag;                                               // 0x0000(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FColor                                 Color;                                             // 0x0008(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FVector>                        Points;                                            // 0x0010(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
};
static_assert(alignof(FP2AnomalyZoneInfo) == 0x000008, "Wrong alignment on FP2AnomalyZoneInfo");
static_assert(sizeof(FP2AnomalyZoneInfo) == 0x000020, "Wrong size on FP2AnomalyZoneInfo");
static_assert(offsetof(FP2AnomalyZoneInfo, Tag) == 0x000000, "Member 'FP2AnomalyZoneInfo::Tag' has a wrong offset!");
static_assert(offsetof(FP2AnomalyZoneInfo, Color) == 0x000008, "Member 'FP2AnomalyZoneInfo::Color' has a wrong offset!");
static_assert(offsetof(FP2AnomalyZoneInfo, Points) == 0x000010, "Member 'FP2AnomalyZoneInfo::Points' has a wrong offset!");

// ScriptStruct Game.P2FactionLevelUpMailInfo
// 0x0098 (0x0098 - 0x0000)
struct FP2FactionLevelUpMailInfo final
{
public:
	bool                                          bSendMail;                                         // 0x0000(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FP2MailCreateParam                     MailCreateParam;                                   // 0x0008(0x0090)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
};
static_assert(alignof(FP2FactionLevelUpMailInfo) == 0x000008, "Wrong alignment on FP2FactionLevelUpMailInfo");
static_assert(sizeof(FP2FactionLevelUpMailInfo) == 0x000098, "Wrong size on FP2FactionLevelUpMailInfo");
static_assert(offsetof(FP2FactionLevelUpMailInfo, bSendMail) == 0x000000, "Member 'FP2FactionLevelUpMailInfo::bSendMail' has a wrong offset!");
static_assert(offsetof(FP2FactionLevelUpMailInfo, MailCreateParam) == 0x000008, "Member 'FP2FactionLevelUpMailInfo::MailCreateParam' has a wrong offset!");

// ScriptStruct Game.P2AnomalyPhaseReq
// 0x0020 (0x0020 - 0x0000)
struct FP2AnomalyPhaseReq final
{
public:
	double                                        Area;                                              // 0x0000(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	double                                        DeployCoastLine;                                   // 0x0008(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	double                                        MaxShrinkSpeed;                                    // 0x0010(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	double                                        MaxGrowSpeed;                                      // 0x0018(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FP2AnomalyPhaseReq) == 0x000008, "Wrong alignment on FP2AnomalyPhaseReq");
static_assert(sizeof(FP2AnomalyPhaseReq) == 0x000020, "Wrong size on FP2AnomalyPhaseReq");
static_assert(offsetof(FP2AnomalyPhaseReq, Area) == 0x000000, "Member 'FP2AnomalyPhaseReq::Area' has a wrong offset!");
static_assert(offsetof(FP2AnomalyPhaseReq, DeployCoastLine) == 0x000008, "Member 'FP2AnomalyPhaseReq::DeployCoastLine' has a wrong offset!");
static_assert(offsetof(FP2AnomalyPhaseReq, MaxShrinkSpeed) == 0x000010, "Member 'FP2AnomalyPhaseReq::MaxShrinkSpeed' has a wrong offset!");
static_assert(offsetof(FP2AnomalyPhaseReq, MaxGrowSpeed) == 0x000018, "Member 'FP2AnomalyPhaseReq::MaxGrowSpeed' has a wrong offset!");

// ScriptStruct Game.P2nomalyHeatMapCell
// 0x00E0 (0x00E0 - 0x0000)
struct FP2nomalyHeatMapCell final
{
public:
	bool                                          IsBlockedByBubble;                                 // 0x0000(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class APawn*>                          InsidePlayers;                                     // 0x0008(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	TSet<int32>                                   InsidePlayerTeams;                                 // 0x0018(0x0050)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	TArray<class APawn*>                          InsideBots;                                        // 0x0068(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	TSet<int32>                                   InsideBotTeams;                                    // 0x0078(0x0050)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	bool                                          StartHeat;                                         // 0x00C8(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C9[0x7];                                       // 0x00C9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	double                                        StartTime;                                         // 0x00D0(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HeatValue;                                         // 0x00D8(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_DC[0x4];                                       // 0x00DC(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FP2nomalyHeatMapCell) == 0x000008, "Wrong alignment on FP2nomalyHeatMapCell");
static_assert(sizeof(FP2nomalyHeatMapCell) == 0x0000E0, "Wrong size on FP2nomalyHeatMapCell");
static_assert(offsetof(FP2nomalyHeatMapCell, IsBlockedByBubble) == 0x000000, "Member 'FP2nomalyHeatMapCell::IsBlockedByBubble' has a wrong offset!");
static_assert(offsetof(FP2nomalyHeatMapCell, InsidePlayers) == 0x000008, "Member 'FP2nomalyHeatMapCell::InsidePlayers' has a wrong offset!");
static_assert(offsetof(FP2nomalyHeatMapCell, InsidePlayerTeams) == 0x000018, "Member 'FP2nomalyHeatMapCell::InsidePlayerTeams' has a wrong offset!");
static_assert(offsetof(FP2nomalyHeatMapCell, InsideBots) == 0x000068, "Member 'FP2nomalyHeatMapCell::InsideBots' has a wrong offset!");
static_assert(offsetof(FP2nomalyHeatMapCell, InsideBotTeams) == 0x000078, "Member 'FP2nomalyHeatMapCell::InsideBotTeams' has a wrong offset!");
static_assert(offsetof(FP2nomalyHeatMapCell, StartHeat) == 0x0000C8, "Member 'FP2nomalyHeatMapCell::StartHeat' has a wrong offset!");
static_assert(offsetof(FP2nomalyHeatMapCell, StartTime) == 0x0000D0, "Member 'FP2nomalyHeatMapCell::StartTime' has a wrong offset!");
static_assert(offsetof(FP2nomalyHeatMapCell, HeatValue) == 0x0000D8, "Member 'FP2nomalyHeatMapCell::HeatValue' has a wrong offset!");

// ScriptStruct Game.P2FactionMessage
// 0x0008 (0x0008 - 0x0000)
struct FP2FactionMessage
{
public:
	class UP2Faction*                             Faction;                                           // 0x0000(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FP2FactionMessage) == 0x000008, "Wrong alignment on FP2FactionMessage");
static_assert(sizeof(FP2FactionMessage) == 0x000008, "Wrong size on FP2FactionMessage");
static_assert(offsetof(FP2FactionMessage, Faction) == 0x000000, "Member 'FP2FactionMessage::Faction' has a wrong offset!");

// ScriptStruct Game.P2ContractMessage
// 0x0008 (0x0010 - 0x0008)
struct FP2ContractMessage : public FP2FactionMessage
{
public:
	class UP2Contract*                            Contract;                                          // 0x0008(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FP2ContractMessage) == 0x000008, "Wrong alignment on FP2ContractMessage");
static_assert(sizeof(FP2ContractMessage) == 0x000010, "Wrong size on FP2ContractMessage");
static_assert(offsetof(FP2ContractMessage, Contract) == 0x000008, "Member 'FP2ContractMessage::Contract' has a wrong offset!");

// ScriptStruct Game.P2ContractRequirementMessage
// 0x0008 (0x0018 - 0x0010)
struct FP2ContractRequirementMessage : public FP2ContractMessage
{
public:
	class UP2ContractRequirement*                 ContractRequirement;                               // 0x0010(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FP2ContractRequirementMessage) == 0x000008, "Wrong alignment on FP2ContractRequirementMessage");
static_assert(sizeof(FP2ContractRequirementMessage) == 0x000018, "Wrong size on FP2ContractRequirementMessage");
static_assert(offsetof(FP2ContractRequirementMessage, ContractRequirement) == 0x000010, "Member 'FP2ContractRequirementMessage::ContractRequirement' has a wrong offset!");

// ScriptStruct Game.P2AnomalyHeatMapGrid
// 0x0098 (0x0098 - 0x0000)
struct FP2AnomalyHeatMapGrid final
{
public:
	int32                                         NColumns;                                          // 0x0000(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector2D                              WorldSize;                                         // 0x0008(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ScorePerPawn;                                      // 0x0018(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ScorePerTeam;                                      // 0x001C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ScoreBotMultiplier;                                // 0x0020(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ScoreHeatThreshold;                                // 0x0024(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ValueHeatThresholdPerSecond;                       // 0x0028(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         LayerCellsBockedBubble;                            // 0x002C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_30[0x68];                                      // 0x0030(0x0068)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FP2AnomalyHeatMapGrid) == 0x000008, "Wrong alignment on FP2AnomalyHeatMapGrid");
static_assert(sizeof(FP2AnomalyHeatMapGrid) == 0x000098, "Wrong size on FP2AnomalyHeatMapGrid");
static_assert(offsetof(FP2AnomalyHeatMapGrid, NColumns) == 0x000000, "Member 'FP2AnomalyHeatMapGrid::NColumns' has a wrong offset!");
static_assert(offsetof(FP2AnomalyHeatMapGrid, WorldSize) == 0x000008, "Member 'FP2AnomalyHeatMapGrid::WorldSize' has a wrong offset!");
static_assert(offsetof(FP2AnomalyHeatMapGrid, ScorePerPawn) == 0x000018, "Member 'FP2AnomalyHeatMapGrid::ScorePerPawn' has a wrong offset!");
static_assert(offsetof(FP2AnomalyHeatMapGrid, ScorePerTeam) == 0x00001C, "Member 'FP2AnomalyHeatMapGrid::ScorePerTeam' has a wrong offset!");
static_assert(offsetof(FP2AnomalyHeatMapGrid, ScoreBotMultiplier) == 0x000020, "Member 'FP2AnomalyHeatMapGrid::ScoreBotMultiplier' has a wrong offset!");
static_assert(offsetof(FP2AnomalyHeatMapGrid, ScoreHeatThreshold) == 0x000024, "Member 'FP2AnomalyHeatMapGrid::ScoreHeatThreshold' has a wrong offset!");
static_assert(offsetof(FP2AnomalyHeatMapGrid, ValueHeatThresholdPerSecond) == 0x000028, "Member 'FP2AnomalyHeatMapGrid::ValueHeatThresholdPerSecond' has a wrong offset!");
static_assert(offsetof(FP2AnomalyHeatMapGrid, LayerCellsBockedBubble) == 0x00002C, "Member 'FP2AnomalyHeatMapGrid::LayerCellsBockedBubble' has a wrong offset!");

// ScriptStruct Game.P2AnomalyInclusionZone
// 0x0018 (0x0018 - 0x0000)
struct FP2AnomalyInclusionZone final
{
public:
	struct FColor                                 Color;                                             // 0x0000(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FVector>                        Points;                                            // 0x0008(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
};
static_assert(alignof(FP2AnomalyInclusionZone) == 0x000008, "Wrong alignment on FP2AnomalyInclusionZone");
static_assert(sizeof(FP2AnomalyInclusionZone) == 0x000018, "Wrong size on FP2AnomalyInclusionZone");
static_assert(offsetof(FP2AnomalyInclusionZone, Color) == 0x000000, "Member 'FP2AnomalyInclusionZone::Color' has a wrong offset!");
static_assert(offsetof(FP2AnomalyInclusionZone, Points) == 0x000008, "Member 'FP2AnomalyInclusionZone::Points' has a wrong offset!");

// ScriptStruct Game.P2FactionMessage_Reputation
// 0x0008 (0x0010 - 0x0008)
struct FP2FactionMessage_Reputation final : public FP2FactionMessage
{
public:
	int32                                         PreviousReputation;                                // 0x0008(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         CurrentReputation;                                 // 0x000C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FP2FactionMessage_Reputation) == 0x000008, "Wrong alignment on FP2FactionMessage_Reputation");
static_assert(sizeof(FP2FactionMessage_Reputation) == 0x000010, "Wrong size on FP2FactionMessage_Reputation");
static_assert(offsetof(FP2FactionMessage_Reputation, PreviousReputation) == 0x000008, "Member 'FP2FactionMessage_Reputation::PreviousReputation' has a wrong offset!");
static_assert(offsetof(FP2FactionMessage_Reputation, CurrentReputation) == 0x00000C, "Member 'FP2FactionMessage_Reputation::CurrentReputation' has a wrong offset!");

// ScriptStruct Game.P2SegmentsInfo
// 0x0028 (0x0028 - 0x0000)
struct FP2SegmentsInfo final
{
public:
	int32                                         IndexStartA;                                       // 0x0000(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         IndexEndA;                                         // 0x0004(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         IndexStartB;                                       // 0x0008(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         IndexEndB;                                         // 0x000C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Location;                                          // 0x0010(0x0018)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FP2SegmentsInfo) == 0x000008, "Wrong alignment on FP2SegmentsInfo");
static_assert(sizeof(FP2SegmentsInfo) == 0x000028, "Wrong size on FP2SegmentsInfo");
static_assert(offsetof(FP2SegmentsInfo, IndexStartA) == 0x000000, "Member 'FP2SegmentsInfo::IndexStartA' has a wrong offset!");
static_assert(offsetof(FP2SegmentsInfo, IndexEndA) == 0x000004, "Member 'FP2SegmentsInfo::IndexEndA' has a wrong offset!");
static_assert(offsetof(FP2SegmentsInfo, IndexStartB) == 0x000008, "Member 'FP2SegmentsInfo::IndexStartB' has a wrong offset!");
static_assert(offsetof(FP2SegmentsInfo, IndexEndB) == 0x00000C, "Member 'FP2SegmentsInfo::IndexEndB' has a wrong offset!");
static_assert(offsetof(FP2SegmentsInfo, Location) == 0x000010, "Member 'FP2SegmentsInfo::Location' has a wrong offset!");

// ScriptStruct Game.P2AnomalySpeedTest
// 0x0018 (0x0018 - 0x0000)
struct FP2AnomalySpeedTest final
{
public:
	double                                        MaxDistanceTest;                                   // 0x0000(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	double                                        MaxSpeed;                                          // 0x0008(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         AnomalyPhaseMaxSpeed;                              // 0x0010(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         CpMaxSpeed;                                        // 0x0014(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FP2AnomalySpeedTest) == 0x000008, "Wrong alignment on FP2AnomalySpeedTest");
static_assert(sizeof(FP2AnomalySpeedTest) == 0x000018, "Wrong size on FP2AnomalySpeedTest");
static_assert(offsetof(FP2AnomalySpeedTest, MaxDistanceTest) == 0x000000, "Member 'FP2AnomalySpeedTest::MaxDistanceTest' has a wrong offset!");
static_assert(offsetof(FP2AnomalySpeedTest, MaxSpeed) == 0x000008, "Member 'FP2AnomalySpeedTest::MaxSpeed' has a wrong offset!");
static_assert(offsetof(FP2AnomalySpeedTest, AnomalyPhaseMaxSpeed) == 0x000010, "Member 'FP2AnomalySpeedTest::AnomalyPhaseMaxSpeed' has a wrong offset!");
static_assert(offsetof(FP2AnomalySpeedTest, CpMaxSpeed) == 0x000014, "Member 'FP2AnomalySpeedTest::CpMaxSpeed' has a wrong offset!");

// ScriptStruct Game.P2InstantEffectZones
// 0x0010 (0x0010 - 0x0000)
struct FP2InstantEffectZones final
{
public:
	TArray<class UP2TriggerZoneComponent*>        Array;                                             // 0x0000(0x0010)(ExportObject, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(FP2InstantEffectZones) == 0x000008, "Wrong alignment on FP2InstantEffectZones");
static_assert(sizeof(FP2InstantEffectZones) == 0x000010, "Wrong size on FP2InstantEffectZones");
static_assert(offsetof(FP2InstantEffectZones, Array) == 0x000000, "Member 'FP2InstantEffectZones::Array' has a wrong offset!");

// ScriptStruct Game.P2ZonesByType
// 0x0050 (0x0050 - 0x0000)
struct FP2ZonesByType final
{
public:
	TMap<struct FGameplayTag, struct FP2Zones>    Map;                                               // 0x0000(0x0050)(ContainsInstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(FP2ZonesByType) == 0x000008, "Wrong alignment on FP2ZonesByType");
static_assert(sizeof(FP2ZonesByType) == 0x000050, "Wrong size on FP2ZonesByType");
static_assert(offsetof(FP2ZonesByType, Map) == 0x000000, "Member 'FP2ZonesByType::Map' has a wrong offset!");

// ScriptStruct Game.P2ArmorSetup
// 0x0100 (0x0100 - 0x0000)
struct FP2ArmorSetup final
{
public:
	float                                         Durability;                                        // 0x0000(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UCurveFloat*                            DurabilityDamageResistanceCurve;                   // 0x0008(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TMap<struct FGameplayTag, struct FP2ArmorConfig> ZoneArmorMap;                                   // 0x0010(0x0050)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TMap<struct FGameplayTag, float>              StatusEffectResistance;                            // 0x0060(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TMap<struct FGameplayTag, float>              DestructibilityMultiplierFromDamageTypeMap;        // 0x00B0(0x0050)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
};
static_assert(alignof(FP2ArmorSetup) == 0x000008, "Wrong alignment on FP2ArmorSetup");
static_assert(sizeof(FP2ArmorSetup) == 0x000100, "Wrong size on FP2ArmorSetup");
static_assert(offsetof(FP2ArmorSetup, Durability) == 0x000000, "Member 'FP2ArmorSetup::Durability' has a wrong offset!");
static_assert(offsetof(FP2ArmorSetup, DurabilityDamageResistanceCurve) == 0x000008, "Member 'FP2ArmorSetup::DurabilityDamageResistanceCurve' has a wrong offset!");
static_assert(offsetof(FP2ArmorSetup, ZoneArmorMap) == 0x000010, "Member 'FP2ArmorSetup::ZoneArmorMap' has a wrong offset!");
static_assert(offsetof(FP2ArmorSetup, StatusEffectResistance) == 0x000060, "Member 'FP2ArmorSetup::StatusEffectResistance' has a wrong offset!");
static_assert(offsetof(FP2ArmorSetup, DestructibilityMultiplierFromDamageTypeMap) == 0x0000B0, "Member 'FP2ArmorSetup::DestructibilityMultiplierFromDamageTypeMap' has a wrong offset!");

// ScriptStruct Game.P2FireVoxel
// 0x0070 (0x0070 - 0x0000)
struct FP2FireVoxel final
{
public:
	uint8                                         Pad_0[0x68];                                       // 0x0000(0x0068)(Fixing Size After Last Property [ Dumper-7 ])
	class UP2FireData*                            VoxelFireData;                                     // 0x0068(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FP2FireVoxel) == 0x000008, "Wrong alignment on FP2FireVoxel");
static_assert(sizeof(FP2FireVoxel) == 0x000070, "Wrong size on FP2FireVoxel");
static_assert(offsetof(FP2FireVoxel, VoxelFireData) == 0x000068, "Member 'FP2FireVoxel::VoxelFireData' has a wrong offset!");

// ScriptStruct Game.P2RequireItemInfoForRepairArmor
// 0x0058 (0x0058 - 0x0000)
struct FP2RequireItemInfoForRepairArmor final
{
public:
	struct FP2ExchangeInfo                        ItemInfo;                                          // 0x0000(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	bool                                          bIsFlexibleItemCount;                              // 0x0050(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_51[0x7];                                       // 0x0051(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FP2RequireItemInfoForRepairArmor) == 0x000008, "Wrong alignment on FP2RequireItemInfoForRepairArmor");
static_assert(sizeof(FP2RequireItemInfoForRepairArmor) == 0x000058, "Wrong size on FP2RequireItemInfoForRepairArmor");
static_assert(offsetof(FP2RequireItemInfoForRepairArmor, ItemInfo) == 0x000000, "Member 'FP2RequireItemInfoForRepairArmor::ItemInfo' has a wrong offset!");
static_assert(offsetof(FP2RequireItemInfoForRepairArmor, bIsFlexibleItemCount) == 0x000050, "Member 'FP2RequireItemInfoForRepairArmor::bIsFlexibleItemCount' has a wrong offset!");

// ScriptStruct Game.P2ArmorClassDataInfo
// 0x0070 (0x0070 - 0x0000)
struct FP2ArmorClassDataInfo final
{
public:
	struct FGameplayTagContainer                  ItemTypeContainer;                                 // 0x0000(0x0020)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TMap<int32, int32>                            BallisticProtectionArmorClassMap;                  // 0x0020(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
};
static_assert(alignof(FP2ArmorClassDataInfo) == 0x000008, "Wrong alignment on FP2ArmorClassDataInfo");
static_assert(sizeof(FP2ArmorClassDataInfo) == 0x000070, "Wrong size on FP2ArmorClassDataInfo");
static_assert(offsetof(FP2ArmorClassDataInfo, ItemTypeContainer) == 0x000000, "Member 'FP2ArmorClassDataInfo::ItemTypeContainer' has a wrong offset!");
static_assert(offsetof(FP2ArmorClassDataInfo, BallisticProtectionArmorClassMap) == 0x000020, "Member 'FP2ArmorClassDataInfo::BallisticProtectionArmorClassMap' has a wrong offset!");

// ScriptStruct Game.P2ContractMissionResetTracker
// 0x0058 (0x0060 - 0x0008)
struct FP2ContractMissionResetTracker final : public FP2ContractMissionReset
{
public:
	struct FDateTime                              LastKnownReset;                                    // 0x0008(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TMap<struct FGameplayTag, int32>              NumContractsAssigned;                              // 0x0010(0x0050)(RepSkip, NativeAccessSpecifierPublic)
};
static_assert(alignof(FP2ContractMissionResetTracker) == 0x000008, "Wrong alignment on FP2ContractMissionResetTracker");
static_assert(sizeof(FP2ContractMissionResetTracker) == 0x000060, "Wrong size on FP2ContractMissionResetTracker");
static_assert(offsetof(FP2ContractMissionResetTracker, LastKnownReset) == 0x000008, "Member 'FP2ContractMissionResetTracker::LastKnownReset' has a wrong offset!");
static_assert(offsetof(FP2ContractMissionResetTracker, NumContractsAssigned) == 0x000010, "Member 'FP2ContractMissionResetTracker::NumContractsAssigned' has a wrong offset!");

// ScriptStruct Game.P2ContainersConfigData
// 0x0028 (0x0028 - 0x0000)
struct FP2ContainersConfigData final
{
public:
	TArray<struct FGameplayTag>                   TargetItemTagArray;                                // 0x0000(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TArray<class UP2ContainerData*>               ContainersConfig;                                  // 0x0010(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TSubclassOf<class UP2ContainersLayoutWidget>  ContainersWidgetClass;                             // 0x0020(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FP2ContainersConfigData) == 0x000008, "Wrong alignment on FP2ContainersConfigData");
static_assert(sizeof(FP2ContainersConfigData) == 0x000028, "Wrong size on FP2ContainersConfigData");
static_assert(offsetof(FP2ContainersConfigData, TargetItemTagArray) == 0x000000, "Member 'FP2ContainersConfigData::TargetItemTagArray' has a wrong offset!");
static_assert(offsetof(FP2ContainersConfigData, ContainersConfig) == 0x000010, "Member 'FP2ContainersConfigData::ContainersConfig' has a wrong offset!");
static_assert(offsetof(FP2ContainersConfigData, ContainersWidgetClass) == 0x000020, "Member 'FP2ContainersConfigData::ContainersWidgetClass' has a wrong offset!");

// ScriptStruct Game.P2SurfacePropagationParams
// 0x000C (0x000C - 0x0000)
struct FP2SurfacePropagationParams final
{
public:
	float                                         PropagationTimeScale;                              // 0x0000(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LifeDecayScale;                                    // 0x0004(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BufferDecayScale;                                  // 0x0008(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FP2SurfacePropagationParams) == 0x000004, "Wrong alignment on FP2SurfacePropagationParams");
static_assert(sizeof(FP2SurfacePropagationParams) == 0x00000C, "Wrong size on FP2SurfacePropagationParams");
static_assert(offsetof(FP2SurfacePropagationParams, PropagationTimeScale) == 0x000000, "Member 'FP2SurfacePropagationParams::PropagationTimeScale' has a wrong offset!");
static_assert(offsetof(FP2SurfacePropagationParams, LifeDecayScale) == 0x000004, "Member 'FP2SurfacePropagationParams::LifeDecayScale' has a wrong offset!");
static_assert(offsetof(FP2SurfacePropagationParams, BufferDecayScale) == 0x000008, "Member 'FP2SurfacePropagationParams::BufferDecayScale' has a wrong offset!");

// ScriptStruct Game.P2AttributeEffectSourceInfo
// 0x0010 (0x0010 - 0x0000)
struct FP2AttributeEffectSourceInfo final
{
public:
	class UGameplayEffect*                        SourceEffect;                                      // 0x0000(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SourceDelta;                                       // 0x0008(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FP2AttributeEffectSourceInfo) == 0x000008, "Wrong alignment on FP2AttributeEffectSourceInfo");
static_assert(sizeof(FP2AttributeEffectSourceInfo) == 0x000010, "Wrong size on FP2AttributeEffectSourceInfo");
static_assert(offsetof(FP2AttributeEffectSourceInfo, SourceEffect) == 0x000000, "Member 'FP2AttributeEffectSourceInfo::SourceEffect' has a wrong offset!");
static_assert(offsetof(FP2AttributeEffectSourceInfo, SourceDelta) == 0x000008, "Member 'FP2AttributeEffectSourceInfo::SourceDelta' has a wrong offset!");

// ScriptStruct Game.P2AttributeEffectInfo
// 0x00D0 (0x00D0 - 0x0000)
struct FP2AttributeEffectInfo final
{
public:
	struct FGameplayAttribute                     Attribute;                                         // 0x0000(0x0038)(BlueprintVisible, BlueprintReadOnly, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTagRequirements               ModifierTags;                                      // 0x0038(0x0040)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FGameplayTagRequirements               OngoingTags;                                       // 0x0078(0x0040)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	float                                         TotalDelta;                                        // 0x00B8(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_BC[0x4];                                       // 0x00BC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FP2AttributeEffectSourceInfo>   SourceEffects;                                     // 0x00C0(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FP2AttributeEffectInfo) == 0x000008, "Wrong alignment on FP2AttributeEffectInfo");
static_assert(sizeof(FP2AttributeEffectInfo) == 0x0000D0, "Wrong size on FP2AttributeEffectInfo");
static_assert(offsetof(FP2AttributeEffectInfo, Attribute) == 0x000000, "Member 'FP2AttributeEffectInfo::Attribute' has a wrong offset!");
static_assert(offsetof(FP2AttributeEffectInfo, ModifierTags) == 0x000038, "Member 'FP2AttributeEffectInfo::ModifierTags' has a wrong offset!");
static_assert(offsetof(FP2AttributeEffectInfo, OngoingTags) == 0x000078, "Member 'FP2AttributeEffectInfo::OngoingTags' has a wrong offset!");
static_assert(offsetof(FP2AttributeEffectInfo, TotalDelta) == 0x0000B8, "Member 'FP2AttributeEffectInfo::TotalDelta' has a wrong offset!");
static_assert(offsetof(FP2AttributeEffectInfo, SourceEffects) == 0x0000C0, "Member 'FP2AttributeEffectInfo::SourceEffects' has a wrong offset!");

// ScriptStruct Game.P2GameplayAbilityActorInfo
// 0x0018 (0x0060 - 0x0048)
struct FP2GameplayAbilityActorInfo final : public FGameplayAbilityActorInfo
{
public:
	TWeakObjectPtr<class AP2HeroCharacter>        Character;                                         // 0x0048(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TWeakObjectPtr<class UP2EquipmentManagerComponent> EquipmentManager;                             // 0x0050(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TWeakObjectPtr<class UP2HeroComponent>        HeroComponent;                                     // 0x0058(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FP2GameplayAbilityActorInfo) == 0x000008, "Wrong alignment on FP2GameplayAbilityActorInfo");
static_assert(sizeof(FP2GameplayAbilityActorInfo) == 0x000060, "Wrong size on FP2GameplayAbilityActorInfo");
static_assert(offsetof(FP2GameplayAbilityActorInfo, Character) == 0x000048, "Member 'FP2GameplayAbilityActorInfo::Character' has a wrong offset!");
static_assert(offsetof(FP2GameplayAbilityActorInfo, EquipmentManager) == 0x000050, "Member 'FP2GameplayAbilityActorInfo::EquipmentManager' has a wrong offset!");
static_assert(offsetof(FP2GameplayAbilityActorInfo, HeroComponent) == 0x000058, "Member 'FP2GameplayAbilityActorInfo::HeroComponent' has a wrong offset!");

// ScriptStruct Game.P2AttributeClamp
// 0x0080 (0x0080 - 0x0000)
struct FP2AttributeClamp final
{
public:
	float                                         MinFloat;                                          // 0x0000(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxFloat;                                          // 0x0004(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayAttribute                     MinAttribute;                                      // 0x0008(0x0038)(Edit, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayAttribute                     MaxAttribute;                                      // 0x0040(0x0038)(Edit, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EP2AttributeClampMode                         MinMode;                                           // 0x0078(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EP2AttributeClampMode                         MaxMode;                                           // 0x0079(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_7A[0x6];                                       // 0x007A(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FP2AttributeClamp) == 0x000008, "Wrong alignment on FP2AttributeClamp");
static_assert(sizeof(FP2AttributeClamp) == 0x000080, "Wrong size on FP2AttributeClamp");
static_assert(offsetof(FP2AttributeClamp, MinFloat) == 0x000000, "Member 'FP2AttributeClamp::MinFloat' has a wrong offset!");
static_assert(offsetof(FP2AttributeClamp, MaxFloat) == 0x000004, "Member 'FP2AttributeClamp::MaxFloat' has a wrong offset!");
static_assert(offsetof(FP2AttributeClamp, MinAttribute) == 0x000008, "Member 'FP2AttributeClamp::MinAttribute' has a wrong offset!");
static_assert(offsetof(FP2AttributeClamp, MaxAttribute) == 0x000040, "Member 'FP2AttributeClamp::MaxAttribute' has a wrong offset!");
static_assert(offsetof(FP2AttributeClamp, MinMode) == 0x000078, "Member 'FP2AttributeClamp::MinMode' has a wrong offset!");
static_assert(offsetof(FP2AttributeClamp, MaxMode) == 0x000079, "Member 'FP2AttributeClamp::MaxMode' has a wrong offset!");

// ScriptStruct Game.P2AttributeClampConfig
// 0x0100 (0x0100 - 0x0000)
struct FP2AttributeClampConfig final
{
public:
	struct FP2AttributeClamp                      BaseValue;                                         // 0x0000(0x0080)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FP2AttributeClamp                      CurrentValue;                                      // 0x0080(0x0080)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
};
static_assert(alignof(FP2AttributeClampConfig) == 0x000008, "Wrong alignment on FP2AttributeClampConfig");
static_assert(sizeof(FP2AttributeClampConfig) == 0x000100, "Wrong size on FP2AttributeClampConfig");
static_assert(offsetof(FP2AttributeClampConfig, BaseValue) == 0x000000, "Member 'FP2AttributeClampConfig::BaseValue' has a wrong offset!");
static_assert(offsetof(FP2AttributeClampConfig, CurrentValue) == 0x000080, "Member 'FP2AttributeClampConfig::CurrentValue' has a wrong offset!");

// ScriptStruct Game.PawnSubAkComponentConfig
// 0x0038 (0x0038 - 0x0000)
struct FPawnSubAkComponentConfig final
{
public:
	class FName                                   SocketName;                                        // 0x0000(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                RelativeOffset;                                    // 0x0008(0x0018)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bRelativeOffsetInComponentSpace;                   // 0x0020(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_21[0x3];                                       // 0x0021(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTag                           LocalReverbSettingsTag;                            // 0x0024(0x0008)(Edit, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           RemoteReverbSettingsTag;                           // 0x002C(0x0008)(Edit, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_34[0x4];                                       // 0x0034(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FPawnSubAkComponentConfig) == 0x000008, "Wrong alignment on FPawnSubAkComponentConfig");
static_assert(sizeof(FPawnSubAkComponentConfig) == 0x000038, "Wrong size on FPawnSubAkComponentConfig");
static_assert(offsetof(FPawnSubAkComponentConfig, SocketName) == 0x000000, "Member 'FPawnSubAkComponentConfig::SocketName' has a wrong offset!");
static_assert(offsetof(FPawnSubAkComponentConfig, RelativeOffset) == 0x000008, "Member 'FPawnSubAkComponentConfig::RelativeOffset' has a wrong offset!");
static_assert(offsetof(FPawnSubAkComponentConfig, bRelativeOffsetInComponentSpace) == 0x000020, "Member 'FPawnSubAkComponentConfig::bRelativeOffsetInComponentSpace' has a wrong offset!");
static_assert(offsetof(FPawnSubAkComponentConfig, LocalReverbSettingsTag) == 0x000024, "Member 'FPawnSubAkComponentConfig::LocalReverbSettingsTag' has a wrong offset!");
static_assert(offsetof(FPawnSubAkComponentConfig, RemoteReverbSettingsTag) == 0x00002C, "Member 'FPawnSubAkComponentConfig::RemoteReverbSettingsTag' has a wrong offset!");

// ScriptStruct Game.P2BeamRifleTargetedPawnData
// 0x0018 (0x0018 - 0x0000)
struct FP2BeamRifleTargetedPawnData final
{
public:
	class APawn*                                  TargetPawn;                                        // 0x0000(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   TargetBone;                                        // 0x0008(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RelativePitch;                                     // 0x0010(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RelativeYaw;                                       // 0x0014(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FP2BeamRifleTargetedPawnData) == 0x000008, "Wrong alignment on FP2BeamRifleTargetedPawnData");
static_assert(sizeof(FP2BeamRifleTargetedPawnData) == 0x000018, "Wrong size on FP2BeamRifleTargetedPawnData");
static_assert(offsetof(FP2BeamRifleTargetedPawnData, TargetPawn) == 0x000000, "Member 'FP2BeamRifleTargetedPawnData::TargetPawn' has a wrong offset!");
static_assert(offsetof(FP2BeamRifleTargetedPawnData, TargetBone) == 0x000008, "Member 'FP2BeamRifleTargetedPawnData::TargetBone' has a wrong offset!");
static_assert(offsetof(FP2BeamRifleTargetedPawnData, RelativePitch) == 0x000010, "Member 'FP2BeamRifleTargetedPawnData::RelativePitch' has a wrong offset!");
static_assert(offsetof(FP2BeamRifleTargetedPawnData, RelativeYaw) == 0x000014, "Member 'FP2BeamRifleTargetedPawnData::RelativeYaw' has a wrong offset!");

// ScriptStruct Game.PawnAkComponentSetup
// 0x0070 (0x0070 - 0x0000)
struct FPawnAkComponentSetup final
{
public:
	struct FAkOcclusionConfig                     OcclusionConfig;                                   // 0x0000(0x0004)(Edit, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
	struct FPawnDefaultAkComponentConfig          DefaultAkComponentConfig;                          // 0x0004(0x0010)(Edit, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<struct FGameplayTag, struct FPawnSubAkComponentConfig> SubAkComponentConfigMap;             // 0x0018(0x0050)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	bool                                          bShouldAlwaysUseOnlyDefault;                       // 0x0068(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_69[0x7];                                       // 0x0069(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FPawnAkComponentSetup) == 0x000008, "Wrong alignment on FPawnAkComponentSetup");
static_assert(sizeof(FPawnAkComponentSetup) == 0x000070, "Wrong size on FPawnAkComponentSetup");
static_assert(offsetof(FPawnAkComponentSetup, OcclusionConfig) == 0x000000, "Member 'FPawnAkComponentSetup::OcclusionConfig' has a wrong offset!");
static_assert(offsetof(FPawnAkComponentSetup, DefaultAkComponentConfig) == 0x000004, "Member 'FPawnAkComponentSetup::DefaultAkComponentConfig' has a wrong offset!");
static_assert(offsetof(FPawnAkComponentSetup, SubAkComponentConfigMap) == 0x000018, "Member 'FPawnAkComponentSetup::SubAkComponentConfigMap' has a wrong offset!");
static_assert(offsetof(FPawnAkComponentSetup, bShouldAlwaysUseOnlyDefault) == 0x000068, "Member 'FPawnAkComponentSetup::bShouldAlwaysUseOnlyDefault' has a wrong offset!");

// ScriptStruct Game.P2SnapToFoliageData
// 0x0080 (0x0080 - 0x0000)
struct FP2SnapToFoliageData final
{
public:
	class FString                                 InternalId;                                        // 0x0000(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FTransform                             Transform;                                         // 0x0010(0x0060)(BlueprintVisible, BlueprintReadOnly, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UP2SnapToFoliageAssetUserData*          AssetUserData;                                     // 0x0070(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_78[0x8];                                       // 0x0078(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FP2SnapToFoliageData) == 0x000010, "Wrong alignment on FP2SnapToFoliageData");
static_assert(sizeof(FP2SnapToFoliageData) == 0x000080, "Wrong size on FP2SnapToFoliageData");
static_assert(offsetof(FP2SnapToFoliageData, InternalId) == 0x000000, "Member 'FP2SnapToFoliageData::InternalId' has a wrong offset!");
static_assert(offsetof(FP2SnapToFoliageData, Transform) == 0x000010, "Member 'FP2SnapToFoliageData::Transform' has a wrong offset!");
static_assert(offsetof(FP2SnapToFoliageData, AssetUserData) == 0x000070, "Member 'FP2SnapToFoliageData::AssetUserData' has a wrong offset!");

// ScriptStruct Game.P2GameplayContextDependencyGraphVertex
// 0x0020 (0x0020 - 0x0000)
struct FP2GameplayContextDependencyGraphVertex final
{
public:
	class UP2GameplayContextDataBase*             Data;                                              // 0x0000(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_8[0x8];                                        // 0x0008(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UP2GameplayContextDataBase*>     NextDataList;                                      // 0x0010(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FP2GameplayContextDependencyGraphVertex) == 0x000008, "Wrong alignment on FP2GameplayContextDependencyGraphVertex");
static_assert(sizeof(FP2GameplayContextDependencyGraphVertex) == 0x000020, "Wrong size on FP2GameplayContextDependencyGraphVertex");
static_assert(offsetof(FP2GameplayContextDependencyGraphVertex, Data) == 0x000000, "Member 'FP2GameplayContextDependencyGraphVertex::Data' has a wrong offset!");
static_assert(offsetof(FP2GameplayContextDependencyGraphVertex, NextDataList) == 0x000010, "Member 'FP2GameplayContextDependencyGraphVertex::NextDataList' has a wrong offset!");

// ScriptStruct Game.P2WeatherSoundsOnFoliage
// 0x0010 (0x0010 - 0x0000)
struct FP2WeatherSoundsOnFoliage final
{
public:
	class UAkAudioEvent*                          WindAkEvent;                                       // 0x0000(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAkAudioEvent*                          RainAkEvent;                                       // 0x0008(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FP2WeatherSoundsOnFoliage) == 0x000008, "Wrong alignment on FP2WeatherSoundsOnFoliage");
static_assert(sizeof(FP2WeatherSoundsOnFoliage) == 0x000010, "Wrong size on FP2WeatherSoundsOnFoliage");
static_assert(offsetof(FP2WeatherSoundsOnFoliage, WindAkEvent) == 0x000000, "Member 'FP2WeatherSoundsOnFoliage::WindAkEvent' has a wrong offset!");
static_assert(offsetof(FP2WeatherSoundsOnFoliage, RainAkEvent) == 0x000008, "Member 'FP2WeatherSoundsOnFoliage::RainAkEvent' has a wrong offset!");

// ScriptStruct Game.P2AudioRoom
// 0x0040 (0x0040 - 0x0000)
struct FP2AudioRoom final
{
public:
	int32                                         Index;                                             // 0x0000(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Priority;                                          // 0x0004(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FBoxSphereBounds                       Bounds;                                            // 0x0008(0x0038)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FP2AudioRoom) == 0x000008, "Wrong alignment on FP2AudioRoom");
static_assert(sizeof(FP2AudioRoom) == 0x000040, "Wrong size on FP2AudioRoom");
static_assert(offsetof(FP2AudioRoom, Index) == 0x000000, "Member 'FP2AudioRoom::Index' has a wrong offset!");
static_assert(offsetof(FP2AudioRoom, Priority) == 0x000004, "Member 'FP2AudioRoom::Priority' has a wrong offset!");
static_assert(offsetof(FP2AudioRoom, Bounds) == 0x000008, "Member 'FP2AudioRoom::Bounds' has a wrong offset!");

// ScriptStruct Game.P2BioArmorPartConfig
// 0x0030 (0x0030 - 0x0000)
struct FP2BioArmorPartConfig final
{
public:
	class USkeletalMesh*                          SkeletalMesh;                                      // 0x0000(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         TrackedMaterialIndex;                              // 0x0008(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UMaterialInterface*                     UnwrapMaterial;                                    // 0x0010(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMaterialInterface*                     FadeMaterial;                                      // 0x0018(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         RenderTargetResolution;                            // 0x0020(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCreateFirstPersonMesh;                            // 0x0024(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsVisible;                                        // 0x0025(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_26[0x2];                                       // 0x0026(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         EffectRadiusScalar;                                // 0x0028(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C[0x4];                                       // 0x002C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FP2BioArmorPartConfig) == 0x000008, "Wrong alignment on FP2BioArmorPartConfig");
static_assert(sizeof(FP2BioArmorPartConfig) == 0x000030, "Wrong size on FP2BioArmorPartConfig");
static_assert(offsetof(FP2BioArmorPartConfig, SkeletalMesh) == 0x000000, "Member 'FP2BioArmorPartConfig::SkeletalMesh' has a wrong offset!");
static_assert(offsetof(FP2BioArmorPartConfig, TrackedMaterialIndex) == 0x000008, "Member 'FP2BioArmorPartConfig::TrackedMaterialIndex' has a wrong offset!");
static_assert(offsetof(FP2BioArmorPartConfig, UnwrapMaterial) == 0x000010, "Member 'FP2BioArmorPartConfig::UnwrapMaterial' has a wrong offset!");
static_assert(offsetof(FP2BioArmorPartConfig, FadeMaterial) == 0x000018, "Member 'FP2BioArmorPartConfig::FadeMaterial' has a wrong offset!");
static_assert(offsetof(FP2BioArmorPartConfig, RenderTargetResolution) == 0x000020, "Member 'FP2BioArmorPartConfig::RenderTargetResolution' has a wrong offset!");
static_assert(offsetof(FP2BioArmorPartConfig, bCreateFirstPersonMesh) == 0x000024, "Member 'FP2BioArmorPartConfig::bCreateFirstPersonMesh' has a wrong offset!");
static_assert(offsetof(FP2BioArmorPartConfig, bIsVisible) == 0x000025, "Member 'FP2BioArmorPartConfig::bIsVisible' has a wrong offset!");
static_assert(offsetof(FP2BioArmorPartConfig, EffectRadiusScalar) == 0x000028, "Member 'FP2BioArmorPartConfig::EffectRadiusScalar' has a wrong offset!");

// ScriptStruct Game.P2ContextRequirement_ItemRequirements
// 0x0020 (0x0020 - 0x0000)
struct FP2ContextRequirement_ItemRequirements final
{
public:
	EP2ContextRequirement_ItemRequirementsSource  Source;                                            // 0x0000(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UP2ItemData*                            ItemData;                                          // 0x0008(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EP2ContextRequirement_ItemRequirementsType    Type;                                              // 0x0010(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x3];                                       // 0x0011(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         Amount;                                            // 0x0014(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bRecursive;                                        // 0x0018(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCountMagazineAmmo;                                // 0x0019(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1A[0x6];                                       // 0x001A(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FP2ContextRequirement_ItemRequirements) == 0x000008, "Wrong alignment on FP2ContextRequirement_ItemRequirements");
static_assert(sizeof(FP2ContextRequirement_ItemRequirements) == 0x000020, "Wrong size on FP2ContextRequirement_ItemRequirements");
static_assert(offsetof(FP2ContextRequirement_ItemRequirements, Source) == 0x000000, "Member 'FP2ContextRequirement_ItemRequirements::Source' has a wrong offset!");
static_assert(offsetof(FP2ContextRequirement_ItemRequirements, ItemData) == 0x000008, "Member 'FP2ContextRequirement_ItemRequirements::ItemData' has a wrong offset!");
static_assert(offsetof(FP2ContextRequirement_ItemRequirements, Type) == 0x000010, "Member 'FP2ContextRequirement_ItemRequirements::Type' has a wrong offset!");
static_assert(offsetof(FP2ContextRequirement_ItemRequirements, Amount) == 0x000014, "Member 'FP2ContextRequirement_ItemRequirements::Amount' has a wrong offset!");
static_assert(offsetof(FP2ContextRequirement_ItemRequirements, bRecursive) == 0x000018, "Member 'FP2ContextRequirement_ItemRequirements::bRecursive' has a wrong offset!");
static_assert(offsetof(FP2ContextRequirement_ItemRequirements, bCountMagazineAmmo) == 0x000019, "Member 'FP2ContextRequirement_ItemRequirements::bCountMagazineAmmo' has a wrong offset!");

// ScriptStruct Game.P2BioArmorPartInstance
// 0x0040 (0x0040 - 0x0000)
struct FP2BioArmorPartInstance final
{
public:
	class USkeletalMeshComponent*                 TrackedSk;                                         // 0x0000(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USkeletalMeshComponent*                 TrackedSk_FPP;                                     // 0x0008(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USkeletalMeshComponent*                 EffectSk;                                          // 0x0010(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMaterialInstanceDynamic*               UnwrapMID;                                         // 0x0018(0x0008)(ZeroConstructor, Transient, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMaterialInstanceDynamic*               FadeMID;                                           // 0x0020(0x0008)(ZeroConstructor, Transient, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USceneCaptureComponent2D*               SceneCaptureComponent;                             // 0x0028(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTextureRenderTarget2D*                 RenderTarget;                                      // 0x0030(0x0008)(ZeroConstructor, Transient, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         EffectRadiusScalar;                                // 0x0038(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3C[0x4];                                       // 0x003C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FP2BioArmorPartInstance) == 0x000008, "Wrong alignment on FP2BioArmorPartInstance");
static_assert(sizeof(FP2BioArmorPartInstance) == 0x000040, "Wrong size on FP2BioArmorPartInstance");
static_assert(offsetof(FP2BioArmorPartInstance, TrackedSk) == 0x000000, "Member 'FP2BioArmorPartInstance::TrackedSk' has a wrong offset!");
static_assert(offsetof(FP2BioArmorPartInstance, TrackedSk_FPP) == 0x000008, "Member 'FP2BioArmorPartInstance::TrackedSk_FPP' has a wrong offset!");
static_assert(offsetof(FP2BioArmorPartInstance, EffectSk) == 0x000010, "Member 'FP2BioArmorPartInstance::EffectSk' has a wrong offset!");
static_assert(offsetof(FP2BioArmorPartInstance, UnwrapMID) == 0x000018, "Member 'FP2BioArmorPartInstance::UnwrapMID' has a wrong offset!");
static_assert(offsetof(FP2BioArmorPartInstance, FadeMID) == 0x000020, "Member 'FP2BioArmorPartInstance::FadeMID' has a wrong offset!");
static_assert(offsetof(FP2BioArmorPartInstance, SceneCaptureComponent) == 0x000028, "Member 'FP2BioArmorPartInstance::SceneCaptureComponent' has a wrong offset!");
static_assert(offsetof(FP2BioArmorPartInstance, RenderTarget) == 0x000030, "Member 'FP2BioArmorPartInstance::RenderTarget' has a wrong offset!");
static_assert(offsetof(FP2BioArmorPartInstance, EffectRadiusScalar) == 0x000038, "Member 'FP2BioArmorPartInstance::EffectRadiusScalar' has a wrong offset!");

// ScriptStruct Game.P2BioArmorGeneralConfig
// 0x0028 (0x0028 - 0x0000)
struct FP2BioArmorGeneralConfig final
{
public:
	TArray<struct FP2BioArmorPartConfig>          PartConfigs;                                       // 0x0000(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	float                                         DefaultRadius;                                     // 0x0010(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UCurveFloat*                            DamageToRadiusCurve;                               // 0x0018(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         EffectTimeout;                                     // 0x0020(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_24[0x4];                                       // 0x0024(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FP2BioArmorGeneralConfig) == 0x000008, "Wrong alignment on FP2BioArmorGeneralConfig");
static_assert(sizeof(FP2BioArmorGeneralConfig) == 0x000028, "Wrong size on FP2BioArmorGeneralConfig");
static_assert(offsetof(FP2BioArmorGeneralConfig, PartConfigs) == 0x000000, "Member 'FP2BioArmorGeneralConfig::PartConfigs' has a wrong offset!");
static_assert(offsetof(FP2BioArmorGeneralConfig, DefaultRadius) == 0x000010, "Member 'FP2BioArmorGeneralConfig::DefaultRadius' has a wrong offset!");
static_assert(offsetof(FP2BioArmorGeneralConfig, DamageToRadiusCurve) == 0x000018, "Member 'FP2BioArmorGeneralConfig::DamageToRadiusCurve' has a wrong offset!");
static_assert(offsetof(FP2BioArmorGeneralConfig, EffectTimeout) == 0x000020, "Member 'FP2BioArmorGeneralConfig::EffectTimeout' has a wrong offset!");

// ScriptStruct Game.P2WeaponEffectSet_CameraShake
// 0x0008 (0x0008 - 0x0000)
struct FP2WeaponEffectSet_CameraShake final
{
public:
	TSubclassOf<class UCameraShakeBase>           CameraShakeClass;                                  // 0x0000(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FP2WeaponEffectSet_CameraShake) == 0x000008, "Wrong alignment on FP2WeaponEffectSet_CameraShake");
static_assert(sizeof(FP2WeaponEffectSet_CameraShake) == 0x000008, "Wrong size on FP2WeaponEffectSet_CameraShake");
static_assert(offsetof(FP2WeaponEffectSet_CameraShake, CameraShakeClass) == 0x000000, "Member 'FP2WeaponEffectSet_CameraShake::CameraShakeClass' has a wrong offset!");

// ScriptStruct Game.P2BulletCapturedData
// 0x00D8 (0x00D8 - 0x0000)
struct FP2BulletCapturedData final
{
public:
	TArray<struct FP2AbilitySet_GameplayEffect>   GameplayEffects;                                   // 0x0000(0x0010)(ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	class UP2WeaponData*                          WeaponData;                                        // 0x0010(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UP2AmmoData*                            AmmoData;                                          // 0x0018(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_20[0xB8];                                      // 0x0020(0x00B8)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FP2BulletCapturedData) == 0x000008, "Wrong alignment on FP2BulletCapturedData");
static_assert(sizeof(FP2BulletCapturedData) == 0x0000D8, "Wrong size on FP2BulletCapturedData");
static_assert(offsetof(FP2BulletCapturedData, GameplayEffects) == 0x000000, "Member 'FP2BulletCapturedData::GameplayEffects' has a wrong offset!");
static_assert(offsetof(FP2BulletCapturedData, WeaponData) == 0x000010, "Member 'FP2BulletCapturedData::WeaponData' has a wrong offset!");
static_assert(offsetof(FP2BulletCapturedData, AmmoData) == 0x000018, "Member 'FP2BulletCapturedData::AmmoData' has a wrong offset!");

// ScriptStruct Game.P2BulletDataMap
// 0x0050 (0x0050 - 0x0000)
struct FP2BulletDataMap final
{
public:
	TMap<uint32, struct FP2BulletCapturedData>    Map;                                               // 0x0000(0x0050)(ContainsInstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(FP2BulletDataMap) == 0x000008, "Wrong alignment on FP2BulletDataMap");
static_assert(sizeof(FP2BulletDataMap) == 0x000050, "Wrong size on FP2BulletDataMap");
static_assert(offsetof(FP2BulletDataMap, Map) == 0x000000, "Member 'FP2BulletDataMap::Map' has a wrong offset!");

// ScriptStruct Game.P2GameplayContextRequirementItemFilter
// 0x0038 (0x0038 - 0x0000)
struct FP2GameplayContextRequirementItemFilter final
{
public:
	TArray<class UP2ItemData*>                    SpecificItems;                                     // 0x0000(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FGameplayTagContainer                  ItemTags;                                          // 0x0010(0x0020)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FP2GameplayContextRequirementItemRequirements ItemRequirements;                           // 0x0030(0x0003)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_33[0x5];                                       // 0x0033(0x0005)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FP2GameplayContextRequirementItemFilter) == 0x000008, "Wrong alignment on FP2GameplayContextRequirementItemFilter");
static_assert(sizeof(FP2GameplayContextRequirementItemFilter) == 0x000038, "Wrong size on FP2GameplayContextRequirementItemFilter");
static_assert(offsetof(FP2GameplayContextRequirementItemFilter, SpecificItems) == 0x000000, "Member 'FP2GameplayContextRequirementItemFilter::SpecificItems' has a wrong offset!");
static_assert(offsetof(FP2GameplayContextRequirementItemFilter, ItemTags) == 0x000010, "Member 'FP2GameplayContextRequirementItemFilter::ItemTags' has a wrong offset!");
static_assert(offsetof(FP2GameplayContextRequirementItemFilter, ItemRequirements) == 0x000030, "Member 'FP2GameplayContextRequirementItemFilter::ItemRequirements' has a wrong offset!");

// ScriptStruct Game.P2BulletHitGameplayCueConfig
// 0x0028 (0x0028 - 0x0000)
struct FP2BulletHitGameplayCueConfig final
{
public:
	struct FGameplayTag                           GameplayCueTag;                                    // 0x0000(0x0008)(Edit, BlueprintVisible, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTagContainer                  SourceTagFilter;                                   // 0x0008(0x0020)(Edit, BlueprintVisible, DisableEditOnInstance, NativeAccessSpecifierPublic)
};
static_assert(alignof(FP2BulletHitGameplayCueConfig) == 0x000008, "Wrong alignment on FP2BulletHitGameplayCueConfig");
static_assert(sizeof(FP2BulletHitGameplayCueConfig) == 0x000028, "Wrong size on FP2BulletHitGameplayCueConfig");
static_assert(offsetof(FP2BulletHitGameplayCueConfig, GameplayCueTag) == 0x000000, "Member 'FP2BulletHitGameplayCueConfig::GameplayCueTag' has a wrong offset!");
static_assert(offsetof(FP2BulletHitGameplayCueConfig, SourceTagFilter) == 0x000008, "Member 'FP2BulletHitGameplayCueConfig::SourceTagFilter' has a wrong offset!");

// ScriptStruct Game.BulletHitAudioEvent
// 0x0028 (0x0028 - 0x0000)
struct alignas(0x08) FBulletHitAudioEvent final
{
public:
	uint8                                         Pad_0[0x28];                                       // 0x0000(0x0028)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FBulletHitAudioEvent) == 0x000008, "Wrong alignment on FBulletHitAudioEvent");
static_assert(sizeof(FBulletHitAudioEvent) == 0x000028, "Wrong size on FBulletHitAudioEvent");

// ScriptStruct Game.P2HighlightInventoryWidgetParams
// 0x0060 (0x0060 - 0x0000)
struct FP2HighlightInventoryWidgetParams final
{
public:
	EP2HighlightInventoryWidgetType               Type;                                              // 0x0000(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EInventorySlotWidgetType                      SlotType;                                          // 0x0001(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2[0x6];                                        // 0x0002(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	class UP2ItemData*                            ItemData;                                          // 0x0008(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSet<EInventoryContainerWidgetType>           ItemLocationWhiteList;                             // 0x0010(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
};
static_assert(alignof(FP2HighlightInventoryWidgetParams) == 0x000008, "Wrong alignment on FP2HighlightInventoryWidgetParams");
static_assert(sizeof(FP2HighlightInventoryWidgetParams) == 0x000060, "Wrong size on FP2HighlightInventoryWidgetParams");
static_assert(offsetof(FP2HighlightInventoryWidgetParams, Type) == 0x000000, "Member 'FP2HighlightInventoryWidgetParams::Type' has a wrong offset!");
static_assert(offsetof(FP2HighlightInventoryWidgetParams, SlotType) == 0x000001, "Member 'FP2HighlightInventoryWidgetParams::SlotType' has a wrong offset!");
static_assert(offsetof(FP2HighlightInventoryWidgetParams, ItemData) == 0x000008, "Member 'FP2HighlightInventoryWidgetParams::ItemData' has a wrong offset!");
static_assert(offsetof(FP2HighlightInventoryWidgetParams, ItemLocationWhiteList) == 0x000010, "Member 'FP2HighlightInventoryWidgetParams::ItemLocationWhiteList' has a wrong offset!");

// ScriptStruct Game.P2BulletHitValidationData
// 0x01A8 (0x01A8 - 0x0000)
struct FP2BulletHitValidationData final
{
public:
	uint8                                         Pad_0[0x160];                                      // 0x0000(0x0160)(Fixing Size After Last Property [ Dumper-7 ])
	class AActor*                                 Instigator;                                        // 0x0160(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 Target;                                            // 0x0168(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_170[0x38];                                     // 0x0170(0x0038)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FP2BulletHitValidationData) == 0x000008, "Wrong alignment on FP2BulletHitValidationData");
static_assert(sizeof(FP2BulletHitValidationData) == 0x0001A8, "Wrong size on FP2BulletHitValidationData");
static_assert(offsetof(FP2BulletHitValidationData, Instigator) == 0x000160, "Member 'FP2BulletHitValidationData::Instigator' has a wrong offset!");
static_assert(offsetof(FP2BulletHitValidationData, Target) == 0x000168, "Member 'FP2BulletHitValidationData::Target' has a wrong offset!");

// ScriptStruct Game.P2AmmoFiredPayload
// 0x0058 (0x0058 - 0x0000)
struct FP2AmmoFiredPayload final
{
public:
	class UObject*                                SourceObject;                                      // 0x0000(0x0008)(BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 Instigator;                                        // 0x0008(0x0008)(BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Location;                                          // 0x0010(0x0018)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Direction;                                         // 0x0028(0x0018)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FP2AmmoDescriptor                      Ammo;                                              // 0x0040(0x0018)(BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FP2AmmoFiredPayload) == 0x000008, "Wrong alignment on FP2AmmoFiredPayload");
static_assert(sizeof(FP2AmmoFiredPayload) == 0x000058, "Wrong size on FP2AmmoFiredPayload");
static_assert(offsetof(FP2AmmoFiredPayload, SourceObject) == 0x000000, "Member 'FP2AmmoFiredPayload::SourceObject' has a wrong offset!");
static_assert(offsetof(FP2AmmoFiredPayload, Instigator) == 0x000008, "Member 'FP2AmmoFiredPayload::Instigator' has a wrong offset!");
static_assert(offsetof(FP2AmmoFiredPayload, Location) == 0x000010, "Member 'FP2AmmoFiredPayload::Location' has a wrong offset!");
static_assert(offsetof(FP2AmmoFiredPayload, Direction) == 0x000028, "Member 'FP2AmmoFiredPayload::Direction' has a wrong offset!");
static_assert(offsetof(FP2AmmoFiredPayload, Ammo) == 0x000040, "Member 'FP2AmmoFiredPayload::Ammo' has a wrong offset!");

// ScriptStruct Game.P2WeaponEffectSet_Vfx
// 0x0010 (0x0010 - 0x0000)
struct FP2WeaponEffectSet_Vfx final
{
public:
	class UNiagaraSystem*                         MuzzleFlash;                                       // 0x0000(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bShouldAttachToMuzzle;                             // 0x0008(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsHitScan;                                        // 0x0009(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A[0x6];                                        // 0x000A(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FP2WeaponEffectSet_Vfx) == 0x000008, "Wrong alignment on FP2WeaponEffectSet_Vfx");
static_assert(sizeof(FP2WeaponEffectSet_Vfx) == 0x000010, "Wrong size on FP2WeaponEffectSet_Vfx");
static_assert(offsetof(FP2WeaponEffectSet_Vfx, MuzzleFlash) == 0x000000, "Member 'FP2WeaponEffectSet_Vfx::MuzzleFlash' has a wrong offset!");
static_assert(offsetof(FP2WeaponEffectSet_Vfx, bShouldAttachToMuzzle) == 0x000008, "Member 'FP2WeaponEffectSet_Vfx::bShouldAttachToMuzzle' has a wrong offset!");
static_assert(offsetof(FP2WeaponEffectSet_Vfx, bIsHitScan) == 0x000009, "Member 'FP2WeaponEffectSet_Vfx::bIsHitScan' has a wrong offset!");

// ScriptStruct Game.P2BulletInstance
// 0x0118 (0x0118 - 0x0000)
struct alignas(0x08) FP2BulletInstance final
{
public:
	uint8                                         Pad_0[0x118];                                      // 0x0000(0x0118)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FP2BulletInstance) == 0x000008, "Wrong alignment on FP2BulletInstance");
static_assert(sizeof(FP2BulletInstance) == 0x000118, "Wrong size on FP2BulletInstance");

// ScriptStruct Game.P2BulletTracerInstance
// 0x0008 (0x0008 - 0x0000)
struct FP2BulletTracerInstance final
{
public:
	class UNiagaraComponent*                      ParticleSystem;                                    // 0x0000(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FP2BulletTracerInstance) == 0x000008, "Wrong alignment on FP2BulletTracerInstance");
static_assert(sizeof(FP2BulletTracerInstance) == 0x000008, "Wrong size on FP2BulletTracerInstance");
static_assert(offsetof(FP2BulletTracerInstance, ParticleSystem) == 0x000000, "Member 'FP2BulletTracerInstance::ParticleSystem' has a wrong offset!");

// ScriptStruct Game.P2SpotlightFarDepthHitContext
// 0x00F0 (0x00F0 - 0x0000)
struct alignas(0x08) FP2SpotlightFarDepthHitContext final
{
public:
	uint8                                         Pad_0[0xF0];                                       // 0x0000(0x00F0)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FP2SpotlightFarDepthHitContext) == 0x000008, "Wrong alignment on FP2SpotlightFarDepthHitContext");
static_assert(sizeof(FP2SpotlightFarDepthHitContext) == 0x0000F0, "Wrong size on FP2SpotlightFarDepthHitContext");

// ScriptStruct Game.P2DamageStatusEffectInfo
// 0x0080 (0x0080 - 0x0000)
struct FP2DamageStatusEffectInfo final
{
public:
	struct FGameplayTag                           StatusEffectTag;                                   // 0x0000(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           SetByCallerChanceTag;                              // 0x0008(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           SetByCallerStacksTag;                              // 0x0010(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bMultiplyChanceByDamageDone : 1;                   // 0x0018(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bMultiplyStacksByDamageDone : 1;                   // 0x0018(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bApplyOnlyIfPenetrated : 1;                        // 0x0018(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_19[0x7];                                       // 0x0019(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FP2ScalableFloat                       LevelLimit;                                        // 0x0020(0x0030)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FP2ScalableFloat                       StackLimit;                                        // 0x0050(0x0030)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
};
static_assert(alignof(FP2DamageStatusEffectInfo) == 0x000008, "Wrong alignment on FP2DamageStatusEffectInfo");
static_assert(sizeof(FP2DamageStatusEffectInfo) == 0x000080, "Wrong size on FP2DamageStatusEffectInfo");
static_assert(offsetof(FP2DamageStatusEffectInfo, StatusEffectTag) == 0x000000, "Member 'FP2DamageStatusEffectInfo::StatusEffectTag' has a wrong offset!");
static_assert(offsetof(FP2DamageStatusEffectInfo, SetByCallerChanceTag) == 0x000008, "Member 'FP2DamageStatusEffectInfo::SetByCallerChanceTag' has a wrong offset!");
static_assert(offsetof(FP2DamageStatusEffectInfo, SetByCallerStacksTag) == 0x000010, "Member 'FP2DamageStatusEffectInfo::SetByCallerStacksTag' has a wrong offset!");
static_assert(offsetof(FP2DamageStatusEffectInfo, LevelLimit) == 0x000020, "Member 'FP2DamageStatusEffectInfo::LevelLimit' has a wrong offset!");
static_assert(offsetof(FP2DamageStatusEffectInfo, StackLimit) == 0x000050, "Member 'FP2DamageStatusEffectInfo::StackLimit' has a wrong offset!");

// ScriptStruct Game.P2ContractStateQuery
// 0x0014 (0x0014 - 0x0000)
struct FP2ContractStateQuery final
{
public:
	struct FDataRegistryId                        DataRegistryId;                                    // 0x0000(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EP2ContractState                              State;                                             // 0x0010(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EP2ContractStateQueryType                     Type;                                              // 0x0011(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_12[0x2];                                       // 0x0012(0x0002)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FP2ContractStateQuery) == 0x000004, "Wrong alignment on FP2ContractStateQuery");
static_assert(sizeof(FP2ContractStateQuery) == 0x000014, "Wrong size on FP2ContractStateQuery");
static_assert(offsetof(FP2ContractStateQuery, DataRegistryId) == 0x000000, "Member 'FP2ContractStateQuery::DataRegistryId' has a wrong offset!");
static_assert(offsetof(FP2ContractStateQuery, State) == 0x000010, "Member 'FP2ContractStateQuery::State' has a wrong offset!");
static_assert(offsetof(FP2ContractStateQuery, Type) == 0x000011, "Member 'FP2ContractStateQuery::Type' has a wrong offset!");

// ScriptStruct Game.CameraLagConfig
// 0x0030 (0x0030 - 0x0000)
struct FCameraLagConfig final
{
public:
	float                                         VelocitySpikeThreshold;                            // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FP2Remap                               SpikeTimeToInterpSpeedRemap;                       // 0x0008(0x0028)(Edit, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCameraLagConfig) == 0x000008, "Wrong alignment on FCameraLagConfig");
static_assert(sizeof(FCameraLagConfig) == 0x000030, "Wrong size on FCameraLagConfig");
static_assert(offsetof(FCameraLagConfig, VelocitySpikeThreshold) == 0x000000, "Member 'FCameraLagConfig::VelocitySpikeThreshold' has a wrong offset!");
static_assert(offsetof(FCameraLagConfig, SpikeTimeToInterpSpeedRemap) == 0x000008, "Member 'FCameraLagConfig::SpikeTimeToInterpSpeedRemap' has a wrong offset!");

// ScriptStruct Game.P2CameraSmoothingProcessor
// 0x0150 (0x0150 - 0x0000)
struct FP2CameraSmoothingProcessor final
{
public:
	class UCameraSmoothingDataAsset*              Data;                                              // 0x0000(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_8[0x88];                                       // 0x0008(0x0088)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVectorRK4SpringInterpolator           SpringInterpolatorHorizontal;                      // 0x0090(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_98[0x58];                                      // 0x0098(0x0058)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVectorRK4SpringInterpolator           SpringInterpolatorVertical;                        // 0x00F0(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_F8[0x58];                                      // 0x00F8(0x0058)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FP2CameraSmoothingProcessor) == 0x000008, "Wrong alignment on FP2CameraSmoothingProcessor");
static_assert(sizeof(FP2CameraSmoothingProcessor) == 0x000150, "Wrong size on FP2CameraSmoothingProcessor");
static_assert(offsetof(FP2CameraSmoothingProcessor, Data) == 0x000000, "Member 'FP2CameraSmoothingProcessor::Data' has a wrong offset!");
static_assert(offsetof(FP2CameraSmoothingProcessor, SpringInterpolatorHorizontal) == 0x000090, "Member 'FP2CameraSmoothingProcessor::SpringInterpolatorHorizontal' has a wrong offset!");
static_assert(offsetof(FP2CameraSmoothingProcessor, SpringInterpolatorVertical) == 0x0000F0, "Member 'FP2CameraSmoothingProcessor::SpringInterpolatorVertical' has a wrong offset!");

// ScriptStruct Game.P2GameplayCue_SeverityEntry
// 0x000C (0x000C - 0x0000)
struct FP2GameplayCue_SeverityEntry final
{
public:
	struct FGameplayTag                           Severity;                                          // 0x0000(0x0008)(Edit, BlueprintVisible, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Value;                                             // 0x0008(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FP2GameplayCue_SeverityEntry) == 0x000004, "Wrong alignment on FP2GameplayCue_SeverityEntry");
static_assert(sizeof(FP2GameplayCue_SeverityEntry) == 0x00000C, "Wrong size on FP2GameplayCue_SeverityEntry");
static_assert(offsetof(FP2GameplayCue_SeverityEntry, Severity) == 0x000000, "Member 'FP2GameplayCue_SeverityEntry::Severity' has a wrong offset!");
static_assert(offsetof(FP2GameplayCue_SeverityEntry, Value) == 0x000008, "Member 'FP2GameplayCue_SeverityEntry::Value' has a wrong offset!");

// ScriptStruct Game.CameraViewLimitSettings
// 0x0050 (0x0050 - 0x0000)
struct FCameraViewLimitSettings final
{
public:
	TMap<struct FGameplayTag, struct FCameraViewLimitConfig> TagLimitMap;                            // 0x0000(0x0050)(Edit, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCameraViewLimitSettings) == 0x000008, "Wrong alignment on FCameraViewLimitSettings");
static_assert(sizeof(FCameraViewLimitSettings) == 0x000050, "Wrong size on FCameraViewLimitSettings");
static_assert(offsetof(FCameraViewLimitSettings, TagLimitMap) == 0x000000, "Member 'FCameraViewLimitSettings::TagLimitMap' has a wrong offset!");

// ScriptStruct Game.P2DamageEffectContext
// 0x0028 (0x0028 - 0x0000)
struct FP2DamageEffectContext final
{
public:
	float                                         Distance;                                          // 0x0000(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaterialPenetrationMultiplier;                     // 0x0004(0x0004)(ZeroConstructor, IsPlainOldData, RepSkip, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FP2DamageStatusEffectInfo>      StatusEffects;                                     // 0x0008(0x0010)(ZeroConstructor, RepSkip, NativeAccessSpecifierPublic)
	uint8                                         Pad_18[0x10];                                      // 0x0018(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FP2DamageEffectContext) == 0x000008, "Wrong alignment on FP2DamageEffectContext");
static_assert(sizeof(FP2DamageEffectContext) == 0x000028, "Wrong size on FP2DamageEffectContext");
static_assert(offsetof(FP2DamageEffectContext, Distance) == 0x000000, "Member 'FP2DamageEffectContext::Distance' has a wrong offset!");
static_assert(offsetof(FP2DamageEffectContext, MaterialPenetrationMultiplier) == 0x000004, "Member 'FP2DamageEffectContext::MaterialPenetrationMultiplier' has a wrong offset!");
static_assert(offsetof(FP2DamageEffectContext, StatusEffects) == 0x000008, "Member 'FP2DamageEffectContext::StatusEffects' has a wrong offset!");

// ScriptStruct Game.P2GameplayEffectContext
// 0x0030 (0x00B0 - 0x0080)
struct FP2GameplayEffectContext final : public FGameplayEffectContext
{
public:
	int32                                         ShotIndex;                                         // 0x0080(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_84[0x4];                                       // 0x0084(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FP2DamageEffectContext                 DamageContext;                                     // 0x0088(0x0028)(Protected, NativeAccessSpecifierProtected)
};
static_assert(alignof(FP2GameplayEffectContext) == 0x000008, "Wrong alignment on FP2GameplayEffectContext");
static_assert(sizeof(FP2GameplayEffectContext) == 0x0000B0, "Wrong size on FP2GameplayEffectContext");
static_assert(offsetof(FP2GameplayEffectContext, ShotIndex) == 0x000080, "Member 'FP2GameplayEffectContext::ShotIndex' has a wrong offset!");
static_assert(offsetof(FP2GameplayEffectContext, DamageContext) == 0x000088, "Member 'FP2GameplayEffectContext::DamageContext' has a wrong offset!");

// ScriptStruct Game.P2ChallengeDetailsMessage
// 0x0018 (0x0018 - 0x0000)
struct FP2ChallengeDetailsMessage final
{
public:
	uint8                                         Pad_0[0x10];                                       // 0x0000(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class UObject*                                Target;                                            // 0x0010(0x0008)(BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FP2ChallengeDetailsMessage) == 0x000008, "Wrong alignment on FP2ChallengeDetailsMessage");
static_assert(sizeof(FP2ChallengeDetailsMessage) == 0x000018, "Wrong size on FP2ChallengeDetailsMessage");
static_assert(offsetof(FP2ChallengeDetailsMessage, Target) == 0x000010, "Member 'FP2ChallengeDetailsMessage::Target' has a wrong offset!");

// ScriptStruct Game.P2SplineTravelDirectionConfig
// 0x000C (0x000C - 0x0000)
struct FP2SplineTravelDirectionConfig final
{
public:
	float                                         DefaultSpeed;                                      // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         InputForwardSpeed;                                 // 0x0004(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         InputBackSpeed;                                    // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FP2SplineTravelDirectionConfig) == 0x000004, "Wrong alignment on FP2SplineTravelDirectionConfig");
static_assert(sizeof(FP2SplineTravelDirectionConfig) == 0x00000C, "Wrong size on FP2SplineTravelDirectionConfig");
static_assert(offsetof(FP2SplineTravelDirectionConfig, DefaultSpeed) == 0x000000, "Member 'FP2SplineTravelDirectionConfig::DefaultSpeed' has a wrong offset!");
static_assert(offsetof(FP2SplineTravelDirectionConfig, InputForwardSpeed) == 0x000004, "Member 'FP2SplineTravelDirectionConfig::InputForwardSpeed' has a wrong offset!");
static_assert(offsetof(FP2SplineTravelDirectionConfig, InputBackSpeed) == 0x000008, "Member 'FP2SplineTravelDirectionConfig::InputBackSpeed' has a wrong offset!");

// ScriptStruct Game.P2SplineMoveMobilityConfig
// 0x0108 (0x0108 - 0x0000)
struct FP2SplineMoveMobilityConfig final
{
public:
	bool                                          bSupportsTwoDirections;                            // 0x0000(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FP2SplineTravelDirectionConfig         DefaultTravelDirectionConfig;                      // 0x0004(0x000C)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	TMap<EP2SplineTravelDirection, struct FP2SplineTravelDirectionConfig> DirectionMap;              // 0x0010(0x0050)(Edit, NativeAccessSpecifierPublic)
	float                                         AccelerationForward;                               // 0x0060(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AccelerationBack;                                  // 0x0064(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Deceleration;                                      // 0x0068(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SlowForwardInputScale;                             // 0x006C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SlowBackInputScale;                                // 0x0070(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_74[0x4];                                       // 0x0074(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<EMovementMode, float>                    InheritVelocityScaleMap;                           // 0x0078(0x0050)(Edit, NativeAccessSpecifierPublic)
	float                                         VelocityInheritLimit;                              // 0x00C8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bApplyVelocityDuringMount;                         // 0x00CC(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_CD[0x3];                                       // 0x00CD(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MountDuration;                                     // 0x00D0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CorrectionInterpSpeed;                             // 0x00D4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUseLateralOffset;                                 // 0x00D8(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D9[0x3];                                       // 0x00D9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MaxLateralOffset;                                  // 0x00DC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bApplyStopModTarget;                               // 0x00E0(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_E1[0x3];                                       // 0x00E1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         StopModMinSpeed;                                   // 0x00E4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              StopModTarget;                                     // 0x00E8(0x0010)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         StopModInterpSpeed;                                // 0x00F8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         StopModDeltaScale;                                 // 0x00FC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         StepDistance;                                      // 0x0100(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_104[0x4];                                      // 0x0104(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FP2SplineMoveMobilityConfig) == 0x000008, "Wrong alignment on FP2SplineMoveMobilityConfig");
static_assert(sizeof(FP2SplineMoveMobilityConfig) == 0x000108, "Wrong size on FP2SplineMoveMobilityConfig");
static_assert(offsetof(FP2SplineMoveMobilityConfig, bSupportsTwoDirections) == 0x000000, "Member 'FP2SplineMoveMobilityConfig::bSupportsTwoDirections' has a wrong offset!");
static_assert(offsetof(FP2SplineMoveMobilityConfig, DefaultTravelDirectionConfig) == 0x000004, "Member 'FP2SplineMoveMobilityConfig::DefaultTravelDirectionConfig' has a wrong offset!");
static_assert(offsetof(FP2SplineMoveMobilityConfig, DirectionMap) == 0x000010, "Member 'FP2SplineMoveMobilityConfig::DirectionMap' has a wrong offset!");
static_assert(offsetof(FP2SplineMoveMobilityConfig, AccelerationForward) == 0x000060, "Member 'FP2SplineMoveMobilityConfig::AccelerationForward' has a wrong offset!");
static_assert(offsetof(FP2SplineMoveMobilityConfig, AccelerationBack) == 0x000064, "Member 'FP2SplineMoveMobilityConfig::AccelerationBack' has a wrong offset!");
static_assert(offsetof(FP2SplineMoveMobilityConfig, Deceleration) == 0x000068, "Member 'FP2SplineMoveMobilityConfig::Deceleration' has a wrong offset!");
static_assert(offsetof(FP2SplineMoveMobilityConfig, SlowForwardInputScale) == 0x00006C, "Member 'FP2SplineMoveMobilityConfig::SlowForwardInputScale' has a wrong offset!");
static_assert(offsetof(FP2SplineMoveMobilityConfig, SlowBackInputScale) == 0x000070, "Member 'FP2SplineMoveMobilityConfig::SlowBackInputScale' has a wrong offset!");
static_assert(offsetof(FP2SplineMoveMobilityConfig, InheritVelocityScaleMap) == 0x000078, "Member 'FP2SplineMoveMobilityConfig::InheritVelocityScaleMap' has a wrong offset!");
static_assert(offsetof(FP2SplineMoveMobilityConfig, VelocityInheritLimit) == 0x0000C8, "Member 'FP2SplineMoveMobilityConfig::VelocityInheritLimit' has a wrong offset!");
static_assert(offsetof(FP2SplineMoveMobilityConfig, bApplyVelocityDuringMount) == 0x0000CC, "Member 'FP2SplineMoveMobilityConfig::bApplyVelocityDuringMount' has a wrong offset!");
static_assert(offsetof(FP2SplineMoveMobilityConfig, MountDuration) == 0x0000D0, "Member 'FP2SplineMoveMobilityConfig::MountDuration' has a wrong offset!");
static_assert(offsetof(FP2SplineMoveMobilityConfig, CorrectionInterpSpeed) == 0x0000D4, "Member 'FP2SplineMoveMobilityConfig::CorrectionInterpSpeed' has a wrong offset!");
static_assert(offsetof(FP2SplineMoveMobilityConfig, bUseLateralOffset) == 0x0000D8, "Member 'FP2SplineMoveMobilityConfig::bUseLateralOffset' has a wrong offset!");
static_assert(offsetof(FP2SplineMoveMobilityConfig, MaxLateralOffset) == 0x0000DC, "Member 'FP2SplineMoveMobilityConfig::MaxLateralOffset' has a wrong offset!");
static_assert(offsetof(FP2SplineMoveMobilityConfig, bApplyStopModTarget) == 0x0000E0, "Member 'FP2SplineMoveMobilityConfig::bApplyStopModTarget' has a wrong offset!");
static_assert(offsetof(FP2SplineMoveMobilityConfig, StopModMinSpeed) == 0x0000E4, "Member 'FP2SplineMoveMobilityConfig::StopModMinSpeed' has a wrong offset!");
static_assert(offsetof(FP2SplineMoveMobilityConfig, StopModTarget) == 0x0000E8, "Member 'FP2SplineMoveMobilityConfig::StopModTarget' has a wrong offset!");
static_assert(offsetof(FP2SplineMoveMobilityConfig, StopModInterpSpeed) == 0x0000F8, "Member 'FP2SplineMoveMobilityConfig::StopModInterpSpeed' has a wrong offset!");
static_assert(offsetof(FP2SplineMoveMobilityConfig, StopModDeltaScale) == 0x0000FC, "Member 'FP2SplineMoveMobilityConfig::StopModDeltaScale' has a wrong offset!");
static_assert(offsetof(FP2SplineMoveMobilityConfig, StepDistance) == 0x000100, "Member 'FP2SplineMoveMobilityConfig::StepDistance' has a wrong offset!");

// ScriptStruct Game.P2SplineMoveConfig
// 0x0178 (0x0178 - 0x0000)
struct FP2SplineMoveConfig final
{
public:
	float                                         MountDistance;                                     // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxMountVerticalVelocity;                          // 0x0004(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bReverseDistanceCheck;                             // 0x0008(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUseAutoMount;                                     // 0x0009(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bNotifyInteract;                                   // 0x000A(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_B[0x1];                                        // 0x000B(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         EndCapDistance;                                    // 0x000C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bOverrideMobilityConfig;                           // 0x0010(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x7];                                       // 0x0011(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FP2SplineMoveMobilityConfig            MobilityConfigOverride;                            // 0x0018(0x0108)(Edit, NativeAccessSpecifierPublic)
	bool                                          bOverrideActivationMap;                            // 0x0120(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_121[0x7];                                      // 0x0121(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<struct FGameplayTag, class UP2SplineMoveActivationInfo_Base*> ActivationMap;                // 0x0128(0x0050)(Edit, NativeAccessSpecifierPublic)
};
static_assert(alignof(FP2SplineMoveConfig) == 0x000008, "Wrong alignment on FP2SplineMoveConfig");
static_assert(sizeof(FP2SplineMoveConfig) == 0x000178, "Wrong size on FP2SplineMoveConfig");
static_assert(offsetof(FP2SplineMoveConfig, MountDistance) == 0x000000, "Member 'FP2SplineMoveConfig::MountDistance' has a wrong offset!");
static_assert(offsetof(FP2SplineMoveConfig, MaxMountVerticalVelocity) == 0x000004, "Member 'FP2SplineMoveConfig::MaxMountVerticalVelocity' has a wrong offset!");
static_assert(offsetof(FP2SplineMoveConfig, bReverseDistanceCheck) == 0x000008, "Member 'FP2SplineMoveConfig::bReverseDistanceCheck' has a wrong offset!");
static_assert(offsetof(FP2SplineMoveConfig, bUseAutoMount) == 0x000009, "Member 'FP2SplineMoveConfig::bUseAutoMount' has a wrong offset!");
static_assert(offsetof(FP2SplineMoveConfig, bNotifyInteract) == 0x00000A, "Member 'FP2SplineMoveConfig::bNotifyInteract' has a wrong offset!");
static_assert(offsetof(FP2SplineMoveConfig, EndCapDistance) == 0x00000C, "Member 'FP2SplineMoveConfig::EndCapDistance' has a wrong offset!");
static_assert(offsetof(FP2SplineMoveConfig, bOverrideMobilityConfig) == 0x000010, "Member 'FP2SplineMoveConfig::bOverrideMobilityConfig' has a wrong offset!");
static_assert(offsetof(FP2SplineMoveConfig, MobilityConfigOverride) == 0x000018, "Member 'FP2SplineMoveConfig::MobilityConfigOverride' has a wrong offset!");
static_assert(offsetof(FP2SplineMoveConfig, bOverrideActivationMap) == 0x000120, "Member 'FP2SplineMoveConfig::bOverrideActivationMap' has a wrong offset!");
static_assert(offsetof(FP2SplineMoveConfig, ActivationMap) == 0x000128, "Member 'FP2SplineMoveConfig::ActivationMap' has a wrong offset!");

// ScriptStruct Game.P2GameplayCue_NiagaraHitFx
// 0x0010 (0x0010 - 0x0000)
struct FP2GameplayCue_NiagaraHitFx final
{
public:
	class UNiagaraSystem*                         Particle;                                          // 0x0000(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bApplyDistanceScale;                               // 0x0008(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FP2GameplayCue_NiagaraHitFx) == 0x000008, "Wrong alignment on FP2GameplayCue_NiagaraHitFx");
static_assert(sizeof(FP2GameplayCue_NiagaraHitFx) == 0x000010, "Wrong size on FP2GameplayCue_NiagaraHitFx");
static_assert(offsetof(FP2GameplayCue_NiagaraHitFx, Particle) == 0x000000, "Member 'FP2GameplayCue_NiagaraHitFx::Particle' has a wrong offset!");
static_assert(offsetof(FP2GameplayCue_NiagaraHitFx, bApplyDistanceScale) == 0x000008, "Member 'FP2GameplayCue_NiagaraHitFx::bApplyDistanceScale' has a wrong offset!");

// ScriptStruct Game.P2DeferredCurveCache
// 0x0050 (0x0050 - 0x0000)
struct alignas(0x08) FP2DeferredCurveCache final
{
public:
	uint8                                         Pad_0[0x50];                                       // 0x0000(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FP2DeferredCurveCache) == 0x000008, "Wrong alignment on FP2DeferredCurveCache");
static_assert(sizeof(FP2DeferredCurveCache) == 0x000050, "Wrong size on FP2DeferredCurveCache");

// ScriptStruct Game.P2AnimCurveCache
// 0x00A0 (0x00A0 - 0x0000)
struct FP2AnimCurveCache final
{
public:
	TMap<struct FGameplayTag, class FName>        TagToNameMap;                                      // 0x0000(0x0050)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TMap<struct FGameplayTag, float>              CachedCurveMap;                                    // 0x0050(0x0050)(Transient, NativeAccessSpecifierPrivate)
};
static_assert(alignof(FP2AnimCurveCache) == 0x000008, "Wrong alignment on FP2AnimCurveCache");
static_assert(sizeof(FP2AnimCurveCache) == 0x0000A0, "Wrong size on FP2AnimCurveCache");
static_assert(offsetof(FP2AnimCurveCache, TagToNameMap) == 0x000000, "Member 'FP2AnimCurveCache::TagToNameMap' has a wrong offset!");
static_assert(offsetof(FP2AnimCurveCache, CachedCurveMap) == 0x000050, "Member 'FP2AnimCurveCache::CachedCurveMap' has a wrong offset!");

// ScriptStruct Game.P2FacilityModuleConfig
// 0x0038 (0x0038 - 0x0000)
struct FP2FacilityModuleConfig final
{
public:
	struct FGameplayTag                           FacilityTag;                                       // 0x0000(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         InstallCost;                                       // 0x0008(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         InstallWaitSec;                                    // 0x000C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         AdditionalQueueingLimit;                           // 0x0010(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BonusMultiplier;                                   // 0x0014(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RandomAmountMultiplier;                            // 0x0018(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TimeReduceMultiplier;                              // 0x001C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         UninstallCost;                                     // 0x0020(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         UninstallWaitSec;                                  // 0x0024(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class UP2FacilityFunction*>            Functions;                                         // 0x0028(0x0010)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, ContainsInstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(FP2FacilityModuleConfig) == 0x000008, "Wrong alignment on FP2FacilityModuleConfig");
static_assert(sizeof(FP2FacilityModuleConfig) == 0x000038, "Wrong size on FP2FacilityModuleConfig");
static_assert(offsetof(FP2FacilityModuleConfig, FacilityTag) == 0x000000, "Member 'FP2FacilityModuleConfig::FacilityTag' has a wrong offset!");
static_assert(offsetof(FP2FacilityModuleConfig, InstallCost) == 0x000008, "Member 'FP2FacilityModuleConfig::InstallCost' has a wrong offset!");
static_assert(offsetof(FP2FacilityModuleConfig, InstallWaitSec) == 0x00000C, "Member 'FP2FacilityModuleConfig::InstallWaitSec' has a wrong offset!");
static_assert(offsetof(FP2FacilityModuleConfig, AdditionalQueueingLimit) == 0x000010, "Member 'FP2FacilityModuleConfig::AdditionalQueueingLimit' has a wrong offset!");
static_assert(offsetof(FP2FacilityModuleConfig, BonusMultiplier) == 0x000014, "Member 'FP2FacilityModuleConfig::BonusMultiplier' has a wrong offset!");
static_assert(offsetof(FP2FacilityModuleConfig, RandomAmountMultiplier) == 0x000018, "Member 'FP2FacilityModuleConfig::RandomAmountMultiplier' has a wrong offset!");
static_assert(offsetof(FP2FacilityModuleConfig, TimeReduceMultiplier) == 0x00001C, "Member 'FP2FacilityModuleConfig::TimeReduceMultiplier' has a wrong offset!");
static_assert(offsetof(FP2FacilityModuleConfig, UninstallCost) == 0x000020, "Member 'FP2FacilityModuleConfig::UninstallCost' has a wrong offset!");
static_assert(offsetof(FP2FacilityModuleConfig, UninstallWaitSec) == 0x000024, "Member 'FP2FacilityModuleConfig::UninstallWaitSec' has a wrong offset!");
static_assert(offsetof(FP2FacilityModuleConfig, Functions) == 0x000028, "Member 'FP2FacilityModuleConfig::Functions' has a wrong offset!");

// ScriptStruct Game.P2AttachOffsetAnimContext
// 0x0020 (0x0020 - 0x0000)
struct FP2AttachOffsetAnimContext final
{
public:
	TArray<class FName>                           BoneArray;                                         // 0x0000(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FTransform>                     TransformArray;                                    // 0x0010(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FP2AttachOffsetAnimContext) == 0x000008, "Wrong alignment on FP2AttachOffsetAnimContext");
static_assert(sizeof(FP2AttachOffsetAnimContext) == 0x000020, "Wrong size on FP2AttachOffsetAnimContext");
static_assert(offsetof(FP2AttachOffsetAnimContext, BoneArray) == 0x000000, "Member 'FP2AttachOffsetAnimContext::BoneArray' has a wrong offset!");
static_assert(offsetof(FP2AttachOffsetAnimContext, TransformArray) == 0x000010, "Member 'FP2AttachOffsetAnimContext::TransformArray' has a wrong offset!");

// ScriptStruct Game.P2GripTransitionData
// 0x0010 (0x0010 - 0x0000)
struct FP2GripTransitionData final
{
public:
	struct FGameplayTag                           GripTag;                                           // 0x0000(0x0008)(Edit, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequenceBase*                      TransitionSequence;                                // 0x0008(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FP2GripTransitionData) == 0x000008, "Wrong alignment on FP2GripTransitionData");
static_assert(sizeof(FP2GripTransitionData) == 0x000010, "Wrong size on FP2GripTransitionData");
static_assert(offsetof(FP2GripTransitionData, GripTag) == 0x000000, "Member 'FP2GripTransitionData::GripTag' has a wrong offset!");
static_assert(offsetof(FP2GripTransitionData, TransitionSequence) == 0x000008, "Member 'FP2GripTransitionData::TransitionSequence' has a wrong offset!");

// ScriptStruct Game.KeyBindingContext
// 0x00A8 (0x00A8 - 0x0000)
struct FKeyBindingContext final
{
public:
	struct FEnhancedActionKeyMapping              Mapping;                                           // 0x0000(0x0098)(ContainsInstancedReference, NativeAccessSpecifierPublic)
	TArray<struct FKey>                           BindKeys;                                          // 0x0098(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FKeyBindingContext) == 0x000008, "Wrong alignment on FKeyBindingContext");
static_assert(sizeof(FKeyBindingContext) == 0x0000A8, "Wrong size on FKeyBindingContext");
static_assert(offsetof(FKeyBindingContext, Mapping) == 0x000000, "Member 'FKeyBindingContext::Mapping' has a wrong offset!");
static_assert(offsetof(FKeyBindingContext, BindKeys) == 0x000098, "Member 'FKeyBindingContext::BindKeys' has a wrong offset!");

// ScriptStruct Game.P2CharacterGroundInfo
// 0x00F8 (0x00F8 - 0x0000)
struct FP2CharacterGroundInfo final
{
public:
	uint8                                         Pad_0[0x8];                                        // 0x0000(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FHitResult                             GroundHitResult;                                   // 0x0008(0x00E8)(BlueprintVisible, BlueprintReadOnly, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	float                                         GroundDistance;                                    // 0x00F0(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_F4[0x4];                                       // 0x00F4(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FP2CharacterGroundInfo) == 0x000008, "Wrong alignment on FP2CharacterGroundInfo");
static_assert(sizeof(FP2CharacterGroundInfo) == 0x0000F8, "Wrong size on FP2CharacterGroundInfo");
static_assert(offsetof(FP2CharacterGroundInfo, GroundHitResult) == 0x000008, "Member 'FP2CharacterGroundInfo::GroundHitResult' has a wrong offset!");
static_assert(offsetof(FP2CharacterGroundInfo, GroundDistance) == 0x0000F0, "Member 'FP2CharacterGroundInfo::GroundDistance' has a wrong offset!");

// ScriptStruct Game.CharacterStanceProcessorConfig
// 0x0038 (0x0038 - 0x0000)
struct FCharacterStanceProcessorConfig final
{
public:
	float                                         StanceAlphaTargetInterpSpeed;                      // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FP2Remap                               CrouchTargetSpeedRemap;                            // 0x0008(0x0028)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	float                                         StanceSpringStrength;                              // 0x0030(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         StanceSpringDamping;                               // 0x0034(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCharacterStanceProcessorConfig) == 0x000008, "Wrong alignment on FCharacterStanceProcessorConfig");
static_assert(sizeof(FCharacterStanceProcessorConfig) == 0x000038, "Wrong size on FCharacterStanceProcessorConfig");
static_assert(offsetof(FCharacterStanceProcessorConfig, StanceAlphaTargetInterpSpeed) == 0x000000, "Member 'FCharacterStanceProcessorConfig::StanceAlphaTargetInterpSpeed' has a wrong offset!");
static_assert(offsetof(FCharacterStanceProcessorConfig, CrouchTargetSpeedRemap) == 0x000008, "Member 'FCharacterStanceProcessorConfig::CrouchTargetSpeedRemap' has a wrong offset!");
static_assert(offsetof(FCharacterStanceProcessorConfig, StanceSpringStrength) == 0x000030, "Member 'FCharacterStanceProcessorConfig::StanceSpringStrength' has a wrong offset!");
static_assert(offsetof(FCharacterStanceProcessorConfig, StanceSpringDamping) == 0x000034, "Member 'FCharacterStanceProcessorConfig::StanceSpringDamping' has a wrong offset!");

// ScriptStruct Game.P2ContractRecipe
// 0x0018 (0x0018 - 0x0000)
struct FP2ContractRecipe final
{
public:
	struct FDataRegistryType                      DataRegistryType;                                  // 0x0000(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FP2CraftingDataRow>             Recipes;                                           // 0x0008(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FP2ContractRecipe) == 0x000008, "Wrong alignment on FP2ContractRecipe");
static_assert(sizeof(FP2ContractRecipe) == 0x000018, "Wrong size on FP2ContractRecipe");
static_assert(offsetof(FP2ContractRecipe, DataRegistryType) == 0x000000, "Member 'FP2ContractRecipe::DataRegistryType' has a wrong offset!");
static_assert(offsetof(FP2ContractRecipe, Recipes) == 0x000008, "Member 'FP2ContractRecipe::Recipes' has a wrong offset!");

// ScriptStruct Game.CharacterStanceProcessor
// 0x0060 (0x0060 - 0x0000)
struct alignas(0x08) FCharacterStanceProcessor final
{
public:
	uint8                                         Pad_0[0x60];                                       // 0x0000(0x0060)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FCharacterStanceProcessor) == 0x000008, "Wrong alignment on FCharacterStanceProcessor");
static_assert(sizeof(FCharacterStanceProcessor) == 0x000060, "Wrong size on FCharacterStanceProcessor");

// ScriptStruct Game.CharacterSlideMovementConfig
// 0x0070 (0x0070 - 0x0000)
struct FCharacterSlideMovementConfig final
{
public:
	float                                         GravityScale;                                      // 0x0000(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MinSpeedForWalking;                                // 0x0004(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Deceleration;                                      // 0x0008(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxLateralAcceleration;                            // 0x000C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FP2Remap                               LateralAccelScaleBySlopeRemap;                     // 0x0010(0x0028)(Edit, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
	struct FP2Remap                               SlopeDecelerationScaleRemap;                       // 0x0038(0x0028)(Edit, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
	float                                         MaxSlopeAngle;                                     // 0x0060(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MinImpactZ;                                        // 0x0064(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCurveFloat*                            VelocityDampingCurve;                              // 0x0068(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCharacterSlideMovementConfig) == 0x000008, "Wrong alignment on FCharacterSlideMovementConfig");
static_assert(sizeof(FCharacterSlideMovementConfig) == 0x000070, "Wrong size on FCharacterSlideMovementConfig");
static_assert(offsetof(FCharacterSlideMovementConfig, GravityScale) == 0x000000, "Member 'FCharacterSlideMovementConfig::GravityScale' has a wrong offset!");
static_assert(offsetof(FCharacterSlideMovementConfig, MinSpeedForWalking) == 0x000004, "Member 'FCharacterSlideMovementConfig::MinSpeedForWalking' has a wrong offset!");
static_assert(offsetof(FCharacterSlideMovementConfig, Deceleration) == 0x000008, "Member 'FCharacterSlideMovementConfig::Deceleration' has a wrong offset!");
static_assert(offsetof(FCharacterSlideMovementConfig, MaxLateralAcceleration) == 0x00000C, "Member 'FCharacterSlideMovementConfig::MaxLateralAcceleration' has a wrong offset!");
static_assert(offsetof(FCharacterSlideMovementConfig, LateralAccelScaleBySlopeRemap) == 0x000010, "Member 'FCharacterSlideMovementConfig::LateralAccelScaleBySlopeRemap' has a wrong offset!");
static_assert(offsetof(FCharacterSlideMovementConfig, SlopeDecelerationScaleRemap) == 0x000038, "Member 'FCharacterSlideMovementConfig::SlopeDecelerationScaleRemap' has a wrong offset!");
static_assert(offsetof(FCharacterSlideMovementConfig, MaxSlopeAngle) == 0x000060, "Member 'FCharacterSlideMovementConfig::MaxSlopeAngle' has a wrong offset!");
static_assert(offsetof(FCharacterSlideMovementConfig, MinImpactZ) == 0x000064, "Member 'FCharacterSlideMovementConfig::MinImpactZ' has a wrong offset!");
static_assert(offsetof(FCharacterSlideMovementConfig, VelocityDampingCurve) == 0x000068, "Member 'FCharacterSlideMovementConfig::VelocityDampingCurve' has a wrong offset!");

// ScriptStruct Game.P2TimeRange
// 0x0008 (0x0008 - 0x0000)
struct FP2TimeRange final
{
public:
	float                                         Min;                                               // 0x0000(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Max;                                               // 0x0004(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FP2TimeRange) == 0x000004, "Wrong alignment on FP2TimeRange");
static_assert(sizeof(FP2TimeRange) == 0x000008, "Wrong size on FP2TimeRange");
static_assert(offsetof(FP2TimeRange, Min) == 0x000000, "Member 'FP2TimeRange::Min' has a wrong offset!");
static_assert(offsetof(FP2TimeRange, Max) == 0x000004, "Member 'FP2TimeRange::Max' has a wrong offset!");

// ScriptStruct Game.StanceMovementSpeedConfig
// 0x0010 (0x0010 - 0x0000)
struct FStanceMovementSpeedConfig final
{
public:
	class UCurveFloat*                            RunDirectionalSpeedCurve;                          // 0x0000(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCurveFloat*                            SprintDirectionalSpeedCurve;                       // 0x0008(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FStanceMovementSpeedConfig) == 0x000008, "Wrong alignment on FStanceMovementSpeedConfig");
static_assert(sizeof(FStanceMovementSpeedConfig) == 0x000010, "Wrong size on FStanceMovementSpeedConfig");
static_assert(offsetof(FStanceMovementSpeedConfig, RunDirectionalSpeedCurve) == 0x000000, "Member 'FStanceMovementSpeedConfig::RunDirectionalSpeedCurve' has a wrong offset!");
static_assert(offsetof(FStanceMovementSpeedConfig, SprintDirectionalSpeedCurve) == 0x000008, "Member 'FStanceMovementSpeedConfig::SprintDirectionalSpeedCurve' has a wrong offset!");

// ScriptStruct Game.AccelerationConfig
// 0x0008 (0x0008 - 0x0000)
struct FAccelerationConfig final
{
public:
	class UCurveFloat*                            AccelerationBySpeedCurve;                          // 0x0000(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAccelerationConfig) == 0x000008, "Wrong alignment on FAccelerationConfig");
static_assert(sizeof(FAccelerationConfig) == 0x000008, "Wrong size on FAccelerationConfig");
static_assert(offsetof(FAccelerationConfig, AccelerationBySpeedCurve) == 0x000000, "Member 'FAccelerationConfig::AccelerationBySpeedCurve' has a wrong offset!");

// ScriptStruct Game.P2EffectStackData
// 0x0010 (0x0010 - 0x0000)
struct FP2EffectStackData final
{
public:
	TSubclassOf<class UGameplayEffect>            Effect;                                            // 0x0000(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         NumberOfStacks;                                    // 0x0008(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FP2EffectStackData) == 0x000008, "Wrong alignment on FP2EffectStackData");
static_assert(sizeof(FP2EffectStackData) == 0x000010, "Wrong size on FP2EffectStackData");
static_assert(offsetof(FP2EffectStackData, Effect) == 0x000000, "Member 'FP2EffectStackData::Effect' has a wrong offset!");
static_assert(offsetof(FP2EffectStackData, NumberOfStacks) == 0x000008, "Member 'FP2EffectStackData::NumberOfStacks' has a wrong offset!");

// ScriptStruct Game.P2InteriorWeaponTailData
// 0x0038 (0x0038 - 0x0000)
struct alignas(0x08) FP2InteriorWeaponTailData final
{
public:
	uint8                                         Pad_0[0x38];                                       // 0x0000(0x0038)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FP2InteriorWeaponTailData) == 0x000008, "Wrong alignment on FP2InteriorWeaponTailData");
static_assert(sizeof(FP2InteriorWeaponTailData) == 0x000038, "Wrong size on FP2InteriorWeaponTailData");

// ScriptStruct Game.P2ConsumptionModeInfo
// 0x0030 (0x0030 - 0x0000)
struct FP2ConsumptionModeInfo final
{
public:
	TArray<struct FP2EffectStackData>             RemovedEffects;                                    // 0x0000(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, NativeAccessSpecifierPublic)
	TArray<struct FP2EffectStackData>             AddedEffects;                                      // 0x0010(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, NativeAccessSpecifierPublic)
	float                                         AmountHealed;                                      // 0x0020(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_24[0xC];                                       // 0x0024(0x000C)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FP2ConsumptionModeInfo) == 0x000008, "Wrong alignment on FP2ConsumptionModeInfo");
static_assert(sizeof(FP2ConsumptionModeInfo) == 0x000030, "Wrong size on FP2ConsumptionModeInfo");
static_assert(offsetof(FP2ConsumptionModeInfo, RemovedEffects) == 0x000000, "Member 'FP2ConsumptionModeInfo::RemovedEffects' has a wrong offset!");
static_assert(offsetof(FP2ConsumptionModeInfo, AddedEffects) == 0x000010, "Member 'FP2ConsumptionModeInfo::AddedEffects' has a wrong offset!");
static_assert(offsetof(FP2ConsumptionModeInfo, AmountHealed) == 0x000020, "Member 'FP2ConsumptionModeInfo::AmountHealed' has a wrong offset!");

// ScriptStruct Game.P2ConsumptionModeConfig
// 0x0028 (0x0028 - 0x0000)
struct FP2ConsumptionModeConfig final
{
public:
	TSubclassOf<class UGameplayEffect>            ConsumeEffect;                                     // 0x0000(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FDataRegistryId                        ConsumptionType;                                   // 0x0008(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ConsumeDuration;                                   // 0x0018(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUseContinuously;                                  // 0x001C(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1D[0x3];                                       // 0x001D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         ChargesToConsume;                                  // 0x0020(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         StacksToConsume;                                   // 0x0024(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FP2ConsumptionModeConfig) == 0x000008, "Wrong alignment on FP2ConsumptionModeConfig");
static_assert(sizeof(FP2ConsumptionModeConfig) == 0x000028, "Wrong size on FP2ConsumptionModeConfig");
static_assert(offsetof(FP2ConsumptionModeConfig, ConsumeEffect) == 0x000000, "Member 'FP2ConsumptionModeConfig::ConsumeEffect' has a wrong offset!");
static_assert(offsetof(FP2ConsumptionModeConfig, ConsumptionType) == 0x000008, "Member 'FP2ConsumptionModeConfig::ConsumptionType' has a wrong offset!");
static_assert(offsetof(FP2ConsumptionModeConfig, ConsumeDuration) == 0x000018, "Member 'FP2ConsumptionModeConfig::ConsumeDuration' has a wrong offset!");
static_assert(offsetof(FP2ConsumptionModeConfig, bUseContinuously) == 0x00001C, "Member 'FP2ConsumptionModeConfig::bUseContinuously' has a wrong offset!");
static_assert(offsetof(FP2ConsumptionModeConfig, ChargesToConsume) == 0x000020, "Member 'FP2ConsumptionModeConfig::ChargesToConsume' has a wrong offset!");
static_assert(offsetof(FP2ConsumptionModeConfig, StacksToConsume) == 0x000024, "Member 'FP2ConsumptionModeConfig::StacksToConsume' has a wrong offset!");

// ScriptStruct Game.P2HUDGameplayMessage
// 0x0018 (0x0018 - 0x0000)
struct FP2HUDGameplayMessage final
{
public:
	class UWidget*                                Widget;                                            // 0x0000(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           MessageTag;                                        // 0x0008(0x0008)(BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   WidgetName;                                        // 0x0010(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FP2HUDGameplayMessage) == 0x000008, "Wrong alignment on FP2HUDGameplayMessage");
static_assert(sizeof(FP2HUDGameplayMessage) == 0x000018, "Wrong size on FP2HUDGameplayMessage");
static_assert(offsetof(FP2HUDGameplayMessage, Widget) == 0x000000, "Member 'FP2HUDGameplayMessage::Widget' has a wrong offset!");
static_assert(offsetof(FP2HUDGameplayMessage, MessageTag) == 0x000008, "Member 'FP2HUDGameplayMessage::MessageTag' has a wrong offset!");
static_assert(offsetof(FP2HUDGameplayMessage, WidgetName) == 0x000010, "Member 'FP2HUDGameplayMessage::WidgetName' has a wrong offset!");

// ScriptStruct Game.P2ConsumptionMode
// 0x0068 (0x0068 - 0x0000)
struct FP2ConsumptionMode final
{
public:
	TArray<class UP2ConsumeAction*>               Actions;                                           // 0x0000(0x0010)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, ContainsInstancedReference, NativeAccessSpecifierPublic)
	struct FP2ConsumptionModeConfig               Config;                                            // 0x0010(0x0028)(Edit, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
	struct FP2ConsumptionModeInfo                 Info;                                              // 0x0038(0x0030)(Edit, BlueprintVisible, BlueprintReadOnly, EditConst, NativeAccessSpecifierPublic)
};
static_assert(alignof(FP2ConsumptionMode) == 0x000008, "Wrong alignment on FP2ConsumptionMode");
static_assert(sizeof(FP2ConsumptionMode) == 0x000068, "Wrong size on FP2ConsumptionMode");
static_assert(offsetof(FP2ConsumptionMode, Actions) == 0x000000, "Member 'FP2ConsumptionMode::Actions' has a wrong offset!");
static_assert(offsetof(FP2ConsumptionMode, Config) == 0x000010, "Member 'FP2ConsumptionMode::Config' has a wrong offset!");
static_assert(offsetof(FP2ConsumptionMode, Info) == 0x000038, "Member 'FP2ConsumptionMode::Info' has a wrong offset!");

// ScriptStruct Game.P2ConsumableModePair
// 0x0010 (0x0010 - 0x0000)
struct FP2ConsumableModePair final
{
public:
	class UP2Consumable*                          Consumable;                                        // 0x0000(0x0008)(BlueprintVisible, ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ModeIndex;                                         // 0x0008(0x0004)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FP2ConsumableModePair) == 0x000008, "Wrong alignment on FP2ConsumableModePair");
static_assert(sizeof(FP2ConsumableModePair) == 0x000010, "Wrong size on FP2ConsumableModePair");
static_assert(offsetof(FP2ConsumableModePair, Consumable) == 0x000000, "Member 'FP2ConsumableModePair::Consumable' has a wrong offset!");
static_assert(offsetof(FP2ConsumableModePair, ModeIndex) == 0x000008, "Member 'FP2ConsumableModePair::ModeIndex' has a wrong offset!");

// ScriptStruct Game.P2MediaPopupInputIconText
// 0x0020 (0x0020 - 0x0000)
struct FP2MediaPopupInputIconText final
{
public:
	class UInputAction*                           InputAction;                                       // 0x0000(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FText                                   Text;                                              // 0x0008(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
};
static_assert(alignof(FP2MediaPopupInputIconText) == 0x000008, "Wrong alignment on FP2MediaPopupInputIconText");
static_assert(sizeof(FP2MediaPopupInputIconText) == 0x000020, "Wrong size on FP2MediaPopupInputIconText");
static_assert(offsetof(FP2MediaPopupInputIconText, InputAction) == 0x000000, "Member 'FP2MediaPopupInputIconText::InputAction' has a wrong offset!");
static_assert(offsetof(FP2MediaPopupInputIconText, Text) == 0x000008, "Member 'FP2MediaPopupInputIconText::Text' has a wrong offset!");

// ScriptStruct Game.P2AdditionalMeshConfig
// 0x0018 (0x0018 - 0x0000)
struct FP2AdditionalMeshConfig final
{
public:
	struct FGameplayTag                           SocketTag;                                         // 0x0000(0x0008)(Edit, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UMeshComponent>             MeshComponentClass;                                // 0x0008(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAttachToFppSkeleton;                              // 0x0010(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAttachToFakeBody;                                 // 0x0011(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bVisbileOnPickupableMesh;                          // 0x0012(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bSetMasterPose;                                    // 0x0013(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUseParentCollision;                               // 0x0014(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bWeldBodies;                                       // 0x0015(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_16[0x2];                                       // 0x0016(0x0002)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FP2AdditionalMeshConfig) == 0x000008, "Wrong alignment on FP2AdditionalMeshConfig");
static_assert(sizeof(FP2AdditionalMeshConfig) == 0x000018, "Wrong size on FP2AdditionalMeshConfig");
static_assert(offsetof(FP2AdditionalMeshConfig, SocketTag) == 0x000000, "Member 'FP2AdditionalMeshConfig::SocketTag' has a wrong offset!");
static_assert(offsetof(FP2AdditionalMeshConfig, MeshComponentClass) == 0x000008, "Member 'FP2AdditionalMeshConfig::MeshComponentClass' has a wrong offset!");
static_assert(offsetof(FP2AdditionalMeshConfig, bAttachToFppSkeleton) == 0x000010, "Member 'FP2AdditionalMeshConfig::bAttachToFppSkeleton' has a wrong offset!");
static_assert(offsetof(FP2AdditionalMeshConfig, bAttachToFakeBody) == 0x000011, "Member 'FP2AdditionalMeshConfig::bAttachToFakeBody' has a wrong offset!");
static_assert(offsetof(FP2AdditionalMeshConfig, bVisbileOnPickupableMesh) == 0x000012, "Member 'FP2AdditionalMeshConfig::bVisbileOnPickupableMesh' has a wrong offset!");
static_assert(offsetof(FP2AdditionalMeshConfig, bSetMasterPose) == 0x000013, "Member 'FP2AdditionalMeshConfig::bSetMasterPose' has a wrong offset!");
static_assert(offsetof(FP2AdditionalMeshConfig, bUseParentCollision) == 0x000014, "Member 'FP2AdditionalMeshConfig::bUseParentCollision' has a wrong offset!");
static_assert(offsetof(FP2AdditionalMeshConfig, bWeldBodies) == 0x000015, "Member 'FP2AdditionalMeshConfig::bWeldBodies' has a wrong offset!");

// ScriptStruct Game.P2ContextualHelperCheckbox
// 0x0050 (0x0050 - 0x0000)
struct FP2ContextualHelperCheckbox final
{
public:
	uint8                                         Pad_0[0x8];                                        // 0x0000(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	EP2GameplayContextRequirementType             RequirementTypeToTrack;                            // 0x0008(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   Title;                                             // 0x0010(0x0018)(NativeAccessSpecifierPublic)
	EP2ContextualHelperWidgetIconType             IconType;                                          // 0x0028(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_29[0x7];                                       // 0x0029(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   Text;                                              // 0x0030(0x0018)(NativeAccessSpecifierPublic)
	class UP2ItemData*                            IconItemData;                                      // 0x0048(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FP2ContextualHelperCheckbox) == 0x000008, "Wrong alignment on FP2ContextualHelperCheckbox");
static_assert(sizeof(FP2ContextualHelperCheckbox) == 0x000050, "Wrong size on FP2ContextualHelperCheckbox");
static_assert(offsetof(FP2ContextualHelperCheckbox, RequirementTypeToTrack) == 0x000008, "Member 'FP2ContextualHelperCheckbox::RequirementTypeToTrack' has a wrong offset!");
static_assert(offsetof(FP2ContextualHelperCheckbox, Title) == 0x000010, "Member 'FP2ContextualHelperCheckbox::Title' has a wrong offset!");
static_assert(offsetof(FP2ContextualHelperCheckbox, IconType) == 0x000028, "Member 'FP2ContextualHelperCheckbox::IconType' has a wrong offset!");
static_assert(offsetof(FP2ContextualHelperCheckbox, Text) == 0x000030, "Member 'FP2ContextualHelperCheckbox::Text' has a wrong offset!");
static_assert(offsetof(FP2ContextualHelperCheckbox, IconItemData) == 0x000048, "Member 'FP2ContextualHelperCheckbox::IconItemData' has a wrong offset!");

// ScriptStruct Game.PositionInfoSize
// 0x0008 (0x0010 - 0x0008)
struct FPositionInfoSize final : public FPositionInfo
{
public:
	struct FIntPoint                              Size;                                              // 0x0008(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FPositionInfoSize) == 0x000004, "Wrong alignment on FPositionInfoSize");
static_assert(sizeof(FPositionInfoSize) == 0x000010, "Wrong size on FPositionInfoSize");
static_assert(offsetof(FPositionInfoSize, Size) == 0x000008, "Member 'FPositionInfoSize::Size' has a wrong offset!");

// ScriptStruct Game.P2ContextualHelperWidgetMessage
// 0x0008 (0x0008 - 0x0000)
struct FP2ContextualHelperWidgetMessage final
{
public:
	class UP2GameplayContext*                     OwningGameplayContext;                             // 0x0000(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FP2ContextualHelperWidgetMessage) == 0x000008, "Wrong alignment on FP2ContextualHelperWidgetMessage");
static_assert(sizeof(FP2ContextualHelperWidgetMessage) == 0x000008, "Wrong size on FP2ContextualHelperWidgetMessage");
static_assert(offsetof(FP2ContextualHelperWidgetMessage, OwningGameplayContext) == 0x000000, "Member 'FP2ContextualHelperWidgetMessage::OwningGameplayContext' has a wrong offset!");

// ScriptStruct Game.ControlModifierHandle
// 0x0004 (0x0004 - 0x0000)
struct alignas(0x04) FControlModifierHandle final
{
public:
	uint8                                         Pad_0[0x4];                                        // 0x0000(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FControlModifierHandle) == 0x000004, "Wrong alignment on FControlModifierHandle");
static_assert(sizeof(FControlModifierHandle) == 0x000004, "Wrong size on FControlModifierHandle");

// ScriptStruct Game.P2CueTranslator_CharacterOutput
// 0x0038 (0x0038 - 0x0000)
struct alignas(0x08) FP2CueTranslator_CharacterOutput final
{
public:
	uint8                                         Pad_0[0x30];                                       // 0x0000(0x0030)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         Index;                                             // 0x0030(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_34[0x4];                                       // 0x0034(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FP2CueTranslator_CharacterOutput) == 0x000008, "Wrong alignment on FP2CueTranslator_CharacterOutput");
static_assert(sizeof(FP2CueTranslator_CharacterOutput) == 0x000038, "Wrong size on FP2CueTranslator_CharacterOutput");
static_assert(offsetof(FP2CueTranslator_CharacterOutput, Index) == 0x000030, "Member 'FP2CueTranslator_CharacterOutput::Index' has a wrong offset!");

// ScriptStruct Game.P2EquipmentMessage_ItemPlaced
// 0x0018 (0x0018 - 0x0000)
struct FP2EquipmentMessage_ItemPlaced final
{
public:
	class UP2Item*                                OldItem;                                           // 0x0000(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UP2Item*                                NewItem;                                           // 0x0008(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         StackChange;                                       // 0x0010(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FP2EquipmentMessage_ItemPlaced) == 0x000008, "Wrong alignment on FP2EquipmentMessage_ItemPlaced");
static_assert(sizeof(FP2EquipmentMessage_ItemPlaced) == 0x000018, "Wrong size on FP2EquipmentMessage_ItemPlaced");
static_assert(offsetof(FP2EquipmentMessage_ItemPlaced, OldItem) == 0x000000, "Member 'FP2EquipmentMessage_ItemPlaced::OldItem' has a wrong offset!");
static_assert(offsetof(FP2EquipmentMessage_ItemPlaced, NewItem) == 0x000008, "Member 'FP2EquipmentMessage_ItemPlaced::NewItem' has a wrong offset!");
static_assert(offsetof(FP2EquipmentMessage_ItemPlaced, StackChange) == 0x000010, "Member 'FP2EquipmentMessage_ItemPlaced::StackChange' has a wrong offset!");

// ScriptStruct Game.P2CueTranslator_TagReplaceOutput
// 0x0038 (0x0038 - 0x0000)
struct alignas(0x08) FP2CueTranslator_TagReplaceOutput final
{
public:
	uint8                                         Pad_0[0x30];                                       // 0x0000(0x0030)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         Index;                                             // 0x0030(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_34[0x4];                                       // 0x0034(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FP2CueTranslator_TagReplaceOutput) == 0x000008, "Wrong alignment on FP2CueTranslator_TagReplaceOutput");
static_assert(sizeof(FP2CueTranslator_TagReplaceOutput) == 0x000038, "Wrong size on FP2CueTranslator_TagReplaceOutput");
static_assert(offsetof(FP2CueTranslator_TagReplaceOutput, Index) == 0x000030, "Member 'FP2CueTranslator_TagReplaceOutput::Index' has a wrong offset!");

// ScriptStruct Game.P2CustomizationBakeItem
// 0x0044 (0x0050 - 0x000C)
struct FP2CustomizationBakeItem final : public FFastArraySerializerItem
{
public:
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class AActor*                                 Owner;                                             // 0x0010(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USkeletalMesh*                          ReferenceMesh;                                     // 0x0018(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCustomizableSlotTable*                 SlotTable;                                         // 0x0020(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class UCustomizableSkinObject*>        SkinObjects;                                       // 0x0028(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_38[0x18];                                      // 0x0038(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FP2CustomizationBakeItem) == 0x000008, "Wrong alignment on FP2CustomizationBakeItem");
static_assert(sizeof(FP2CustomizationBakeItem) == 0x000050, "Wrong size on FP2CustomizationBakeItem");
static_assert(offsetof(FP2CustomizationBakeItem, Owner) == 0x000010, "Member 'FP2CustomizationBakeItem::Owner' has a wrong offset!");
static_assert(offsetof(FP2CustomizationBakeItem, ReferenceMesh) == 0x000018, "Member 'FP2CustomizationBakeItem::ReferenceMesh' has a wrong offset!");
static_assert(offsetof(FP2CustomizationBakeItem, SlotTable) == 0x000020, "Member 'FP2CustomizationBakeItem::SlotTable' has a wrong offset!");
static_assert(offsetof(FP2CustomizationBakeItem, SkinObjects) == 0x000028, "Member 'FP2CustomizationBakeItem::SkinObjects' has a wrong offset!");

// ScriptStruct Game.P2ItemIconRenderRequest
// 0x0038 (0x0038 - 0x0000)
struct FP2ItemIconRenderRequest final
{
public:
	uint8                                         Pad_0[0x18];                                       // 0x0000(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	class AP2RenderActor_Item*                    RenderActor;                                       // 0x0018(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_20[0x10];                                      // 0x0020(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class UP2Item*                                RenderItem;                                        // 0x0030(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FP2ItemIconRenderRequest) == 0x000008, "Wrong alignment on FP2ItemIconRenderRequest");
static_assert(sizeof(FP2ItemIconRenderRequest) == 0x000038, "Wrong size on FP2ItemIconRenderRequest");
static_assert(offsetof(FP2ItemIconRenderRequest, RenderActor) == 0x000018, "Member 'FP2ItemIconRenderRequest::RenderActor' has a wrong offset!");
static_assert(offsetof(FP2ItemIconRenderRequest, RenderItem) == 0x000030, "Member 'FP2ItemIconRenderRequest::RenderItem' has a wrong offset!");

// ScriptStruct Game.P2CustomizationBakeArray
// 0x0018 (0x0120 - 0x0108)
struct FP2CustomizationBakeArray final : public FFastArraySerializer
{
public:
	uint8                                         Pad_108[0x8];                                      // 0x0108(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FP2CustomizationBakeItem>       Items;                                             // 0x0110(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
};
static_assert(alignof(FP2CustomizationBakeArray) == 0x000008, "Wrong alignment on FP2CustomizationBakeArray");
static_assert(sizeof(FP2CustomizationBakeArray) == 0x000120, "Wrong size on FP2CustomizationBakeArray");
static_assert(offsetof(FP2CustomizationBakeArray, Items) == 0x000110, "Member 'FP2CustomizationBakeArray::Items' has a wrong offset!");

// ScriptStruct Game.P2SkinSlotConfiguration
// 0x0010 (0x0010 - 0x0000)
struct FP2SkinSlotConfiguration final
{
public:
	TArray<class UP2SkinMaterialParameter*>       SlotMaterialParameters;                            // 0x0000(0x0010)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, DisableEditOnInstance, ContainsInstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(FP2SkinSlotConfiguration) == 0x000008, "Wrong alignment on FP2SkinSlotConfiguration");
static_assert(sizeof(FP2SkinSlotConfiguration) == 0x000010, "Wrong size on FP2SkinSlotConfiguration");
static_assert(offsetof(FP2SkinSlotConfiguration, SlotMaterialParameters) == 0x000000, "Member 'FP2SkinSlotConfiguration::SlotMaterialParameters' has a wrong offset!");

// ScriptStruct Game.P2SlotAttachSocketData
// 0x0070 (0x0070 - 0x0000)
struct FP2SlotAttachSocketData final
{
public:
	class FName                                   AttachSocketName;                                  // 0x0000(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_8[0x8];                                        // 0x0008(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             AttachTransform;                                   // 0x0010(0x0060)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FP2SlotAttachSocketData) == 0x000010, "Wrong alignment on FP2SlotAttachSocketData");
static_assert(sizeof(FP2SlotAttachSocketData) == 0x000070, "Wrong size on FP2SlotAttachSocketData");
static_assert(offsetof(FP2SlotAttachSocketData, AttachSocketName) == 0x000000, "Member 'FP2SlotAttachSocketData::AttachSocketName' has a wrong offset!");
static_assert(offsetof(FP2SlotAttachSocketData, AttachTransform) == 0x000010, "Member 'FP2SlotAttachSocketData::AttachTransform' has a wrong offset!");

// ScriptStruct Game.P2ItemSkinPart
// 0x0028 (0x0028 - 0x0000)
struct FP2ItemSkinPart final
{
public:
	struct FGameplayTagContainer                  ItemTags;                                          // 0x0000(0x0020)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	class UP2ItemSkin*                            ItemSkin;                                          // 0x0020(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FP2ItemSkinPart) == 0x000008, "Wrong alignment on FP2ItemSkinPart");
static_assert(sizeof(FP2ItemSkinPart) == 0x000028, "Wrong size on FP2ItemSkinPart");
static_assert(offsetof(FP2ItemSkinPart, ItemTags) == 0x000000, "Member 'FP2ItemSkinPart::ItemTags' has a wrong offset!");
static_assert(offsetof(FP2ItemSkinPart, ItemSkin) == 0x000020, "Member 'FP2ItemSkinPart::ItemSkin' has a wrong offset!");

// ScriptStruct Game.P2SkinCustomizationDataIDs
// 0x0020 (0x0020 - 0x0000)
struct FP2SkinCustomizationDataIDs final
{
public:
	struct FPrimaryAssetId                        ItemSkinContainerID;                               // 0x0000(0x0010)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FPrimaryAssetId>                SkinSlotPresetsIDs;                                // 0x0010(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FP2SkinCustomizationDataIDs) == 0x000008, "Wrong alignment on FP2SkinCustomizationDataIDs");
static_assert(sizeof(FP2SkinCustomizationDataIDs) == 0x000020, "Wrong size on FP2SkinCustomizationDataIDs");
static_assert(offsetof(FP2SkinCustomizationDataIDs, ItemSkinContainerID) == 0x000000, "Member 'FP2SkinCustomizationDataIDs::ItemSkinContainerID' has a wrong offset!");
static_assert(offsetof(FP2SkinCustomizationDataIDs, SkinSlotPresetsIDs) == 0x000010, "Member 'FP2SkinCustomizationDataIDs::SkinSlotPresetsIDs' has a wrong offset!");

// ScriptStruct Game.P2ParticipantStatus
// 0x0018 (0x0018 - 0x0000)
struct FP2ParticipantStatus final
{
public:
	class FString                                 ParticipantId;                                     // 0x0000(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsMuted;                                          // 0x0010(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsSelf;                                           // 0x0011(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsSpeaking;                                       // 0x0012(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_13[0x5];                                       // 0x0013(0x0005)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FP2ParticipantStatus) == 0x000008, "Wrong alignment on FP2ParticipantStatus");
static_assert(sizeof(FP2ParticipantStatus) == 0x000018, "Wrong size on FP2ParticipantStatus");
static_assert(offsetof(FP2ParticipantStatus, ParticipantId) == 0x000000, "Member 'FP2ParticipantStatus::ParticipantId' has a wrong offset!");
static_assert(offsetof(FP2ParticipantStatus, bIsMuted) == 0x000010, "Member 'FP2ParticipantStatus::bIsMuted' has a wrong offset!");
static_assert(offsetof(FP2ParticipantStatus, bIsSelf) == 0x000011, "Member 'FP2ParticipantStatus::bIsSelf' has a wrong offset!");
static_assert(offsetof(FP2ParticipantStatus, bIsSpeaking) == 0x000012, "Member 'FP2ParticipantStatus::bIsSpeaking' has a wrong offset!");

// ScriptStruct Game.P2DamageCalculationResult
// 0x0050 (0x0050 - 0x0000)
struct FP2DamageCalculationResult final
{
public:
	float                                         ModifiedDamage;                                    // 0x0000(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FP2DamageToArmorResult>         DamageToArmor;                                     // 0x0008(0x0010)(BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	float                                         PenetrationMultiplier;                             // 0x0018(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C[0x4];                                       // 0x001C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FP2StatusEffectSpec>            StatusEffects;                                     // 0x0020(0x0010)(BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	struct FGameplayTagContainer                  RelevantVictimTags;                                // 0x0030(0x0020)(BlueprintVisible, NativeAccessSpecifierPublic)
};
static_assert(alignof(FP2DamageCalculationResult) == 0x000008, "Wrong alignment on FP2DamageCalculationResult");
static_assert(sizeof(FP2DamageCalculationResult) == 0x000050, "Wrong size on FP2DamageCalculationResult");
static_assert(offsetof(FP2DamageCalculationResult, ModifiedDamage) == 0x000000, "Member 'FP2DamageCalculationResult::ModifiedDamage' has a wrong offset!");
static_assert(offsetof(FP2DamageCalculationResult, DamageToArmor) == 0x000008, "Member 'FP2DamageCalculationResult::DamageToArmor' has a wrong offset!");
static_assert(offsetof(FP2DamageCalculationResult, PenetrationMultiplier) == 0x000018, "Member 'FP2DamageCalculationResult::PenetrationMultiplier' has a wrong offset!");
static_assert(offsetof(FP2DamageCalculationResult, StatusEffects) == 0x000020, "Member 'FP2DamageCalculationResult::StatusEffects' has a wrong offset!");
static_assert(offsetof(FP2DamageCalculationResult, RelevantVictimTags) == 0x000030, "Member 'FP2DamageCalculationResult::RelevantVictimTags' has a wrong offset!");

// ScriptStruct Game.P2SmokeVolumeHoleInfo
// 0x0020 (0x0020 - 0x0000)
struct alignas(0x08) FP2SmokeVolumeHoleInfo final
{
public:
	uint8                                         Pad_0[0x20];                                       // 0x0000(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FP2SmokeVolumeHoleInfo) == 0x000008, "Wrong alignment on FP2SmokeVolumeHoleInfo");
static_assert(sizeof(FP2SmokeVolumeHoleInfo) == 0x000020, "Wrong size on FP2SmokeVolumeHoleInfo");

// ScriptStruct Game.P2SmokeTraverseInfo
// 0x0068 (0x0068 - 0x0000)
struct FP2SmokeTraverseInfo final
{
public:
	TMap<class AP2SmokeActor*, struct FP2SmokeVolumeHoleInfo> ActorInfoMap;                          // 0x0000(0x0050)(Transient, NativeAccessSpecifierPublic)
	uint8                                         Pad_50[0x18];                                      // 0x0050(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FP2SmokeTraverseInfo) == 0x000008, "Wrong alignment on FP2SmokeTraverseInfo");
static_assert(sizeof(FP2SmokeTraverseInfo) == 0x000068, "Wrong size on FP2SmokeTraverseInfo");
static_assert(offsetof(FP2SmokeTraverseInfo, ActorInfoMap) == 0x000000, "Member 'FP2SmokeTraverseInfo::ActorInfoMap' has a wrong offset!");

// ScriptStruct Game.P2HitInfo
// 0x0108 (0x0108 - 0x0000)
struct FP2HitInfo final
{
public:
	EP2HitType                                    Type;                                              // 0x0000(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FHitResult                             HitResult;                                         // 0x0008(0x00E8)(BlueprintVisible, BlueprintReadOnly, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	class AActor*                                 Instigator;                                        // 0x00F0(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BaseDamage;                                        // 0x00F8(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           DamageType;                                        // 0x00FC(0x0008)(BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_104[0x4];                                      // 0x0104(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FP2HitInfo) == 0x000008, "Wrong alignment on FP2HitInfo");
static_assert(sizeof(FP2HitInfo) == 0x000108, "Wrong size on FP2HitInfo");
static_assert(offsetof(FP2HitInfo, Type) == 0x000000, "Member 'FP2HitInfo::Type' has a wrong offset!");
static_assert(offsetof(FP2HitInfo, HitResult) == 0x000008, "Member 'FP2HitInfo::HitResult' has a wrong offset!");
static_assert(offsetof(FP2HitInfo, Instigator) == 0x0000F0, "Member 'FP2HitInfo::Instigator' has a wrong offset!");
static_assert(offsetof(FP2HitInfo, BaseDamage) == 0x0000F8, "Member 'FP2HitInfo::BaseDamage' has a wrong offset!");
static_assert(offsetof(FP2HitInfo, DamageType) == 0x0000FC, "Member 'FP2HitInfo::DamageType' has a wrong offset!");

// ScriptStruct Game.P2DbnoStateConfig
// 0x0038 (0x0038 - 0x0000)
struct FP2DbnoStateConfig final
{
public:
	float                                         Damage;                                            // 0x0000(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DamageInterval;                                    // 0x0004(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UGameplayEffect>            DamageGameplayEffect;                              // 0x0008(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UGameplayEffect>            ActivationGameplayEffect;                          // 0x0010(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ReviveDuration;                                    // 0x0018(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C[0x4];                                       // 0x001C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class UP2CameraMode>              CameraModeTpp;                                     // 0x0020(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UP2CameraMode>              CameraModeFpp;                                     // 0x0028(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UCameraShakeBase>           CameraShake;                                       // 0x0030(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FP2DbnoStateConfig) == 0x000008, "Wrong alignment on FP2DbnoStateConfig");
static_assert(sizeof(FP2DbnoStateConfig) == 0x000038, "Wrong size on FP2DbnoStateConfig");
static_assert(offsetof(FP2DbnoStateConfig, Damage) == 0x000000, "Member 'FP2DbnoStateConfig::Damage' has a wrong offset!");
static_assert(offsetof(FP2DbnoStateConfig, DamageInterval) == 0x000004, "Member 'FP2DbnoStateConfig::DamageInterval' has a wrong offset!");
static_assert(offsetof(FP2DbnoStateConfig, DamageGameplayEffect) == 0x000008, "Member 'FP2DbnoStateConfig::DamageGameplayEffect' has a wrong offset!");
static_assert(offsetof(FP2DbnoStateConfig, ActivationGameplayEffect) == 0x000010, "Member 'FP2DbnoStateConfig::ActivationGameplayEffect' has a wrong offset!");
static_assert(offsetof(FP2DbnoStateConfig, ReviveDuration) == 0x000018, "Member 'FP2DbnoStateConfig::ReviveDuration' has a wrong offset!");
static_assert(offsetof(FP2DbnoStateConfig, CameraModeTpp) == 0x000020, "Member 'FP2DbnoStateConfig::CameraModeTpp' has a wrong offset!");
static_assert(offsetof(FP2DbnoStateConfig, CameraModeFpp) == 0x000028, "Member 'FP2DbnoStateConfig::CameraModeFpp' has a wrong offset!");
static_assert(offsetof(FP2DbnoStateConfig, CameraShake) == 0x000030, "Member 'FP2DbnoStateConfig::CameraShake' has a wrong offset!");

// ScriptStruct Game.CharacterStateScalars
// 0x000C (0x000C - 0x0000)
struct FCharacterStateScalars final
{
public:
	float                                         ControlRecoil;                                     // 0x0000(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AnimRecoil;                                        // 0x0004(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Inertia;                                           // 0x0008(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCharacterStateScalars) == 0x000004, "Wrong alignment on FCharacterStateScalars");
static_assert(sizeof(FCharacterStateScalars) == 0x00000C, "Wrong size on FCharacterStateScalars");
static_assert(offsetof(FCharacterStateScalars, ControlRecoil) == 0x000000, "Member 'FCharacterStateScalars::ControlRecoil' has a wrong offset!");
static_assert(offsetof(FCharacterStateScalars, AnimRecoil) == 0x000004, "Member 'FCharacterStateScalars::AnimRecoil' has a wrong offset!");
static_assert(offsetof(FCharacterStateScalars, Inertia) == 0x000008, "Member 'FCharacterStateScalars::Inertia' has a wrong offset!");

// ScriptStruct Game.P2DeployZoneInfo
// 0x001C (0x001C - 0x0000)
struct FP2DeployZoneInfo final
{
public:
	struct FGameplayTag                           ZoneTag;                                           // 0x0000(0x0008)(BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         TeamCount;                                         // 0x0008(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, RepSkip, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ActiveLocations;                                   // 0x000C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         DisabledLocations;                                 // 0x0010(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         TotalLocations;                                    // 0x0014(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_18[0x4];                                       // 0x0018(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FP2DeployZoneInfo) == 0x000004, "Wrong alignment on FP2DeployZoneInfo");
static_assert(sizeof(FP2DeployZoneInfo) == 0x00001C, "Wrong size on FP2DeployZoneInfo");
static_assert(offsetof(FP2DeployZoneInfo, ZoneTag) == 0x000000, "Member 'FP2DeployZoneInfo::ZoneTag' has a wrong offset!");
static_assert(offsetof(FP2DeployZoneInfo, TeamCount) == 0x000008, "Member 'FP2DeployZoneInfo::TeamCount' has a wrong offset!");
static_assert(offsetof(FP2DeployZoneInfo, ActiveLocations) == 0x00000C, "Member 'FP2DeployZoneInfo::ActiveLocations' has a wrong offset!");
static_assert(offsetof(FP2DeployZoneInfo, DisabledLocations) == 0x000010, "Member 'FP2DeployZoneInfo::DisabledLocations' has a wrong offset!");
static_assert(offsetof(FP2DeployZoneInfo, TotalLocations) == 0x000014, "Member 'FP2DeployZoneInfo::TotalLocations' has a wrong offset!");

// ScriptStruct Game.P2DeployZoneSettings
// 0x0030 (0x0030 - 0x0000)
struct FP2DeployZoneSettings final
{
public:
	struct FP2IntPerSessionDifficulty             MaxAvailableLocations;                             // 0x0000(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FP2IntPerSessionDifficulty             MinActiveLocations;                                // 0x0018(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
};
static_assert(alignof(FP2DeployZoneSettings) == 0x000008, "Wrong alignment on FP2DeployZoneSettings");
static_assert(sizeof(FP2DeployZoneSettings) == 0x000030, "Wrong size on FP2DeployZoneSettings");
static_assert(offsetof(FP2DeployZoneSettings, MaxAvailableLocations) == 0x000000, "Member 'FP2DeployZoneSettings::MaxAvailableLocations' has a wrong offset!");
static_assert(offsetof(FP2DeployZoneSettings, MinActiveLocations) == 0x000018, "Member 'FP2DeployZoneSettings::MinActiveLocations' has a wrong offset!");

// ScriptStruct Game.P2DialogueTableRow
// 0x0028 (0x0030 - 0x0008)
struct FP2DialogueTableRow final : public FTableRowBase
{
public:
	class FString                                 Trigger;                                           // 0x0008(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bPlayRemotePerspective;                            // 0x0018(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bPlayOnComms;                                      // 0x0019(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bPlayOnEnemies;                                    // 0x001A(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EP2DialogueQueryPriority                      Priority;                                          // 0x001B(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bOverrideEqualPriority;                            // 0x001C(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1D[0x3];                                       // 0x001D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Cooldown;                                          // 0x0020(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         QueueTime;                                         // 0x0024(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsLooping;                                        // 0x0028(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_29[0x7];                                       // 0x0029(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FP2DialogueTableRow) == 0x000008, "Wrong alignment on FP2DialogueTableRow");
static_assert(sizeof(FP2DialogueTableRow) == 0x000030, "Wrong size on FP2DialogueTableRow");
static_assert(offsetof(FP2DialogueTableRow, Trigger) == 0x000008, "Member 'FP2DialogueTableRow::Trigger' has a wrong offset!");
static_assert(offsetof(FP2DialogueTableRow, bPlayRemotePerspective) == 0x000018, "Member 'FP2DialogueTableRow::bPlayRemotePerspective' has a wrong offset!");
static_assert(offsetof(FP2DialogueTableRow, bPlayOnComms) == 0x000019, "Member 'FP2DialogueTableRow::bPlayOnComms' has a wrong offset!");
static_assert(offsetof(FP2DialogueTableRow, bPlayOnEnemies) == 0x00001A, "Member 'FP2DialogueTableRow::bPlayOnEnemies' has a wrong offset!");
static_assert(offsetof(FP2DialogueTableRow, Priority) == 0x00001B, "Member 'FP2DialogueTableRow::Priority' has a wrong offset!");
static_assert(offsetof(FP2DialogueTableRow, bOverrideEqualPriority) == 0x00001C, "Member 'FP2DialogueTableRow::bOverrideEqualPriority' has a wrong offset!");
static_assert(offsetof(FP2DialogueTableRow, Cooldown) == 0x000020, "Member 'FP2DialogueTableRow::Cooldown' has a wrong offset!");
static_assert(offsetof(FP2DialogueTableRow, QueueTime) == 0x000024, "Member 'FP2DialogueTableRow::QueueTime' has a wrong offset!");
static_assert(offsetof(FP2DialogueTableRow, bIsLooping) == 0x000028, "Member 'FP2DialogueTableRow::bIsLooping' has a wrong offset!");

// ScriptStruct Game.P2RenderActorAnomaly
// 0x0018 (0x0018 - 0x0000)
struct FP2RenderActorAnomaly final
{
public:
	class AP2DynamicAnomaly*                      DynamicAnomaly;                                    // 0x0000(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class USplineMeshComponent*>           SplineMeshs;                                       // 0x0008(0x0010)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(FP2RenderActorAnomaly) == 0x000008, "Wrong alignment on FP2RenderActorAnomaly");
static_assert(sizeof(FP2RenderActorAnomaly) == 0x000018, "Wrong size on FP2RenderActorAnomaly");
static_assert(offsetof(FP2RenderActorAnomaly, DynamicAnomaly) == 0x000000, "Member 'FP2RenderActorAnomaly::DynamicAnomaly' has a wrong offset!");
static_assert(offsetof(FP2RenderActorAnomaly, SplineMeshs) == 0x000008, "Member 'FP2RenderActorAnomaly::SplineMeshs' has a wrong offset!");

// ScriptStruct Game.P2DistanceTrackerHandle
// 0x0004 (0x0004 - 0x0000)
struct alignas(0x04) FP2DistanceTrackerHandle final
{
public:
	uint8                                         Pad_0[0x4];                                        // 0x0000(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FP2DistanceTrackerHandle) == 0x000004, "Wrong alignment on FP2DistanceTrackerHandle");
static_assert(sizeof(FP2DistanceTrackerHandle) == 0x000004, "Wrong size on FP2DistanceTrackerHandle");

// ScriptStruct Game.P2DoorWrapper
// 0x0010 (0x0010 - 0x0000)
struct FP2DoorWrapper final
{
public:
	class UMeshComponent*                         Mesh;                                              // 0x0000(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UP2DoorInfoComponent*                   InfoComponent;                                     // 0x0008(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FP2DoorWrapper) == 0x000008, "Wrong alignment on FP2DoorWrapper");
static_assert(sizeof(FP2DoorWrapper) == 0x000010, "Wrong size on FP2DoorWrapper");
static_assert(offsetof(FP2DoorWrapper, Mesh) == 0x000000, "Member 'FP2DoorWrapper::Mesh' has a wrong offset!");
static_assert(offsetof(FP2DoorWrapper, InfoComponent) == 0x000008, "Member 'FP2DoorWrapper::InfoComponent' has a wrong offset!");

// ScriptStruct Game.P2HealthChangedMessage
// 0x0298 (0x0298 - 0x0000)
struct FP2HealthChangedMessage final
{
public:
	struct FGameplayEffectSpec                    DamageSpec;                                        // 0x0000(0x0298)(BlueprintVisible, BlueprintReadOnly, Transient, NativeAccessSpecifierPublic)
};
static_assert(alignof(FP2HealthChangedMessage) == 0x000008, "Wrong alignment on FP2HealthChangedMessage");
static_assert(sizeof(FP2HealthChangedMessage) == 0x000298, "Wrong size on FP2HealthChangedMessage");
static_assert(offsetof(FP2HealthChangedMessage, DamageSpec) == 0x000000, "Member 'FP2HealthChangedMessage::DamageSpec' has a wrong offset!");

// ScriptStruct Game.P2DPV_VehicleData
// 0x0008 (0x0008 - 0x0000)
struct FP2DPV_VehicleData final
{
public:
	float                                         MaxAccel;                                          // 0x0000(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxSpeed;                                          // 0x0004(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FP2DPV_VehicleData) == 0x000004, "Wrong alignment on FP2DPV_VehicleData");
static_assert(sizeof(FP2DPV_VehicleData) == 0x000008, "Wrong size on FP2DPV_VehicleData");
static_assert(offsetof(FP2DPV_VehicleData, MaxAccel) == 0x000000, "Member 'FP2DPV_VehicleData::MaxAccel' has a wrong offset!");
static_assert(offsetof(FP2DPV_VehicleData, MaxSpeed) == 0x000004, "Member 'FP2DPV_VehicleData::MaxSpeed' has a wrong offset!");

// ScriptStruct Game.P2ExtractionPointTypeSettings
// 0x0038 (0x0038 - 0x0000)
struct FP2ExtractionPointTypeSettings final
{
public:
	struct FCurveTableRowHandle                   ActivationPhases;                                  // 0x0000(0x0010)(Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FP2TimeRange                           ActivationDelay;                                   // 0x0010(0x0008)(Edit, BlueprintVisible, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
	struct FGameplayCueTag                        ActivationCue;                                     // 0x0018(0x0008)(Edit, BlueprintVisible, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
	TArray<int32>                                 AutoInitiationPhases;                              // 0x0020(0x0010)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	float                                         LifetimeOffset;                                    // 0x0030(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_34[0x4];                                       // 0x0034(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FP2ExtractionPointTypeSettings) == 0x000008, "Wrong alignment on FP2ExtractionPointTypeSettings");
static_assert(sizeof(FP2ExtractionPointTypeSettings) == 0x000038, "Wrong size on FP2ExtractionPointTypeSettings");
static_assert(offsetof(FP2ExtractionPointTypeSettings, ActivationPhases) == 0x000000, "Member 'FP2ExtractionPointTypeSettings::ActivationPhases' has a wrong offset!");
static_assert(offsetof(FP2ExtractionPointTypeSettings, ActivationDelay) == 0x000010, "Member 'FP2ExtractionPointTypeSettings::ActivationDelay' has a wrong offset!");
static_assert(offsetof(FP2ExtractionPointTypeSettings, ActivationCue) == 0x000018, "Member 'FP2ExtractionPointTypeSettings::ActivationCue' has a wrong offset!");
static_assert(offsetof(FP2ExtractionPointTypeSettings, AutoInitiationPhases) == 0x000020, "Member 'FP2ExtractionPointTypeSettings::AutoInitiationPhases' has a wrong offset!");
static_assert(offsetof(FP2ExtractionPointTypeSettings, LifetimeOffset) == 0x000030, "Member 'FP2ExtractionPointTypeSettings::LifetimeOffset' has a wrong offset!");

// ScriptStruct Game.P2RadialUIItemDataByPriolity
// 0x0018 (0x0018 - 0x0000)
struct FP2RadialUIItemDataByPriolity final
{
public:
	int32                                         Priolity;                                          // 0x0000(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UP2ItemData*                            ItemData;                                          // 0x0008(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UP2Item*                                P2Item;                                            // 0x0010(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FP2RadialUIItemDataByPriolity) == 0x000008, "Wrong alignment on FP2RadialUIItemDataByPriolity");
static_assert(sizeof(FP2RadialUIItemDataByPriolity) == 0x000018, "Wrong size on FP2RadialUIItemDataByPriolity");
static_assert(offsetof(FP2RadialUIItemDataByPriolity, Priolity) == 0x000000, "Member 'FP2RadialUIItemDataByPriolity::Priolity' has a wrong offset!");
static_assert(offsetof(FP2RadialUIItemDataByPriolity, ItemData) == 0x000008, "Member 'FP2RadialUIItemDataByPriolity::ItemData' has a wrong offset!");
static_assert(offsetof(FP2RadialUIItemDataByPriolity, P2Item) == 0x000010, "Member 'FP2RadialUIItemDataByPriolity::P2Item' has a wrong offset!");

// ScriptStruct Game.P2ExtractionPointGroup
// 0x0020 (0x0020 - 0x0000)
struct FP2ExtractionPointGroup final
{
public:
	TArray<class AActor*>                         ExtractionPoints;                                  // 0x0000(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<class AActor*>                         ActiveExtractionPoints;                            // 0x0010(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FP2ExtractionPointGroup) == 0x000008, "Wrong alignment on FP2ExtractionPointGroup");
static_assert(sizeof(FP2ExtractionPointGroup) == 0x000020, "Wrong size on FP2ExtractionPointGroup");
static_assert(offsetof(FP2ExtractionPointGroup, ExtractionPoints) == 0x000000, "Member 'FP2ExtractionPointGroup::ExtractionPoints' has a wrong offset!");
static_assert(offsetof(FP2ExtractionPointGroup, ActiveExtractionPoints) == 0x000010, "Member 'FP2ExtractionPointGroup::ActiveExtractionPoints' has a wrong offset!");

// ScriptStruct Game.P2InitialMailData
// 0x0038 (0x0038 - 0x0000)
struct FP2InitialMailData final
{
public:
	EP2InGameMailCategory                         MailCategory;                                      // 0x0000(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   Title;                                             // 0x0008(0x0018)(Edit, NativeAccessSpecifierPublic)
	class FText                                   Body;                                              // 0x0020(0x0018)(Edit, NativeAccessSpecifierPublic)
};
static_assert(alignof(FP2InitialMailData) == 0x000008, "Wrong alignment on FP2InitialMailData");
static_assert(sizeof(FP2InitialMailData) == 0x000038, "Wrong size on FP2InitialMailData");
static_assert(offsetof(FP2InitialMailData, MailCategory) == 0x000000, "Member 'FP2InitialMailData::MailCategory' has a wrong offset!");
static_assert(offsetof(FP2InitialMailData, Title) == 0x000008, "Member 'FP2InitialMailData::Title' has a wrong offset!");
static_assert(offsetof(FP2InitialMailData, Body) == 0x000020, "Member 'FP2InitialMailData::Body' has a wrong offset!");

// ScriptStruct Game.P2AssetBase
// 0x0030 (0x0030 - 0x0000)
struct FP2AssetBase
{
public:
	TSoftObjectPtr<class UCustomizableSkinObject> CSO;                                               // 0x0000(0x0030)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FP2AssetBase) == 0x000008, "Wrong alignment on FP2AssetBase");
static_assert(sizeof(FP2AssetBase) == 0x000030, "Wrong size on FP2AssetBase");
static_assert(offsetof(FP2AssetBase, CSO) == 0x000000, "Member 'FP2AssetBase::CSO' has a wrong offset!");

// ScriptStruct Game.P2FactionLevelData
// 0x00F0 (0x00F8 - 0x0008)
struct FP2FactionLevelData final : public FTableRowBase
{
public:
	struct FGameplayTag                           FactionLevelTag;                                   // 0x0008(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FText                                   DisplayName;                                       // 0x0010(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	int32                                         RequiredReputation;                                // 0x0028(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         DisplayLevel;                                      // 0x002C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSlateColor                            TextDisplayColor;                                  // 0x0030(0x0014)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FLinearColor                           ImageDisplayColor;                                 // 0x0044(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         WageValuePerMin;                                   // 0x0054(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PenaltyMultiplier;                                 // 0x0058(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5C[0x4];                                       // 0x005C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FP2FactionLevelUpMailInfo              FactionLevelUpMailInfo;                            // 0x0060(0x0098)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
};
static_assert(alignof(FP2FactionLevelData) == 0x000008, "Wrong alignment on FP2FactionLevelData");
static_assert(sizeof(FP2FactionLevelData) == 0x0000F8, "Wrong size on FP2FactionLevelData");
static_assert(offsetof(FP2FactionLevelData, FactionLevelTag) == 0x000008, "Member 'FP2FactionLevelData::FactionLevelTag' has a wrong offset!");
static_assert(offsetof(FP2FactionLevelData, DisplayName) == 0x000010, "Member 'FP2FactionLevelData::DisplayName' has a wrong offset!");
static_assert(offsetof(FP2FactionLevelData, RequiredReputation) == 0x000028, "Member 'FP2FactionLevelData::RequiredReputation' has a wrong offset!");
static_assert(offsetof(FP2FactionLevelData, DisplayLevel) == 0x00002C, "Member 'FP2FactionLevelData::DisplayLevel' has a wrong offset!");
static_assert(offsetof(FP2FactionLevelData, TextDisplayColor) == 0x000030, "Member 'FP2FactionLevelData::TextDisplayColor' has a wrong offset!");
static_assert(offsetof(FP2FactionLevelData, ImageDisplayColor) == 0x000044, "Member 'FP2FactionLevelData::ImageDisplayColor' has a wrong offset!");
static_assert(offsetof(FP2FactionLevelData, WageValuePerMin) == 0x000054, "Member 'FP2FactionLevelData::WageValuePerMin' has a wrong offset!");
static_assert(offsetof(FP2FactionLevelData, PenaltyMultiplier) == 0x000058, "Member 'FP2FactionLevelData::PenaltyMultiplier' has a wrong offset!");
static_assert(offsetof(FP2FactionLevelData, FactionLevelUpMailInfo) == 0x000060, "Member 'FP2FactionLevelData::FactionLevelUpMailInfo' has a wrong offset!");

// ScriptStruct Game.P2TeamChangedMessage
// 0x0030 (0x0030 - 0x0000)
struct FP2TeamChangedMessage final
{
public:
	int32                                         TeamId;                                            // 0x0000(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class AP2TeamStateBase*                       TeamState;                                         // 0x0008(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_10[0x20];                                      // 0x0010(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FP2TeamChangedMessage) == 0x000008, "Wrong alignment on FP2TeamChangedMessage");
static_assert(sizeof(FP2TeamChangedMessage) == 0x000030, "Wrong size on FP2TeamChangedMessage");
static_assert(offsetof(FP2TeamChangedMessage, TeamId) == 0x000000, "Member 'FP2TeamChangedMessage::TeamId' has a wrong offset!");
static_assert(offsetof(FP2TeamChangedMessage, TeamState) == 0x000008, "Member 'FP2TeamChangedMessage::TeamState' has a wrong offset!");

// ScriptStruct Game.P2ContractMessage_State
// 0x0008 (0x0018 - 0x0010)
struct FP2ContractMessage_State final : public FP2ContractMessage
{
public:
	EP2ContractState                              PreviousState;                                     // 0x0010(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EP2ContractState                              CurrentState;                                      // 0x0011(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_12[0x6];                                       // 0x0012(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FP2ContractMessage_State) == 0x000008, "Wrong alignment on FP2ContractMessage_State");
static_assert(sizeof(FP2ContractMessage_State) == 0x000018, "Wrong size on FP2ContractMessage_State");
static_assert(offsetof(FP2ContractMessage_State, PreviousState) == 0x000010, "Member 'FP2ContractMessage_State::PreviousState' has a wrong offset!");
static_assert(offsetof(FP2ContractMessage_State, CurrentState) == 0x000011, "Member 'FP2ContractMessage_State::CurrentState' has a wrong offset!");

// ScriptStruct Game.P2StatusEffectApplicationConfig
// 0x0110 (0x0110 - 0x0000)
struct FP2StatusEffectApplicationConfig final
{
public:
	struct FGameplayTag                           StatusEffectTag;                                   // 0x0000(0x0008)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bRemoveEffectOnLeave;                              // 0x0008(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bApplyOnEnterForEveryOverlap;                      // 0x0009(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A[0x2];                                        // 0x000A(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         StacksOnEnter;                                     // 0x000C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bScaleWithDistance;                                // 0x0010(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x3];                                       // 0x0011(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         StackCountPerPeriod;                               // 0x0014(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRuntimeFloatCurve                     StacksPerPeriodToDistanceCurve;                    // 0x0018(0x0088)(Edit, NativeAccessSpecifierPublic)
	float                                         Chance;                                            // 0x00A0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A4[0x4];                                       // 0x00A4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FP2ScalableFloat                       ScalableLevelLimit;                                // 0x00A8(0x0030)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	struct FP2ScalableFloat                       ScalableStackLimit;                                // 0x00D8(0x0030)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	float                                         TimePerPeriod;                                     // 0x0108(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EP2TriggerZoneStackApplicationType            StackApplicationType;                              // 0x010C(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_10D[0x3];                                      // 0x010D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FP2StatusEffectApplicationConfig) == 0x000008, "Wrong alignment on FP2StatusEffectApplicationConfig");
static_assert(sizeof(FP2StatusEffectApplicationConfig) == 0x000110, "Wrong size on FP2StatusEffectApplicationConfig");
static_assert(offsetof(FP2StatusEffectApplicationConfig, StatusEffectTag) == 0x000000, "Member 'FP2StatusEffectApplicationConfig::StatusEffectTag' has a wrong offset!");
static_assert(offsetof(FP2StatusEffectApplicationConfig, bRemoveEffectOnLeave) == 0x000008, "Member 'FP2StatusEffectApplicationConfig::bRemoveEffectOnLeave' has a wrong offset!");
static_assert(offsetof(FP2StatusEffectApplicationConfig, bApplyOnEnterForEveryOverlap) == 0x000009, "Member 'FP2StatusEffectApplicationConfig::bApplyOnEnterForEveryOverlap' has a wrong offset!");
static_assert(offsetof(FP2StatusEffectApplicationConfig, StacksOnEnter) == 0x00000C, "Member 'FP2StatusEffectApplicationConfig::StacksOnEnter' has a wrong offset!");
static_assert(offsetof(FP2StatusEffectApplicationConfig, bScaleWithDistance) == 0x000010, "Member 'FP2StatusEffectApplicationConfig::bScaleWithDistance' has a wrong offset!");
static_assert(offsetof(FP2StatusEffectApplicationConfig, StackCountPerPeriod) == 0x000014, "Member 'FP2StatusEffectApplicationConfig::StackCountPerPeriod' has a wrong offset!");
static_assert(offsetof(FP2StatusEffectApplicationConfig, StacksPerPeriodToDistanceCurve) == 0x000018, "Member 'FP2StatusEffectApplicationConfig::StacksPerPeriodToDistanceCurve' has a wrong offset!");
static_assert(offsetof(FP2StatusEffectApplicationConfig, Chance) == 0x0000A0, "Member 'FP2StatusEffectApplicationConfig::Chance' has a wrong offset!");
static_assert(offsetof(FP2StatusEffectApplicationConfig, ScalableLevelLimit) == 0x0000A8, "Member 'FP2StatusEffectApplicationConfig::ScalableLevelLimit' has a wrong offset!");
static_assert(offsetof(FP2StatusEffectApplicationConfig, ScalableStackLimit) == 0x0000D8, "Member 'FP2StatusEffectApplicationConfig::ScalableStackLimit' has a wrong offset!");
static_assert(offsetof(FP2StatusEffectApplicationConfig, TimePerPeriod) == 0x000108, "Member 'FP2StatusEffectApplicationConfig::TimePerPeriod' has a wrong offset!");
static_assert(offsetof(FP2StatusEffectApplicationConfig, StackApplicationType) == 0x00010C, "Member 'FP2StatusEffectApplicationConfig::StackApplicationType' has a wrong offset!");

// ScriptStruct Game.P2ContractRequirementMessage_State
// 0x0008 (0x0020 - 0x0018)
struct FP2ContractRequirementMessage_State final : public FP2ContractRequirementMessage
{
public:
	EP2ContractRequirementState                   PreviousState;                                     // 0x0018(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EP2ContractRequirementState                   CurrentState;                                      // 0x0019(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1A[0x6];                                       // 0x001A(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FP2ContractRequirementMessage_State) == 0x000008, "Wrong alignment on FP2ContractRequirementMessage_State");
static_assert(sizeof(FP2ContractRequirementMessage_State) == 0x000020, "Wrong size on FP2ContractRequirementMessage_State");
static_assert(offsetof(FP2ContractRequirementMessage_State, PreviousState) == 0x000018, "Member 'FP2ContractRequirementMessage_State::PreviousState' has a wrong offset!");
static_assert(offsetof(FP2ContractRequirementMessage_State, CurrentState) == 0x000019, "Member 'FP2ContractRequirementMessage_State::CurrentState' has a wrong offset!");

// ScriptStruct Game.P2AntiCheatMessage_SpawnThrowableRejected
// 0x0050 (0x0050 - 0x0000)
struct FP2AntiCheatMessage_SpawnThrowableRejected final
{
public:
	class AP2BaseCharacter*                       Character;                                         // 0x0000(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector_NetQuantize                    VelocityDelta;                                     // 0x0008(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector_NetQuantize                    LocationDelta;                                     // 0x0020(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               RotationDelta;                                     // 0x0038(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FP2AntiCheatMessage_SpawnThrowableRejected) == 0x000008, "Wrong alignment on FP2AntiCheatMessage_SpawnThrowableRejected");
static_assert(sizeof(FP2AntiCheatMessage_SpawnThrowableRejected) == 0x000050, "Wrong size on FP2AntiCheatMessage_SpawnThrowableRejected");
static_assert(offsetof(FP2AntiCheatMessage_SpawnThrowableRejected, Character) == 0x000000, "Member 'FP2AntiCheatMessage_SpawnThrowableRejected::Character' has a wrong offset!");
static_assert(offsetof(FP2AntiCheatMessage_SpawnThrowableRejected, VelocityDelta) == 0x000008, "Member 'FP2AntiCheatMessage_SpawnThrowableRejected::VelocityDelta' has a wrong offset!");
static_assert(offsetof(FP2AntiCheatMessage_SpawnThrowableRejected, LocationDelta) == 0x000020, "Member 'FP2AntiCheatMessage_SpawnThrowableRejected::LocationDelta' has a wrong offset!");
static_assert(offsetof(FP2AntiCheatMessage_SpawnThrowableRejected, RotationDelta) == 0x000038, "Member 'FP2AntiCheatMessage_SpawnThrowableRejected::RotationDelta' has a wrong offset!");

// ScriptStruct Game.P2RepFireVoxel
// 0x0050 (0x0050 - 0x0000)
struct alignas(0x08) FP2RepFireVoxel final
{
public:
	uint8                                         Pad_0[0x50];                                       // 0x0000(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FP2RepFireVoxel) == 0x000008, "Wrong alignment on FP2RepFireVoxel");
static_assert(sizeof(FP2RepFireVoxel) == 0x000050, "Wrong size on FP2RepFireVoxel");

// ScriptStruct Game.P2PlayerFlashlightContext
// 0x0010 (0x0010 - 0x0000)
struct FP2PlayerFlashlightContext final
{
public:
	TArray<class UP2SpotLightComponent*>          LightComponents;                                   // 0x0000(0x0010)(ExportObject, ZeroConstructor, Transient, ContainsInstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(FP2PlayerFlashlightContext) == 0x000008, "Wrong alignment on FP2PlayerFlashlightContext");
static_assert(sizeof(FP2PlayerFlashlightContext) == 0x000010, "Wrong size on FP2PlayerFlashlightContext");
static_assert(offsetof(FP2PlayerFlashlightContext, LightComponents) == 0x000000, "Member 'FP2PlayerFlashlightContext::LightComponents' has a wrong offset!");

// ScriptStruct Game.P2GeneralSoundInfo
// 0x0010 (0x0010 - 0x0000)
struct FP2GeneralSoundInfo final
{
public:
	struct FGameplayTag                           GeneralSoundTag;                                   // 0x0000(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAkAudioEvent*                          GeneralAKAudioEvent;                               // 0x0008(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FP2GeneralSoundInfo) == 0x000008, "Wrong alignment on FP2GeneralSoundInfo");
static_assert(sizeof(FP2GeneralSoundInfo) == 0x000010, "Wrong size on FP2GeneralSoundInfo");
static_assert(offsetof(FP2GeneralSoundInfo, GeneralSoundTag) == 0x000000, "Member 'FP2GeneralSoundInfo::GeneralSoundTag' has a wrong offset!");
static_assert(offsetof(FP2GeneralSoundInfo, GeneralAKAudioEvent) == 0x000008, "Member 'FP2GeneralSoundInfo::GeneralAKAudioEvent' has a wrong offset!");

// ScriptStruct Game.P2FPPPostProcessSettings
// 0x0028 (0x0028 - 0x0000)
struct FP2FPPPostProcessSettings final
{
public:
	float                                         DofRadius;                                         // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TranslucentEdgesRadius;                            // 0x0004(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TranslucentEdgesStrength;                          // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxRadius;                                         // 0x000C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SplitDepthOffset;                                  // 0x0010(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Depth;                                             // 0x0014(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Notes;                                             // 0x0018(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FP2FPPPostProcessSettings) == 0x000008, "Wrong alignment on FP2FPPPostProcessSettings");
static_assert(sizeof(FP2FPPPostProcessSettings) == 0x000028, "Wrong size on FP2FPPPostProcessSettings");
static_assert(offsetof(FP2FPPPostProcessSettings, DofRadius) == 0x000000, "Member 'FP2FPPPostProcessSettings::DofRadius' has a wrong offset!");
static_assert(offsetof(FP2FPPPostProcessSettings, TranslucentEdgesRadius) == 0x000004, "Member 'FP2FPPPostProcessSettings::TranslucentEdgesRadius' has a wrong offset!");
static_assert(offsetof(FP2FPPPostProcessSettings, TranslucentEdgesStrength) == 0x000008, "Member 'FP2FPPPostProcessSettings::TranslucentEdgesStrength' has a wrong offset!");
static_assert(offsetof(FP2FPPPostProcessSettings, MaxRadius) == 0x00000C, "Member 'FP2FPPPostProcessSettings::MaxRadius' has a wrong offset!");
static_assert(offsetof(FP2FPPPostProcessSettings, SplitDepthOffset) == 0x000010, "Member 'FP2FPPPostProcessSettings::SplitDepthOffset' has a wrong offset!");
static_assert(offsetof(FP2FPPPostProcessSettings, Depth) == 0x000014, "Member 'FP2FPPPostProcessSettings::Depth' has a wrong offset!");
static_assert(offsetof(FP2FPPPostProcessSettings, Notes) == 0x000018, "Member 'FP2FPPPostProcessSettings::Notes' has a wrong offset!");

// ScriptStruct Game.P2GameFeatureActionEntry
// 0x0060 (0x0060 - 0x0000)
struct FP2GameFeatureActionEntry final
{
public:
	TSoftClassPtr<class UClass>                   ActorClass;                                        // 0x0000(0x0030)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftClassPtr<class UClass>                   ActionClass;                                       // 0x0030(0x0030)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FP2GameFeatureActionEntry) == 0x000008, "Wrong alignment on FP2GameFeatureActionEntry");
static_assert(sizeof(FP2GameFeatureActionEntry) == 0x000060, "Wrong size on FP2GameFeatureActionEntry");
static_assert(offsetof(FP2GameFeatureActionEntry, ActorClass) == 0x000000, "Member 'FP2GameFeatureActionEntry::ActorClass' has a wrong offset!");
static_assert(offsetof(FP2GameFeatureActionEntry, ActionClass) == 0x000030, "Member 'FP2GameFeatureActionEntry::ActionClass' has a wrong offset!");

// ScriptStruct Game.P2ContextRequirementRef
// 0x0008 (0x0008 - 0x0000)
struct FP2ContextRequirementRef final
{
public:
	EP2GameplayContextRequirementType             Type;                                              // 0x0000(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         Index;                                             // 0x0004(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FP2ContextRequirementRef) == 0x000004, "Wrong alignment on FP2ContextRequirementRef");
static_assert(sizeof(FP2ContextRequirementRef) == 0x000008, "Wrong size on FP2ContextRequirementRef");
static_assert(offsetof(FP2ContextRequirementRef, Type) == 0x000000, "Member 'FP2ContextRequirementRef::Type' has a wrong offset!");
static_assert(offsetof(FP2ContextRequirementRef, Index) == 0x000004, "Member 'FP2ContextRequirementRef::Index' has a wrong offset!");

// ScriptStruct Game.P2FalloffIntensityParams
// 0x000C (0x000C - 0x0000)
struct FP2FalloffIntensityParams final
{
public:
	float                                         WorldInnerRadius;                                  // 0x0000(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         WorldOuterRadius;                                  // 0x0004(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         WorldFalloffExponent;                              // 0x0008(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FP2FalloffIntensityParams) == 0x000004, "Wrong alignment on FP2FalloffIntensityParams");
static_assert(sizeof(FP2FalloffIntensityParams) == 0x00000C, "Wrong size on FP2FalloffIntensityParams");
static_assert(offsetof(FP2FalloffIntensityParams, WorldInnerRadius) == 0x000000, "Member 'FP2FalloffIntensityParams::WorldInnerRadius' has a wrong offset!");
static_assert(offsetof(FP2FalloffIntensityParams, WorldOuterRadius) == 0x000004, "Member 'FP2FalloffIntensityParams::WorldOuterRadius' has a wrong offset!");
static_assert(offsetof(FP2FalloffIntensityParams, WorldFalloffExponent) == 0x000008, "Member 'FP2FalloffIntensityParams::WorldFalloffExponent' has a wrong offset!");

// ScriptStruct Game.P2GameplayCueNotify_CameraShakeInfo
// 0x00B8 (0x00B8 - 0x0000)
struct FP2GameplayCueNotify_CameraShakeInfo final
{
public:
	struct FP2GameplayCueNotify_SpawnCondition    SpawnConditionOverride;                            // 0x0000(0x0048)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FP2GameplayCueNotify_PlacementInfo     PlacementInfoOverride;                             // 0x0048(0x0040)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
	TSubclassOf<class UCameraShakeBase>           CameraShake;                                       // 0x0088(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ShakeScale;                                        // 0x0090(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EP2GameplayCueNotify_EffectPlaySpace          PlaySpace;                                         // 0x0094(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_95[0x3];                                       // 0x0095(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	uint8                                         bOverrideSpawnCondition : 1;                       // 0x0098(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bOverridePlacementInfo : 1;                        // 0x0098(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bPlayInWorld : 1;                                  // 0x0098(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bScaleWithNormalizedMagnitude : 1;                 // 0x0098(0x0001)(BitIndex: 0x03, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_99[0x3];                                       // 0x0099(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         WorldInnerRadius;                                  // 0x009C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         WorldOuterRadius;                                  // 0x00A0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         WorldFalloffExponent;                              // 0x00A4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCustomizeVerticalFalloffIntensity;                // 0x00A8(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A9[0x3];                                       // 0x00A9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FP2FalloffIntensityParams              VerticalIntensityParams;                           // 0x00AC(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FP2GameplayCueNotify_CameraShakeInfo) == 0x000008, "Wrong alignment on FP2GameplayCueNotify_CameraShakeInfo");
static_assert(sizeof(FP2GameplayCueNotify_CameraShakeInfo) == 0x0000B8, "Wrong size on FP2GameplayCueNotify_CameraShakeInfo");
static_assert(offsetof(FP2GameplayCueNotify_CameraShakeInfo, SpawnConditionOverride) == 0x000000, "Member 'FP2GameplayCueNotify_CameraShakeInfo::SpawnConditionOverride' has a wrong offset!");
static_assert(offsetof(FP2GameplayCueNotify_CameraShakeInfo, PlacementInfoOverride) == 0x000048, "Member 'FP2GameplayCueNotify_CameraShakeInfo::PlacementInfoOverride' has a wrong offset!");
static_assert(offsetof(FP2GameplayCueNotify_CameraShakeInfo, CameraShake) == 0x000088, "Member 'FP2GameplayCueNotify_CameraShakeInfo::CameraShake' has a wrong offset!");
static_assert(offsetof(FP2GameplayCueNotify_CameraShakeInfo, ShakeScale) == 0x000090, "Member 'FP2GameplayCueNotify_CameraShakeInfo::ShakeScale' has a wrong offset!");
static_assert(offsetof(FP2GameplayCueNotify_CameraShakeInfo, PlaySpace) == 0x000094, "Member 'FP2GameplayCueNotify_CameraShakeInfo::PlaySpace' has a wrong offset!");
static_assert(offsetof(FP2GameplayCueNotify_CameraShakeInfo, WorldInnerRadius) == 0x00009C, "Member 'FP2GameplayCueNotify_CameraShakeInfo::WorldInnerRadius' has a wrong offset!");
static_assert(offsetof(FP2GameplayCueNotify_CameraShakeInfo, WorldOuterRadius) == 0x0000A0, "Member 'FP2GameplayCueNotify_CameraShakeInfo::WorldOuterRadius' has a wrong offset!");
static_assert(offsetof(FP2GameplayCueNotify_CameraShakeInfo, WorldFalloffExponent) == 0x0000A4, "Member 'FP2GameplayCueNotify_CameraShakeInfo::WorldFalloffExponent' has a wrong offset!");
static_assert(offsetof(FP2GameplayCueNotify_CameraShakeInfo, bCustomizeVerticalFalloffIntensity) == 0x0000A8, "Member 'FP2GameplayCueNotify_CameraShakeInfo::bCustomizeVerticalFalloffIntensity' has a wrong offset!");
static_assert(offsetof(FP2GameplayCueNotify_CameraShakeInfo, VerticalIntensityParams) == 0x0000AC, "Member 'FP2GameplayCueNotify_CameraShakeInfo::VerticalIntensityParams' has a wrong offset!");

// ScriptStruct Game.P2ConsumableMeshWrapper
// 0x0010 (0x0010 - 0x0000)
struct alignas(0x04) FP2ConsumableMeshWrapper final
{
public:
	uint8                                         Pad_0[0x10];                                       // 0x0000(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FP2ConsumableMeshWrapper) == 0x000004, "Wrong alignment on FP2ConsumableMeshWrapper");
static_assert(sizeof(FP2ConsumableMeshWrapper) == 0x000010, "Wrong size on FP2ConsumableMeshWrapper");

// ScriptStruct Game.P2WeaponEffectSet_Audio
// 0x0128 (0x0128 - 0x0000)
struct FP2WeaponEffectSet_Audio final
{
public:
	class UAkAudioEvent*                          SingleShotSound;                                   // 0x0000(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EAudioEventType                               AudioEventType;                                    // 0x0008(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EAudioEventType                               AudioEventTypeForRemote;                           // 0x0009(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A[0x6];                                        // 0x000A(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	class UAkAudioEvent*                          FullAutoSoundLoopStart;                            // 0x0010(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAkAudioEvent*                          FullAutoSoundLoopStop;                             // 0x0018(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAkAudioEvent*                          FullAutoSingleEvent;                               // 0x0020(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TMap<EP2WwiseTeamStatus, float>               ShotReleaseTimeFactor;                             // 0x0028(0x0050)(Edit, NativeAccessSpecifierPublic)
	TMap<struct FGameplayTag, float>              CaliberAttenuationScaling;                         // 0x0078(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TMap<struct FGameplayTag, float>              ModAttenuationScaling;                             // 0x00C8(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	class UP2InteriorWeaponTailsSettings*         InteriorWeaponTailsSettings;                       // 0x0118(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UP2QuadTailWeaponConfig*                QuadWeaponTailsSettings;                           // 0x0120(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FP2WeaponEffectSet_Audio) == 0x000008, "Wrong alignment on FP2WeaponEffectSet_Audio");
static_assert(sizeof(FP2WeaponEffectSet_Audio) == 0x000128, "Wrong size on FP2WeaponEffectSet_Audio");
static_assert(offsetof(FP2WeaponEffectSet_Audio, SingleShotSound) == 0x000000, "Member 'FP2WeaponEffectSet_Audio::SingleShotSound' has a wrong offset!");
static_assert(offsetof(FP2WeaponEffectSet_Audio, AudioEventType) == 0x000008, "Member 'FP2WeaponEffectSet_Audio::AudioEventType' has a wrong offset!");
static_assert(offsetof(FP2WeaponEffectSet_Audio, AudioEventTypeForRemote) == 0x000009, "Member 'FP2WeaponEffectSet_Audio::AudioEventTypeForRemote' has a wrong offset!");
static_assert(offsetof(FP2WeaponEffectSet_Audio, FullAutoSoundLoopStart) == 0x000010, "Member 'FP2WeaponEffectSet_Audio::FullAutoSoundLoopStart' has a wrong offset!");
static_assert(offsetof(FP2WeaponEffectSet_Audio, FullAutoSoundLoopStop) == 0x000018, "Member 'FP2WeaponEffectSet_Audio::FullAutoSoundLoopStop' has a wrong offset!");
static_assert(offsetof(FP2WeaponEffectSet_Audio, FullAutoSingleEvent) == 0x000020, "Member 'FP2WeaponEffectSet_Audio::FullAutoSingleEvent' has a wrong offset!");
static_assert(offsetof(FP2WeaponEffectSet_Audio, ShotReleaseTimeFactor) == 0x000028, "Member 'FP2WeaponEffectSet_Audio::ShotReleaseTimeFactor' has a wrong offset!");
static_assert(offsetof(FP2WeaponEffectSet_Audio, CaliberAttenuationScaling) == 0x000078, "Member 'FP2WeaponEffectSet_Audio::CaliberAttenuationScaling' has a wrong offset!");
static_assert(offsetof(FP2WeaponEffectSet_Audio, ModAttenuationScaling) == 0x0000C8, "Member 'FP2WeaponEffectSet_Audio::ModAttenuationScaling' has a wrong offset!");
static_assert(offsetof(FP2WeaponEffectSet_Audio, InteriorWeaponTailsSettings) == 0x000118, "Member 'FP2WeaponEffectSet_Audio::InteriorWeaponTailsSettings' has a wrong offset!");
static_assert(offsetof(FP2WeaponEffectSet_Audio, QuadWeaponTailsSettings) == 0x000120, "Member 'FP2WeaponEffectSet_Audio::QuadWeaponTailsSettings' has a wrong offset!");

// ScriptStruct Game.P2GameplayCueNotify_ShockwaveInfo
// 0x0098 (0x0098 - 0x0000)
struct FP2GameplayCueNotify_ShockwaveInfo final
{
public:
	struct FP2GameplayCueNotify_SpawnCondition    SpawnConditionOverride;                            // 0x0000(0x0048)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FP2GameplayCueNotify_PlacementInfo     PlacementInfoOverride;                             // 0x0048(0x0040)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         bOverrideSpawnCondition : 1;                       // 0x0088(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bOverridePlacementInfo : 1;                        // 0x0088(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_89[0x3];                                       // 0x0089(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Radius;                                            // 0x008C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Duration;                                          // 0x0090(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Strength;                                          // 0x0094(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FP2GameplayCueNotify_ShockwaveInfo) == 0x000008, "Wrong alignment on FP2GameplayCueNotify_ShockwaveInfo");
static_assert(sizeof(FP2GameplayCueNotify_ShockwaveInfo) == 0x000098, "Wrong size on FP2GameplayCueNotify_ShockwaveInfo");
static_assert(offsetof(FP2GameplayCueNotify_ShockwaveInfo, SpawnConditionOverride) == 0x000000, "Member 'FP2GameplayCueNotify_ShockwaveInfo::SpawnConditionOverride' has a wrong offset!");
static_assert(offsetof(FP2GameplayCueNotify_ShockwaveInfo, PlacementInfoOverride) == 0x000048, "Member 'FP2GameplayCueNotify_ShockwaveInfo::PlacementInfoOverride' has a wrong offset!");
static_assert(offsetof(FP2GameplayCueNotify_ShockwaveInfo, Radius) == 0x00008C, "Member 'FP2GameplayCueNotify_ShockwaveInfo::Radius' has a wrong offset!");
static_assert(offsetof(FP2GameplayCueNotify_ShockwaveInfo, Duration) == 0x000090, "Member 'FP2GameplayCueNotify_ShockwaveInfo::Duration' has a wrong offset!");
static_assert(offsetof(FP2GameplayCueNotify_ShockwaveInfo, Strength) == 0x000094, "Member 'FP2GameplayCueNotify_ShockwaveInfo::Strength' has a wrong offset!");

// ScriptStruct Game.P2GameplayCue_HitFx
// 0x0118 (0x0118 - 0x0000)
struct FP2GameplayCue_HitFx final
{
public:
	struct FP2GameplayCueNotify_NiagaraVariation  Particle;                                          // 0x0000(0x0058)(Edit, BlueprintVisible, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FP2GameplayCueNotify_AkEventVariation  AkEvent;                                           // 0x0058(0x0080)(Edit, BlueprintVisible, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FAkEventSlotConfig                     DeadBodyHitAkEvent;                                // 0x00D8(0x0030)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          bApplyDistanceScale;                               // 0x0108(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUseDamageThreshold;                               // 0x0109(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUsePenetrationThreshold;                          // 0x010A(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bPlayIfPenetrated;                                 // 0x010B(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bPlayIfNotPenetrated;                              // 0x010C(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_10D[0x3];                                      // 0x010D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         DamageThreshold;                                   // 0x0110(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PenetrationThreshold;                              // 0x0114(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FP2GameplayCue_HitFx) == 0x000008, "Wrong alignment on FP2GameplayCue_HitFx");
static_assert(sizeof(FP2GameplayCue_HitFx) == 0x000118, "Wrong size on FP2GameplayCue_HitFx");
static_assert(offsetof(FP2GameplayCue_HitFx, Particle) == 0x000000, "Member 'FP2GameplayCue_HitFx::Particle' has a wrong offset!");
static_assert(offsetof(FP2GameplayCue_HitFx, AkEvent) == 0x000058, "Member 'FP2GameplayCue_HitFx::AkEvent' has a wrong offset!");
static_assert(offsetof(FP2GameplayCue_HitFx, DeadBodyHitAkEvent) == 0x0000D8, "Member 'FP2GameplayCue_HitFx::DeadBodyHitAkEvent' has a wrong offset!");
static_assert(offsetof(FP2GameplayCue_HitFx, bApplyDistanceScale) == 0x000108, "Member 'FP2GameplayCue_HitFx::bApplyDistanceScale' has a wrong offset!");
static_assert(offsetof(FP2GameplayCue_HitFx, bUseDamageThreshold) == 0x000109, "Member 'FP2GameplayCue_HitFx::bUseDamageThreshold' has a wrong offset!");
static_assert(offsetof(FP2GameplayCue_HitFx, bUsePenetrationThreshold) == 0x00010A, "Member 'FP2GameplayCue_HitFx::bUsePenetrationThreshold' has a wrong offset!");
static_assert(offsetof(FP2GameplayCue_HitFx, bPlayIfPenetrated) == 0x00010B, "Member 'FP2GameplayCue_HitFx::bPlayIfPenetrated' has a wrong offset!");
static_assert(offsetof(FP2GameplayCue_HitFx, bPlayIfNotPenetrated) == 0x00010C, "Member 'FP2GameplayCue_HitFx::bPlayIfNotPenetrated' has a wrong offset!");
static_assert(offsetof(FP2GameplayCue_HitFx, DamageThreshold) == 0x000110, "Member 'FP2GameplayCue_HitFx::DamageThreshold' has a wrong offset!");
static_assert(offsetof(FP2GameplayCue_HitFx, PenetrationThreshold) == 0x000114, "Member 'FP2GameplayCue_HitFx::PenetrationThreshold' has a wrong offset!");

// ScriptStruct Game.AnimSpringInstance
// 0x0170 (0x0170 - 0x0000)
struct alignas(0x10) FAnimSpringInstance final
{
public:
	class UAnimSpringSimData*                     SimData;                                           // 0x0000(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_8[0x168];                                      // 0x0008(0x0168)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FAnimSpringInstance) == 0x000010, "Wrong alignment on FAnimSpringInstance");
static_assert(sizeof(FAnimSpringInstance) == 0x000170, "Wrong size on FAnimSpringInstance");
static_assert(offsetof(FAnimSpringInstance, SimData) == 0x000000, "Member 'FAnimSpringInstance::SimData' has a wrong offset!");

// ScriptStruct Game.P2GameplayCue_MaterialFXSettings
// 0x0008 (0x0008 - 0x0000)
struct FP2GameplayCue_MaterialFXSettings final
{
public:
	float                                         Radius;                                            // 0x0000(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MfxLayers;                                         // 0x0004(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FP2GameplayCue_MaterialFXSettings) == 0x000004, "Wrong alignment on FP2GameplayCue_MaterialFXSettings");
static_assert(sizeof(FP2GameplayCue_MaterialFXSettings) == 0x000008, "Wrong size on FP2GameplayCue_MaterialFXSettings");
static_assert(offsetof(FP2GameplayCue_MaterialFXSettings, Radius) == 0x000000, "Member 'FP2GameplayCue_MaterialFXSettings::Radius' has a wrong offset!");
static_assert(offsetof(FP2GameplayCue_MaterialFXSettings, MfxLayers) == 0x000004, "Member 'FP2GameplayCue_MaterialFXSettings::MfxLayers' has a wrong offset!");

// ScriptStruct Game.P2VocalSFXData
// 0x0048 (0x0048 - 0x0000)
struct FP2VocalSFXData final
{
public:
	struct FAkEventSlotConfig                     Config;                                            // 0x0000(0x0030)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FGameplayTag                           PlaybackTag;                                       // 0x0030(0x0008)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Priority;                                          // 0x0038(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Cooldown;                                          // 0x003C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FadeOutDuration;                                   // 0x0040(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAlwaysTopPriority;                                // 0x0044(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDiscardOlderInstance;                             // 0x0045(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_46[0x2];                                       // 0x0046(0x0002)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FP2VocalSFXData) == 0x000008, "Wrong alignment on FP2VocalSFXData");
static_assert(sizeof(FP2VocalSFXData) == 0x000048, "Wrong size on FP2VocalSFXData");
static_assert(offsetof(FP2VocalSFXData, Config) == 0x000000, "Member 'FP2VocalSFXData::Config' has a wrong offset!");
static_assert(offsetof(FP2VocalSFXData, PlaybackTag) == 0x000030, "Member 'FP2VocalSFXData::PlaybackTag' has a wrong offset!");
static_assert(offsetof(FP2VocalSFXData, Priority) == 0x000038, "Member 'FP2VocalSFXData::Priority' has a wrong offset!");
static_assert(offsetof(FP2VocalSFXData, Cooldown) == 0x00003C, "Member 'FP2VocalSFXData::Cooldown' has a wrong offset!");
static_assert(offsetof(FP2VocalSFXData, FadeOutDuration) == 0x000040, "Member 'FP2VocalSFXData::FadeOutDuration' has a wrong offset!");
static_assert(offsetof(FP2VocalSFXData, bAlwaysTopPriority) == 0x000044, "Member 'FP2VocalSFXData::bAlwaysTopPriority' has a wrong offset!");
static_assert(offsetof(FP2VocalSFXData, bDiscardOlderInstance) == 0x000045, "Member 'FP2VocalSFXData::bDiscardOlderInstance' has a wrong offset!");

// ScriptStruct Game.AnimSpringModifierSet
// 0x0010 (0x0010 - 0x0000)
struct FAnimSpringModifierSet final
{
public:
	TArray<class UAnimSpringModifierCalculatorBase*> Calculators;                                    // 0x0000(0x0010)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, ContainsInstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAnimSpringModifierSet) == 0x000008, "Wrong alignment on FAnimSpringModifierSet");
static_assert(sizeof(FAnimSpringModifierSet) == 0x000010, "Wrong size on FAnimSpringModifierSet");
static_assert(offsetof(FAnimSpringModifierSet, Calculators) == 0x000000, "Member 'FAnimSpringModifierSet::Calculators' has a wrong offset!");

// ScriptStruct Game.FallDamageInfo
// 0x000C (0x000C - 0x0000)
struct FFallDamageInfo final
{
public:
	float                                         DamageInitialVelocity;                             // 0x0000(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FractureVelocity;                                  // 0x0004(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DamageLethalVelocity;                              // 0x0008(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FFallDamageInfo) == 0x000004, "Wrong alignment on FFallDamageInfo");
static_assert(sizeof(FFallDamageInfo) == 0x00000C, "Wrong size on FFallDamageInfo");
static_assert(offsetof(FFallDamageInfo, DamageInitialVelocity) == 0x000000, "Member 'FFallDamageInfo::DamageInitialVelocity' has a wrong offset!");
static_assert(offsetof(FFallDamageInfo, FractureVelocity) == 0x000004, "Member 'FFallDamageInfo::FractureVelocity' has a wrong offset!");
static_assert(offsetof(FFallDamageInfo, DamageLethalVelocity) == 0x000008, "Member 'FFallDamageInfo::DamageLethalVelocity' has a wrong offset!");

// ScriptStruct Game.P2StatusEffectSoundPriorityLocality
// 0x0200 (0x0200 - 0x0000)
struct FP2StatusEffectSoundPriorityLocality final
{
public:
	struct FGameplayTag                           GameplayEffectTag;                                 // 0x0000(0x0008)(Edit, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FP2StatusEffectSoundPrioritySettings   LocalSettings;                                     // 0x0008(0x0038)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	struct FP2StatusEffectSoundPrioritySettings   RemoteSettings;                                    // 0x0040(0x0038)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	struct FAkEventSlotConfig                     OnApplyAkEventSlotConfig;                          // 0x0078(0x0030)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, NativeAccessSpecifierPublic)
	class FString                                 OnApplyDialogueQuery;                              // 0x00A8(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FAkEventSlotConfig                     OnIncreaseAkEventSlotConfig;                       // 0x00B8(0x0030)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, NativeAccessSpecifierPublic)
	class FString                                 OnIncreaseDialogueQuery;                           // 0x00E8(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FAkEventSlotConfig                     OnRemoveAkEventSlotConfig;                         // 0x00F8(0x0030)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, NativeAccessSpecifierPublic)
	class FString                                 OnRemoveDialogueQuery;                             // 0x0128(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FAkEventSlotConfig                     OnRecurringAkEventSlotConfig;                      // 0x0138(0x0030)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, NativeAccessSpecifierPublic)
	class FString                                 OnRecurringDialogueQuery;                          // 0x0168(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FAkEventSlotConfig                     LoopingAkEventSlotConfig;                          // 0x0178(0x0030)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, NativeAccessSpecifierPublic)
	class FString                                 LoopingDialogueQuery;                              // 0x01A8(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FAkEventSlotConfig                     OptionalLoopingStopAkEventSlotConfig;              // 0x01B8(0x0030)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, NativeAccessSpecifierPublic)
	float                                         FadeOutDurationSec;                                // 0x01E8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bApplyBusEffects;                                  // 0x01EC(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1ED[0x3];                                      // 0x01ED(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class UAkAudioEvent*                          BusEffectStartEvent;                               // 0x01F0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAkAudioEvent*                          BusEffectStopEvent;                                // 0x01F8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FP2StatusEffectSoundPriorityLocality) == 0x000008, "Wrong alignment on FP2StatusEffectSoundPriorityLocality");
static_assert(sizeof(FP2StatusEffectSoundPriorityLocality) == 0x000200, "Wrong size on FP2StatusEffectSoundPriorityLocality");
static_assert(offsetof(FP2StatusEffectSoundPriorityLocality, GameplayEffectTag) == 0x000000, "Member 'FP2StatusEffectSoundPriorityLocality::GameplayEffectTag' has a wrong offset!");
static_assert(offsetof(FP2StatusEffectSoundPriorityLocality, LocalSettings) == 0x000008, "Member 'FP2StatusEffectSoundPriorityLocality::LocalSettings' has a wrong offset!");
static_assert(offsetof(FP2StatusEffectSoundPriorityLocality, RemoteSettings) == 0x000040, "Member 'FP2StatusEffectSoundPriorityLocality::RemoteSettings' has a wrong offset!");
static_assert(offsetof(FP2StatusEffectSoundPriorityLocality, OnApplyAkEventSlotConfig) == 0x000078, "Member 'FP2StatusEffectSoundPriorityLocality::OnApplyAkEventSlotConfig' has a wrong offset!");
static_assert(offsetof(FP2StatusEffectSoundPriorityLocality, OnApplyDialogueQuery) == 0x0000A8, "Member 'FP2StatusEffectSoundPriorityLocality::OnApplyDialogueQuery' has a wrong offset!");
static_assert(offsetof(FP2StatusEffectSoundPriorityLocality, OnIncreaseAkEventSlotConfig) == 0x0000B8, "Member 'FP2StatusEffectSoundPriorityLocality::OnIncreaseAkEventSlotConfig' has a wrong offset!");
static_assert(offsetof(FP2StatusEffectSoundPriorityLocality, OnIncreaseDialogueQuery) == 0x0000E8, "Member 'FP2StatusEffectSoundPriorityLocality::OnIncreaseDialogueQuery' has a wrong offset!");
static_assert(offsetof(FP2StatusEffectSoundPriorityLocality, OnRemoveAkEventSlotConfig) == 0x0000F8, "Member 'FP2StatusEffectSoundPriorityLocality::OnRemoveAkEventSlotConfig' has a wrong offset!");
static_assert(offsetof(FP2StatusEffectSoundPriorityLocality, OnRemoveDialogueQuery) == 0x000128, "Member 'FP2StatusEffectSoundPriorityLocality::OnRemoveDialogueQuery' has a wrong offset!");
static_assert(offsetof(FP2StatusEffectSoundPriorityLocality, OnRecurringAkEventSlotConfig) == 0x000138, "Member 'FP2StatusEffectSoundPriorityLocality::OnRecurringAkEventSlotConfig' has a wrong offset!");
static_assert(offsetof(FP2StatusEffectSoundPriorityLocality, OnRecurringDialogueQuery) == 0x000168, "Member 'FP2StatusEffectSoundPriorityLocality::OnRecurringDialogueQuery' has a wrong offset!");
static_assert(offsetof(FP2StatusEffectSoundPriorityLocality, LoopingAkEventSlotConfig) == 0x000178, "Member 'FP2StatusEffectSoundPriorityLocality::LoopingAkEventSlotConfig' has a wrong offset!");
static_assert(offsetof(FP2StatusEffectSoundPriorityLocality, LoopingDialogueQuery) == 0x0001A8, "Member 'FP2StatusEffectSoundPriorityLocality::LoopingDialogueQuery' has a wrong offset!");
static_assert(offsetof(FP2StatusEffectSoundPriorityLocality, OptionalLoopingStopAkEventSlotConfig) == 0x0001B8, "Member 'FP2StatusEffectSoundPriorityLocality::OptionalLoopingStopAkEventSlotConfig' has a wrong offset!");
static_assert(offsetof(FP2StatusEffectSoundPriorityLocality, FadeOutDurationSec) == 0x0001E8, "Member 'FP2StatusEffectSoundPriorityLocality::FadeOutDurationSec' has a wrong offset!");
static_assert(offsetof(FP2StatusEffectSoundPriorityLocality, bApplyBusEffects) == 0x0001EC, "Member 'FP2StatusEffectSoundPriorityLocality::bApplyBusEffects' has a wrong offset!");
static_assert(offsetof(FP2StatusEffectSoundPriorityLocality, BusEffectStartEvent) == 0x0001F0, "Member 'FP2StatusEffectSoundPriorityLocality::BusEffectStartEvent' has a wrong offset!");
static_assert(offsetof(FP2StatusEffectSoundPriorityLocality, BusEffectStopEvent) == 0x0001F8, "Member 'FP2StatusEffectSoundPriorityLocality::BusEffectStopEvent' has a wrong offset!");

// ScriptStruct Game.P2DeathData
// 0x0030 (0x0030 - 0x0000)
struct FP2DeathData final
{
public:
	EP2DeathState                                 State;                                             // 0x0000(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FP2FinalBlowImpulseData                FinalBlowData;                                     // 0x0008(0x0028)(NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FP2DeathData) == 0x000008, "Wrong alignment on FP2DeathData");
static_assert(sizeof(FP2DeathData) == 0x000030, "Wrong size on FP2DeathData");
static_assert(offsetof(FP2DeathData, State) == 0x000000, "Member 'FP2DeathData::State' has a wrong offset!");
static_assert(offsetof(FP2DeathData, FinalBlowData) == 0x000008, "Member 'FP2DeathData::FinalBlowData' has a wrong offset!");

// ScriptStruct Game.ControlRecoilInitialShotConfig
// 0x0018 (0x0018 - 0x0000)
struct FControlRecoilInitialShotConfig final
{
public:
	struct FVector2D                              MainBufferRange;                                   // 0x0000(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HorizontalRecoilScale;                             // 0x0010(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         VerticalRecoilScale;                               // 0x0014(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FControlRecoilInitialShotConfig) == 0x000008, "Wrong alignment on FControlRecoilInitialShotConfig");
static_assert(sizeof(FControlRecoilInitialShotConfig) == 0x000018, "Wrong size on FControlRecoilInitialShotConfig");
static_assert(offsetof(FControlRecoilInitialShotConfig, MainBufferRange) == 0x000000, "Member 'FControlRecoilInitialShotConfig::MainBufferRange' has a wrong offset!");
static_assert(offsetof(FControlRecoilInitialShotConfig, HorizontalRecoilScale) == 0x000010, "Member 'FControlRecoilInitialShotConfig::HorizontalRecoilScale' has a wrong offset!");
static_assert(offsetof(FControlRecoilInitialShotConfig, VerticalRecoilScale) == 0x000014, "Member 'FControlRecoilInitialShotConfig::VerticalRecoilScale' has a wrong offset!");

// ScriptStruct Game.P2ReplicatedAcceleration
// 0x0003 (0x0003 - 0x0000)
struct FP2ReplicatedAcceleration final
{
public:
	uint8                                         AccelXYRadians;                                    // 0x0000(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         AccelXYMagnitude;                                  // 0x0001(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int8                                          AccelZ;                                            // 0x0002(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FP2ReplicatedAcceleration) == 0x000001, "Wrong alignment on FP2ReplicatedAcceleration");
static_assert(sizeof(FP2ReplicatedAcceleration) == 0x000003, "Wrong size on FP2ReplicatedAcceleration");
static_assert(offsetof(FP2ReplicatedAcceleration, AccelXYRadians) == 0x000000, "Member 'FP2ReplicatedAcceleration::AccelXYRadians' has a wrong offset!");
static_assert(offsetof(FP2ReplicatedAcceleration, AccelXYMagnitude) == 0x000001, "Member 'FP2ReplicatedAcceleration::AccelXYMagnitude' has a wrong offset!");
static_assert(offsetof(FP2ReplicatedAcceleration, AccelZ) == 0x000002, "Member 'FP2ReplicatedAcceleration::AccelZ' has a wrong offset!");

// ScriptStruct Game.P2ReplicatedDownedState
// 0x0001 (0x0001 - 0x0000)
struct FP2ReplicatedDownedState final
{
public:
	bool                                          bIsDowned;                                         // 0x0000(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FP2ReplicatedDownedState) == 0x000001, "Wrong alignment on FP2ReplicatedDownedState");
static_assert(sizeof(FP2ReplicatedDownedState) == 0x000001, "Wrong size on FP2ReplicatedDownedState");
static_assert(offsetof(FP2ReplicatedDownedState, bIsDowned) == 0x000000, "Member 'FP2ReplicatedDownedState::bIsDowned' has a wrong offset!");

// ScriptStruct Game.P2HealthHudInfoProperty
// 0x0008 (0x0008 - 0x0000)
struct FP2HealthHudInfoProperty final
{
public:
	float                                         Value;                                             // 0x0000(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsSame;                                            // 0x0004(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5[0x3];                                        // 0x0005(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FP2HealthHudInfoProperty) == 0x000004, "Wrong alignment on FP2HealthHudInfoProperty");
static_assert(sizeof(FP2HealthHudInfoProperty) == 0x000008, "Wrong size on FP2HealthHudInfoProperty");
static_assert(offsetof(FP2HealthHudInfoProperty, Value) == 0x000000, "Member 'FP2HealthHudInfoProperty::Value' has a wrong offset!");
static_assert(offsetof(FP2HealthHudInfoProperty, IsSame) == 0x000004, "Member 'FP2HealthHudInfoProperty::IsSame' has a wrong offset!");

// ScriptStruct Game.P2HealthHudInfo
// 0x002C (0x002C - 0x0000)
struct FP2HealthHudInfo final
{
public:
	struct FP2HealthHudInfoProperty               MinHealth;                                         // 0x0000(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
	struct FP2HealthHudInfoProperty               MaxHealth;                                         // 0x0008(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
	float                                         MinBPM;                                            // 0x0010(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxBPM;                                            // 0x0014(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSlateColor                            Color;                                             // 0x0018(0x0014)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
};
static_assert(alignof(FP2HealthHudInfo) == 0x000004, "Wrong alignment on FP2HealthHudInfo");
static_assert(sizeof(FP2HealthHudInfo) == 0x00002C, "Wrong size on FP2HealthHudInfo");
static_assert(offsetof(FP2HealthHudInfo, MinHealth) == 0x000000, "Member 'FP2HealthHudInfo::MinHealth' has a wrong offset!");
static_assert(offsetof(FP2HealthHudInfo, MaxHealth) == 0x000008, "Member 'FP2HealthHudInfo::MaxHealth' has a wrong offset!");
static_assert(offsetof(FP2HealthHudInfo, MinBPM) == 0x000010, "Member 'FP2HealthHudInfo::MinBPM' has a wrong offset!");
static_assert(offsetof(FP2HealthHudInfo, MaxBPM) == 0x000014, "Member 'FP2HealthHudInfo::MaxBPM' has a wrong offset!");
static_assert(offsetof(FP2HealthHudInfo, Color) == 0x000018, "Member 'FP2HealthHudInfo::Color' has a wrong offset!");

// ScriptStruct Game.ImportantMessageInfo
// 0x0020 (0x0020 - 0x0000)
struct FImportantMessageInfo final
{
public:
	class FText                                   TxtMessage;                                        // 0x0000(0x0018)(NativeAccessSpecifierPublic)
	int8                                          Priority;                                          // 0x0018(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19[0x3];                                       // 0x0019(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         ShowDuration;                                      // 0x001C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FImportantMessageInfo) == 0x000008, "Wrong alignment on FImportantMessageInfo");
static_assert(sizeof(FImportantMessageInfo) == 0x000020, "Wrong size on FImportantMessageInfo");
static_assert(offsetof(FImportantMessageInfo, TxtMessage) == 0x000000, "Member 'FImportantMessageInfo::TxtMessage' has a wrong offset!");
static_assert(offsetof(FImportantMessageInfo, Priority) == 0x000018, "Member 'FImportantMessageInfo::Priority' has a wrong offset!");
static_assert(offsetof(FImportantMessageInfo, ShowDuration) == 0x00001C, "Member 'FImportantMessageInfo::ShowDuration' has a wrong offset!");

// ScriptStruct Game.P2InputMapping
// 0x0010 (0x0010 - 0x0000)
struct FP2InputMapping final
{
public:
	class UInputMappingContext*                   InputMappingContext;                               // 0x0000(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         InputPriority;                                     // 0x0008(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FP2InputMapping) == 0x000008, "Wrong alignment on FP2InputMapping");
static_assert(sizeof(FP2InputMapping) == 0x000010, "Wrong size on FP2InputMapping");
static_assert(offsetof(FP2InputMapping, InputMappingContext) == 0x000000, "Member 'FP2InputMapping::InputMappingContext' has a wrong offset!");
static_assert(offsetof(FP2InputMapping, InputPriority) == 0x000008, "Member 'FP2InputMapping::InputPriority' has a wrong offset!");

// ScriptStruct Game.P2ContainerLayoutVariable
// 0x000C (0x000C - 0x0000)
struct FP2ContainerLayoutVariable final
{
public:
	int32                                         Index;                                             // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FIntPoint                              Size;                                              // 0x0004(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FP2ContainerLayoutVariable) == 0x000004, "Wrong alignment on FP2ContainerLayoutVariable");
static_assert(sizeof(FP2ContainerLayoutVariable) == 0x00000C, "Wrong size on FP2ContainerLayoutVariable");
static_assert(offsetof(FP2ContainerLayoutVariable, Index) == 0x000000, "Member 'FP2ContainerLayoutVariable::Index' has a wrong offset!");
static_assert(offsetof(FP2ContainerLayoutVariable, Size) == 0x000004, "Member 'FP2ContainerLayoutVariable::Size' has a wrong offset!");

// ScriptStruct Game.P2ItemsExtractedMessage
// 0x0068 (0x0068 - 0x0000)
struct FP2ItemsExtractedMessage final
{
public:
	TWeakObjectPtr<class AP2HeroCharacter>        HeroCharacter;                                     // 0x0000(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FPrimaryAssetId>                ItemIdsExtracted;                                  // 0x0008(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TMap<struct FGameplayTag, int32>              LootContextTagsExtracted;                          // 0x0018(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
};
static_assert(alignof(FP2ItemsExtractedMessage) == 0x000008, "Wrong alignment on FP2ItemsExtractedMessage");
static_assert(sizeof(FP2ItemsExtractedMessage) == 0x000068, "Wrong size on FP2ItemsExtractedMessage");
static_assert(offsetof(FP2ItemsExtractedMessage, HeroCharacter) == 0x000000, "Member 'FP2ItemsExtractedMessage::HeroCharacter' has a wrong offset!");
static_assert(offsetof(FP2ItemsExtractedMessage, ItemIdsExtracted) == 0x000008, "Member 'FP2ItemsExtractedMessage::ItemIdsExtracted' has a wrong offset!");
static_assert(offsetof(FP2ItemsExtractedMessage, LootContextTagsExtracted) == 0x000018, "Member 'FP2ItemsExtractedMessage::LootContextTagsExtracted' has a wrong offset!");

// ScriptStruct Game.ItemTickFunction
// 0x0010 (0x0058 - 0x0048)
struct FItemTickFunction final : public FTickFunction
{
public:
	uint8                                         Pad_48[0x10];                                      // 0x0048(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FItemTickFunction) == 0x000008, "Wrong alignment on FItemTickFunction");
static_assert(sizeof(FItemTickFunction) == 0x000058, "Wrong size on FItemTickFunction");

// ScriptStruct Game.P2ItemHUDInfo
// 0x0160 (0x0160 - 0x0000)
struct FP2ItemHUDInfo final
{
public:
	TSubclassOf<class UP2ItemHUDWidgetComponent>  ComponentClass;                                    // 0x0000(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UUserWidget>                WidgetClass;                                       // 0x0008(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   AttachSocketName;                                  // 0x0010(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              DrawSize;                                          // 0x0018(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              Pivot;                                             // 0x0028(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_38[0x8];                                       // 0x0038(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             DefaultTransform;                                  // 0x0040(0x0060)(Edit, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FTransform                             TransformHip;                                      // 0x00A0(0x0060)(Edit, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FTransform                             TransformADS;                                      // 0x0100(0x0060)(Edit, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FP2ItemHUDInfo) == 0x000010, "Wrong alignment on FP2ItemHUDInfo");
static_assert(sizeof(FP2ItemHUDInfo) == 0x000160, "Wrong size on FP2ItemHUDInfo");
static_assert(offsetof(FP2ItemHUDInfo, ComponentClass) == 0x000000, "Member 'FP2ItemHUDInfo::ComponentClass' has a wrong offset!");
static_assert(offsetof(FP2ItemHUDInfo, WidgetClass) == 0x000008, "Member 'FP2ItemHUDInfo::WidgetClass' has a wrong offset!");
static_assert(offsetof(FP2ItemHUDInfo, AttachSocketName) == 0x000010, "Member 'FP2ItemHUDInfo::AttachSocketName' has a wrong offset!");
static_assert(offsetof(FP2ItemHUDInfo, DrawSize) == 0x000018, "Member 'FP2ItemHUDInfo::DrawSize' has a wrong offset!");
static_assert(offsetof(FP2ItemHUDInfo, Pivot) == 0x000028, "Member 'FP2ItemHUDInfo::Pivot' has a wrong offset!");
static_assert(offsetof(FP2ItemHUDInfo, DefaultTransform) == 0x000040, "Member 'FP2ItemHUDInfo::DefaultTransform' has a wrong offset!");
static_assert(offsetof(FP2ItemHUDInfo, TransformHip) == 0x0000A0, "Member 'FP2ItemHUDInfo::TransformHip' has a wrong offset!");
static_assert(offsetof(FP2ItemHUDInfo, TransformADS) == 0x000100, "Member 'FP2ItemHUDInfo::TransformADS' has a wrong offset!");

// ScriptStruct Game.SpreadStateContext
// 0x0030 (0x0030 - 0x0000)
struct FSpreadStateContext final
{
public:
	class UWeaponSpreadData*                      WeaponSpreadData;                                  // 0x0000(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_8[0x28];                                       // 0x0008(0x0028)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FSpreadStateContext) == 0x000008, "Wrong alignment on FSpreadStateContext");
static_assert(sizeof(FSpreadStateContext) == 0x000030, "Wrong size on FSpreadStateContext");
static_assert(offsetof(FSpreadStateContext, WeaponSpreadData) == 0x000000, "Member 'FSpreadStateContext::WeaponSpreadData' has a wrong offset!");

// ScriptStruct Game.P2EquipmentMessage_AttributesChanged
// 0x0020 (0x0028 - 0x0008)
struct FP2EquipmentMessage_AttributesChanged final : public FP2EquipmentMessage
{
public:
	struct FP2EquipmentAttributes                 NewAttributes;                                     // 0x0008(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
	struct FP2EquipmentAttributes                 PreviousAttributes;                                // 0x0010(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
	class UP2Item*                                ItemInstigator;                                    // 0x0018(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAdded;                                            // 0x0020(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_21[0x3];                                       // 0x0021(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         StackDelta;                                        // 0x0024(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FP2EquipmentMessage_AttributesChanged) == 0x000008, "Wrong alignment on FP2EquipmentMessage_AttributesChanged");
static_assert(sizeof(FP2EquipmentMessage_AttributesChanged) == 0x000028, "Wrong size on FP2EquipmentMessage_AttributesChanged");
static_assert(offsetof(FP2EquipmentMessage_AttributesChanged, NewAttributes) == 0x000008, "Member 'FP2EquipmentMessage_AttributesChanged::NewAttributes' has a wrong offset!");
static_assert(offsetof(FP2EquipmentMessage_AttributesChanged, PreviousAttributes) == 0x000010, "Member 'FP2EquipmentMessage_AttributesChanged::PreviousAttributes' has a wrong offset!");
static_assert(offsetof(FP2EquipmentMessage_AttributesChanged, ItemInstigator) == 0x000018, "Member 'FP2EquipmentMessage_AttributesChanged::ItemInstigator' has a wrong offset!");
static_assert(offsetof(FP2EquipmentMessage_AttributesChanged, bAdded) == 0x000020, "Member 'FP2EquipmentMessage_AttributesChanged::bAdded' has a wrong offset!");
static_assert(offsetof(FP2EquipmentMessage_AttributesChanged, StackDelta) == 0x000024, "Member 'FP2EquipmentMessage_AttributesChanged::StackDelta' has a wrong offset!");

// ScriptStruct Game.P2InventoryMessage_ItemUsageFailure
// 0x0028 (0x0028 - 0x0000)
struct FP2InventoryMessage_ItemUsageFailure final
{
public:
	EItemActionFailedType                         FailedType;                                        // 0x0000(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   FailedReason;                                      // 0x0008(0x0018)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	class UP2ItemData*                            ItemData;                                          // 0x0020(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FP2InventoryMessage_ItemUsageFailure) == 0x000008, "Wrong alignment on FP2InventoryMessage_ItemUsageFailure");
static_assert(sizeof(FP2InventoryMessage_ItemUsageFailure) == 0x000028, "Wrong size on FP2InventoryMessage_ItemUsageFailure");
static_assert(offsetof(FP2InventoryMessage_ItemUsageFailure, FailedType) == 0x000000, "Member 'FP2InventoryMessage_ItemUsageFailure::FailedType' has a wrong offset!");
static_assert(offsetof(FP2InventoryMessage_ItemUsageFailure, FailedReason) == 0x000008, "Member 'FP2InventoryMessage_ItemUsageFailure::FailedReason' has a wrong offset!");
static_assert(offsetof(FP2InventoryMessage_ItemUsageFailure, ItemData) == 0x000020, "Member 'FP2InventoryMessage_ItemUsageFailure::ItemData' has a wrong offset!");

// ScriptStruct Game.AimDownSightProcessor
// 0x000C (0x000C - 0x0000)
struct alignas(0x04) FAimDownSightProcessor final
{
public:
	uint8                                         Pad_0[0xC];                                        // 0x0000(0x000C)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FAimDownSightProcessor) == 0x000004, "Wrong alignment on FAimDownSightProcessor");
static_assert(sizeof(FAimDownSightProcessor) == 0x00000C, "Wrong size on FAimDownSightProcessor");

// ScriptStruct Game.P2InstancedPerspectiveMeshComponents
// 0x0018 (0x0018 - 0x0000)
struct FP2InstancedPerspectiveMeshComponents final
{
public:
	TWeakObjectPtr<class UMeshComponent>          FppMeshComponent;                                  // 0x0000(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, InstancedReference, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TWeakObjectPtr<class UMeshComponent>          TppMeshComponent;                                  // 0x0008(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, InstancedReference, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TWeakObjectPtr<class UMeshComponent>          FakeBodyMeshComponent;                             // 0x0010(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, InstancedReference, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FP2InstancedPerspectiveMeshComponents) == 0x000004, "Wrong alignment on FP2InstancedPerspectiveMeshComponents");
static_assert(sizeof(FP2InstancedPerspectiveMeshComponents) == 0x000018, "Wrong size on FP2InstancedPerspectiveMeshComponents");
static_assert(offsetof(FP2InstancedPerspectiveMeshComponents, FppMeshComponent) == 0x000000, "Member 'FP2InstancedPerspectiveMeshComponents::FppMeshComponent' has a wrong offset!");
static_assert(offsetof(FP2InstancedPerspectiveMeshComponents, TppMeshComponent) == 0x000008, "Member 'FP2InstancedPerspectiveMeshComponents::TppMeshComponent' has a wrong offset!");
static_assert(offsetof(FP2InstancedPerspectiveMeshComponents, FakeBodyMeshComponent) == 0x000010, "Member 'FP2InstancedPerspectiveMeshComponents::FakeBodyMeshComponent' has a wrong offset!");

// ScriptStruct Game.P2ItemDataAmount
// 0x0010 (0x0010 - 0x0000)
struct FP2ItemDataAmount final
{
public:
	class UP2ItemData*                            ItemData;                                          // 0x0000(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Amount;                                            // 0x0008(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FP2ItemDataAmount) == 0x000008, "Wrong alignment on FP2ItemDataAmount");
static_assert(sizeof(FP2ItemDataAmount) == 0x000010, "Wrong size on FP2ItemDataAmount");
static_assert(offsetof(FP2ItemDataAmount, ItemData) == 0x000000, "Member 'FP2ItemDataAmount::ItemData' has a wrong offset!");
static_assert(offsetof(FP2ItemDataAmount, Amount) == 0x000008, "Member 'FP2ItemDataAmount::Amount' has a wrong offset!");

// ScriptStruct Game.P2AttributeGameplayCueInfo
// 0x00B0 (0x00B0 - 0x0000)
struct FP2AttributeGameplayCueInfo final
{
public:
	struct FGameplayCueTag                        Cue;                                               // 0x0000(0x0008)(Edit, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
	struct FGameplayAttribute                     Attribute;                                         // 0x0008(0x0038)(Edit, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 AttributeRtpc;                                     // 0x0040(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FFloatRange                            AttributeRange;                                    // 0x0050(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ExtraSlackForCueRemoval;                           // 0x0060(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_64[0x4];                                       // 0x0064(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTagContainer                  RequireTags;                                       // 0x0068(0x0020)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FGameplayTagContainer                  IgnoreTags;                                        // 0x0088(0x0020)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	bool                                          bPlayOnLocal;                                      // 0x00A8(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bPlayOnRemote;                                     // 0x00A9(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bPlayOnServer;                                     // 0x00AA(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUseAttributeRtpc;                                 // 0x00AB(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_AC[0x4];                                       // 0x00AC(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FP2AttributeGameplayCueInfo) == 0x000008, "Wrong alignment on FP2AttributeGameplayCueInfo");
static_assert(sizeof(FP2AttributeGameplayCueInfo) == 0x0000B0, "Wrong size on FP2AttributeGameplayCueInfo");
static_assert(offsetof(FP2AttributeGameplayCueInfo, Cue) == 0x000000, "Member 'FP2AttributeGameplayCueInfo::Cue' has a wrong offset!");
static_assert(offsetof(FP2AttributeGameplayCueInfo, Attribute) == 0x000008, "Member 'FP2AttributeGameplayCueInfo::Attribute' has a wrong offset!");
static_assert(offsetof(FP2AttributeGameplayCueInfo, AttributeRtpc) == 0x000040, "Member 'FP2AttributeGameplayCueInfo::AttributeRtpc' has a wrong offset!");
static_assert(offsetof(FP2AttributeGameplayCueInfo, AttributeRange) == 0x000050, "Member 'FP2AttributeGameplayCueInfo::AttributeRange' has a wrong offset!");
static_assert(offsetof(FP2AttributeGameplayCueInfo, ExtraSlackForCueRemoval) == 0x000060, "Member 'FP2AttributeGameplayCueInfo::ExtraSlackForCueRemoval' has a wrong offset!");
static_assert(offsetof(FP2AttributeGameplayCueInfo, RequireTags) == 0x000068, "Member 'FP2AttributeGameplayCueInfo::RequireTags' has a wrong offset!");
static_assert(offsetof(FP2AttributeGameplayCueInfo, IgnoreTags) == 0x000088, "Member 'FP2AttributeGameplayCueInfo::IgnoreTags' has a wrong offset!");
static_assert(offsetof(FP2AttributeGameplayCueInfo, bPlayOnLocal) == 0x0000A8, "Member 'FP2AttributeGameplayCueInfo::bPlayOnLocal' has a wrong offset!");
static_assert(offsetof(FP2AttributeGameplayCueInfo, bPlayOnRemote) == 0x0000A9, "Member 'FP2AttributeGameplayCueInfo::bPlayOnRemote' has a wrong offset!");
static_assert(offsetof(FP2AttributeGameplayCueInfo, bPlayOnServer) == 0x0000AA, "Member 'FP2AttributeGameplayCueInfo::bPlayOnServer' has a wrong offset!");
static_assert(offsetof(FP2AttributeGameplayCueInfo, bUseAttributeRtpc) == 0x0000AB, "Member 'FP2AttributeGameplayCueInfo::bUseAttributeRtpc' has a wrong offset!");

// ScriptStruct Game.P2TargetingLaserConfig
// 0x0058 (0x0058 - 0x0000)
struct alignas(0x08) FP2TargetingLaserConfig final
{
public:
	struct FGameplayTag                           SlotTag;                                           // 0x0000(0x0008)(Edit, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2f                              TargetAreaMin;                                     // 0x0008(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2f                              TargetAreaMax;                                     // 0x0010(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LaserRotationSpeed;                                // 0x0018(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TWeakObjectPtr<class UP2Laser>                LaserItem;                                         // 0x001C(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_24[0x34];                                      // 0x0024(0x0034)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FP2TargetingLaserConfig) == 0x000008, "Wrong alignment on FP2TargetingLaserConfig");
static_assert(sizeof(FP2TargetingLaserConfig) == 0x000058, "Wrong size on FP2TargetingLaserConfig");
static_assert(offsetof(FP2TargetingLaserConfig, SlotTag) == 0x000000, "Member 'FP2TargetingLaserConfig::SlotTag' has a wrong offset!");
static_assert(offsetof(FP2TargetingLaserConfig, TargetAreaMin) == 0x000008, "Member 'FP2TargetingLaserConfig::TargetAreaMin' has a wrong offset!");
static_assert(offsetof(FP2TargetingLaserConfig, TargetAreaMax) == 0x000010, "Member 'FP2TargetingLaserConfig::TargetAreaMax' has a wrong offset!");
static_assert(offsetof(FP2TargetingLaserConfig, LaserRotationSpeed) == 0x000018, "Member 'FP2TargetingLaserConfig::LaserRotationSpeed' has a wrong offset!");
static_assert(offsetof(FP2TargetingLaserConfig, LaserItem) == 0x00001C, "Member 'FP2TargetingLaserConfig::LaserItem' has a wrong offset!");

// ScriptStruct Game.P2GameplayCueNotify_SpawnResult
// 0x0058 (0x0058 - 0x0000)
struct FP2GameplayCueNotify_SpawnResult final
{
public:
	TArray<class UFXSystemComponent*>             FxSystemComponents;                                // 0x0000(0x0010)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, Transient, ContainsInstancedReference, UObjectWrapper, NativeAccessSpecifierPublic)
	TArray<struct FP2AkPlayingEventInfo>          AudioEvents;                                       // 0x0010(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, NativeAccessSpecifierPublic)
	TArray<class UCameraShakeBase*>               CameraShakes;                                      // 0x0020(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, UObjectWrapper, NativeAccessSpecifierPublic)
	TArray<TScriptInterface<class ICameraLensEffectInterface>> CameraLensEffects;                    // 0x0030(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, UObjectWrapper, NativeAccessSpecifierPublic)
	class UForceFeedbackComponent*                ForceFeedbackComponent;                            // 0x0040(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, Transient, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class APlayerController*                      ForceFeedbackTargetPC;                             // 0x0048(0x0008)(ZeroConstructor, Transient, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UDecalComponent*                        DecalComponent;                                    // 0x0050(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, Transient, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FP2GameplayCueNotify_SpawnResult) == 0x000008, "Wrong alignment on FP2GameplayCueNotify_SpawnResult");
static_assert(sizeof(FP2GameplayCueNotify_SpawnResult) == 0x000058, "Wrong size on FP2GameplayCueNotify_SpawnResult");
static_assert(offsetof(FP2GameplayCueNotify_SpawnResult, FxSystemComponents) == 0x000000, "Member 'FP2GameplayCueNotify_SpawnResult::FxSystemComponents' has a wrong offset!");
static_assert(offsetof(FP2GameplayCueNotify_SpawnResult, AudioEvents) == 0x000010, "Member 'FP2GameplayCueNotify_SpawnResult::AudioEvents' has a wrong offset!");
static_assert(offsetof(FP2GameplayCueNotify_SpawnResult, CameraShakes) == 0x000020, "Member 'FP2GameplayCueNotify_SpawnResult::CameraShakes' has a wrong offset!");
static_assert(offsetof(FP2GameplayCueNotify_SpawnResult, CameraLensEffects) == 0x000030, "Member 'FP2GameplayCueNotify_SpawnResult::CameraLensEffects' has a wrong offset!");
static_assert(offsetof(FP2GameplayCueNotify_SpawnResult, ForceFeedbackComponent) == 0x000040, "Member 'FP2GameplayCueNotify_SpawnResult::ForceFeedbackComponent' has a wrong offset!");
static_assert(offsetof(FP2GameplayCueNotify_SpawnResult, ForceFeedbackTargetPC) == 0x000048, "Member 'FP2GameplayCueNotify_SpawnResult::ForceFeedbackTargetPC' has a wrong offset!");
static_assert(offsetof(FP2GameplayCueNotify_SpawnResult, DecalComponent) == 0x000050, "Member 'FP2GameplayCueNotify_SpawnResult::DecalComponent' has a wrong offset!");

// ScriptStruct Game.P2ItemIconCache
// 0x0038 (0x0038 - 0x0000)
struct FP2ItemIconCache final
{
public:
	class UTexture*                               IconTexture;                                       // 0x0000(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_8[0x30];                                       // 0x0008(0x0030)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FP2ItemIconCache) == 0x000008, "Wrong alignment on FP2ItemIconCache");
static_assert(sizeof(FP2ItemIconCache) == 0x000038, "Wrong size on FP2ItemIconCache");
static_assert(offsetof(FP2ItemIconCache, IconTexture) == 0x000000, "Member 'FP2ItemIconCache::IconTexture' has a wrong offset!");

// ScriptStruct Game.P2ItemIconSubscriberMap
// 0x0050 (0x0050 - 0x0000)
struct FP2ItemIconSubscriberMap final
{
public:
	TMap<uint64, struct FP2ItemIconSubscriber>    SubscriberMap;                                     // 0x0000(0x0050)(Transient, NativeAccessSpecifierPublic)
};
static_assert(alignof(FP2ItemIconSubscriberMap) == 0x000008, "Wrong alignment on FP2ItemIconSubscriberMap");
static_assert(sizeof(FP2ItemIconSubscriberMap) == 0x000050, "Wrong size on FP2ItemIconSubscriberMap");
static_assert(offsetof(FP2ItemIconSubscriberMap, SubscriberMap) == 0x000000, "Member 'FP2ItemIconSubscriberMap::SubscriberMap' has a wrong offset!");

// ScriptStruct Game.P2SpeakerArrayChannelEventConfig
// 0x0010 (0x0010 - 0x0000)
struct FP2SpeakerArrayChannelEventConfig final
{
public:
	class UAkAudioEvent*                          AkStartEvent;                                      // 0x0000(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAkAudioEvent*                          AkStopEvent;                                       // 0x0008(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FP2SpeakerArrayChannelEventConfig) == 0x000008, "Wrong alignment on FP2SpeakerArrayChannelEventConfig");
static_assert(sizeof(FP2SpeakerArrayChannelEventConfig) == 0x000010, "Wrong size on FP2SpeakerArrayChannelEventConfig");
static_assert(offsetof(FP2SpeakerArrayChannelEventConfig, AkStartEvent) == 0x000000, "Member 'FP2SpeakerArrayChannelEventConfig::AkStartEvent' has a wrong offset!");
static_assert(offsetof(FP2SpeakerArrayChannelEventConfig, AkStopEvent) == 0x000008, "Member 'FP2SpeakerArrayChannelEventConfig::AkStopEvent' has a wrong offset!");

// ScriptStruct Game.P2ItemDataIconCallback
// 0x0018 (0x0018 - 0x0000)
struct alignas(0x08) FP2ItemDataIconCallback final
{
public:
	uint8                                         Pad_0[0x18];                                       // 0x0000(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FP2ItemDataIconCallback) == 0x000008, "Wrong alignment on FP2ItemDataIconCallback");
static_assert(sizeof(FP2ItemDataIconCallback) == 0x000018, "Wrong size on FP2ItemDataIconCallback");

// ScriptStruct Game.P2RenderItemInfo
// 0x0018 (0x0018 - 0x0000)
struct alignas(0x04) FP2RenderItemInfo final
{
public:
	uint8                                         Pad_0[0x18];                                       // 0x0000(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FP2RenderItemInfo) == 0x000004, "Wrong alignment on FP2RenderItemInfo");
static_assert(sizeof(FP2RenderItemInfo) == 0x000018, "Wrong size on FP2RenderItemInfo");

// ScriptStruct Game.P2FaunaSnapToFoliageSpeciesCollectionSettings
// 0x0004 (0x0004 - 0x0000)
struct FP2FaunaSnapToFoliageSpeciesCollectionSettings final
{
public:
	float                                         TriggerChance;                                     // 0x0000(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FP2FaunaSnapToFoliageSpeciesCollectionSettings) == 0x000004, "Wrong alignment on FP2FaunaSnapToFoliageSpeciesCollectionSettings");
static_assert(sizeof(FP2FaunaSnapToFoliageSpeciesCollectionSettings) == 0x000004, "Wrong size on FP2FaunaSnapToFoliageSpeciesCollectionSettings");
static_assert(offsetof(FP2FaunaSnapToFoliageSpeciesCollectionSettings, TriggerChance) == 0x000000, "Member 'FP2FaunaSnapToFoliageSpeciesCollectionSettings::TriggerChance' has a wrong offset!");

// ScriptStruct Game.P2ItemStatAccessorParams
// 0x0128 (0x0128 - 0x0000)
struct FP2ItemStatAccessorParams final
{
public:
	class FText                                   Title;                                             // 0x0000(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	class FText                                   Units;                                             // 0x0018(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FGameplayTag                           Stat;                                              // 0x0030(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           ScalingStat;                                       // 0x0038(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TMap<EP2StatWidgetType, TSubclassOf<class UP2ItemStatWidget>> StatWidgetClassMap;                // 0x0040(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, UObjectWrapper, NativeAccessSpecifierPublic)
	float                                         DefaultValue;                                      // 0x0090(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Weight;                                            // 0x0094(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MinValue;                                          // 0x0098(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxValue;                                          // 0x009C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ERoundingMode                                 RoundingMode;                                      // 0x00A0(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A1[0x3];                                       // 0x00A1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         MinimumFractionalDigits;                           // 0x00A4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MaximumFractionalDigits;                           // 0x00A8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bHigherIsBetter;                                   // 0x00AC(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bShow;                                             // 0x00AD(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUseDefaultValue;                                  // 0x00AE(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDisplayAsPercent;                                 // 0x00AF(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bReverseSign;                                      // 0x00B0(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAlwaysShowSign;                                   // 0x00B1(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_B2[0x2];                                       // 0x00B2(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         Priority;                                          // 0x00B4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EP2StatSpanType                               SpanType;                                          // 0x00B8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_BC[0x4];                                       // 0x00BC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   DefaultTooltipText;                                // 0x00C0(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TMap<EP2StatWidgetType, TSubclassOf<class UP2BaseTooltipWidget>> TooltipWidgetClassMap;          // 0x00D8(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, UObjectWrapper, NativeAccessSpecifierPublic)
};
static_assert(alignof(FP2ItemStatAccessorParams) == 0x000008, "Wrong alignment on FP2ItemStatAccessorParams");
static_assert(sizeof(FP2ItemStatAccessorParams) == 0x000128, "Wrong size on FP2ItemStatAccessorParams");
static_assert(offsetof(FP2ItemStatAccessorParams, Title) == 0x000000, "Member 'FP2ItemStatAccessorParams::Title' has a wrong offset!");
static_assert(offsetof(FP2ItemStatAccessorParams, Units) == 0x000018, "Member 'FP2ItemStatAccessorParams::Units' has a wrong offset!");
static_assert(offsetof(FP2ItemStatAccessorParams, Stat) == 0x000030, "Member 'FP2ItemStatAccessorParams::Stat' has a wrong offset!");
static_assert(offsetof(FP2ItemStatAccessorParams, ScalingStat) == 0x000038, "Member 'FP2ItemStatAccessorParams::ScalingStat' has a wrong offset!");
static_assert(offsetof(FP2ItemStatAccessorParams, StatWidgetClassMap) == 0x000040, "Member 'FP2ItemStatAccessorParams::StatWidgetClassMap' has a wrong offset!");
static_assert(offsetof(FP2ItemStatAccessorParams, DefaultValue) == 0x000090, "Member 'FP2ItemStatAccessorParams::DefaultValue' has a wrong offset!");
static_assert(offsetof(FP2ItemStatAccessorParams, Weight) == 0x000094, "Member 'FP2ItemStatAccessorParams::Weight' has a wrong offset!");
static_assert(offsetof(FP2ItemStatAccessorParams, MinValue) == 0x000098, "Member 'FP2ItemStatAccessorParams::MinValue' has a wrong offset!");
static_assert(offsetof(FP2ItemStatAccessorParams, MaxValue) == 0x00009C, "Member 'FP2ItemStatAccessorParams::MaxValue' has a wrong offset!");
static_assert(offsetof(FP2ItemStatAccessorParams, RoundingMode) == 0x0000A0, "Member 'FP2ItemStatAccessorParams::RoundingMode' has a wrong offset!");
static_assert(offsetof(FP2ItemStatAccessorParams, MinimumFractionalDigits) == 0x0000A4, "Member 'FP2ItemStatAccessorParams::MinimumFractionalDigits' has a wrong offset!");
static_assert(offsetof(FP2ItemStatAccessorParams, MaximumFractionalDigits) == 0x0000A8, "Member 'FP2ItemStatAccessorParams::MaximumFractionalDigits' has a wrong offset!");
static_assert(offsetof(FP2ItemStatAccessorParams, bHigherIsBetter) == 0x0000AC, "Member 'FP2ItemStatAccessorParams::bHigherIsBetter' has a wrong offset!");
static_assert(offsetof(FP2ItemStatAccessorParams, bShow) == 0x0000AD, "Member 'FP2ItemStatAccessorParams::bShow' has a wrong offset!");
static_assert(offsetof(FP2ItemStatAccessorParams, bUseDefaultValue) == 0x0000AE, "Member 'FP2ItemStatAccessorParams::bUseDefaultValue' has a wrong offset!");
static_assert(offsetof(FP2ItemStatAccessorParams, bDisplayAsPercent) == 0x0000AF, "Member 'FP2ItemStatAccessorParams::bDisplayAsPercent' has a wrong offset!");
static_assert(offsetof(FP2ItemStatAccessorParams, bReverseSign) == 0x0000B0, "Member 'FP2ItemStatAccessorParams::bReverseSign' has a wrong offset!");
static_assert(offsetof(FP2ItemStatAccessorParams, bAlwaysShowSign) == 0x0000B1, "Member 'FP2ItemStatAccessorParams::bAlwaysShowSign' has a wrong offset!");
static_assert(offsetof(FP2ItemStatAccessorParams, Priority) == 0x0000B4, "Member 'FP2ItemStatAccessorParams::Priority' has a wrong offset!");
static_assert(offsetof(FP2ItemStatAccessorParams, SpanType) == 0x0000B8, "Member 'FP2ItemStatAccessorParams::SpanType' has a wrong offset!");
static_assert(offsetof(FP2ItemStatAccessorParams, DefaultTooltipText) == 0x0000C0, "Member 'FP2ItemStatAccessorParams::DefaultTooltipText' has a wrong offset!");
static_assert(offsetof(FP2ItemStatAccessorParams, TooltipWidgetClassMap) == 0x0000D8, "Member 'FP2ItemStatAccessorParams::TooltipWidgetClassMap' has a wrong offset!");

// ScriptStruct Game.P2ItemDBEntry
// 0x0038 (0x0038 - 0x0000)
struct FP2ItemDBEntry final
{
public:
	TSoftObjectPtr<class UP2ItemData>             ItemData;                                          // 0x0000(0x0030)(UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           Tag;                                               // 0x0030(0x0008)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FP2ItemDBEntry) == 0x000008, "Wrong alignment on FP2ItemDBEntry");
static_assert(sizeof(FP2ItemDBEntry) == 0x000038, "Wrong size on FP2ItemDBEntry");
static_assert(offsetof(FP2ItemDBEntry, ItemData) == 0x000000, "Member 'FP2ItemDBEntry::ItemData' has a wrong offset!");
static_assert(offsetof(FP2ItemDBEntry, Tag) == 0x000030, "Member 'FP2ItemDBEntry::Tag' has a wrong offset!");

// ScriptStruct Game.P2IvPlantAudioConfig
// 0x0040 (0x0040 - 0x0000)
struct FP2IvPlantAudioConfig final
{
public:
	class UCurveFloat*                            FadeoutTimeMsCurve;                                // 0x0000(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EAkCurveInterpolation                         FadeoutCurve;                                      // 0x0008(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FAkEventSlotConfig                     EventConfig;                                       // 0x0010(0x0030)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FP2IvPlantAudioConfig) == 0x000008, "Wrong alignment on FP2IvPlantAudioConfig");
static_assert(sizeof(FP2IvPlantAudioConfig) == 0x000040, "Wrong size on FP2IvPlantAudioConfig");
static_assert(offsetof(FP2IvPlantAudioConfig, FadeoutTimeMsCurve) == 0x000000, "Member 'FP2IvPlantAudioConfig::FadeoutTimeMsCurve' has a wrong offset!");
static_assert(offsetof(FP2IvPlantAudioConfig, FadeoutCurve) == 0x000008, "Member 'FP2IvPlantAudioConfig::FadeoutCurve' has a wrong offset!");
static_assert(offsetof(FP2IvPlantAudioConfig, EventConfig) == 0x000010, "Member 'FP2IvPlantAudioConfig::EventConfig' has a wrong offset!");

// ScriptStruct Game.P2ColorMapIntegrationSettings
// 0x001C (0x001C - 0x0000)
struct FP2ColorMapIntegrationSettings final
{
public:
	float                                         ALPHA;                                             // 0x0000(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RMax;                                              // 0x0004(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DRadius;                                           // 0x0008(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RMin;                                              // 0x000C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CacheGridSize;                                     // 0x0010(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         RadialSlices;                                      // 0x0014(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         LogTermCount;                                      // 0x0018(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FP2ColorMapIntegrationSettings) == 0x000004, "Wrong alignment on FP2ColorMapIntegrationSettings");
static_assert(sizeof(FP2ColorMapIntegrationSettings) == 0x00001C, "Wrong size on FP2ColorMapIntegrationSettings");
static_assert(offsetof(FP2ColorMapIntegrationSettings, ALPHA) == 0x000000, "Member 'FP2ColorMapIntegrationSettings::ALPHA' has a wrong offset!");
static_assert(offsetof(FP2ColorMapIntegrationSettings, RMax) == 0x000004, "Member 'FP2ColorMapIntegrationSettings::RMax' has a wrong offset!");
static_assert(offsetof(FP2ColorMapIntegrationSettings, DRadius) == 0x000008, "Member 'FP2ColorMapIntegrationSettings::DRadius' has a wrong offset!");
static_assert(offsetof(FP2ColorMapIntegrationSettings, RMin) == 0x00000C, "Member 'FP2ColorMapIntegrationSettings::RMin' has a wrong offset!");
static_assert(offsetof(FP2ColorMapIntegrationSettings, CacheGridSize) == 0x000010, "Member 'FP2ColorMapIntegrationSettings::CacheGridSize' has a wrong offset!");
static_assert(offsetof(FP2ColorMapIntegrationSettings, RadialSlices) == 0x000014, "Member 'FP2ColorMapIntegrationSettings::RadialSlices' has a wrong offset!");
static_assert(offsetof(FP2ColorMapIntegrationSettings, LogTermCount) == 0x000018, "Member 'FP2ColorMapIntegrationSettings::LogTermCount' has a wrong offset!");

// ScriptStruct Game.P2ColorMapGunTailConfig
// 0x0034 (0x0034 - 0x0000)
struct FP2ColorMapGunTailConfig final
{
public:
	class FName                                   Name;                                              // 0x0000(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EP2RegionColor                                Color;                                             // 0x0008(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x3];                                        // 0x0009(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   RtpcName;                                          // 0x000C(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BlendBias;                                         // 0x0014(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FP2ColorMapIntegrationSettings         IntegrationSettings;                               // 0x0018(0x001C)(Edit, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FP2ColorMapGunTailConfig) == 0x000004, "Wrong alignment on FP2ColorMapGunTailConfig");
static_assert(sizeof(FP2ColorMapGunTailConfig) == 0x000034, "Wrong size on FP2ColorMapGunTailConfig");
static_assert(offsetof(FP2ColorMapGunTailConfig, Name) == 0x000000, "Member 'FP2ColorMapGunTailConfig::Name' has a wrong offset!");
static_assert(offsetof(FP2ColorMapGunTailConfig, Color) == 0x000008, "Member 'FP2ColorMapGunTailConfig::Color' has a wrong offset!");
static_assert(offsetof(FP2ColorMapGunTailConfig, RtpcName) == 0x00000C, "Member 'FP2ColorMapGunTailConfig::RtpcName' has a wrong offset!");
static_assert(offsetof(FP2ColorMapGunTailConfig, BlendBias) == 0x000014, "Member 'FP2ColorMapGunTailConfig::BlendBias' has a wrong offset!");
static_assert(offsetof(FP2ColorMapGunTailConfig, IntegrationSettings) == 0x000018, "Member 'FP2ColorMapGunTailConfig::IntegrationSettings' has a wrong offset!");

// ScriptStruct Game.P2LevelVolumeInfo
// 0x0010 (0x0010 - 0x0000)
struct FP2LevelVolumeInfo final
{
public:
	struct FGameplayTag                           LevelTag;                                          // 0x0000(0x0008)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   DataLayerName;                                     // 0x0008(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FP2LevelVolumeInfo) == 0x000004, "Wrong alignment on FP2LevelVolumeInfo");
static_assert(sizeof(FP2LevelVolumeInfo) == 0x000010, "Wrong size on FP2LevelVolumeInfo");
static_assert(offsetof(FP2LevelVolumeInfo, LevelTag) == 0x000000, "Member 'FP2LevelVolumeInfo::LevelTag' has a wrong offset!");
static_assert(offsetof(FP2LevelVolumeInfo, DataLayerName) == 0x000008, "Member 'FP2LevelVolumeInfo::DataLayerName' has a wrong offset!");

// ScriptStruct Game.P2PercentageConfigTagPair
// 0x000C (0x000C - 0x0000)
struct FP2PercentageConfigTagPair final
{
public:
	float                                         Percentage;                                        // 0x0000(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           Config;                                            // 0x0004(0x0008)(Edit, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FP2PercentageConfigTagPair) == 0x000004, "Wrong alignment on FP2PercentageConfigTagPair");
static_assert(sizeof(FP2PercentageConfigTagPair) == 0x00000C, "Wrong size on FP2PercentageConfigTagPair");
static_assert(offsetof(FP2PercentageConfigTagPair, Percentage) == 0x000000, "Member 'FP2PercentageConfigTagPair::Percentage' has a wrong offset!");
static_assert(offsetof(FP2PercentageConfigTagPair, Config) == 0x000004, "Member 'FP2PercentageConfigTagPair::Config' has a wrong offset!");

// ScriptStruct Game.P2LockRandomizationConfiguration
// 0x0010 (0x0010 - 0x0000)
struct FP2LockRandomizationConfiguration final
{
public:
	TArray<struct FP2PercentageConfigTagPair>     Configurations;                                    // 0x0000(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
};
static_assert(alignof(FP2LockRandomizationConfiguration) == 0x000008, "Wrong alignment on FP2LockRandomizationConfiguration");
static_assert(sizeof(FP2LockRandomizationConfiguration) == 0x000010, "Wrong size on FP2LockRandomizationConfiguration");
static_assert(offsetof(FP2LockRandomizationConfiguration, Configurations) == 0x000000, "Member 'FP2LockRandomizationConfiguration::Configurations' has a wrong offset!");

// ScriptStruct Game.P2LockMeshConfiguration
// 0x00F0 (0x00F0 - 0x0000)
struct FP2LockMeshConfiguration final
{
public:
	TArray<struct FP2LockMeshWrapper>             HealthMeshArray;                                   // 0x0000(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, ContainsInstancedReference, NativeAccessSpecifierPublic)
	float                                         MaxHealth;                                         // 0x0010(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0xC];                                       // 0x0014(0x000C)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             MeshSpawnOffset;                                   // 0x0020(0x0060)(Edit, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class FName>                           LockpickMountSocketNames;                          // 0x0080(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TMap<EP2HitType, float>                       HitTypeMultipliers;                                // 0x0090(0x0050)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	bool                                          bCanBeDamaged;                                     // 0x00E0(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bShouldDestroyMesh;                                // 0x00E1(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_E2[0x2];                                       // 0x00E2(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTag                           DestroyedGameplayCue;                              // 0x00E4(0x0008)(Edit, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_EC[0x4];                                       // 0x00EC(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FP2LockMeshConfiguration) == 0x000010, "Wrong alignment on FP2LockMeshConfiguration");
static_assert(sizeof(FP2LockMeshConfiguration) == 0x0000F0, "Wrong size on FP2LockMeshConfiguration");
static_assert(offsetof(FP2LockMeshConfiguration, HealthMeshArray) == 0x000000, "Member 'FP2LockMeshConfiguration::HealthMeshArray' has a wrong offset!");
static_assert(offsetof(FP2LockMeshConfiguration, MaxHealth) == 0x000010, "Member 'FP2LockMeshConfiguration::MaxHealth' has a wrong offset!");
static_assert(offsetof(FP2LockMeshConfiguration, MeshSpawnOffset) == 0x000020, "Member 'FP2LockMeshConfiguration::MeshSpawnOffset' has a wrong offset!");
static_assert(offsetof(FP2LockMeshConfiguration, LockpickMountSocketNames) == 0x000080, "Member 'FP2LockMeshConfiguration::LockpickMountSocketNames' has a wrong offset!");
static_assert(offsetof(FP2LockMeshConfiguration, HitTypeMultipliers) == 0x000090, "Member 'FP2LockMeshConfiguration::HitTypeMultipliers' has a wrong offset!");
static_assert(offsetof(FP2LockMeshConfiguration, bCanBeDamaged) == 0x0000E0, "Member 'FP2LockMeshConfiguration::bCanBeDamaged' has a wrong offset!");
static_assert(offsetof(FP2LockMeshConfiguration, bShouldDestroyMesh) == 0x0000E1, "Member 'FP2LockMeshConfiguration::bShouldDestroyMesh' has a wrong offset!");
static_assert(offsetof(FP2LockMeshConfiguration, DestroyedGameplayCue) == 0x0000E4, "Member 'FP2LockMeshConfiguration::DestroyedGameplayCue' has a wrong offset!");

// ScriptStruct Game.P2ShowOrHiddenWidgetNames
// 0x0010 (0x0010 - 0x0000)
struct FP2ShowOrHiddenWidgetNames final
{
public:
	TArray<class FName>                           WidgetNames;                                       // 0x0000(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FP2ShowOrHiddenWidgetNames) == 0x000008, "Wrong alignment on FP2ShowOrHiddenWidgetNames");
static_assert(sizeof(FP2ShowOrHiddenWidgetNames) == 0x000010, "Wrong size on FP2ShowOrHiddenWidgetNames");
static_assert(offsetof(FP2ShowOrHiddenWidgetNames, WidgetNames) == 0x000000, "Member 'FP2ShowOrHiddenWidgetNames::WidgetNames' has a wrong offset!");

// ScriptStruct Game.P2UIConfigDataRow
// 0x00B8 (0x00C0 - 0x0008)
struct FP2UIConfigDataRow final : public FTableRowBase
{
public:
	TSubclassOf<class UUserWidget>                WidgetClass;                                       // 0x0008(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UUserWidget>                WidgetClass_Gamepad;                               // 0x0010(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         ZOrder;                                            // 0x0018(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         IsPlayerScreen;                                    // 0x0019(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EInputMode                                    InputMode;                                         // 0x001A(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EMouseCaptureMode                             GameMouseCaptureMode;                              // 0x001B(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C[0x4];                                       // 0x001C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<class FName, struct FP2ShowOrHiddenWidgetNames> ShowWidgetNames;                            // 0x0020(0x0050)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	TMap<class FName, struct FP2ShowOrHiddenWidgetNames> HideWidgetNames;                            // 0x0070(0x0050)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
};
static_assert(alignof(FP2UIConfigDataRow) == 0x000008, "Wrong alignment on FP2UIConfigDataRow");
static_assert(sizeof(FP2UIConfigDataRow) == 0x0000C0, "Wrong size on FP2UIConfigDataRow");
static_assert(offsetof(FP2UIConfigDataRow, WidgetClass) == 0x000008, "Member 'FP2UIConfigDataRow::WidgetClass' has a wrong offset!");
static_assert(offsetof(FP2UIConfigDataRow, WidgetClass_Gamepad) == 0x000010, "Member 'FP2UIConfigDataRow::WidgetClass_Gamepad' has a wrong offset!");
static_assert(offsetof(FP2UIConfigDataRow, ZOrder) == 0x000018, "Member 'FP2UIConfigDataRow::ZOrder' has a wrong offset!");
static_assert(offsetof(FP2UIConfigDataRow, IsPlayerScreen) == 0x000019, "Member 'FP2UIConfigDataRow::IsPlayerScreen' has a wrong offset!");
static_assert(offsetof(FP2UIConfigDataRow, InputMode) == 0x00001A, "Member 'FP2UIConfigDataRow::InputMode' has a wrong offset!");
static_assert(offsetof(FP2UIConfigDataRow, GameMouseCaptureMode) == 0x00001B, "Member 'FP2UIConfigDataRow::GameMouseCaptureMode' has a wrong offset!");
static_assert(offsetof(FP2UIConfigDataRow, ShowWidgetNames) == 0x000020, "Member 'FP2UIConfigDataRow::ShowWidgetNames' has a wrong offset!");
static_assert(offsetof(FP2UIConfigDataRow, HideWidgetNames) == 0x000070, "Member 'FP2UIConfigDataRow::HideWidgetNames' has a wrong offset!");

// ScriptStruct Game.P2LootAttachData
// 0x0090 (0x0090 - 0x0000)
struct FP2LootAttachData final
{
public:
	struct FSoftObjectPath                        PointComponent;                                    // 0x0000(0x0020)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   AttachComponent;                                   // 0x0020(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   AttachSocket;                                      // 0x0028(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FTransform                             AttachTransform;                                   // 0x0030(0x0060)(IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FP2LootAttachData) == 0x000010, "Wrong alignment on FP2LootAttachData");
static_assert(sizeof(FP2LootAttachData) == 0x000090, "Wrong size on FP2LootAttachData");
static_assert(offsetof(FP2LootAttachData, PointComponent) == 0x000000, "Member 'FP2LootAttachData::PointComponent' has a wrong offset!");
static_assert(offsetof(FP2LootAttachData, AttachComponent) == 0x000020, "Member 'FP2LootAttachData::AttachComponent' has a wrong offset!");
static_assert(offsetof(FP2LootAttachData, AttachSocket) == 0x000028, "Member 'FP2LootAttachData::AttachSocket' has a wrong offset!");
static_assert(offsetof(FP2LootAttachData, AttachTransform) == 0x000030, "Member 'FP2LootAttachData::AttachTransform' has a wrong offset!");

// ScriptStruct Game.P2SpawnPointSearchResult
// 0x0020 (0x0020 - 0x0000)
struct alignas(0x08) FP2SpawnPointSearchResult final
{
public:
	uint8                                         Pad_0[0x20];                                       // 0x0000(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FP2SpawnPointSearchResult) == 0x000008, "Wrong alignment on FP2SpawnPointSearchResult");
static_assert(sizeof(FP2SpawnPointSearchResult) == 0x000020, "Wrong size on FP2SpawnPointSearchResult");

// ScriptStruct Game.P2SpawnPointSearchCache
// 0x00A0 (0x00A0 - 0x0000)
struct alignas(0x08) FP2SpawnPointSearchCache final
{
public:
	uint8                                         Pad_0[0xA0];                                       // 0x0000(0x00A0)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FP2SpawnPointSearchCache) == 0x000008, "Wrong alignment on FP2SpawnPointSearchCache");
static_assert(sizeof(FP2SpawnPointSearchCache) == 0x0000A0, "Wrong size on FP2SpawnPointSearchCache");

// ScriptStruct Game.P2UIPlayerSkillDisplayDataRow
// 0x0068 (0x0070 - 0x0008)
struct FP2UIPlayerSkillDisplayDataRow final : public FTableRowBase
{
public:
	struct FGameplayTag                           PlayerSkillTag;                                    // 0x0008(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FText                                   DisplayName;                                       // 0x0010(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	class FText                                   ShortDescription;                                  // 0x0028(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UTexture2D>              Icon;                                              // 0x0040(0x0030)(Edit, BlueprintVisible, BlueprintReadOnly, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FP2UIPlayerSkillDisplayDataRow) == 0x000008, "Wrong alignment on FP2UIPlayerSkillDisplayDataRow");
static_assert(sizeof(FP2UIPlayerSkillDisplayDataRow) == 0x000070, "Wrong size on FP2UIPlayerSkillDisplayDataRow");
static_assert(offsetof(FP2UIPlayerSkillDisplayDataRow, PlayerSkillTag) == 0x000008, "Member 'FP2UIPlayerSkillDisplayDataRow::PlayerSkillTag' has a wrong offset!");
static_assert(offsetof(FP2UIPlayerSkillDisplayDataRow, DisplayName) == 0x000010, "Member 'FP2UIPlayerSkillDisplayDataRow::DisplayName' has a wrong offset!");
static_assert(offsetof(FP2UIPlayerSkillDisplayDataRow, ShortDescription) == 0x000028, "Member 'FP2UIPlayerSkillDisplayDataRow::ShortDescription' has a wrong offset!");
static_assert(offsetof(FP2UIPlayerSkillDisplayDataRow, Icon) == 0x000040, "Member 'FP2UIPlayerSkillDisplayDataRow::Icon' has a wrong offset!");

// ScriptStruct Game.P2LootSpawnAreaNode
// 0x00D8 (0x00D8 - 0x0000)
struct alignas(0x08) FP2LootSpawnAreaNode final
{
public:
	uint8                                         Pad_0[0xD8];                                       // 0x0000(0x00D8)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FP2LootSpawnAreaNode) == 0x000008, "Wrong alignment on FP2LootSpawnAreaNode");
static_assert(sizeof(FP2LootSpawnAreaNode) == 0x0000D8, "Wrong size on FP2LootSpawnAreaNode");

// ScriptStruct Game.P2LootContextTagRatioModifier
// 0x0008 (0x0008 - 0x0000)
struct FP2LootContextTagRatioModifier final
{
public:
	float                                         PrimaryContextRatioModifier;                       // 0x0000(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SecondaryContextRatioModifier;                     // 0x0004(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FP2LootContextTagRatioModifier) == 0x000004, "Wrong alignment on FP2LootContextTagRatioModifier");
static_assert(sizeof(FP2LootContextTagRatioModifier) == 0x000008, "Wrong size on FP2LootContextTagRatioModifier");
static_assert(offsetof(FP2LootContextTagRatioModifier, PrimaryContextRatioModifier) == 0x000000, "Member 'FP2LootContextTagRatioModifier::PrimaryContextRatioModifier' has a wrong offset!");
static_assert(offsetof(FP2LootContextTagRatioModifier, SecondaryContextRatioModifier) == 0x000004, "Member 'FP2LootContextTagRatioModifier::SecondaryContextRatioModifier' has a wrong offset!");

// ScriptStruct Game.P2LootSpawnSettings
// 0x00B0 (0x00B0 - 0x0000)
struct FP2LootSpawnSettings final
{
public:
	TMap<int32, float>                            RarityRatios;                                      // 0x0000(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	TMap<struct FGameplayTag, float>              CategoryRatios;                                    // 0x0050(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FP2LootContextTagRatioModifier         ItemContextTagRatioModifiers;                      // 0x00A0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, NativeAccessSpecifierPublic)
	struct FP2LootContextTagRatioModifier         CrateContextTagRatioModifiers;                     // 0x00A8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FP2LootSpawnSettings) == 0x000008, "Wrong alignment on FP2LootSpawnSettings");
static_assert(sizeof(FP2LootSpawnSettings) == 0x0000B0, "Wrong size on FP2LootSpawnSettings");
static_assert(offsetof(FP2LootSpawnSettings, RarityRatios) == 0x000000, "Member 'FP2LootSpawnSettings::RarityRatios' has a wrong offset!");
static_assert(offsetof(FP2LootSpawnSettings, CategoryRatios) == 0x000050, "Member 'FP2LootSpawnSettings::CategoryRatios' has a wrong offset!");
static_assert(offsetof(FP2LootSpawnSettings, ItemContextTagRatioModifiers) == 0x0000A0, "Member 'FP2LootSpawnSettings::ItemContextTagRatioModifiers' has a wrong offset!");
static_assert(offsetof(FP2LootSpawnSettings, CrateContextTagRatioModifiers) == 0x0000A8, "Member 'FP2LootSpawnSettings::CrateContextTagRatioModifiers' has a wrong offset!");

// ScriptStruct Game.P2LootSpawnRatioTierItem
// 0x0008 (0x000C - 0x0004)
struct FP2LootSpawnRatioTierItem final : public FP2LootSpawnRatioBase
{
public:
	struct FGameplayTag                           TierTag;                                           // 0x0004(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FP2LootSpawnRatioTierItem) == 0x000004, "Wrong alignment on FP2LootSpawnRatioTierItem");
static_assert(sizeof(FP2LootSpawnRatioTierItem) == 0x00000C, "Wrong size on FP2LootSpawnRatioTierItem");
static_assert(offsetof(FP2LootSpawnRatioTierItem, TierTag) == 0x000004, "Member 'FP2LootSpawnRatioTierItem::TierTag' has a wrong offset!");

// ScriptStruct Game.P2LootSpawnRatioTierCrate
// 0x0008 (0x000C - 0x0004)
struct FP2LootSpawnRatioTierCrate final : public FP2LootSpawnRatioBase
{
public:
	struct FGameplayTag                           TierTag;                                           // 0x0004(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FP2LootSpawnRatioTierCrate) == 0x000004, "Wrong alignment on FP2LootSpawnRatioTierCrate");
static_assert(sizeof(FP2LootSpawnRatioTierCrate) == 0x00000C, "Wrong size on FP2LootSpawnRatioTierCrate");
static_assert(offsetof(FP2LootSpawnRatioTierCrate, TierTag) == 0x000004, "Member 'FP2LootSpawnRatioTierCrate::TierTag' has a wrong offset!");

// ScriptStruct Game.P2LootSpawnRatioRarityItem
// 0x0004 (0x0008 - 0x0004)
struct FP2LootSpawnRatioRarityItem final : public FP2LootSpawnRatioBase
{
public:
	int32                                         Rarity;                                            // 0x0004(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FP2LootSpawnRatioRarityItem) == 0x000004, "Wrong alignment on FP2LootSpawnRatioRarityItem");
static_assert(sizeof(FP2LootSpawnRatioRarityItem) == 0x000008, "Wrong size on FP2LootSpawnRatioRarityItem");
static_assert(offsetof(FP2LootSpawnRatioRarityItem, Rarity) == 0x000004, "Member 'FP2LootSpawnRatioRarityItem::Rarity' has a wrong offset!");

// ScriptStruct Game.P2TargetData_BulletHit
// 0x0110 (0x0118 - 0x0008)
struct FP2TargetData_BulletHit final : public FGameplayAbilityTargetData
{
public:
	struct FHitResult                             HitResult;                                         // 0x0008(0x00E8)(BlueprintVisible, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	struct FGameplayTag                           LimbDamageZone;                                    // 0x00F0(0x0008)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           LimbHitMapZone;                                    // 0x00F8(0x0008)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint32                                        InstanceId;                                        // 0x0100(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DistanceTraveled;                                  // 0x0104(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HitVelocity;                                       // 0x0108(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TimeInAir;                                         // 0x010C(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PenetrationDepth;                                  // 0x0110(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EP2BulletHitType                              HitType;                                           // 0x0114(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         ShotIndex;                                         // 0x0115(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_116[0x2];                                      // 0x0116(0x0002)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FP2TargetData_BulletHit) == 0x000008, "Wrong alignment on FP2TargetData_BulletHit");
static_assert(sizeof(FP2TargetData_BulletHit) == 0x000118, "Wrong size on FP2TargetData_BulletHit");
static_assert(offsetof(FP2TargetData_BulletHit, HitResult) == 0x000008, "Member 'FP2TargetData_BulletHit::HitResult' has a wrong offset!");
static_assert(offsetof(FP2TargetData_BulletHit, LimbDamageZone) == 0x0000F0, "Member 'FP2TargetData_BulletHit::LimbDamageZone' has a wrong offset!");
static_assert(offsetof(FP2TargetData_BulletHit, LimbHitMapZone) == 0x0000F8, "Member 'FP2TargetData_BulletHit::LimbHitMapZone' has a wrong offset!");
static_assert(offsetof(FP2TargetData_BulletHit, InstanceId) == 0x000100, "Member 'FP2TargetData_BulletHit::InstanceId' has a wrong offset!");
static_assert(offsetof(FP2TargetData_BulletHit, DistanceTraveled) == 0x000104, "Member 'FP2TargetData_BulletHit::DistanceTraveled' has a wrong offset!");
static_assert(offsetof(FP2TargetData_BulletHit, HitVelocity) == 0x000108, "Member 'FP2TargetData_BulletHit::HitVelocity' has a wrong offset!");
static_assert(offsetof(FP2TargetData_BulletHit, TimeInAir) == 0x00010C, "Member 'FP2TargetData_BulletHit::TimeInAir' has a wrong offset!");
static_assert(offsetof(FP2TargetData_BulletHit, PenetrationDepth) == 0x000110, "Member 'FP2TargetData_BulletHit::PenetrationDepth' has a wrong offset!");
static_assert(offsetof(FP2TargetData_BulletHit, HitType) == 0x000114, "Member 'FP2TargetData_BulletHit::HitType' has a wrong offset!");
static_assert(offsetof(FP2TargetData_BulletHit, ShotIndex) == 0x000115, "Member 'FP2TargetData_BulletHit::ShotIndex' has a wrong offset!");

// ScriptStruct Game.P2LootSpawnRatioRarityCrate
// 0x0004 (0x0008 - 0x0004)
struct FP2LootSpawnRatioRarityCrate final : public FP2LootSpawnRatioBase
{
public:
	int32                                         Rarity;                                            // 0x0004(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FP2LootSpawnRatioRarityCrate) == 0x000004, "Wrong alignment on FP2LootSpawnRatioRarityCrate");
static_assert(sizeof(FP2LootSpawnRatioRarityCrate) == 0x000008, "Wrong size on FP2LootSpawnRatioRarityCrate");
static_assert(offsetof(FP2LootSpawnRatioRarityCrate, Rarity) == 0x000004, "Member 'FP2LootSpawnRatioRarityCrate::Rarity' has a wrong offset!");

// ScriptStruct Game.ControlRecoilProcessor
// 0x0040 (0x0040 - 0x0000)
struct alignas(0x08) FControlRecoilProcessor final
{
public:
	uint8                                         Pad_0[0x40];                                       // 0x0000(0x0040)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FControlRecoilProcessor) == 0x000008, "Wrong alignment on FControlRecoilProcessor");
static_assert(sizeof(FControlRecoilProcessor) == 0x000040, "Wrong size on FControlRecoilProcessor");

// ScriptStruct Game.P2LootSpawnItem
// 0x0024 (0x0028 - 0x0004)
struct FP2LootSpawnItem final : public FP2LootSpawnRatioBase
{
public:
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UP2ItemData*                            Item;                                              // 0x0008(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FP2LootSpawnMinMax                     Stack;                                             // 0x0010(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, NativeAccessSpecifierPublic)
	TArray<struct FP2LootSpawnAttachable>         Attachables;                                       // 0x0018(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FP2LootSpawnItem) == 0x000008, "Wrong alignment on FP2LootSpawnItem");
static_assert(sizeof(FP2LootSpawnItem) == 0x000028, "Wrong size on FP2LootSpawnItem");
static_assert(offsetof(FP2LootSpawnItem, Item) == 0x000008, "Member 'FP2LootSpawnItem::Item' has a wrong offset!");
static_assert(offsetof(FP2LootSpawnItem, Stack) == 0x000010, "Member 'FP2LootSpawnItem::Stack' has a wrong offset!");
static_assert(offsetof(FP2LootSpawnItem, Attachables) == 0x000018, "Member 'FP2LootSpawnItem::Attachables' has a wrong offset!");

// ScriptStruct Game.P2TargetData_DamageTarget
// 0x0010 (0x0018 - 0x0008)
struct FP2TargetData_DamageTarget : public FGameplayAbilityTargetData
{
public:
	uint8                                         Pad_8[0x10];                                       // 0x0008(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FP2TargetData_DamageTarget) == 0x000008, "Wrong alignment on FP2TargetData_DamageTarget");
static_assert(sizeof(FP2TargetData_DamageTarget) == 0x000018, "Wrong size on FP2TargetData_DamageTarget");

// ScriptStruct Game.P2TargetData_RadialDamageTarget
// 0x0020 (0x0038 - 0x0018)
struct FP2TargetData_RadialDamageTarget final : public FP2TargetData_DamageTarget
{
public:
	uint8                                         Pad_18[0x20];                                      // 0x0018(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FP2TargetData_RadialDamageTarget) == 0x000008, "Wrong alignment on FP2TargetData_RadialDamageTarget");
static_assert(sizeof(FP2TargetData_RadialDamageTarget) == 0x000038, "Wrong size on FP2TargetData_RadialDamageTarget");

// ScriptStruct Game.P2LootSpawnFixedItem
// 0x0020 (0x00D0 - 0x00B0)
struct FP2LootSpawnFixedItem final : public FP2LootSpawnFixedBase
{
public:
	class UP2ItemData*                            Object;                                            // 0x00B0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FP2LootSpawnMinMax                     Stack;                                             // 0x00B8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, NativeAccessSpecifierPublic)
	TArray<struct FP2LootSpawnAttachable>         Attachables;                                       // 0x00C0(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FP2LootSpawnFixedItem) == 0x000008, "Wrong alignment on FP2LootSpawnFixedItem");
static_assert(sizeof(FP2LootSpawnFixedItem) == 0x0000D0, "Wrong size on FP2LootSpawnFixedItem");
static_assert(offsetof(FP2LootSpawnFixedItem, Object) == 0x0000B0, "Member 'FP2LootSpawnFixedItem::Object' has a wrong offset!");
static_assert(offsetof(FP2LootSpawnFixedItem, Stack) == 0x0000B8, "Member 'FP2LootSpawnFixedItem::Stack' has a wrong offset!");
static_assert(offsetof(FP2LootSpawnFixedItem, Attachables) == 0x0000C0, "Member 'FP2LootSpawnFixedItem::Attachables' has a wrong offset!");

// ScriptStruct Game.P2TargetData_Interact
// 0x0028 (0x0030 - 0x0008)
struct FP2TargetData_Interact final : public FGameplayAbilityTargetData
{
public:
	uint8                                         Pad_8[0x28];                                       // 0x0008(0x0028)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FP2TargetData_Interact) == 0x000008, "Wrong alignment on FP2TargetData_Interact");
static_assert(sizeof(FP2TargetData_Interact) == 0x000030, "Wrong size on FP2TargetData_Interact");

// ScriptStruct Game.P2LootSpawnZoneSettings
// 0x0058 (0x0068 - 0x0010)
struct FP2LootSpawnZoneSettings final : public FP2LootSpawnBrushSettings
{
public:
	struct FP2LootSpawnMinMax                     RandomItemAmount;                                  // 0x0010(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, NativeAccessSpecifierPublic)
	struct FP2LootSpawnMinMax                     RandomCrateAmount;                                 // 0x0018(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, NativeAccessSpecifierPublic)
	struct FP2LootSpawnMinMax                     RandomItemsInsideCratesAmount;                     // 0x0020(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, NativeAccessSpecifierPublic)
	TArray<struct FP2LootSpawnRatioTierItem>      ItemTierRatio;                                     // 0x0028(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FP2LootSpawnRatioTierCrate>     CrateTierRatio;                                    // 0x0038(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FP2LootSpawnRatioRarityItem>    ItemRarityRatio;                                   // 0x0048(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FP2LootSpawnRatioRarityCrate>   CrateRarityRatio;                                  // 0x0058(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FP2LootSpawnZoneSettings) == 0x000008, "Wrong alignment on FP2LootSpawnZoneSettings");
static_assert(sizeof(FP2LootSpawnZoneSettings) == 0x000068, "Wrong size on FP2LootSpawnZoneSettings");
static_assert(offsetof(FP2LootSpawnZoneSettings, RandomItemAmount) == 0x000010, "Member 'FP2LootSpawnZoneSettings::RandomItemAmount' has a wrong offset!");
static_assert(offsetof(FP2LootSpawnZoneSettings, RandomCrateAmount) == 0x000018, "Member 'FP2LootSpawnZoneSettings::RandomCrateAmount' has a wrong offset!");
static_assert(offsetof(FP2LootSpawnZoneSettings, RandomItemsInsideCratesAmount) == 0x000020, "Member 'FP2LootSpawnZoneSettings::RandomItemsInsideCratesAmount' has a wrong offset!");
static_assert(offsetof(FP2LootSpawnZoneSettings, ItemTierRatio) == 0x000028, "Member 'FP2LootSpawnZoneSettings::ItemTierRatio' has a wrong offset!");
static_assert(offsetof(FP2LootSpawnZoneSettings, CrateTierRatio) == 0x000038, "Member 'FP2LootSpawnZoneSettings::CrateTierRatio' has a wrong offset!");
static_assert(offsetof(FP2LootSpawnZoneSettings, ItemRarityRatio) == 0x000048, "Member 'FP2LootSpawnZoneSettings::ItemRarityRatio' has a wrong offset!");
static_assert(offsetof(FP2LootSpawnZoneSettings, CrateRarityRatio) == 0x000058, "Member 'FP2LootSpawnZoneSettings::CrateRarityRatio' has a wrong offset!");

// ScriptStruct Game.P2LootSpawnZoneConfig
// 0x00A0 (0x00A0 - 0x0000)
struct FP2LootSpawnZoneConfig final
{
public:
	class UP2LootSpawnZoneData*                   ZoneData;                                          // 0x0000(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FP2LootSpawnZoneSettings               ZoneSettings;                                      // 0x0008(0x0068)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	TArray<struct FP2LootSpawnZoneSettings>       ZoneSettingsPerSessionDifficulty;                  // 0x0070(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FP2LootSpawnFixedItem>          FixedItem;                                         // 0x0080(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FP2LootSpawnFixedCrate>         FixedCrate;                                        // 0x0090(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FP2LootSpawnZoneConfig) == 0x000008, "Wrong alignment on FP2LootSpawnZoneConfig");
static_assert(sizeof(FP2LootSpawnZoneConfig) == 0x0000A0, "Wrong size on FP2LootSpawnZoneConfig");
static_assert(offsetof(FP2LootSpawnZoneConfig, ZoneData) == 0x000000, "Member 'FP2LootSpawnZoneConfig::ZoneData' has a wrong offset!");
static_assert(offsetof(FP2LootSpawnZoneConfig, ZoneSettings) == 0x000008, "Member 'FP2LootSpawnZoneConfig::ZoneSettings' has a wrong offset!");
static_assert(offsetof(FP2LootSpawnZoneConfig, ZoneSettingsPerSessionDifficulty) == 0x000070, "Member 'FP2LootSpawnZoneConfig::ZoneSettingsPerSessionDifficulty' has a wrong offset!");
static_assert(offsetof(FP2LootSpawnZoneConfig, FixedItem) == 0x000080, "Member 'FP2LootSpawnZoneConfig::FixedItem' has a wrong offset!");
static_assert(offsetof(FP2LootSpawnZoneConfig, FixedCrate) == 0x000090, "Member 'FP2LootSpawnZoneConfig::FixedCrate' has a wrong offset!");

// ScriptStruct Game.P2LootSpawnContextConfig
// 0x00B0 (0x00B0 - 0x0000)
struct FP2LootSpawnContextConfig final
{
public:
	class UP2LootSpawnContextData*                ContextData;                                       // 0x0000(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FP2LootSpawnContextSettings            ContextSettings;                                   // 0x0008(0x0090)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FP2LootSpawnCategoryRatio              CategoryRatio;                                     // 0x0098(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          bExclusive;                                        // 0x00A4(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bRewardRoom;                                       // 0x00A5(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A6[0x2];                                       // 0x00A6(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         RewardRoomMultiplier;                              // 0x00A8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_AC[0x4];                                       // 0x00AC(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FP2LootSpawnContextConfig) == 0x000008, "Wrong alignment on FP2LootSpawnContextConfig");
static_assert(sizeof(FP2LootSpawnContextConfig) == 0x0000B0, "Wrong size on FP2LootSpawnContextConfig");
static_assert(offsetof(FP2LootSpawnContextConfig, ContextData) == 0x000000, "Member 'FP2LootSpawnContextConfig::ContextData' has a wrong offset!");
static_assert(offsetof(FP2LootSpawnContextConfig, ContextSettings) == 0x000008, "Member 'FP2LootSpawnContextConfig::ContextSettings' has a wrong offset!");
static_assert(offsetof(FP2LootSpawnContextConfig, CategoryRatio) == 0x000098, "Member 'FP2LootSpawnContextConfig::CategoryRatio' has a wrong offset!");
static_assert(offsetof(FP2LootSpawnContextConfig, bExclusive) == 0x0000A4, "Member 'FP2LootSpawnContextConfig::bExclusive' has a wrong offset!");
static_assert(offsetof(FP2LootSpawnContextConfig, bRewardRoom) == 0x0000A5, "Member 'FP2LootSpawnContextConfig::bRewardRoom' has a wrong offset!");
static_assert(offsetof(FP2LootSpawnContextConfig, RewardRoomMultiplier) == 0x0000A8, "Member 'FP2LootSpawnContextConfig::RewardRoomMultiplier' has a wrong offset!");

// ScriptStruct Game.P2TargetData_ItemAction
// 0x0010 (0x0018 - 0x0008)
struct FP2TargetData_ItemAction : public FGameplayAbilityTargetData
{
public:
	uint8                                         Pad_8[0x10];                                       // 0x0008(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FP2TargetData_ItemAction) == 0x000008, "Wrong alignment on FP2TargetData_ItemAction");
static_assert(sizeof(FP2TargetData_ItemAction) == 0x000018, "Wrong size on FP2TargetData_ItemAction");

// ScriptStruct Game.P2TargetData_InventoryEquipItem
// 0x0010 (0x0028 - 0x0018)
struct FP2TargetData_InventoryEquipItem final : public FP2TargetData_ItemAction
{
public:
	uint8                                         Pad_18[0x10];                                      // 0x0018(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FP2TargetData_InventoryEquipItem) == 0x000008, "Wrong alignment on FP2TargetData_InventoryEquipItem");
static_assert(sizeof(FP2TargetData_InventoryEquipItem) == 0x000028, "Wrong size on FP2TargetData_InventoryEquipItem");

// ScriptStruct Game.P2LootSpawnFallbackMeshTransform
// 0x0030 (0x0030 - 0x0000)
struct FP2LootSpawnFallbackMeshTransform final
{
public:
	struct FVector_NetQuantize100                 Location;                                          // 0x0000(0x0018)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               Rotation;                                          // 0x0018(0x0018)(ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FP2LootSpawnFallbackMeshTransform) == 0x000008, "Wrong alignment on FP2LootSpawnFallbackMeshTransform");
static_assert(sizeof(FP2LootSpawnFallbackMeshTransform) == 0x000030, "Wrong size on FP2LootSpawnFallbackMeshTransform");
static_assert(offsetof(FP2LootSpawnFallbackMeshTransform, Location) == 0x000000, "Member 'FP2LootSpawnFallbackMeshTransform::Location' has a wrong offset!");
static_assert(offsetof(FP2LootSpawnFallbackMeshTransform, Rotation) == 0x000018, "Member 'FP2LootSpawnFallbackMeshTransform::Rotation' has a wrong offset!");

// ScriptStruct Game.BaseSpreadConfig
// 0x0010 (0x0010 - 0x0000)
struct FBaseSpreadConfig final
{
public:
	float                                         IncreasePerShot;                                   // 0x0000(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DecreasePerSec;                                    // 0x0004(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FiringSpreadMax;                                   // 0x0008(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TotalSpreadMax;                                    // 0x000C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FBaseSpreadConfig) == 0x000004, "Wrong alignment on FBaseSpreadConfig");
static_assert(sizeof(FBaseSpreadConfig) == 0x000010, "Wrong size on FBaseSpreadConfig");
static_assert(offsetof(FBaseSpreadConfig, IncreasePerShot) == 0x000000, "Member 'FBaseSpreadConfig::IncreasePerShot' has a wrong offset!");
static_assert(offsetof(FBaseSpreadConfig, DecreasePerSec) == 0x000004, "Member 'FBaseSpreadConfig::DecreasePerSec' has a wrong offset!");
static_assert(offsetof(FBaseSpreadConfig, FiringSpreadMax) == 0x000008, "Member 'FBaseSpreadConfig::FiringSpreadMax' has a wrong offset!");
static_assert(offsetof(FBaseSpreadConfig, TotalSpreadMax) == 0x00000C, "Member 'FBaseSpreadConfig::TotalSpreadMax' has a wrong offset!");

// ScriptStruct Game.P2LootSpawnFallbackMeshData
// 0x0018 (0x0018 - 0x0000)
struct FP2LootSpawnFallbackMeshData final
{
public:
	class UStaticMesh*                            Asset;                                             // 0x0000(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FP2LootSpawnFallbackMeshTransform> Instances;                                      // 0x0008(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FP2LootSpawnFallbackMeshData) == 0x000008, "Wrong alignment on FP2LootSpawnFallbackMeshData");
static_assert(sizeof(FP2LootSpawnFallbackMeshData) == 0x000018, "Wrong size on FP2LootSpawnFallbackMeshData");
static_assert(offsetof(FP2LootSpawnFallbackMeshData, Asset) == 0x000000, "Member 'FP2LootSpawnFallbackMeshData::Asset' has a wrong offset!");
static_assert(offsetof(FP2LootSpawnFallbackMeshData, Instances) == 0x000008, "Member 'FP2LootSpawnFallbackMeshData::Instances' has a wrong offset!");

// ScriptStruct Game.P2LootSpawnCrateSpaceModifier
// 0x0008 (0x0008 - 0x0000)
struct FP2LootSpawnCrateSpaceModifier final
{
public:
	float                                         Space;                                             // 0x0000(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Bias;                                              // 0x0004(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FP2LootSpawnCrateSpaceModifier) == 0x000004, "Wrong alignment on FP2LootSpawnCrateSpaceModifier");
static_assert(sizeof(FP2LootSpawnCrateSpaceModifier) == 0x000008, "Wrong size on FP2LootSpawnCrateSpaceModifier");
static_assert(offsetof(FP2LootSpawnCrateSpaceModifier, Space) == 0x000000, "Member 'FP2LootSpawnCrateSpaceModifier::Space' has a wrong offset!");
static_assert(offsetof(FP2LootSpawnCrateSpaceModifier, Bias) == 0x000004, "Member 'FP2LootSpawnCrateSpaceModifier::Bias' has a wrong offset!");

// ScriptStruct Game.P2LootSpawnCrateSpaceModifiersPerSessionDifficulty
// 0x0010 (0x0010 - 0x0000)
struct FP2LootSpawnCrateSpaceModifiersPerSessionDifficulty final
{
public:
	TArray<struct FP2LootSpawnCrateSpaceModifier> CrateSpaceModifiers;                               // 0x0000(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FP2LootSpawnCrateSpaceModifiersPerSessionDifficulty) == 0x000008, "Wrong alignment on FP2LootSpawnCrateSpaceModifiersPerSessionDifficulty");
static_assert(sizeof(FP2LootSpawnCrateSpaceModifiersPerSessionDifficulty) == 0x000010, "Wrong size on FP2LootSpawnCrateSpaceModifiersPerSessionDifficulty");
static_assert(offsetof(FP2LootSpawnCrateSpaceModifiersPerSessionDifficulty, CrateSpaceModifiers) == 0x000000, "Member 'FP2LootSpawnCrateSpaceModifiersPerSessionDifficulty::CrateSpaceModifiers' has a wrong offset!");

// ScriptStruct Game.P2ClassReplicationInfoPreset
// 0x0018 (0x0018 - 0x0000)
struct FP2ClassReplicationInfoPreset final
{
public:
	TSubclassOf<class AActor>                     Class;                                             // 0x0000(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DistancePriorityScale;                             // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         StarvationPriorityScale;                           // 0x000C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CullDistanceSquared;                               // 0x0010(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         ReplicationPeriodFrame;                            // 0x0014(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         ActorChannelFrameTimeout;                          // 0x0015(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_16[0x2];                                       // 0x0016(0x0002)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FP2ClassReplicationInfoPreset) == 0x000008, "Wrong alignment on FP2ClassReplicationInfoPreset");
static_assert(sizeof(FP2ClassReplicationInfoPreset) == 0x000018, "Wrong size on FP2ClassReplicationInfoPreset");
static_assert(offsetof(FP2ClassReplicationInfoPreset, Class) == 0x000000, "Member 'FP2ClassReplicationInfoPreset::Class' has a wrong offset!");
static_assert(offsetof(FP2ClassReplicationInfoPreset, DistancePriorityScale) == 0x000008, "Member 'FP2ClassReplicationInfoPreset::DistancePriorityScale' has a wrong offset!");
static_assert(offsetof(FP2ClassReplicationInfoPreset, StarvationPriorityScale) == 0x00000C, "Member 'FP2ClassReplicationInfoPreset::StarvationPriorityScale' has a wrong offset!");
static_assert(offsetof(FP2ClassReplicationInfoPreset, CullDistanceSquared) == 0x000010, "Member 'FP2ClassReplicationInfoPreset::CullDistanceSquared' has a wrong offset!");
static_assert(offsetof(FP2ClassReplicationInfoPreset, ReplicationPeriodFrame) == 0x000014, "Member 'FP2ClassReplicationInfoPreset::ReplicationPeriodFrame' has a wrong offset!");
static_assert(offsetof(FP2ClassReplicationInfoPreset, ActorChannelFrameTimeout) == 0x000015, "Member 'FP2ClassReplicationInfoPreset::ActorChannelFrameTimeout' has a wrong offset!");

// ScriptStruct Game.P2LootSpawnDistributionSettings
// 0x0010 (0x0010 - 0x0000)
struct FP2LootSpawnDistributionSettings final
{
public:
	float                                         BaseCrateBias;                                     // 0x0000(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UCurveFloat*                            CrateSpaceToBiasCurve;                             // 0x0008(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FP2LootSpawnDistributionSettings) == 0x000008, "Wrong alignment on FP2LootSpawnDistributionSettings");
static_assert(sizeof(FP2LootSpawnDistributionSettings) == 0x000010, "Wrong size on FP2LootSpawnDistributionSettings");
static_assert(offsetof(FP2LootSpawnDistributionSettings, BaseCrateBias) == 0x000000, "Member 'FP2LootSpawnDistributionSettings::BaseCrateBias' has a wrong offset!");
static_assert(offsetof(FP2LootSpawnDistributionSettings, CrateSpaceToBiasCurve) == 0x000008, "Member 'FP2LootSpawnDistributionSettings::CrateSpaceToBiasCurve' has a wrong offset!");

// ScriptStruct Game.P2LootSpawnCategoryDistributionSettingsPerSessionDifficulty
// 0x0010 (0x0010 - 0x0000)
struct FP2LootSpawnCategoryDistributionSettingsPerSessionDifficulty final
{
public:
	TArray<class UP2LootSpawnCategoryDistribution*> CategoryDistributions;                           // 0x0000(0x0010)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, ContainsInstancedReference, UObjectWrapper, NativeAccessSpecifierPublic)
};
static_assert(alignof(FP2LootSpawnCategoryDistributionSettingsPerSessionDifficulty) == 0x000008, "Wrong alignment on FP2LootSpawnCategoryDistributionSettingsPerSessionDifficulty");
static_assert(sizeof(FP2LootSpawnCategoryDistributionSettingsPerSessionDifficulty) == 0x000010, "Wrong size on FP2LootSpawnCategoryDistributionSettingsPerSessionDifficulty");
static_assert(offsetof(FP2LootSpawnCategoryDistributionSettingsPerSessionDifficulty, CategoryDistributions) == 0x000000, "Member 'FP2LootSpawnCategoryDistributionSettingsPerSessionDifficulty::CategoryDistributions' has a wrong offset!");

// ScriptStruct Game.P2LootSpawnCategoryDistributionSettings
// 0x0010 (0x0010 - 0x0000)
struct FP2LootSpawnCategoryDistributionSettings final
{
public:
	TArray<struct FP2LootSpawnCategoryDistributionSettingsPerSessionDifficulty> PerSessionDifficultySettings; // 0x0000(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(FP2LootSpawnCategoryDistributionSettings) == 0x000008, "Wrong alignment on FP2LootSpawnCategoryDistributionSettings");
static_assert(sizeof(FP2LootSpawnCategoryDistributionSettings) == 0x000010, "Wrong size on FP2LootSpawnCategoryDistributionSettings");
static_assert(offsetof(FP2LootSpawnCategoryDistributionSettings, PerSessionDifficultySettings) == 0x000000, "Member 'FP2LootSpawnCategoryDistributionSettings::PerSessionDifficultySettings' has a wrong offset!");

// ScriptStruct Game.P2LootSpawnObjectPoolRow
// 0x0028 (0x0030 - 0x0008)
struct FP2LootSpawnObjectPoolRow final : public FTableRowBase
{
public:
	struct FGameplayTagContainer                  Tags;                                              // 0x0008(0x0020)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	int32                                         Minimum;                                           // 0x0028(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Maximum;                                           // 0x002C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FP2LootSpawnObjectPoolRow) == 0x000008, "Wrong alignment on FP2LootSpawnObjectPoolRow");
static_assert(sizeof(FP2LootSpawnObjectPoolRow) == 0x000030, "Wrong size on FP2LootSpawnObjectPoolRow");
static_assert(offsetof(FP2LootSpawnObjectPoolRow, Tags) == 0x000008, "Member 'FP2LootSpawnObjectPoolRow::Tags' has a wrong offset!");
static_assert(offsetof(FP2LootSpawnObjectPoolRow, Minimum) == 0x000028, "Member 'FP2LootSpawnObjectPoolRow::Minimum' has a wrong offset!");
static_assert(offsetof(FP2LootSpawnObjectPoolRow, Maximum) == 0x00002C, "Member 'FP2LootSpawnObjectPoolRow::Maximum' has a wrong offset!");

// ScriptStruct Game.P2ResearchDataInfo
// 0x0008 (0x0010 - 0x0008)
struct FP2ResearchDataInfo final : public FTableRowBase
{
public:
	class UP2ResearchData*                        Data;                                              // 0x0008(0x0008)(Edit, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FP2ResearchDataInfo) == 0x000008, "Wrong alignment on FP2ResearchDataInfo");
static_assert(sizeof(FP2ResearchDataInfo) == 0x000010, "Wrong size on FP2ResearchDataInfo");
static_assert(offsetof(FP2ResearchDataInfo, Data) == 0x000008, "Member 'FP2ResearchDataInfo::Data' has a wrong offset!");

// ScriptStruct Game.P2LootSpawnObjectPoolEntry
// 0x0048 (0x0048 - 0x0000)
struct FP2LootSpawnObjectPoolEntry final
{
public:
	class FName                                   Name;                                              // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<TScriptInterface<class IP2LootSpawnObjectInterface>> Objects;                             // 0x0008(0x0010)(ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
	struct FGameplayTagContainer                  Tags;                                              // 0x0018(0x0020)(NativeAccessSpecifierPublic)
	int32                                         Minimum;                                           // 0x0038(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Maximum;                                           // 0x003C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Available;                                         // 0x0040(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Taken;                                             // 0x0044(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FP2LootSpawnObjectPoolEntry) == 0x000008, "Wrong alignment on FP2LootSpawnObjectPoolEntry");
static_assert(sizeof(FP2LootSpawnObjectPoolEntry) == 0x000048, "Wrong size on FP2LootSpawnObjectPoolEntry");
static_assert(offsetof(FP2LootSpawnObjectPoolEntry, Name) == 0x000000, "Member 'FP2LootSpawnObjectPoolEntry::Name' has a wrong offset!");
static_assert(offsetof(FP2LootSpawnObjectPoolEntry, Objects) == 0x000008, "Member 'FP2LootSpawnObjectPoolEntry::Objects' has a wrong offset!");
static_assert(offsetof(FP2LootSpawnObjectPoolEntry, Tags) == 0x000018, "Member 'FP2LootSpawnObjectPoolEntry::Tags' has a wrong offset!");
static_assert(offsetof(FP2LootSpawnObjectPoolEntry, Minimum) == 0x000038, "Member 'FP2LootSpawnObjectPoolEntry::Minimum' has a wrong offset!");
static_assert(offsetof(FP2LootSpawnObjectPoolEntry, Maximum) == 0x00003C, "Member 'FP2LootSpawnObjectPoolEntry::Maximum' has a wrong offset!");
static_assert(offsetof(FP2LootSpawnObjectPoolEntry, Available) == 0x000040, "Member 'FP2LootSpawnObjectPoolEntry::Available' has a wrong offset!");
static_assert(offsetof(FP2LootSpawnObjectPoolEntry, Taken) == 0x000044, "Member 'FP2LootSpawnObjectPoolEntry::Taken' has a wrong offset!");

// ScriptStruct Game.P2LootSpawnWeightedPoolRow
// 0x0008 (0x0010 - 0x0008)
struct FP2LootSpawnWeightedPoolRow final : public FTableRowBase
{
public:
	float                                         Weight;                                            // 0x0008(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FP2LootSpawnWeightedPoolRow) == 0x000008, "Wrong alignment on FP2LootSpawnWeightedPoolRow");
static_assert(sizeof(FP2LootSpawnWeightedPoolRow) == 0x000010, "Wrong size on FP2LootSpawnWeightedPoolRow");
static_assert(offsetof(FP2LootSpawnWeightedPoolRow, Weight) == 0x000008, "Member 'FP2LootSpawnWeightedPoolRow::Weight' has a wrong offset!");

// ScriptStruct Game.P2LootSpawnWeightedPoolEntry
// 0x0020 (0x0020 - 0x0000)
struct FP2LootSpawnWeightedPoolEntry final
{
public:
	class FName                                   Name;                                              // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<TScriptInterface<class IP2LootSpawnObjectInterface>> Objects;                             // 0x0008(0x0010)(ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
	float                                         Weight;                                            // 0x0018(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C[0x4];                                       // 0x001C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FP2LootSpawnWeightedPoolEntry) == 0x000008, "Wrong alignment on FP2LootSpawnWeightedPoolEntry");
static_assert(sizeof(FP2LootSpawnWeightedPoolEntry) == 0x000020, "Wrong size on FP2LootSpawnWeightedPoolEntry");
static_assert(offsetof(FP2LootSpawnWeightedPoolEntry, Name) == 0x000000, "Member 'FP2LootSpawnWeightedPoolEntry::Name' has a wrong offset!");
static_assert(offsetof(FP2LootSpawnWeightedPoolEntry, Objects) == 0x000008, "Member 'FP2LootSpawnWeightedPoolEntry::Objects' has a wrong offset!");
static_assert(offsetof(FP2LootSpawnWeightedPoolEntry, Weight) == 0x000018, "Member 'FP2LootSpawnWeightedPoolEntry::Weight' has a wrong offset!");

// ScriptStruct Game.P2RootMotionSource_MoveAction
// 0x0020 (0x0100 - 0x00E0)
struct FP2RootMotionSource_MoveAction final : public FRootMotionSource
{
public:
	struct FMoveActionExecData                    ExecData;                                          // 0x00D8(0x0020)(NativeAccessSpecifierPublic)
	uint8                                         Pad_F8[0x8];                                       // 0x00F8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FP2RootMotionSource_MoveAction) == 0x000010, "Wrong alignment on FP2RootMotionSource_MoveAction");
static_assert(sizeof(FP2RootMotionSource_MoveAction) == 0x000100, "Wrong size on FP2RootMotionSource_MoveAction");
static_assert(offsetof(FP2RootMotionSource_MoveAction, ExecData) == 0x0000D8, "Member 'FP2RootMotionSource_MoveAction::ExecData' has a wrong offset!");

// ScriptStruct Game.MapZoomLevels
// 0x0010 (0x0010 - 0x0000)
struct FMapZoomLevels final
{
public:
	TArray<EP2MapZoomLevelType>                   ZoomLevels;                                        // 0x0000(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMapZoomLevels) == 0x000008, "Wrong alignment on FMapZoomLevels");
static_assert(sizeof(FMapZoomLevels) == 0x000010, "Wrong size on FMapZoomLevels");
static_assert(offsetof(FMapZoomLevels, ZoomLevels) == 0x000000, "Member 'FMapZoomLevels::ZoomLevels' has a wrong offset!");

// ScriptStruct Game.P2MapExfiltrationStateSettings
// 0x0014 (0x0014 - 0x0000)
struct FP2MapExfiltrationStateSettings final
{
public:
	bool                                          bVisible;                                          // 0x0000(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FColor                                 MeshColor;                                         // 0x0004(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bOverrideColorNearAnomaly;                         // 0x0008(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x3];                                        // 0x0009(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FColor                                 MeshColorNearInTimeAnomaly;                        // 0x000C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bMeshBlink;                                        // 0x0010(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bRedrawWidgetEveryTick;                            // 0x0011(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_12[0x2];                                       // 0x0012(0x0002)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FP2MapExfiltrationStateSettings) == 0x000004, "Wrong alignment on FP2MapExfiltrationStateSettings");
static_assert(sizeof(FP2MapExfiltrationStateSettings) == 0x000014, "Wrong size on FP2MapExfiltrationStateSettings");
static_assert(offsetof(FP2MapExfiltrationStateSettings, bVisible) == 0x000000, "Member 'FP2MapExfiltrationStateSettings::bVisible' has a wrong offset!");
static_assert(offsetof(FP2MapExfiltrationStateSettings, MeshColor) == 0x000004, "Member 'FP2MapExfiltrationStateSettings::MeshColor' has a wrong offset!");
static_assert(offsetof(FP2MapExfiltrationStateSettings, bOverrideColorNearAnomaly) == 0x000008, "Member 'FP2MapExfiltrationStateSettings::bOverrideColorNearAnomaly' has a wrong offset!");
static_assert(offsetof(FP2MapExfiltrationStateSettings, MeshColorNearInTimeAnomaly) == 0x00000C, "Member 'FP2MapExfiltrationStateSettings::MeshColorNearInTimeAnomaly' has a wrong offset!");
static_assert(offsetof(FP2MapExfiltrationStateSettings, bMeshBlink) == 0x000010, "Member 'FP2MapExfiltrationStateSettings::bMeshBlink' has a wrong offset!");
static_assert(offsetof(FP2MapExfiltrationStateSettings, bRedrawWidgetEveryTick) == 0x000011, "Member 'FP2MapExfiltrationStateSettings::bRedrawWidgetEveryTick' has a wrong offset!");

// ScriptStruct Game.P2MapMeshExtendedDefinition
// 0x0010 (0x0090 - 0x0080)
struct FP2MapMeshExtendedDefinition final : public FP2MapMeshDefinition
{
public:
	struct FGameplayTag                           Tag;                                               // 0x0080(0x0008)(Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_88[0x8];                                       // 0x0088(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FP2MapMeshExtendedDefinition) == 0x000010, "Wrong alignment on FP2MapMeshExtendedDefinition");
static_assert(sizeof(FP2MapMeshExtendedDefinition) == 0x000090, "Wrong size on FP2MapMeshExtendedDefinition");
static_assert(offsetof(FP2MapMeshExtendedDefinition, Tag) == 0x000080, "Member 'FP2MapMeshExtendedDefinition::Tag' has a wrong offset!");

// ScriptStruct Game.P2MapLinkDefinition
// 0x0090 (0x0090 - 0x0000)
struct FP2MapLinkDefinition final
{
public:
	struct FGameplayTag                           Tag;                                               // 0x0000(0x0008)(Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_8[0x8];                                        // 0x0008(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FP2MapMeshDefinition                   Mesh;                                              // 0x0010(0x0080)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FP2MapLinkDefinition) == 0x000010, "Wrong alignment on FP2MapLinkDefinition");
static_assert(sizeof(FP2MapLinkDefinition) == 0x000090, "Wrong size on FP2MapLinkDefinition");
static_assert(offsetof(FP2MapLinkDefinition, Tag) == 0x000000, "Member 'FP2MapLinkDefinition::Tag' has a wrong offset!");
static_assert(offsetof(FP2MapLinkDefinition, Mesh) == 0x000010, "Member 'FP2MapLinkDefinition::Mesh' has a wrong offset!");

// ScriptStruct Game.P2AccessDelaySequenceData
// 0x0010 (0x0010 - 0x0000)
struct FP2AccessDelaySequenceData final
{
public:
	struct FGameplayTag                           SequenceTag;                                       // 0x0000(0x0008)(Edit, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MinPlayLength;                                     // 0x0008(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxPlayLength;                                     // 0x000C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FP2AccessDelaySequenceData) == 0x000004, "Wrong alignment on FP2AccessDelaySequenceData");
static_assert(sizeof(FP2AccessDelaySequenceData) == 0x000010, "Wrong size on FP2AccessDelaySequenceData");
static_assert(offsetof(FP2AccessDelaySequenceData, SequenceTag) == 0x000000, "Member 'FP2AccessDelaySequenceData::SequenceTag' has a wrong offset!");
static_assert(offsetof(FP2AccessDelaySequenceData, MinPlayLength) == 0x000008, "Member 'FP2AccessDelaySequenceData::MinPlayLength' has a wrong offset!");
static_assert(offsetof(FP2AccessDelaySequenceData, MaxPlayLength) == 0x00000C, "Member 'FP2AccessDelaySequenceData::MaxPlayLength' has a wrong offset!");

// ScriptStruct Game.P2LootContextIconDataRow
// 0x0038 (0x0038 - 0x0000)
struct FP2LootContextIconDataRow final
{
public:
	struct FGameplayTag                           LootContextTag;                                    // 0x0000(0x0008)(Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UTexture2D>              LootIcon;                                          // 0x0008(0x0030)(Edit, BlueprintVisible, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FP2LootContextIconDataRow) == 0x000008, "Wrong alignment on FP2LootContextIconDataRow");
static_assert(sizeof(FP2LootContextIconDataRow) == 0x000038, "Wrong size on FP2LootContextIconDataRow");
static_assert(offsetof(FP2LootContextIconDataRow, LootContextTag) == 0x000000, "Member 'FP2LootContextIconDataRow::LootContextTag' has a wrong offset!");
static_assert(offsetof(FP2LootContextIconDataRow, LootIcon) == 0x000008, "Member 'FP2LootContextIconDataRow::LootIcon' has a wrong offset!");

// ScriptStruct Game.P2LocationTooltip
// 0x0040 (0x0040 - 0x0000)
struct FP2LocationTooltip final
{
public:
	bool                                          bEnabled;                                          // 0x0000(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   LocationDescription;                               // 0x0008(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	struct FGameplayTagContainer                  LootContextTags;                                   // 0x0020(0x0020)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
};
static_assert(alignof(FP2LocationTooltip) == 0x000008, "Wrong alignment on FP2LocationTooltip");
static_assert(sizeof(FP2LocationTooltip) == 0x000040, "Wrong size on FP2LocationTooltip");
static_assert(offsetof(FP2LocationTooltip, bEnabled) == 0x000000, "Member 'FP2LocationTooltip::bEnabled' has a wrong offset!");
static_assert(offsetof(FP2LocationTooltip, LocationDescription) == 0x000008, "Member 'FP2LocationTooltip::LocationDescription' has a wrong offset!");
static_assert(offsetof(FP2LocationTooltip, LootContextTags) == 0x000020, "Member 'FP2LocationTooltip::LootContextTags' has a wrong offset!");

// ScriptStruct Game.P2TeamMemberStatusChangedMessage
// 0x0068 (0x0068 - 0x0000)
struct FP2TeamMemberStatusChangedMessage final
{
public:
	int32                                         TeamId;                                            // 0x0000(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class AP2TeamStateBase*                       TeamState;                                         // 0x0008(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_10[0x58];                                      // 0x0010(0x0058)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FP2TeamMemberStatusChangedMessage) == 0x000008, "Wrong alignment on FP2TeamMemberStatusChangedMessage");
static_assert(sizeof(FP2TeamMemberStatusChangedMessage) == 0x000068, "Wrong size on FP2TeamMemberStatusChangedMessage");
static_assert(offsetof(FP2TeamMemberStatusChangedMessage, TeamId) == 0x000000, "Member 'FP2TeamMemberStatusChangedMessage::TeamId' has a wrong offset!");
static_assert(offsetof(FP2TeamMemberStatusChangedMessage, TeamState) == 0x000008, "Member 'FP2TeamMemberStatusChangedMessage::TeamState' has a wrong offset!");

// ScriptStruct Game.P2MapDeploymentMesh
// 0x0090 (0x0090 - 0x0000)
struct FP2MapDeploymentMesh final
{
public:
	struct FP2MapMeshExtendedDefinition           MeshDefinition;                                    // 0x0000(0x0090)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FP2MapDeploymentMesh) == 0x000010, "Wrong alignment on FP2MapDeploymentMesh");
static_assert(sizeof(FP2MapDeploymentMesh) == 0x000090, "Wrong size on FP2MapDeploymentMesh");
static_assert(offsetof(FP2MapDeploymentMesh, MeshDefinition) == 0x000000, "Member 'FP2MapDeploymentMesh::MeshDefinition' has a wrong offset!");

// ScriptStruct Game.P2ContractRequirementArea
// 0x0028 (0x0028 - 0x0000)
struct FP2ContractRequirementArea final
{
public:
	struct FGameplayTag                           LayerTag;                                          // 0x0000(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Location;                                          // 0x0008(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EP2ContractRequirementAreaRadius              Radius;                                            // 0x0020(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ShowWidgetIcon;                                    // 0x0021(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_22[0x6];                                       // 0x0022(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FP2ContractRequirementArea) == 0x000008, "Wrong alignment on FP2ContractRequirementArea");
static_assert(sizeof(FP2ContractRequirementArea) == 0x000028, "Wrong size on FP2ContractRequirementArea");
static_assert(offsetof(FP2ContractRequirementArea, LayerTag) == 0x000000, "Member 'FP2ContractRequirementArea::LayerTag' has a wrong offset!");
static_assert(offsetof(FP2ContractRequirementArea, Location) == 0x000008, "Member 'FP2ContractRequirementArea::Location' has a wrong offset!");
static_assert(offsetof(FP2ContractRequirementArea, Radius) == 0x000020, "Member 'FP2ContractRequirementArea::Radius' has a wrong offset!");
static_assert(offsetof(FP2ContractRequirementArea, ShowWidgetIcon) == 0x000021, "Member 'FP2ContractRequirementArea::ShowWidgetIcon' has a wrong offset!");

// ScriptStruct Game.P2SquadMemberColorData
// 0x0024 (0x0024 - 0x0000)
struct FP2SquadMemberColorData final
{
public:
	int32                                         SquadIndex;                                        // 0x0000(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           MainColor;                                         // 0x0004(0x0010)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           SecondaryColor;                                    // 0x0014(0x0010)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FP2SquadMemberColorData) == 0x000004, "Wrong alignment on FP2SquadMemberColorData");
static_assert(sizeof(FP2SquadMemberColorData) == 0x000024, "Wrong size on FP2SquadMemberColorData");
static_assert(offsetof(FP2SquadMemberColorData, SquadIndex) == 0x000000, "Member 'FP2SquadMemberColorData::SquadIndex' has a wrong offset!");
static_assert(offsetof(FP2SquadMemberColorData, MainColor) == 0x000004, "Member 'FP2SquadMemberColorData::MainColor' has a wrong offset!");
static_assert(offsetof(FP2SquadMemberColorData, SecondaryColor) == 0x000014, "Member 'FP2SquadMemberColorData::SecondaryColor' has a wrong offset!");

// ScriptStruct Game.P2ThrowableActorParams
// 0x0030 (0x0030 - 0x0000)
struct FP2ThrowableActorParams final
{
public:
	class UP2Throwable*                           Throwable;                                         // 0x0000(0x0008)(Edit, ZeroConstructor, DisableEditOnTemplate, EditConst, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                InitialVelocity;                                   // 0x0008(0x0018)(Edit, ZeroConstructor, DisableEditOnTemplate, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ProjectileSpeed;                                   // 0x0020(0x0004)(Edit, ZeroConstructor, DisableEditOnTemplate, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_24[0x4];                                       // 0x0024(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UP2ThrowableData*                       ThrowableData;                                     // 0x0028(0x0008)(Edit, ZeroConstructor, DisableEditOnTemplate, EditConst, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FP2ThrowableActorParams) == 0x000008, "Wrong alignment on FP2ThrowableActorParams");
static_assert(sizeof(FP2ThrowableActorParams) == 0x000030, "Wrong size on FP2ThrowableActorParams");
static_assert(offsetof(FP2ThrowableActorParams, Throwable) == 0x000000, "Member 'FP2ThrowableActorParams::Throwable' has a wrong offset!");
static_assert(offsetof(FP2ThrowableActorParams, InitialVelocity) == 0x000008, "Member 'FP2ThrowableActorParams::InitialVelocity' has a wrong offset!");
static_assert(offsetof(FP2ThrowableActorParams, ProjectileSpeed) == 0x000020, "Member 'FP2ThrowableActorParams::ProjectileSpeed' has a wrong offset!");
static_assert(offsetof(FP2ThrowableActorParams, ThrowableData) == 0x000028, "Member 'FP2ThrowableActorParams::ThrowableData' has a wrong offset!");

// ScriptStruct Game.P2DataLayersCollection
// 0x0010 (0x0010 - 0x0000)
struct FP2DataLayersCollection final
{
public:
	TArray<class UDataLayerAsset*>                DataLayers;                                        // 0x0000(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FP2DataLayersCollection) == 0x000008, "Wrong alignment on FP2DataLayersCollection");
static_assert(sizeof(FP2DataLayersCollection) == 0x000010, "Wrong size on FP2DataLayersCollection");
static_assert(offsetof(FP2DataLayersCollection, DataLayers) == 0x000000, "Member 'FP2DataLayersCollection::DataLayers' has a wrong offset!");

// ScriptStruct Game.P2MovementModeCue
// 0x000C (0x000C - 0x0000)
struct FP2MovementModeCue final
{
public:
	EMovementMode                                 MovementMode;                                      // 0x0000(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EP2CustomMovementMode                         CustomMode;                                        // 0x0001(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2[0x2];                                        // 0x0002(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayCueTag                        GameplayCue;                                       // 0x0004(0x0008)(Edit, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FP2MovementModeCue) == 0x000004, "Wrong alignment on FP2MovementModeCue");
static_assert(sizeof(FP2MovementModeCue) == 0x00000C, "Wrong size on FP2MovementModeCue");
static_assert(offsetof(FP2MovementModeCue, MovementMode) == 0x000000, "Member 'FP2MovementModeCue::MovementMode' has a wrong offset!");
static_assert(offsetof(FP2MovementModeCue, CustomMode) == 0x000001, "Member 'FP2MovementModeCue::CustomMode' has a wrong offset!");
static_assert(offsetof(FP2MovementModeCue, GameplayCue) == 0x000004, "Member 'FP2MovementModeCue::GameplayCue' has a wrong offset!");

// ScriptStruct Game.P2TargetTracePoint
// 0x0040 (0x0040 - 0x0000)
struct FP2TargetTracePoint final
{
public:
	struct FGameplayTag                           DamageZoneTag;                                     // 0x0000(0x0008)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Location;                                          // 0x0008(0x0018)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTagContainer                  RelatedTagsFromPhysicalMaterial;                   // 0x0020(0x0020)(Edit, NativeAccessSpecifierPublic)
};
static_assert(alignof(FP2TargetTracePoint) == 0x000008, "Wrong alignment on FP2TargetTracePoint");
static_assert(sizeof(FP2TargetTracePoint) == 0x000040, "Wrong size on FP2TargetTracePoint");
static_assert(offsetof(FP2TargetTracePoint, DamageZoneTag) == 0x000000, "Member 'FP2TargetTracePoint::DamageZoneTag' has a wrong offset!");
static_assert(offsetof(FP2TargetTracePoint, Location) == 0x000008, "Member 'FP2TargetTracePoint::Location' has a wrong offset!");
static_assert(offsetof(FP2TargetTracePoint, RelatedTagsFromPhysicalMaterial) == 0x000020, "Member 'FP2TargetTracePoint::RelatedTagsFromPhysicalMaterial' has a wrong offset!");

// ScriptStruct Game.P2OperationalTaskNodeDataInfo
// 0x0008 (0x0010 - 0x0008)
struct FP2OperationalTaskNodeDataInfo final : public FP2RequirementDataInfo
{
public:
	class UP2OperationalTaskNodeData*             Data;                                              // 0x0008(0x0008)(Edit, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FP2OperationalTaskNodeDataInfo) == 0x000008, "Wrong alignment on FP2OperationalTaskNodeDataInfo");
static_assert(sizeof(FP2OperationalTaskNodeDataInfo) == 0x000010, "Wrong size on FP2OperationalTaskNodeDataInfo");
static_assert(offsetof(FP2OperationalTaskNodeDataInfo, Data) == 0x000008, "Member 'FP2OperationalTaskNodeDataInfo::Data' has a wrong offset!");

// ScriptStruct Game.P2OperationalTaskStageData
// 0x0048 (0x0048 - 0x0000)
struct FP2OperationalTaskStageData final
{
public:
	class FText                                   StageTitle;                                        // 0x0000(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	TArray<int32>                                 IndexDependencies;                                 // 0x0018(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	class UP2OperationalTaskStageRequirement*     CompletionRequirement;                             // 0x0028(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, PersistentInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class UP2OperationalTaskStageRewardBase*> CompletionRewards;                              // 0x0030(0x0010)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, ContainsInstancedReference, UObjectWrapper, NativeAccessSpecifierPublic)
	float                                         CurrencyReward;                                    // 0x0040(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ExperienceReward;                                  // 0x0044(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FP2OperationalTaskStageData) == 0x000008, "Wrong alignment on FP2OperationalTaskStageData");
static_assert(sizeof(FP2OperationalTaskStageData) == 0x000048, "Wrong size on FP2OperationalTaskStageData");
static_assert(offsetof(FP2OperationalTaskStageData, StageTitle) == 0x000000, "Member 'FP2OperationalTaskStageData::StageTitle' has a wrong offset!");
static_assert(offsetof(FP2OperationalTaskStageData, IndexDependencies) == 0x000018, "Member 'FP2OperationalTaskStageData::IndexDependencies' has a wrong offset!");
static_assert(offsetof(FP2OperationalTaskStageData, CompletionRequirement) == 0x000028, "Member 'FP2OperationalTaskStageData::CompletionRequirement' has a wrong offset!");
static_assert(offsetof(FP2OperationalTaskStageData, CompletionRewards) == 0x000030, "Member 'FP2OperationalTaskStageData::CompletionRewards' has a wrong offset!");
static_assert(offsetof(FP2OperationalTaskStageData, CurrencyReward) == 0x000040, "Member 'FP2OperationalTaskStageData::CurrencyReward' has a wrong offset!");
static_assert(offsetof(FP2OperationalTaskStageData, ExperienceReward) == 0x000044, "Member 'FP2OperationalTaskStageData::ExperienceReward' has a wrong offset!");

// ScriptStruct Game.P2OperationalTaskClothingUpgradeDisplayInfo
// 0x0050 (0x0050 - 0x0000)
struct FP2OperationalTaskClothingUpgradeDisplayInfo final
{
public:
	class FText                                   DisplayName;                                       // 0x0000(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, EditConst, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UTexture2D>              DisplayIcon;                                       // 0x0018(0x0030)(Edit, BlueprintVisible, BlueprintReadOnly, EditConst, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         DisplayLevel;                                      // 0x0048(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4C[0x4];                                       // 0x004C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FP2OperationalTaskClothingUpgradeDisplayInfo) == 0x000008, "Wrong alignment on FP2OperationalTaskClothingUpgradeDisplayInfo");
static_assert(sizeof(FP2OperationalTaskClothingUpgradeDisplayInfo) == 0x000050, "Wrong size on FP2OperationalTaskClothingUpgradeDisplayInfo");
static_assert(offsetof(FP2OperationalTaskClothingUpgradeDisplayInfo, DisplayName) == 0x000000, "Member 'FP2OperationalTaskClothingUpgradeDisplayInfo::DisplayName' has a wrong offset!");
static_assert(offsetof(FP2OperationalTaskClothingUpgradeDisplayInfo, DisplayIcon) == 0x000018, "Member 'FP2OperationalTaskClothingUpgradeDisplayInfo::DisplayIcon' has a wrong offset!");
static_assert(offsetof(FP2OperationalTaskClothingUpgradeDisplayInfo, DisplayLevel) == 0x000048, "Member 'FP2OperationalTaskClothingUpgradeDisplayInfo::DisplayLevel' has a wrong offset!");

// ScriptStruct Game.P2OperationalTaskMessage
// 0x0008 (0x0008 - 0x0000)
struct FP2OperationalTaskMessage
{
public:
	class UP2OperationalTaskNode*                 OperationalTask;                                   // 0x0000(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FP2OperationalTaskMessage) == 0x000008, "Wrong alignment on FP2OperationalTaskMessage");
static_assert(sizeof(FP2OperationalTaskMessage) == 0x000008, "Wrong size on FP2OperationalTaskMessage");
static_assert(offsetof(FP2OperationalTaskMessage, OperationalTask) == 0x000000, "Member 'FP2OperationalTaskMessage::OperationalTask' has a wrong offset!");

// ScriptStruct Game.P2InstantEffectApplicationConfig
// 0x0008 (0x0008 - 0x0000)
struct FP2InstantEffectApplicationConfig final
{
public:
	TSubclassOf<class UGameplayEffect>            GameplayEffect;                                    // 0x0000(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FP2InstantEffectApplicationConfig) == 0x000008, "Wrong alignment on FP2InstantEffectApplicationConfig");
static_assert(sizeof(FP2InstantEffectApplicationConfig) == 0x000008, "Wrong size on FP2InstantEffectApplicationConfig");
static_assert(offsetof(FP2InstantEffectApplicationConfig, GameplayEffect) == 0x000000, "Member 'FP2InstantEffectApplicationConfig::GameplayEffect' has a wrong offset!");

// ScriptStruct Game.P2OperationalTaskStateMessage
// 0x0008 (0x0010 - 0x0008)
struct FP2OperationalTaskStateMessage final : public FP2OperationalTaskMessage
{
public:
	EP2OperationalTaskNodeState                   PreviousState;                                     // 0x0008(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EP2OperationalTaskNodeState                   CurrentState;                                      // 0x0009(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A[0x6];                                        // 0x000A(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FP2OperationalTaskStateMessage) == 0x000008, "Wrong alignment on FP2OperationalTaskStateMessage");
static_assert(sizeof(FP2OperationalTaskStateMessage) == 0x000010, "Wrong size on FP2OperationalTaskStateMessage");
static_assert(offsetof(FP2OperationalTaskStateMessage, PreviousState) == 0x000008, "Member 'FP2OperationalTaskStateMessage::PreviousState' has a wrong offset!");
static_assert(offsetof(FP2OperationalTaskStateMessage, CurrentState) == 0x000009, "Member 'FP2OperationalTaskStateMessage::CurrentState' has a wrong offset!");

// ScriptStruct Game.P2OperationalTaskStageStateMessage
// 0x0008 (0x0010 - 0x0008)
struct FP2OperationalTaskStageStateMessage final : public FP2OperationalTaskMessage
{
public:
	int32                                         StageIndex;                                        // 0x0008(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EP2OperationalTaskStageState                  PreviousState;                                     // 0x000C(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EP2OperationalTaskStageState                  CurrentState;                                      // 0x000D(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_E[0x2];                                        // 0x000E(0x0002)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FP2OperationalTaskStageStateMessage) == 0x000008, "Wrong alignment on FP2OperationalTaskStageStateMessage");
static_assert(sizeof(FP2OperationalTaskStageStateMessage) == 0x000010, "Wrong size on FP2OperationalTaskStageStateMessage");
static_assert(offsetof(FP2OperationalTaskStageStateMessage, StageIndex) == 0x000008, "Member 'FP2OperationalTaskStageStateMessage::StageIndex' has a wrong offset!");
static_assert(offsetof(FP2OperationalTaskStageStateMessage, PreviousState) == 0x00000C, "Member 'FP2OperationalTaskStageStateMessage::PreviousState' has a wrong offset!");
static_assert(offsetof(FP2OperationalTaskStageStateMessage, CurrentState) == 0x00000D, "Member 'FP2OperationalTaskStageStateMessage::CurrentState' has a wrong offset!");

// ScriptStruct Game.P2OutdoorReverbSettingsRow
// 0x0040 (0x0048 - 0x0008)
struct FP2OutdoorReverbSettingsRow final : public FTableRowBase
{
public:
	struct FGameplayTag                           TargetTag;                                         // 0x0008(0x0008)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ReverbMaxDistance;                                 // 0x0010(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FFloatRange                            DirectionalityRange;                               // 0x0014(0x0010)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FFloatRange                            SendLevelRange;                                    // 0x0024(0x0010)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FFloatRange                            SendLevelGainsDB;                                  // 0x0034(0x0010)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_44[0x4];                                       // 0x0044(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FP2OutdoorReverbSettingsRow) == 0x000008, "Wrong alignment on FP2OutdoorReverbSettingsRow");
static_assert(sizeof(FP2OutdoorReverbSettingsRow) == 0x000048, "Wrong size on FP2OutdoorReverbSettingsRow");
static_assert(offsetof(FP2OutdoorReverbSettingsRow, TargetTag) == 0x000008, "Member 'FP2OutdoorReverbSettingsRow::TargetTag' has a wrong offset!");
static_assert(offsetof(FP2OutdoorReverbSettingsRow, ReverbMaxDistance) == 0x000010, "Member 'FP2OutdoorReverbSettingsRow::ReverbMaxDistance' has a wrong offset!");
static_assert(offsetof(FP2OutdoorReverbSettingsRow, DirectionalityRange) == 0x000014, "Member 'FP2OutdoorReverbSettingsRow::DirectionalityRange' has a wrong offset!");
static_assert(offsetof(FP2OutdoorReverbSettingsRow, SendLevelRange) == 0x000024, "Member 'FP2OutdoorReverbSettingsRow::SendLevelRange' has a wrong offset!");
static_assert(offsetof(FP2OutdoorReverbSettingsRow, SendLevelGainsDB) == 0x000034, "Member 'FP2OutdoorReverbSettingsRow::SendLevelGainsDB' has a wrong offset!");

// ScriptStruct Game.P2CustomizationObjectArray
// 0x0020 (0x0020 - 0x0000)
struct FP2CustomizationObjectArray final
{
public:
	TArray<class UP2CustomizationObjectData*>     CustomizationObjects;                              // 0x0000(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, UObjectWrapper, NativeAccessSpecifierPublic)
	TArray<class UP2WearableData*>                CustomizationItems;                                // 0x0010(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, UObjectWrapper, NativeAccessSpecifierPublic)
};
static_assert(alignof(FP2CustomizationObjectArray) == 0x000008, "Wrong alignment on FP2CustomizationObjectArray");
static_assert(sizeof(FP2CustomizationObjectArray) == 0x000020, "Wrong size on FP2CustomizationObjectArray");
static_assert(offsetof(FP2CustomizationObjectArray, CustomizationObjects) == 0x000000, "Member 'FP2CustomizationObjectArray::CustomizationObjects' has a wrong offset!");
static_assert(offsetof(FP2CustomizationObjectArray, CustomizationItems) == 0x000010, "Member 'FP2CustomizationObjectArray::CustomizationItems' has a wrong offset!");

// ScriptStruct Game.P2SelectedCustomization
// 0x00F0 (0x00F0 - 0x0000)
struct FP2SelectedCustomization final
{
public:
	TMap<class FName, class UP2CustomizationObjectData*> SelectedCustomizationObjects;               // 0x0000(0x0050)(NativeAccessSpecifierPublic)
	TMap<class FName, class UP2WearableData*>     SelectedCustomizationItems;                        // 0x0050(0x0050)(NativeAccessSpecifierPublic)
	TMap<class UP2WearableData*, struct FP2SkinCustomizationData> SelectedCustomizationItemSkin;     // 0x00A0(0x0050)(NativeAccessSpecifierPublic)
};
static_assert(alignof(FP2SelectedCustomization) == 0x000008, "Wrong alignment on FP2SelectedCustomization");
static_assert(sizeof(FP2SelectedCustomization) == 0x0000F0, "Wrong size on FP2SelectedCustomization");
static_assert(offsetof(FP2SelectedCustomization, SelectedCustomizationObjects) == 0x000000, "Member 'FP2SelectedCustomization::SelectedCustomizationObjects' has a wrong offset!");
static_assert(offsetof(FP2SelectedCustomization, SelectedCustomizationItems) == 0x000050, "Member 'FP2SelectedCustomization::SelectedCustomizationItems' has a wrong offset!");
static_assert(offsetof(FP2SelectedCustomization, SelectedCustomizationItemSkin) == 0x0000A0, "Member 'FP2SelectedCustomization::SelectedCustomizationItemSkin' has a wrong offset!");

// ScriptStruct Game.P2CustomizationData_RPC
// 0x0018 (0x0018 - 0x0000)
struct FP2CustomizationData_RPC final
{
public:
	class UP2CustomizationBodyData*               Body;                                              // 0x0000(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class UP2CustomizationObjectData*>     CustomizationObjects;                              // 0x0008(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FP2CustomizationData_RPC) == 0x000008, "Wrong alignment on FP2CustomizationData_RPC");
static_assert(sizeof(FP2CustomizationData_RPC) == 0x000018, "Wrong size on FP2CustomizationData_RPC");
static_assert(offsetof(FP2CustomizationData_RPC, Body) == 0x000000, "Member 'FP2CustomizationData_RPC::Body' has a wrong offset!");
static_assert(offsetof(FP2CustomizationData_RPC, CustomizationObjects) == 0x000008, "Member 'FP2CustomizationData_RPC::CustomizationObjects' has a wrong offset!");

// ScriptStruct Game.MapMarkerArray
// 0x0018 (0x0120 - 0x0108)
struct FMapMarkerArray final : public FFastArraySerializer
{
public:
	TArray<struct FMapMarkerItem>                 MapMarkers;                                        // 0x0108(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_118[0x8];                                      // 0x0118(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FMapMarkerArray) == 0x000008, "Wrong alignment on FMapMarkerArray");
static_assert(sizeof(FMapMarkerArray) == 0x000120, "Wrong size on FMapMarkerArray");
static_assert(offsetof(FMapMarkerArray, MapMarkers) == 0x000108, "Member 'FMapMarkerArray::MapMarkers' has a wrong offset!");

// ScriptStruct Game.P2DamageZoneExpReward
// 0x0014 (0x0014 - 0x0000)
struct FP2DamageZoneExpReward final
{
public:
	struct FGameplayTag                           TargetPawnTag;                                     // 0x0000(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           DamageZoneTag;                                     // 0x0008(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ExpCoefficient;                                    // 0x0010(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FP2DamageZoneExpReward) == 0x000004, "Wrong alignment on FP2DamageZoneExpReward");
static_assert(sizeof(FP2DamageZoneExpReward) == 0x000014, "Wrong size on FP2DamageZoneExpReward");
static_assert(offsetof(FP2DamageZoneExpReward, TargetPawnTag) == 0x000000, "Member 'FP2DamageZoneExpReward::TargetPawnTag' has a wrong offset!");
static_assert(offsetof(FP2DamageZoneExpReward, DamageZoneTag) == 0x000008, "Member 'FP2DamageZoneExpReward::DamageZoneTag' has a wrong offset!");
static_assert(offsetof(FP2DamageZoneExpReward, ExpCoefficient) == 0x000010, "Member 'FP2DamageZoneExpReward::ExpCoefficient' has a wrong offset!");

// ScriptStruct Game.P2GradeTextInfo
// 0x0020 (0x0020 - 0x0000)
struct FP2GradeTextInfo final
{
public:
	int32                                         Grade;                                             // 0x0000(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   GradeText;                                         // 0x0008(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
};
static_assert(alignof(FP2GradeTextInfo) == 0x000008, "Wrong alignment on FP2GradeTextInfo");
static_assert(sizeof(FP2GradeTextInfo) == 0x000020, "Wrong size on FP2GradeTextInfo");
static_assert(offsetof(FP2GradeTextInfo, Grade) == 0x000000, "Member 'FP2GradeTextInfo::Grade' has a wrong offset!");
static_assert(offsetof(FP2GradeTextInfo, GradeText) == 0x000008, "Member 'FP2GradeTextInfo::GradeText' has a wrong offset!");

// ScriptStruct Game.WeaponExperience
// 0x0010 (0x0010 - 0x0000)
struct FWeaponExperience final
{
public:
	struct FGameplayTag                           WeaponTag;                                         // 0x0000(0x0008)(Edit, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Expr;                                              // 0x0008(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         BonusExpr;                                         // 0x000C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FWeaponExperience) == 0x000004, "Wrong alignment on FWeaponExperience");
static_assert(sizeof(FWeaponExperience) == 0x000010, "Wrong size on FWeaponExperience");
static_assert(offsetof(FWeaponExperience, WeaponTag) == 0x000000, "Member 'FWeaponExperience::WeaponTag' has a wrong offset!");
static_assert(offsetof(FWeaponExperience, Expr) == 0x000008, "Member 'FWeaponExperience::Expr' has a wrong offset!");
static_assert(offsetof(FWeaponExperience, BonusExpr) == 0x00000C, "Member 'FWeaponExperience::BonusExpr' has a wrong offset!");

// ScriptStruct Game.P2AcquireLevelProcessorConfig
// 0x0010 (0x0010 - 0x0000)
struct FP2AcquireLevelProcessorConfig final
{
public:
	class UP2AcquireLevelEventProcessor*          Processor;                                         // 0x0000(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, PersistentInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Level;                                             // 0x0008(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FP2AcquireLevelProcessorConfig) == 0x000008, "Wrong alignment on FP2AcquireLevelProcessorConfig");
static_assert(sizeof(FP2AcquireLevelProcessorConfig) == 0x000010, "Wrong size on FP2AcquireLevelProcessorConfig");
static_assert(offsetof(FP2AcquireLevelProcessorConfig, Processor) == 0x000000, "Member 'FP2AcquireLevelProcessorConfig::Processor' has a wrong offset!");
static_assert(offsetof(FP2AcquireLevelProcessorConfig, Level) == 0x000008, "Member 'FP2AcquireLevelProcessorConfig::Level' has a wrong offset!");

// ScriptStruct Game.P2PlayerAcquireLevelEventsConfigElement
// 0x0018 (0x0018 - 0x0000)
struct FP2PlayerAcquireLevelEventsConfigElement final
{
public:
	TArray<class UP2AcquireLevelEventProcessor*>  LevelEventProcessors;                              // 0x0000(0x0010)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, ContainsInstancedReference, NativeAccessSpecifierPublic)
	int32                                         Level;                                             // 0x0010(0x0004)(Edit, ZeroConstructor, DisableEditOnTemplate, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FP2PlayerAcquireLevelEventsConfigElement) == 0x000008, "Wrong alignment on FP2PlayerAcquireLevelEventsConfigElement");
static_assert(sizeof(FP2PlayerAcquireLevelEventsConfigElement) == 0x000018, "Wrong size on FP2PlayerAcquireLevelEventsConfigElement");
static_assert(offsetof(FP2PlayerAcquireLevelEventsConfigElement, LevelEventProcessors) == 0x000000, "Member 'FP2PlayerAcquireLevelEventsConfigElement::LevelEventProcessors' has a wrong offset!");
static_assert(offsetof(FP2PlayerAcquireLevelEventsConfigElement, Level) == 0x000010, "Member 'FP2PlayerAcquireLevelEventsConfigElement::Level' has a wrong offset!");

// ScriptStruct Game.P2SkillSlotInfo
// 0x0050 (0x0050 - 0x0000)
struct FP2SkillSlotInfo final
{
public:
	struct FGameplayTagContainer                  SkillInfoTags;                                     // 0x0000(0x0020)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	class UObject*                                SkillObject;                                       // 0x0020(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FText                                   SkillName;                                         // 0x0028(0x0018)(NativeAccessSpecifierPrivate)
	TArray<class FText>                           SkillDescriptions;                                 // 0x0040(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
};
static_assert(alignof(FP2SkillSlotInfo) == 0x000008, "Wrong alignment on FP2SkillSlotInfo");
static_assert(sizeof(FP2SkillSlotInfo) == 0x000050, "Wrong size on FP2SkillSlotInfo");
static_assert(offsetof(FP2SkillSlotInfo, SkillInfoTags) == 0x000000, "Member 'FP2SkillSlotInfo::SkillInfoTags' has a wrong offset!");
static_assert(offsetof(FP2SkillSlotInfo, SkillObject) == 0x000020, "Member 'FP2SkillSlotInfo::SkillObject' has a wrong offset!");
static_assert(offsetof(FP2SkillSlotInfo, SkillName) == 0x000028, "Member 'FP2SkillSlotInfo::SkillName' has a wrong offset!");
static_assert(offsetof(FP2SkillSlotInfo, SkillDescriptions) == 0x000040, "Member 'FP2SkillSlotInfo::SkillDescriptions' has a wrong offset!");

// ScriptStruct Game.P2ActorMessage
// 0x0008 (0x0008 - 0x0000)
struct FP2ActorMessage final
{
public:
	class AActor*                                 Actor;                                             // 0x0000(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FP2ActorMessage) == 0x000008, "Wrong alignment on FP2ActorMessage");
static_assert(sizeof(FP2ActorMessage) == 0x000008, "Wrong size on FP2ActorMessage");
static_assert(offsetof(FP2ActorMessage, Actor) == 0x000000, "Member 'FP2ActorMessage::Actor' has a wrong offset!");

// ScriptStruct Game.P2LevelingData
// 0x0018 (0x0020 - 0x0008)
struct FP2LevelingData final : public FTableRowBase
{
public:
	struct FGameplayTag                           PlayerSkill;                                       // 0x0008(0x0008)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ExperienceToNextLevel;                             // 0x0010(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MainExpLimitPerRaid;                               // 0x0014(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         BonusExpLimitPerRaid;                              // 0x0018(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C[0x4];                                       // 0x001C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FP2LevelingData) == 0x000008, "Wrong alignment on FP2LevelingData");
static_assert(sizeof(FP2LevelingData) == 0x000020, "Wrong size on FP2LevelingData");
static_assert(offsetof(FP2LevelingData, PlayerSkill) == 0x000008, "Member 'FP2LevelingData::PlayerSkill' has a wrong offset!");
static_assert(offsetof(FP2LevelingData, ExperienceToNextLevel) == 0x000010, "Member 'FP2LevelingData::ExperienceToNextLevel' has a wrong offset!");
static_assert(offsetof(FP2LevelingData, MainExpLimitPerRaid) == 0x000014, "Member 'FP2LevelingData::MainExpLimitPerRaid' has a wrong offset!");
static_assert(offsetof(FP2LevelingData, BonusExpLimitPerRaid) == 0x000018, "Member 'FP2LevelingData::BonusExpLimitPerRaid' has a wrong offset!");

// ScriptStruct Game.P2LevelingEventsData
// 0x0010 (0x0018 - 0x0008)
struct FP2LevelingEventsData final : public FTableRowBase
{
public:
	struct FGameplayTag                           PlayerSkill;                                       // 0x0008(0x0008)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UP2PlayerLevelingEventsConfig*          Config;                                            // 0x0010(0x0008)(Edit, ZeroConstructor, NoClear, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FP2LevelingEventsData) == 0x000008, "Wrong alignment on FP2LevelingEventsData");
static_assert(sizeof(FP2LevelingEventsData) == 0x000018, "Wrong size on FP2LevelingEventsData");
static_assert(offsetof(FP2LevelingEventsData, PlayerSkill) == 0x000008, "Member 'FP2LevelingEventsData::PlayerSkill' has a wrong offset!");
static_assert(offsetof(FP2LevelingEventsData, Config) == 0x000010, "Member 'FP2LevelingEventsData::Config' has a wrong offset!");

// ScriptStruct Game.P2AcquireLevelEventsData
// 0x0010 (0x0018 - 0x0008)
struct FP2AcquireLevelEventsData final : public FTableRowBase
{
public:
	struct FGameplayTag                           PlayerSkill;                                       // 0x0008(0x0008)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UP2PlayerAcquireLevelEventsConfig*      Config;                                            // 0x0010(0x0008)(Edit, ZeroConstructor, NoClear, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FP2AcquireLevelEventsData) == 0x000008, "Wrong alignment on FP2AcquireLevelEventsData");
static_assert(sizeof(FP2AcquireLevelEventsData) == 0x000018, "Wrong size on FP2AcquireLevelEventsData");
static_assert(offsetof(FP2AcquireLevelEventsData, PlayerSkill) == 0x000008, "Member 'FP2AcquireLevelEventsData::PlayerSkill' has a wrong offset!");
static_assert(offsetof(FP2AcquireLevelEventsData, Config) == 0x000010, "Member 'FP2AcquireLevelEventsData::Config' has a wrong offset!");

// ScriptStruct Game.P2BindKeys
// 0x0010 (0x0010 - 0x0000)
struct FP2BindKeys final
{
public:
	TArray<struct FKey>                           Keys;                                              // 0x0000(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FP2BindKeys) == 0x000008, "Wrong alignment on FP2BindKeys");
static_assert(sizeof(FP2BindKeys) == 0x000010, "Wrong size on FP2BindKeys");
static_assert(offsetof(FP2BindKeys, Keys) == 0x000000, "Member 'FP2BindKeys::Keys' has a wrong offset!");

// ScriptStruct Game.P2SkillLevelingBase
// 0x0010 (0x0010 - 0x0000)
struct FP2SkillLevelingBase
{
public:
	struct FGameplayTag                           PlayerSkill;                                       // 0x0000(0x0008)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         LevelIdx;                                          // 0x0008(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FP2SkillLevelingBase) == 0x000004, "Wrong alignment on FP2SkillLevelingBase");
static_assert(sizeof(FP2SkillLevelingBase) == 0x000010, "Wrong size on FP2SkillLevelingBase");
static_assert(offsetof(FP2SkillLevelingBase, PlayerSkill) == 0x000000, "Member 'FP2SkillLevelingBase::PlayerSkill' has a wrong offset!");
static_assert(offsetof(FP2SkillLevelingBase, LevelIdx) == 0x000008, "Member 'FP2SkillLevelingBase::LevelIdx' has a wrong offset!");

// ScriptStruct Game.P2SkillLeveling
// 0x000C (0x001C - 0x0010)
struct FP2SkillLeveling final : public FP2SkillLevelingBase
{
public:
	int32                                         LevelExperience;                                   // 0x0010(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         LevelTempExperience;                               // 0x0014(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         LevelBonusTempExperience;                          // 0x0018(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FP2SkillLeveling) == 0x000004, "Wrong alignment on FP2SkillLeveling");
static_assert(sizeof(FP2SkillLeveling) == 0x00001C, "Wrong size on FP2SkillLeveling");
static_assert(offsetof(FP2SkillLeveling, LevelExperience) == 0x000010, "Member 'FP2SkillLeveling::LevelExperience' has a wrong offset!");
static_assert(offsetof(FP2SkillLeveling, LevelTempExperience) == 0x000014, "Member 'FP2SkillLeveling::LevelTempExperience' has a wrong offset!");
static_assert(offsetof(FP2SkillLeveling, LevelBonusTempExperience) == 0x000018, "Member 'FP2SkillLeveling::LevelBonusTempExperience' has a wrong offset!");

// ScriptStruct Game.DisplayActorNames
// 0x0038 (0x0038 - 0x0000)
struct FDisplayActorNames final
{
public:
	class FString                                 ActorName;                                         // 0x0000(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 DisplayName;                                       // 0x0010(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                ActorLocation;                                     // 0x0020(0x0018)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FDisplayActorNames) == 0x000008, "Wrong alignment on FDisplayActorNames");
static_assert(sizeof(FDisplayActorNames) == 0x000038, "Wrong size on FDisplayActorNames");
static_assert(offsetof(FDisplayActorNames, ActorName) == 0x000000, "Member 'FDisplayActorNames::ActorName' has a wrong offset!");
static_assert(offsetof(FDisplayActorNames, DisplayName) == 0x000010, "Member 'FDisplayActorNames::DisplayName' has a wrong offset!");
static_assert(offsetof(FDisplayActorNames, ActorLocation) == 0x000020, "Member 'FDisplayActorNames::ActorLocation' has a wrong offset!");

// ScriptStruct Game.P2UnlockContentBase
// 0x00A8 (0x00A8 - 0x0000)
struct FP2UnlockContentBase
{
public:
	struct FGameplayTag                           UnlockContentTag;                                  // 0x0000(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FP2MailCreateParam                     UnlockMailCreateParam;                             // 0x0008(0x0090)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TArray<class UP2UnlockContentRewardBase*>     UnlockRewards;                                     // 0x0098(0x0010)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, ContainsInstancedReference, UObjectWrapper, NativeAccessSpecifierPublic)
};
static_assert(alignof(FP2UnlockContentBase) == 0x000008, "Wrong alignment on FP2UnlockContentBase");
static_assert(sizeof(FP2UnlockContentBase) == 0x0000A8, "Wrong size on FP2UnlockContentBase");
static_assert(offsetof(FP2UnlockContentBase, UnlockContentTag) == 0x000000, "Member 'FP2UnlockContentBase::UnlockContentTag' has a wrong offset!");
static_assert(offsetof(FP2UnlockContentBase, UnlockMailCreateParam) == 0x000008, "Member 'FP2UnlockContentBase::UnlockMailCreateParam' has a wrong offset!");
static_assert(offsetof(FP2UnlockContentBase, UnlockRewards) == 0x000098, "Member 'FP2UnlockContentBase::UnlockRewards' has a wrong offset!");

// ScriptStruct Game.P2LevelUnlockContent
// 0x0008 (0x00B0 - 0x00A8)
struct FP2LevelUnlockContent final : public FP2UnlockContentBase
{
public:
	int32                                         Level;                                             // 0x00A8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_AC[0x4];                                       // 0x00AC(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FP2LevelUnlockContent) == 0x000008, "Wrong alignment on FP2LevelUnlockContent");
static_assert(sizeof(FP2LevelUnlockContent) == 0x0000B0, "Wrong size on FP2LevelUnlockContent");
static_assert(offsetof(FP2LevelUnlockContent, Level) == 0x0000A8, "Member 'FP2LevelUnlockContent::Level' has a wrong offset!");

// ScriptStruct Game.P2FactionLevelUnlockContent
// 0x0010 (0x00B8 - 0x00A8)
struct FP2FactionLevelUnlockContent final : public FP2UnlockContentBase
{
public:
	struct FGameplayTag                           FactionTag;                                        // 0x00A8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           FactionLevelTag;                                   // 0x00B0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FP2FactionLevelUnlockContent) == 0x000008, "Wrong alignment on FP2FactionLevelUnlockContent");
static_assert(sizeof(FP2FactionLevelUnlockContent) == 0x0000B8, "Wrong size on FP2FactionLevelUnlockContent");
static_assert(offsetof(FP2FactionLevelUnlockContent, FactionTag) == 0x0000A8, "Member 'FP2FactionLevelUnlockContent::FactionTag' has a wrong offset!");
static_assert(offsetof(FP2FactionLevelUnlockContent, FactionLevelTag) == 0x0000B0, "Member 'FP2FactionLevelUnlockContent::FactionLevelTag' has a wrong offset!");

// ScriptStruct Game.P2ToggleableCheatCommand
// 0x0018 (0x0018 - 0x0000)
struct FP2ToggleableCheatCommand final
{
public:
	bool                                          bEnabled;                                          // 0x0000(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 Command;                                           // 0x0008(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FP2ToggleableCheatCommand) == 0x000008, "Wrong alignment on FP2ToggleableCheatCommand");
static_assert(sizeof(FP2ToggleableCheatCommand) == 0x000018, "Wrong size on FP2ToggleableCheatCommand");
static_assert(offsetof(FP2ToggleableCheatCommand, bEnabled) == 0x000000, "Member 'FP2ToggleableCheatCommand::bEnabled' has a wrong offset!");
static_assert(offsetof(FP2ToggleableCheatCommand, Command) == 0x000008, "Member 'FP2ToggleableCheatCommand::Command' has a wrong offset!");

// ScriptStruct Game.P2ItemGradeColorData
// 0x0034 (0x0034 - 0x0000)
struct FP2ItemGradeColorData final
{
public:
	int32                                         ItemGrade;                                         // 0x0000(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           ItemGradeColor;                                    // 0x0004(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           ItemGradeBgColor;                                  // 0x0014(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           ItemGradientColor;                                 // 0x0024(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FP2ItemGradeColorData) == 0x000004, "Wrong alignment on FP2ItemGradeColorData");
static_assert(sizeof(FP2ItemGradeColorData) == 0x000034, "Wrong size on FP2ItemGradeColorData");
static_assert(offsetof(FP2ItemGradeColorData, ItemGrade) == 0x000000, "Member 'FP2ItemGradeColorData::ItemGrade' has a wrong offset!");
static_assert(offsetof(FP2ItemGradeColorData, ItemGradeColor) == 0x000004, "Member 'FP2ItemGradeColorData::ItemGradeColor' has a wrong offset!");
static_assert(offsetof(FP2ItemGradeColorData, ItemGradeBgColor) == 0x000014, "Member 'FP2ItemGradeColorData::ItemGradeBgColor' has a wrong offset!");
static_assert(offsetof(FP2ItemGradeColorData, ItemGradientColor) == 0x000024, "Member 'FP2ItemGradeColorData::ItemGradientColor' has a wrong offset!");

// ScriptStruct Game.P2ItemSnapshot
// 0x0088 (0x0088 - 0x0000)
struct FP2ItemSnapshot final
{
public:
	TWeakObjectPtr<class UP2ItemData>             ItemData;                                          // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<TWeakObjectPtr<class UP2AttachableData>> Attachables;                                     // 0x0008(0x0010)(ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
	int32                                         Quantity;                                          // 0x0018(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TWeakObjectPtr<class UP2AmmoData>             AmmoType;                                          // 0x001C(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_24[0x4];                                       // 0x0024(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UP2Item*>                        ItemsForSnapshot;                                  // 0x0028(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TMap<class UP2ItemData*, int32>               MissingItemDataMap;                                // 0x0038(0x0050)(Transient, RepSkip, NativeAccessSpecifierPublic)
};
static_assert(alignof(FP2ItemSnapshot) == 0x000008, "Wrong alignment on FP2ItemSnapshot");
static_assert(sizeof(FP2ItemSnapshot) == 0x000088, "Wrong size on FP2ItemSnapshot");
static_assert(offsetof(FP2ItemSnapshot, ItemData) == 0x000000, "Member 'FP2ItemSnapshot::ItemData' has a wrong offset!");
static_assert(offsetof(FP2ItemSnapshot, Attachables) == 0x000008, "Member 'FP2ItemSnapshot::Attachables' has a wrong offset!");
static_assert(offsetof(FP2ItemSnapshot, Quantity) == 0x000018, "Member 'FP2ItemSnapshot::Quantity' has a wrong offset!");
static_assert(offsetof(FP2ItemSnapshot, AmmoType) == 0x00001C, "Member 'FP2ItemSnapshot::AmmoType' has a wrong offset!");
static_assert(offsetof(FP2ItemSnapshot, ItemsForSnapshot) == 0x000028, "Member 'FP2ItemSnapshot::ItemsForSnapshot' has a wrong offset!");
static_assert(offsetof(FP2ItemSnapshot, MissingItemDataMap) == 0x000038, "Member 'FP2ItemSnapshot::MissingItemDataMap' has a wrong offset!");

// ScriptStruct Game.P2ContainerItemSnapshot
// 0x0098 (0x0098 - 0x0000)
struct FP2ContainerItemSnapshot final
{
public:
	int32                                         ContainerIdx;                                      // 0x0000(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FP2ItemSnapshot                        ContainerItem;                                     // 0x0008(0x0088)(NativeAccessSpecifierPublic)
	struct FPositionInfo                          PositionInfo;                                      // 0x0090(0x0008)(NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FP2ContainerItemSnapshot) == 0x000008, "Wrong alignment on FP2ContainerItemSnapshot");
static_assert(sizeof(FP2ContainerItemSnapshot) == 0x000098, "Wrong size on FP2ContainerItemSnapshot");
static_assert(offsetof(FP2ContainerItemSnapshot, ContainerIdx) == 0x000000, "Member 'FP2ContainerItemSnapshot::ContainerIdx' has a wrong offset!");
static_assert(offsetof(FP2ContainerItemSnapshot, ContainerItem) == 0x000008, "Member 'FP2ContainerItemSnapshot::ContainerItem' has a wrong offset!");
static_assert(offsetof(FP2ContainerItemSnapshot, PositionInfo) == 0x000090, "Member 'FP2ContainerItemSnapshot::PositionInfo' has a wrong offset!");

// ScriptStruct Game.P2EquipmentSnapshot
// 0x0120 (0x0120 - 0x0000)
struct FP2EquipmentSnapshot final
{
public:
	struct FP2ItemSnapshot                        Item;                                              // 0x0000(0x0088)(NativeAccessSpecifierPublic)
	TArray<struct FP2ContainerItemSnapshot>       Items;                                             // 0x0088(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	struct FP2ItemSnapshot                        BackSlotItem;                                      // 0x0098(0x0088)(NativeAccessSpecifierPublic)
};
static_assert(alignof(FP2EquipmentSnapshot) == 0x000008, "Wrong alignment on FP2EquipmentSnapshot");
static_assert(sizeof(FP2EquipmentSnapshot) == 0x000120, "Wrong size on FP2EquipmentSnapshot");
static_assert(offsetof(FP2EquipmentSnapshot, Item) == 0x000000, "Member 'FP2EquipmentSnapshot::Item' has a wrong offset!");
static_assert(offsetof(FP2EquipmentSnapshot, Items) == 0x000088, "Member 'FP2EquipmentSnapshot::Items' has a wrong offset!");
static_assert(offsetof(FP2EquipmentSnapshot, BackSlotItem) == 0x000098, "Member 'FP2EquipmentSnapshot::BackSlotItem' has a wrong offset!");

// ScriptStruct Game.P2InventoryLoadout
// 0x0038 (0x0038 - 0x0000)
struct FP2InventoryLoadout final
{
public:
	class FString                                 LoadoutName;                                       // 0x0000(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsFavorite;                                       // 0x0010(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x7];                                       // 0x0011(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FP2EquipmentSnapshot>           Equipments;                                        // 0x0018(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FP2ContainerItemSnapshot>       InternalContainerItems;                            // 0x0028(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FP2InventoryLoadout) == 0x000008, "Wrong alignment on FP2InventoryLoadout");
static_assert(sizeof(FP2InventoryLoadout) == 0x000038, "Wrong size on FP2InventoryLoadout");
static_assert(offsetof(FP2InventoryLoadout, LoadoutName) == 0x000000, "Member 'FP2InventoryLoadout::LoadoutName' has a wrong offset!");
static_assert(offsetof(FP2InventoryLoadout, bIsFavorite) == 0x000010, "Member 'FP2InventoryLoadout::bIsFavorite' has a wrong offset!");
static_assert(offsetof(FP2InventoryLoadout, Equipments) == 0x000018, "Member 'FP2InventoryLoadout::Equipments' has a wrong offset!");
static_assert(offsetof(FP2InventoryLoadout, InternalContainerItems) == 0x000028, "Member 'FP2InventoryLoadout::InternalContainerItems' has a wrong offset!");

// ScriptStruct Game.P2EncumberedStateColorData
// 0x0014 (0x0014 - 0x0000)
struct FP2EncumberedStateColorData final
{
public:
	int32                                         EncumberedStateLevel;                              // 0x0000(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           EncumberedStateColor;                              // 0x0004(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FP2EncumberedStateColorData) == 0x000004, "Wrong alignment on FP2EncumberedStateColorData");
static_assert(sizeof(FP2EncumberedStateColorData) == 0x000014, "Wrong size on FP2EncumberedStateColorData");
static_assert(offsetof(FP2EncumberedStateColorData, EncumberedStateLevel) == 0x000000, "Member 'FP2EncumberedStateColorData::EncumberedStateLevel' has a wrong offset!");
static_assert(offsetof(FP2EncumberedStateColorData, EncumberedStateColor) == 0x000004, "Member 'FP2EncumberedStateColorData::EncumberedStateColor' has a wrong offset!");

// ScriptStruct Game.P2PrimaryDataAssetTraits
// 0x0050 (0x0050 - 0x0000)
struct alignas(0x08) FP2PrimaryDataAssetTraits final
{
public:
	uint8                                         Pad_0[0x50];                                       // 0x0000(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FP2PrimaryDataAssetTraits) == 0x000008, "Wrong alignment on FP2PrimaryDataAssetTraits");
static_assert(sizeof(FP2PrimaryDataAssetTraits) == 0x000050, "Wrong size on FP2PrimaryDataAssetTraits");

// ScriptStruct Game.P2QuadAudioAkEvents
// 0x0050 (0x0050 - 0x0000)
struct FP2QuadAudioAkEvents final
{
public:
	TMap<EP2QuadSpeakerPosition, class UAkAudioEvent*> EventSetup;                                   // 0x0000(0x0050)(Edit, BlueprintVisible, UObjectWrapper, NativeAccessSpecifierPublic)
};
static_assert(alignof(FP2QuadAudioAkEvents) == 0x000008, "Wrong alignment on FP2QuadAudioAkEvents");
static_assert(sizeof(FP2QuadAudioAkEvents) == 0x000050, "Wrong size on FP2QuadAudioAkEvents");
static_assert(offsetof(FP2QuadAudioAkEvents, EventSetup) == 0x000000, "Member 'FP2QuadAudioAkEvents::EventSetup' has a wrong offset!");

// ScriptStruct Game.P2RagdollControllerRepData
// 0x0038 (0x0038 - 0x0000)
struct FP2RagdollControllerRepData final
{
public:
	EP2RagdollControllerState                     State;                                             // 0x0000(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FP2RagdollControllerConfig             Config;                                            // 0x0004(0x0014)(BlueprintVisible, BlueprintReadOnly, Transient, NoDestructor, NativeAccessSpecifierPublic)
	class USkeletalMeshComponent*                 RagdollSkeletalMesh;                               // 0x0018(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, Transient, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                InitialVelocity;                                   // 0x0020(0x0018)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FP2RagdollControllerRepData) == 0x000008, "Wrong alignment on FP2RagdollControllerRepData");
static_assert(sizeof(FP2RagdollControllerRepData) == 0x000038, "Wrong size on FP2RagdollControllerRepData");
static_assert(offsetof(FP2RagdollControllerRepData, State) == 0x000000, "Member 'FP2RagdollControllerRepData::State' has a wrong offset!");
static_assert(offsetof(FP2RagdollControllerRepData, Config) == 0x000004, "Member 'FP2RagdollControllerRepData::Config' has a wrong offset!");
static_assert(offsetof(FP2RagdollControllerRepData, RagdollSkeletalMesh) == 0x000018, "Member 'FP2RagdollControllerRepData::RagdollSkeletalMesh' has a wrong offset!");
static_assert(offsetof(FP2RagdollControllerRepData, InitialVelocity) == 0x000020, "Member 'FP2RagdollControllerRepData::InitialVelocity' has a wrong offset!");

// ScriptStruct Game.P2RaidResultHitPointInfo
// 0x000C (0x000C - 0x0000)
struct FP2RaidResultHitPointInfo final
{
public:
	struct FGameplayTag                           HitZoneTag;                                        // 0x0000(0x0008)(BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Count;                                             // 0x0008(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FP2RaidResultHitPointInfo) == 0x000004, "Wrong alignment on FP2RaidResultHitPointInfo");
static_assert(sizeof(FP2RaidResultHitPointInfo) == 0x00000C, "Wrong size on FP2RaidResultHitPointInfo");
static_assert(offsetof(FP2RaidResultHitPointInfo, HitZoneTag) == 0x000000, "Member 'FP2RaidResultHitPointInfo::HitZoneTag' has a wrong offset!");
static_assert(offsetof(FP2RaidResultHitPointInfo, Count) == 0x000008, "Member 'FP2RaidResultHitPointInfo::Count' has a wrong offset!");

// ScriptStruct Game.P2TargetData_InventoryMergeItem
// 0x0010 (0x0028 - 0x0018)
struct FP2TargetData_InventoryMergeItem final : public FP2TargetData_ItemAction
{
public:
	uint8                                         Pad_18[0x10];                                      // 0x0018(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FP2TargetData_InventoryMergeItem) == 0x000008, "Wrong alignment on FP2TargetData_InventoryMergeItem");
static_assert(sizeof(FP2TargetData_InventoryMergeItem) == 0x000028, "Wrong size on FP2TargetData_InventoryMergeItem");

// ScriptStruct Game.P2DeathResolverInputData
// 0x0070 (0x0070 - 0x0000)
struct FP2DeathResolverInputData final
{
public:
	class UObject*                                Instigator;                                        // 0x0000(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTagContainer                  InstigatorTags;                                    // 0x0008(0x0020)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	class UObject*                                Target;                                            // 0x0028(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTagContainer                  MyTags;                                            // 0x0030(0x0020)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FGameplayTagContainer                  ContextTags;                                       // 0x0050(0x0020)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
};
static_assert(alignof(FP2DeathResolverInputData) == 0x000008, "Wrong alignment on FP2DeathResolverInputData");
static_assert(sizeof(FP2DeathResolverInputData) == 0x000070, "Wrong size on FP2DeathResolverInputData");
static_assert(offsetof(FP2DeathResolverInputData, Instigator) == 0x000000, "Member 'FP2DeathResolverInputData::Instigator' has a wrong offset!");
static_assert(offsetof(FP2DeathResolverInputData, InstigatorTags) == 0x000008, "Member 'FP2DeathResolverInputData::InstigatorTags' has a wrong offset!");
static_assert(offsetof(FP2DeathResolverInputData, Target) == 0x000028, "Member 'FP2DeathResolverInputData::Target' has a wrong offset!");
static_assert(offsetof(FP2DeathResolverInputData, MyTags) == 0x000030, "Member 'FP2DeathResolverInputData::MyTags' has a wrong offset!");
static_assert(offsetof(FP2DeathResolverInputData, ContextTags) == 0x000050, "Member 'FP2DeathResolverInputData::ContextTags' has a wrong offset!");

// ScriptStruct Game.P2DeathReasonResolverTableRow
// 0x0008 (0x0010 - 0x0008)
struct FP2DeathReasonResolverTableRow final : public FTableRowBase
{
public:
	TSubclassOf<class UP2DeathReasonResolver>     ResolverClass;                                     // 0x0008(0x0008)(Edit, ZeroConstructor, NoClear, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FP2DeathReasonResolverTableRow) == 0x000008, "Wrong alignment on FP2DeathReasonResolverTableRow");
static_assert(sizeof(FP2DeathReasonResolverTableRow) == 0x000010, "Wrong size on FP2DeathReasonResolverTableRow");
static_assert(offsetof(FP2DeathReasonResolverTableRow, ResolverClass) == 0x000008, "Member 'FP2DeathReasonResolverTableRow::ResolverClass' has a wrong offset!");

// ScriptStruct Game.P2RaidResultHitInfo
// 0x0038 (0x0038 - 0x0000)
struct FP2RaidResultHitInfo final
{
public:
	struct FGameplayTag                           HitMapZoneTag;                                     // 0x0000(0x0008)(BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DamageValue;                                       // 0x0008(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DamageArmorAbsorbed;                               // 0x000C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         HitCount;                                          // 0x0010(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsFatalBlow;                                       // 0x0014(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsAreaOfEffect;                                    // 0x0015(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_16[0x2];                                       // 0x0016(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTagContainer                  DamageTypeTags;                                    // 0x0018(0x0020)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
};
static_assert(alignof(FP2RaidResultHitInfo) == 0x000008, "Wrong alignment on FP2RaidResultHitInfo");
static_assert(sizeof(FP2RaidResultHitInfo) == 0x000038, "Wrong size on FP2RaidResultHitInfo");
static_assert(offsetof(FP2RaidResultHitInfo, HitMapZoneTag) == 0x000000, "Member 'FP2RaidResultHitInfo::HitMapZoneTag' has a wrong offset!");
static_assert(offsetof(FP2RaidResultHitInfo, DamageValue) == 0x000008, "Member 'FP2RaidResultHitInfo::DamageValue' has a wrong offset!");
static_assert(offsetof(FP2RaidResultHitInfo, DamageArmorAbsorbed) == 0x00000C, "Member 'FP2RaidResultHitInfo::DamageArmorAbsorbed' has a wrong offset!");
static_assert(offsetof(FP2RaidResultHitInfo, HitCount) == 0x000010, "Member 'FP2RaidResultHitInfo::HitCount' has a wrong offset!");
static_assert(offsetof(FP2RaidResultHitInfo, IsFatalBlow) == 0x000014, "Member 'FP2RaidResultHitInfo::IsFatalBlow' has a wrong offset!");
static_assert(offsetof(FP2RaidResultHitInfo, IsAreaOfEffect) == 0x000015, "Member 'FP2RaidResultHitInfo::IsAreaOfEffect' has a wrong offset!");
static_assert(offsetof(FP2RaidResultHitInfo, DamageTypeTags) == 0x000018, "Member 'FP2RaidResultHitInfo::DamageTypeTags' has a wrong offset!");

// ScriptStruct Game.P2TargetData_PlaceableSpawn
// 0x0048 (0x0050 - 0x0008)
struct FP2TargetData_PlaceableSpawn final : public FGameplayAbilityTargetData
{
public:
	class UP2PlaceableData*                       PlaceableData;                                     // 0x0008(0x0008)(BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TWeakObjectPtr<class UObject>                 SourceObject;                                      // 0x0010(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                PlacementLocation;                                 // 0x0018(0x0018)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               PlacementRotation;                                 // 0x0030(0x0018)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          bIsContinuous;                                     // 0x0048(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_49[0x7];                                       // 0x0049(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FP2TargetData_PlaceableSpawn) == 0x000008, "Wrong alignment on FP2TargetData_PlaceableSpawn");
static_assert(sizeof(FP2TargetData_PlaceableSpawn) == 0x000050, "Wrong size on FP2TargetData_PlaceableSpawn");
static_assert(offsetof(FP2TargetData_PlaceableSpawn, PlaceableData) == 0x000008, "Member 'FP2TargetData_PlaceableSpawn::PlaceableData' has a wrong offset!");
static_assert(offsetof(FP2TargetData_PlaceableSpawn, SourceObject) == 0x000010, "Member 'FP2TargetData_PlaceableSpawn::SourceObject' has a wrong offset!");
static_assert(offsetof(FP2TargetData_PlaceableSpawn, PlacementLocation) == 0x000018, "Member 'FP2TargetData_PlaceableSpawn::PlacementLocation' has a wrong offset!");
static_assert(offsetof(FP2TargetData_PlaceableSpawn, PlacementRotation) == 0x000030, "Member 'FP2TargetData_PlaceableSpawn::PlacementRotation' has a wrong offset!");
static_assert(offsetof(FP2TargetData_PlaceableSpawn, bIsContinuous) == 0x000048, "Member 'FP2TargetData_PlaceableSpawn::bIsContinuous' has a wrong offset!");

// ScriptStruct Game.P2WeightedAbilitySet
// 0x0030 (0x0030 - 0x0000)
struct FP2WeightedAbilitySet final
{
public:
	TArray<struct FP2AbilitySet_GameplayAbility>  GrantedGameplayAbilities;                          // 0x0000(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	float                                         Weight;                                            // 0x0010(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   Description;                                       // 0x0018(0x0018)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
};
static_assert(alignof(FP2WeightedAbilitySet) == 0x000008, "Wrong alignment on FP2WeightedAbilitySet");
static_assert(sizeof(FP2WeightedAbilitySet) == 0x000030, "Wrong size on FP2WeightedAbilitySet");
static_assert(offsetof(FP2WeightedAbilitySet, GrantedGameplayAbilities) == 0x000000, "Member 'FP2WeightedAbilitySet::GrantedGameplayAbilities' has a wrong offset!");
static_assert(offsetof(FP2WeightedAbilitySet, Weight) == 0x000010, "Member 'FP2WeightedAbilitySet::Weight' has a wrong offset!");
static_assert(offsetof(FP2WeightedAbilitySet, Description) == 0x000018, "Member 'FP2WeightedAbilitySet::Description' has a wrong offset!");

// ScriptStruct Game.P2ReloadMontageSettings
// 0x0010 (0x0010 - 0x0000)
struct FP2ReloadMontageSettings final
{
public:
	class FName                                   SlotName;                                          // 0x0000(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   AdsSlotName;                                       // 0x0008(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FP2ReloadMontageSettings) == 0x000004, "Wrong alignment on FP2ReloadMontageSettings");
static_assert(sizeof(FP2ReloadMontageSettings) == 0x000010, "Wrong size on FP2ReloadMontageSettings");
static_assert(offsetof(FP2ReloadMontageSettings, SlotName) == 0x000000, "Member 'FP2ReloadMontageSettings::SlotName' has a wrong offset!");
static_assert(offsetof(FP2ReloadMontageSettings, AdsSlotName) == 0x000008, "Member 'FP2ReloadMontageSettings::AdsSlotName' has a wrong offset!");

// ScriptStruct Game.P2ReloadSequenceConfiguration
// 0x0010 (0x0010 - 0x0000)
struct FP2ReloadSequenceConfiguration final
{
public:
	TArray<class UP2SequenceInstructionBase*>     Instructions;                                      // 0x0000(0x0010)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, ContainsInstancedReference, UObjectWrapper, NativeAccessSpecifierPublic)
};
static_assert(alignof(FP2ReloadSequenceConfiguration) == 0x000008, "Wrong alignment on FP2ReloadSequenceConfiguration");
static_assert(sizeof(FP2ReloadSequenceConfiguration) == 0x000010, "Wrong size on FP2ReloadSequenceConfiguration");
static_assert(offsetof(FP2ReloadSequenceConfiguration, Instructions) == 0x000000, "Member 'FP2ReloadSequenceConfiguration::Instructions' has a wrong offset!");

// ScriptStruct Game.P2RenderWorldInfo
// 0x0090 (0x0090 - 0x0000)
struct FP2RenderWorldInfo final
{
public:
	TSoftObjectPtr<class UWorld>                  RenderWorld;                                       // 0x0000(0x0030)(Edit, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FTransform                             SpawnTransform;                                    // 0x0030(0x0060)(Edit, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FP2RenderWorldInfo) == 0x000010, "Wrong alignment on FP2RenderWorldInfo");
static_assert(sizeof(FP2RenderWorldInfo) == 0x000090, "Wrong size on FP2RenderWorldInfo");
static_assert(offsetof(FP2RenderWorldInfo, RenderWorld) == 0x000000, "Member 'FP2RenderWorldInfo::RenderWorld' has a wrong offset!");
static_assert(offsetof(FP2RenderWorldInfo, SpawnTransform) == 0x000030, "Member 'FP2RenderWorldInfo::SpawnTransform' has a wrong offset!");

// ScriptStruct Game.P2TargetData_Stun
// 0x0030 (0x0038 - 0x0008)
struct FP2TargetData_Stun final : public FGameplayAbilityTargetData
{
public:
	uint8                                         Pad_8[0x30];                                       // 0x0008(0x0030)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FP2TargetData_Stun) == 0x000008, "Wrong alignment on FP2TargetData_Stun");
static_assert(sizeof(FP2TargetData_Stun) == 0x000038, "Wrong size on FP2TargetData_Stun");

// ScriptStruct Game.P2RentalItemTableRow
// 0x0020 (0x0028 - 0x0008)
struct FP2RentalItemTableRow final : public FTableRowBase
{
public:
	TArray<struct FP2ExchangeInfo>                RentalWearableItems;                               // 0x0008(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TArray<struct FP2ExchangeInfo>                RentalItems;                                       // 0x0018(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
};
static_assert(alignof(FP2RentalItemTableRow) == 0x000008, "Wrong alignment on FP2RentalItemTableRow");
static_assert(sizeof(FP2RentalItemTableRow) == 0x000028, "Wrong size on FP2RentalItemTableRow");
static_assert(offsetof(FP2RentalItemTableRow, RentalWearableItems) == 0x000008, "Member 'FP2RentalItemTableRow::RentalWearableItems' has a wrong offset!");
static_assert(offsetof(FP2RentalItemTableRow, RentalItems) == 0x000018, "Member 'FP2RentalItemTableRow::RentalItems' has a wrong offset!");

// ScriptStruct Game.P2RentalItemInfo
// 0x0014 (0x0014 - 0x0000)
struct FP2RentalItemInfo final
{
public:
	float                                         Ratio;                                             // 0x0000(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FDataRegistryId                        RentalItemTableId;                                 // 0x0004(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FP2RentalItemInfo) == 0x000004, "Wrong alignment on FP2RentalItemInfo");
static_assert(sizeof(FP2RentalItemInfo) == 0x000014, "Wrong size on FP2RentalItemInfo");
static_assert(offsetof(FP2RentalItemInfo, Ratio) == 0x000000, "Member 'FP2RentalItemInfo::Ratio' has a wrong offset!");
static_assert(offsetof(FP2RentalItemInfo, RentalItemTableId) == 0x000004, "Member 'FP2RentalItemInfo::RentalItemTableId' has a wrong offset!");

// ScriptStruct Game.P2RentalItemPool
// 0x0018 (0x0018 - 0x0000)
struct FP2RentalItemPool final
{
public:
	int32                                         MinPlayerLevel;                                    // 0x0000(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MaxPlayerLevel;                                    // 0x0004(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FP2RentalItemInfo>              RentalItemInfos;                                   // 0x0008(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
};
static_assert(alignof(FP2RentalItemPool) == 0x000008, "Wrong alignment on FP2RentalItemPool");
static_assert(sizeof(FP2RentalItemPool) == 0x000018, "Wrong size on FP2RentalItemPool");
static_assert(offsetof(FP2RentalItemPool, MinPlayerLevel) == 0x000000, "Member 'FP2RentalItemPool::MinPlayerLevel' has a wrong offset!");
static_assert(offsetof(FP2RentalItemPool, MaxPlayerLevel) == 0x000004, "Member 'FP2RentalItemPool::MaxPlayerLevel' has a wrong offset!");
static_assert(offsetof(FP2RentalItemPool, RentalItemInfos) == 0x000008, "Member 'FP2RentalItemPool::RentalItemInfos' has a wrong offset!");

// ScriptStruct Game.P2RentalItemSetting
// 0x0018 (0x0018 - 0x0000)
struct FP2RentalItemSetting final
{
public:
	float                                         RentalDuration;                                    // 0x0000(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FP2RentalItemPool>              RentalItemPools;                                   // 0x0008(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
};
static_assert(alignof(FP2RentalItemSetting) == 0x000008, "Wrong alignment on FP2RentalItemSetting");
static_assert(sizeof(FP2RentalItemSetting) == 0x000018, "Wrong size on FP2RentalItemSetting");
static_assert(offsetof(FP2RentalItemSetting, RentalDuration) == 0x000000, "Member 'FP2RentalItemSetting::RentalDuration' has a wrong offset!");
static_assert(offsetof(FP2RentalItemSetting, RentalItemPools) == 0x000008, "Member 'FP2RentalItemSetting::RentalItemPools' has a wrong offset!");

// ScriptStruct Game.P2BoneTarget
// 0x0010 (0x0010 - 0x0000)
struct FP2BoneTarget final
{
public:
	class FName                                   BoneName;                                          // 0x0000(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           DamageZone;                                        // 0x0008(0x0008)(Edit, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FP2BoneTarget) == 0x000004, "Wrong alignment on FP2BoneTarget");
static_assert(sizeof(FP2BoneTarget) == 0x000010, "Wrong size on FP2BoneTarget");
static_assert(offsetof(FP2BoneTarget, BoneName) == 0x000000, "Member 'FP2BoneTarget::BoneName' has a wrong offset!");
static_assert(offsetof(FP2BoneTarget, DamageZone) == 0x000008, "Member 'FP2BoneTarget::DamageZone' has a wrong offset!");

// ScriptStruct Game.P2FactionRentalItemPool
// 0x0020 (0x0020 - 0x0000)
struct FP2FactionRentalItemPool final
{
public:
	int32                                         MinFactionReputation;                              // 0x0000(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MaxFactionReputation;                              // 0x0004(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ReputationPenalty;                                 // 0x0008(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FP2RentalItemInfo>              RentalItemInfos;                                   // 0x0010(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
};
static_assert(alignof(FP2FactionRentalItemPool) == 0x000008, "Wrong alignment on FP2FactionRentalItemPool");
static_assert(sizeof(FP2FactionRentalItemPool) == 0x000020, "Wrong size on FP2FactionRentalItemPool");
static_assert(offsetof(FP2FactionRentalItemPool, MinFactionReputation) == 0x000000, "Member 'FP2FactionRentalItemPool::MinFactionReputation' has a wrong offset!");
static_assert(offsetof(FP2FactionRentalItemPool, MaxFactionReputation) == 0x000004, "Member 'FP2FactionRentalItemPool::MaxFactionReputation' has a wrong offset!");
static_assert(offsetof(FP2FactionRentalItemPool, ReputationPenalty) == 0x000008, "Member 'FP2FactionRentalItemPool::ReputationPenalty' has a wrong offset!");
static_assert(offsetof(FP2FactionRentalItemPool, RentalItemInfos) == 0x000010, "Member 'FP2FactionRentalItemPool::RentalItemInfos' has a wrong offset!");

// ScriptStruct Game.P2FactionRentalItemSetting
// 0x0020 (0x0020 - 0x0000)
struct FP2FactionRentalItemSetting final
{
public:
	struct FGameplayTag                           FactionTag;                                        // 0x0000(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RentalDuration;                                    // 0x0008(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FP2FactionRentalItemPool>       RentalItemPools;                                   // 0x0010(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
};
static_assert(alignof(FP2FactionRentalItemSetting) == 0x000008, "Wrong alignment on FP2FactionRentalItemSetting");
static_assert(sizeof(FP2FactionRentalItemSetting) == 0x000020, "Wrong size on FP2FactionRentalItemSetting");
static_assert(offsetof(FP2FactionRentalItemSetting, FactionTag) == 0x000000, "Member 'FP2FactionRentalItemSetting::FactionTag' has a wrong offset!");
static_assert(offsetof(FP2FactionRentalItemSetting, RentalDuration) == 0x000008, "Member 'FP2FactionRentalItemSetting::RentalDuration' has a wrong offset!");
static_assert(offsetof(FP2FactionRentalItemSetting, RentalItemPools) == 0x000010, "Member 'FP2FactionRentalItemSetting::RentalItemPools' has a wrong offset!");

// ScriptStruct Game.P2RentalItems
// 0x0038 (0x0038 - 0x0000)
struct FP2RentalItems final
{
public:
	struct FGameplayTag                           FactionTag;                                        // 0x0000(0x0008)(BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RentalDuration;                                    // 0x0008(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ReputationPenalty;                                 // 0x000C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FP2ExchangeInfo>                RentalWearableItems;                               // 0x0010(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FP2ExchangeInfo>                RentalItems;                                       // 0x0020(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	class FName                                   RentalItemsKeyName;                                // 0x0030(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FP2RentalItems) == 0x000008, "Wrong alignment on FP2RentalItems");
static_assert(sizeof(FP2RentalItems) == 0x000038, "Wrong size on FP2RentalItems");
static_assert(offsetof(FP2RentalItems, FactionTag) == 0x000000, "Member 'FP2RentalItems::FactionTag' has a wrong offset!");
static_assert(offsetof(FP2RentalItems, RentalDuration) == 0x000008, "Member 'FP2RentalItems::RentalDuration' has a wrong offset!");
static_assert(offsetof(FP2RentalItems, ReputationPenalty) == 0x00000C, "Member 'FP2RentalItems::ReputationPenalty' has a wrong offset!");
static_assert(offsetof(FP2RentalItems, RentalWearableItems) == 0x000010, "Member 'FP2RentalItems::RentalWearableItems' has a wrong offset!");
static_assert(offsetof(FP2RentalItems, RentalItems) == 0x000020, "Member 'FP2RentalItems::RentalItems' has a wrong offset!");
static_assert(offsetof(FP2RentalItems, RentalItemsKeyName) == 0x000030, "Member 'FP2RentalItems::RentalItemsKeyName' has a wrong offset!");

// ScriptStruct Game.P2ReplicatedTimer
// 0x0010 (0x0010 - 0x0000)
struct FP2ReplicatedTimer final
{
public:
	float                                         ServerStartTime;                                   // 0x0000(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         Duration;                                          // 0x0004(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         ServerPauseTime;                                   // 0x0008(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         TotalPauseDuration;                                // 0x000C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
};
static_assert(alignof(FP2ReplicatedTimer) == 0x000004, "Wrong alignment on FP2ReplicatedTimer");
static_assert(sizeof(FP2ReplicatedTimer) == 0x000010, "Wrong size on FP2ReplicatedTimer");
static_assert(offsetof(FP2ReplicatedTimer, ServerStartTime) == 0x000000, "Member 'FP2ReplicatedTimer::ServerStartTime' has a wrong offset!");
static_assert(offsetof(FP2ReplicatedTimer, Duration) == 0x000004, "Member 'FP2ReplicatedTimer::Duration' has a wrong offset!");
static_assert(offsetof(FP2ReplicatedTimer, ServerPauseTime) == 0x000008, "Member 'FP2ReplicatedTimer::ServerPauseTime' has a wrong offset!");
static_assert(offsetof(FP2ReplicatedTimer, TotalPauseDuration) == 0x00000C, "Member 'FP2ReplicatedTimer::TotalPauseDuration' has a wrong offset!");

// ScriptStruct Game.P2AlwaysRelevantActorInfo
// 0x0028 (0x0028 - 0x0000)
struct FP2AlwaysRelevantActorInfo final
{
public:
	class UNetConnection*                         Connection;                                        // 0x0000(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 LastViewer;                                        // 0x0008(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 LastViewTarget;                                    // 0x0010(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 LastPawn;                                          // 0x0018(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 PlayerState;                                       // 0x0020(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FP2AlwaysRelevantActorInfo) == 0x000008, "Wrong alignment on FP2AlwaysRelevantActorInfo");
static_assert(sizeof(FP2AlwaysRelevantActorInfo) == 0x000028, "Wrong size on FP2AlwaysRelevantActorInfo");
static_assert(offsetof(FP2AlwaysRelevantActorInfo, Connection) == 0x000000, "Member 'FP2AlwaysRelevantActorInfo::Connection' has a wrong offset!");
static_assert(offsetof(FP2AlwaysRelevantActorInfo, LastViewer) == 0x000008, "Member 'FP2AlwaysRelevantActorInfo::LastViewer' has a wrong offset!");
static_assert(offsetof(FP2AlwaysRelevantActorInfo, LastViewTarget) == 0x000010, "Member 'FP2AlwaysRelevantActorInfo::LastViewTarget' has a wrong offset!");
static_assert(offsetof(FP2AlwaysRelevantActorInfo, LastPawn) == 0x000018, "Member 'FP2AlwaysRelevantActorInfo::LastPawn' has a wrong offset!");
static_assert(offsetof(FP2AlwaysRelevantActorInfo, PlayerState) == 0x000020, "Member 'FP2AlwaysRelevantActorInfo::PlayerState' has a wrong offset!");

// ScriptStruct Game.P2TeamRelevantActorInfo
// 0x0018 (0x0018 - 0x0000)
struct FP2TeamRelevantActorInfo final
{
public:
	class UNetConnection*                         Connection;                                        // 0x0000(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class AActor*>                         Actors;                                            // 0x0008(0x0010)(ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
};
static_assert(alignof(FP2TeamRelevantActorInfo) == 0x000008, "Wrong alignment on FP2TeamRelevantActorInfo");
static_assert(sizeof(FP2TeamRelevantActorInfo) == 0x000018, "Wrong size on FP2TeamRelevantActorInfo");
static_assert(offsetof(FP2TeamRelevantActorInfo, Connection) == 0x000000, "Member 'FP2TeamRelevantActorInfo::Connection' has a wrong offset!");
static_assert(offsetof(FP2TeamRelevantActorInfo, Actors) == 0x000008, "Member 'FP2TeamRelevantActorInfo::Actors' has a wrong offset!");

// ScriptStruct Game.P2NoCullDistanceOverrides
// 0x0058 (0x0058 - 0x0000)
struct FP2NoCullDistanceOverrides final
{
public:
	class UNetConnection*                         Connection;                                        // 0x0000(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TMap<class AActor*, int32>                    ActorOverrides;                                    // 0x0008(0x0050)(NativeAccessSpecifierPublic)
};
static_assert(alignof(FP2NoCullDistanceOverrides) == 0x000008, "Wrong alignment on FP2NoCullDistanceOverrides");
static_assert(sizeof(FP2NoCullDistanceOverrides) == 0x000058, "Wrong size on FP2NoCullDistanceOverrides");
static_assert(offsetof(FP2NoCullDistanceOverrides, Connection) == 0x000000, "Member 'FP2NoCullDistanceOverrides::Connection' has a wrong offset!");
static_assert(offsetof(FP2NoCullDistanceOverrides, ActorOverrides) == 0x000008, "Member 'FP2NoCullDistanceOverrides::ActorOverrides' has a wrong offset!");

// ScriptStruct Game.P2ResearchNodeDataInfo
// 0x0008 (0x0010 - 0x0008)
struct FP2ResearchNodeDataInfo final : public FP2RequirementDataInfo
{
public:
	class UP2ResearchNodeData*                    Data;                                              // 0x0008(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FP2ResearchNodeDataInfo) == 0x000008, "Wrong alignment on FP2ResearchNodeDataInfo");
static_assert(sizeof(FP2ResearchNodeDataInfo) == 0x000010, "Wrong size on FP2ResearchNodeDataInfo");
static_assert(offsetof(FP2ResearchNodeDataInfo, Data) == 0x000008, "Member 'FP2ResearchNodeDataInfo::Data' has a wrong offset!");

// ScriptStruct Game.P2ResearchStepData
// 0x0030 (0x0030 - 0x0000)
struct FP2ResearchStepData final
{
public:
	class FText                                   StepTitle;                                         // 0x0000(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	float                                         RequiredTime;                                      // 0x0018(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C[0x4];                                       // 0x001C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UP2ResearchNodeRequirement*>     CompletionRequirements;                            // 0x0020(0x0010)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, ContainsInstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(FP2ResearchStepData) == 0x000008, "Wrong alignment on FP2ResearchStepData");
static_assert(sizeof(FP2ResearchStepData) == 0x000030, "Wrong size on FP2ResearchStepData");
static_assert(offsetof(FP2ResearchStepData, StepTitle) == 0x000000, "Member 'FP2ResearchStepData::StepTitle' has a wrong offset!");
static_assert(offsetof(FP2ResearchStepData, RequiredTime) == 0x000018, "Member 'FP2ResearchStepData::RequiredTime' has a wrong offset!");
static_assert(offsetof(FP2ResearchStepData, CompletionRequirements) == 0x000020, "Member 'FP2ResearchStepData::CompletionRequirements' has a wrong offset!");

// ScriptStruct Game.P2RootMotionSource_VaultToLocation
// 0x0080 (0x0160 - 0x00E0)
struct FP2RootMotionSource_VaultToLocation final : public FRootMotionSource
{
public:
	struct FVector                                StartLocation;                                     // 0x00D8(0x0018)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                TargetLocation;                                    // 0x00F0(0x0018)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                DirectionVector;                                   // 0x0108(0x0018)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                MoveStartLocation;                                 // 0x0120(0x0018)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bRestrictSpeedToExpected;                          // 0x0138(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_139[0x3];                                      // 0x0139(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MoveStartTime;                                     // 0x013C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         StartDuration;                                     // 0x0140(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_144[0x4];                                      // 0x0144(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UCurveVector*                           VaultCurveAsset;                                   // 0x0148(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          AnimSequence;                                      // 0x0150(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_158[0x8];                                      // 0x0158(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FP2RootMotionSource_VaultToLocation) == 0x000010, "Wrong alignment on FP2RootMotionSource_VaultToLocation");
static_assert(sizeof(FP2RootMotionSource_VaultToLocation) == 0x000160, "Wrong size on FP2RootMotionSource_VaultToLocation");
static_assert(offsetof(FP2RootMotionSource_VaultToLocation, StartLocation) == 0x0000D8, "Member 'FP2RootMotionSource_VaultToLocation::StartLocation' has a wrong offset!");
static_assert(offsetof(FP2RootMotionSource_VaultToLocation, TargetLocation) == 0x0000F0, "Member 'FP2RootMotionSource_VaultToLocation::TargetLocation' has a wrong offset!");
static_assert(offsetof(FP2RootMotionSource_VaultToLocation, DirectionVector) == 0x000108, "Member 'FP2RootMotionSource_VaultToLocation::DirectionVector' has a wrong offset!");
static_assert(offsetof(FP2RootMotionSource_VaultToLocation, MoveStartLocation) == 0x000120, "Member 'FP2RootMotionSource_VaultToLocation::MoveStartLocation' has a wrong offset!");
static_assert(offsetof(FP2RootMotionSource_VaultToLocation, bRestrictSpeedToExpected) == 0x000138, "Member 'FP2RootMotionSource_VaultToLocation::bRestrictSpeedToExpected' has a wrong offset!");
static_assert(offsetof(FP2RootMotionSource_VaultToLocation, MoveStartTime) == 0x00013C, "Member 'FP2RootMotionSource_VaultToLocation::MoveStartTime' has a wrong offset!");
static_assert(offsetof(FP2RootMotionSource_VaultToLocation, StartDuration) == 0x000140, "Member 'FP2RootMotionSource_VaultToLocation::StartDuration' has a wrong offset!");
static_assert(offsetof(FP2RootMotionSource_VaultToLocation, VaultCurveAsset) == 0x000148, "Member 'FP2RootMotionSource_VaultToLocation::VaultCurveAsset' has a wrong offset!");
static_assert(offsetof(FP2RootMotionSource_VaultToLocation, AnimSequence) == 0x000150, "Member 'FP2RootMotionSource_VaultToLocation::AnimSequence' has a wrong offset!");

// ScriptStruct Game.P2PerspectiveSequenceData
// 0x0028 (0x0028 - 0x0000)
struct FP2PerspectiveSequenceData final
{
public:
	class UAnimSequence*                          TppSequence;                                       // 0x0000(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          FppSequence;                                       // 0x0008(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          WeaponSequence;                                    // 0x0010(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          AdsTppSequence;                                    // 0x0018(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          AdsFppSequence;                                    // 0x0020(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FP2PerspectiveSequenceData) == 0x000008, "Wrong alignment on FP2PerspectiveSequenceData");
static_assert(sizeof(FP2PerspectiveSequenceData) == 0x000028, "Wrong size on FP2PerspectiveSequenceData");
static_assert(offsetof(FP2PerspectiveSequenceData, TppSequence) == 0x000000, "Member 'FP2PerspectiveSequenceData::TppSequence' has a wrong offset!");
static_assert(offsetof(FP2PerspectiveSequenceData, FppSequence) == 0x000008, "Member 'FP2PerspectiveSequenceData::FppSequence' has a wrong offset!");
static_assert(offsetof(FP2PerspectiveSequenceData, WeaponSequence) == 0x000010, "Member 'FP2PerspectiveSequenceData::WeaponSequence' has a wrong offset!");
static_assert(offsetof(FP2PerspectiveSequenceData, AdsTppSequence) == 0x000018, "Member 'FP2PerspectiveSequenceData::AdsTppSequence' has a wrong offset!");
static_assert(offsetof(FP2PerspectiveSequenceData, AdsFppSequence) == 0x000020, "Member 'FP2PerspectiveSequenceData::AdsFppSequence' has a wrong offset!");

// ScriptStruct Game.P2SequenceInstructionList
// 0x0010 (0x0010 - 0x0000)
struct FP2SequenceInstructionList
{
public:
	TArray<class UP2SequenceInstructionBase*>     SequenceInstructions;                              // 0x0000(0x0010)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, ContainsInstancedReference, UObjectWrapper, NativeAccessSpecifierPublic)
};
static_assert(alignof(FP2SequenceInstructionList) == 0x000008, "Wrong alignment on FP2SequenceInstructionList");
static_assert(sizeof(FP2SequenceInstructionList) == 0x000010, "Wrong size on FP2SequenceInstructionList");
static_assert(offsetof(FP2SequenceInstructionList, SequenceInstructions) == 0x000000, "Member 'FP2SequenceInstructionList::SequenceInstructions' has a wrong offset!");

// ScriptStruct Game.P2AccessDelaySequenceArrayWrapper
// 0x0010 (0x0010 - 0x0000)
struct FP2AccessDelaySequenceArrayWrapper final
{
public:
	TArray<struct FP2AccessDelaySequenceData>     Sequences;                                         // 0x0000(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
};
static_assert(alignof(FP2AccessDelaySequenceArrayWrapper) == 0x000008, "Wrong alignment on FP2AccessDelaySequenceArrayWrapper");
static_assert(sizeof(FP2AccessDelaySequenceArrayWrapper) == 0x000010, "Wrong size on FP2AccessDelaySequenceArrayWrapper");
static_assert(offsetof(FP2AccessDelaySequenceArrayWrapper, Sequences) == 0x000000, "Member 'FP2AccessDelaySequenceArrayWrapper::Sequences' has a wrong offset!");

// ScriptStruct Game.P2SequenceInstructionList_WithTags
// 0x0028 (0x0038 - 0x0010)
struct FP2SequenceInstructionList_WithTags final : public FP2SequenceInstructionList
{
public:
	struct FGameplayTagContainer                  ItemTags;                                          // 0x0010(0x0020)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	bool                                          bMatchTagExact;                                    // 0x0030(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_31[0x7];                                       // 0x0031(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FP2SequenceInstructionList_WithTags) == 0x000008, "Wrong alignment on FP2SequenceInstructionList_WithTags");
static_assert(sizeof(FP2SequenceInstructionList_WithTags) == 0x000038, "Wrong size on FP2SequenceInstructionList_WithTags");
static_assert(offsetof(FP2SequenceInstructionList_WithTags, ItemTags) == 0x000010, "Member 'FP2SequenceInstructionList_WithTags::ItemTags' has a wrong offset!");
static_assert(offsetof(FP2SequenceInstructionList_WithTags, bMatchTagExact) == 0x000030, "Member 'FP2SequenceInstructionList_WithTags::bMatchTagExact' has a wrong offset!");

// ScriptStruct Game.P2SingleSessionDifficultySettings
// 0x0001 (0x0001 - 0x0000)
struct FP2SingleSessionDifficultySettings final
{
public:
	uint8                                         Pad_0[0x1];                                        // 0x0000(0x0001)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FP2SingleSessionDifficultySettings) == 0x000001, "Wrong alignment on FP2SingleSessionDifficultySettings");
static_assert(sizeof(FP2SingleSessionDifficultySettings) == 0x000001, "Wrong size on FP2SingleSessionDifficultySettings");

// ScriptStruct Game.P2ColorMapAmbientBedChannelConfig
// 0x0078 (0x0078 - 0x0000)
struct FP2ColorMapAmbientBedChannelConfig final
{
public:
	class FName                                   Name;                                              // 0x0000(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EP2RegionColor                                Color;                                             // 0x0008(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FP2SpeakerArrayChannelEventConfig      SpeakerArrayChannels[0x4];                         // 0x0010(0x0010)(Edit, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   IntensityRtpcName;                                 // 0x0050(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FP2ColorMapIntegrationSettings         IntegrationSettings;                               // 0x0058(0x001C)(Edit, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_74[0x4];                                       // 0x0074(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FP2ColorMapAmbientBedChannelConfig) == 0x000008, "Wrong alignment on FP2ColorMapAmbientBedChannelConfig");
static_assert(sizeof(FP2ColorMapAmbientBedChannelConfig) == 0x000078, "Wrong size on FP2ColorMapAmbientBedChannelConfig");
static_assert(offsetof(FP2ColorMapAmbientBedChannelConfig, Name) == 0x000000, "Member 'FP2ColorMapAmbientBedChannelConfig::Name' has a wrong offset!");
static_assert(offsetof(FP2ColorMapAmbientBedChannelConfig, Color) == 0x000008, "Member 'FP2ColorMapAmbientBedChannelConfig::Color' has a wrong offset!");
static_assert(offsetof(FP2ColorMapAmbientBedChannelConfig, SpeakerArrayChannels) == 0x000010, "Member 'FP2ColorMapAmbientBedChannelConfig::SpeakerArrayChannels' has a wrong offset!");
static_assert(offsetof(FP2ColorMapAmbientBedChannelConfig, IntensityRtpcName) == 0x000050, "Member 'FP2ColorMapAmbientBedChannelConfig::IntensityRtpcName' has a wrong offset!");
static_assert(offsetof(FP2ColorMapAmbientBedChannelConfig, IntegrationSettings) == 0x000058, "Member 'FP2ColorMapAmbientBedChannelConfig::IntegrationSettings' has a wrong offset!");

// ScriptStruct Game.P2SnapToFoliageSpeciesSettings
// 0x0020 (0x0020 - 0x0000)
struct FP2SnapToFoliageSpeciesSettings final
{
public:
	EP2SnapToFoliageLocationOffset                HeightSlot;                                        // 0x0000(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         TriggerChance;                                     // 0x0004(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          OverrideDistanceTravelledGate;                     // 0x0008(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x3];                                        // 0x0009(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FFloatRange                            DistanceTraveledGateMeterMinMax;                   // 0x000C(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C[0x4];                                       // 0x001C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FP2SnapToFoliageSpeciesSettings) == 0x000004, "Wrong alignment on FP2SnapToFoliageSpeciesSettings");
static_assert(sizeof(FP2SnapToFoliageSpeciesSettings) == 0x000020, "Wrong size on FP2SnapToFoliageSpeciesSettings");
static_assert(offsetof(FP2SnapToFoliageSpeciesSettings, HeightSlot) == 0x000000, "Member 'FP2SnapToFoliageSpeciesSettings::HeightSlot' has a wrong offset!");
static_assert(offsetof(FP2SnapToFoliageSpeciesSettings, TriggerChance) == 0x000004, "Member 'FP2SnapToFoliageSpeciesSettings::TriggerChance' has a wrong offset!");
static_assert(offsetof(FP2SnapToFoliageSpeciesSettings, OverrideDistanceTravelledGate) == 0x000008, "Member 'FP2SnapToFoliageSpeciesSettings::OverrideDistanceTravelledGate' has a wrong offset!");
static_assert(offsetof(FP2SnapToFoliageSpeciesSettings, DistanceTraveledGateMeterMinMax) == 0x00000C, "Member 'FP2SnapToFoliageSpeciesSettings::DistanceTraveledGateMeterMinMax' has a wrong offset!");

// ScriptStruct Game.P2FaunaSounds
// 0x0050 (0x0050 - 0x0000)
struct FP2FaunaSounds final
{
public:
	TMap<class UP2FaunaSnapToFoliageSpeciesCollectionDataAsset*, struct FP2FaunaSnapToFoliageSpeciesCollectionSettings> SpeciesCollection; // 0x0000(0x0050)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
};
static_assert(alignof(FP2FaunaSounds) == 0x000008, "Wrong alignment on FP2FaunaSounds");
static_assert(sizeof(FP2FaunaSounds) == 0x000050, "Wrong size on FP2FaunaSounds");
static_assert(offsetof(FP2FaunaSounds, SpeciesCollection) == 0x000000, "Member 'FP2FaunaSounds::SpeciesCollection' has a wrong offset!");

// ScriptStruct Game.P2ColorMapFaunaSnapToFoliageChannelConfig
// 0x0068 (0x0068 - 0x0000)
struct FP2ColorMapFaunaSnapToFoliageChannelConfig final
{
public:
	float                                         TriggerChance;                                     // 0x0000(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FFloatRange                            DistanceTraveledGateMeterMinMax;                   // 0x0004(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<struct FGameplayTag, struct FP2FaunaSounds> FaunaSounds;                                    // 0x0018(0x0050)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
};
static_assert(alignof(FP2ColorMapFaunaSnapToFoliageChannelConfig) == 0x000008, "Wrong alignment on FP2ColorMapFaunaSnapToFoliageChannelConfig");
static_assert(sizeof(FP2ColorMapFaunaSnapToFoliageChannelConfig) == 0x000068, "Wrong size on FP2ColorMapFaunaSnapToFoliageChannelConfig");
static_assert(offsetof(FP2ColorMapFaunaSnapToFoliageChannelConfig, TriggerChance) == 0x000000, "Member 'FP2ColorMapFaunaSnapToFoliageChannelConfig::TriggerChance' has a wrong offset!");
static_assert(offsetof(FP2ColorMapFaunaSnapToFoliageChannelConfig, DistanceTraveledGateMeterMinMax) == 0x000004, "Member 'FP2ColorMapFaunaSnapToFoliageChannelConfig::DistanceTraveledGateMeterMinMax' has a wrong offset!");
static_assert(offsetof(FP2ColorMapFaunaSnapToFoliageChannelConfig, FaunaSounds) == 0x000018, "Member 'FP2ColorMapFaunaSnapToFoliageChannelConfig::FaunaSounds' has a wrong offset!");

// ScriptStruct Game.P2ColorMapSpatialFaunaChannelConfig
// 0x0038 (0x0038 - 0x0000)
struct FP2ColorMapSpatialFaunaChannelConfig final
{
public:
	class FName                                   Name;                                              // 0x0000(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EP2RegionColor                                Color;                                             // 0x0008(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UAkAudioEvent*                          AkEvent;                                           // 0x0010(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Interval;                                          // 0x0018(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         IntervalMinOffset;                                 // 0x001C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         IntervalMaxOffset;                                 // 0x0020(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         EventCount;                                        // 0x0024(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         EventCountMinOffset;                               // 0x0028(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         EventCountMaxOffset;                               // 0x002C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Radius;                                            // 0x0030(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_34[0x4];                                       // 0x0034(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FP2ColorMapSpatialFaunaChannelConfig) == 0x000008, "Wrong alignment on FP2ColorMapSpatialFaunaChannelConfig");
static_assert(sizeof(FP2ColorMapSpatialFaunaChannelConfig) == 0x000038, "Wrong size on FP2ColorMapSpatialFaunaChannelConfig");
static_assert(offsetof(FP2ColorMapSpatialFaunaChannelConfig, Name) == 0x000000, "Member 'FP2ColorMapSpatialFaunaChannelConfig::Name' has a wrong offset!");
static_assert(offsetof(FP2ColorMapSpatialFaunaChannelConfig, Color) == 0x000008, "Member 'FP2ColorMapSpatialFaunaChannelConfig::Color' has a wrong offset!");
static_assert(offsetof(FP2ColorMapSpatialFaunaChannelConfig, AkEvent) == 0x000010, "Member 'FP2ColorMapSpatialFaunaChannelConfig::AkEvent' has a wrong offset!");
static_assert(offsetof(FP2ColorMapSpatialFaunaChannelConfig, Interval) == 0x000018, "Member 'FP2ColorMapSpatialFaunaChannelConfig::Interval' has a wrong offset!");
static_assert(offsetof(FP2ColorMapSpatialFaunaChannelConfig, IntervalMinOffset) == 0x00001C, "Member 'FP2ColorMapSpatialFaunaChannelConfig::IntervalMinOffset' has a wrong offset!");
static_assert(offsetof(FP2ColorMapSpatialFaunaChannelConfig, IntervalMaxOffset) == 0x000020, "Member 'FP2ColorMapSpatialFaunaChannelConfig::IntervalMaxOffset' has a wrong offset!");
static_assert(offsetof(FP2ColorMapSpatialFaunaChannelConfig, EventCount) == 0x000024, "Member 'FP2ColorMapSpatialFaunaChannelConfig::EventCount' has a wrong offset!");
static_assert(offsetof(FP2ColorMapSpatialFaunaChannelConfig, EventCountMinOffset) == 0x000028, "Member 'FP2ColorMapSpatialFaunaChannelConfig::EventCountMinOffset' has a wrong offset!");
static_assert(offsetof(FP2ColorMapSpatialFaunaChannelConfig, EventCountMaxOffset) == 0x00002C, "Member 'FP2ColorMapSpatialFaunaChannelConfig::EventCountMaxOffset' has a wrong offset!");
static_assert(offsetof(FP2ColorMapSpatialFaunaChannelConfig, Radius) == 0x000030, "Member 'FP2ColorMapSpatialFaunaChannelConfig::Radius' has a wrong offset!");

// ScriptStruct Game.AmbientSpeakerData
// 0x0068 (0x0068 - 0x0000)
struct FAmbientSpeakerData final
{
public:
	uint8                                         Pad_0[0x8];                                        // 0x0000(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UAkComponent*                           Component;                                         // 0x0008(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_10[0x58];                                      // 0x0010(0x0058)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FAmbientSpeakerData) == 0x000008, "Wrong alignment on FAmbientSpeakerData");
static_assert(sizeof(FAmbientSpeakerData) == 0x000068, "Wrong size on FAmbientSpeakerData");
static_assert(offsetof(FAmbientSpeakerData, Component) == 0x000008, "Member 'FAmbientSpeakerData::Component' has a wrong offset!");

// ScriptStruct Game.AmbientChannelData
// 0x0100 (0x0100 - 0x0000)
struct alignas(0x08) FAmbientChannelData final
{
public:
	uint8                                         Pad_0[0x100];                                      // 0x0000(0x0100)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FAmbientChannelData) == 0x000008, "Wrong alignment on FAmbientChannelData");
static_assert(sizeof(FAmbientChannelData) == 0x000100, "Wrong size on FAmbientChannelData");

// ScriptStruct Game.EphemeralChannelData
// 0x00A0 (0x00A0 - 0x0000)
struct alignas(0x08) FEphemeralChannelData final
{
public:
	uint8                                         Pad_0[0xA0];                                       // 0x0000(0x00A0)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FEphemeralChannelData) == 0x000008, "Wrong alignment on FEphemeralChannelData");
static_assert(sizeof(FEphemeralChannelData) == 0x0000A0, "Wrong size on FEphemeralChannelData");

// ScriptStruct Game.P2SplineMoveAttributeContext
// 0x0040 (0x0040 - 0x0000)
struct FP2SplineMoveAttributeContext final
{
public:
	struct FGameplayAttribute                     BoundAttribute;                                    // 0x0000(0x0038)(Edit, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EP2SplineMoveAttributeMode                    Mode;                                              // 0x0038(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Magnitude;                                         // 0x003C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FP2SplineMoveAttributeContext) == 0x000008, "Wrong alignment on FP2SplineMoveAttributeContext");
static_assert(sizeof(FP2SplineMoveAttributeContext) == 0x000040, "Wrong size on FP2SplineMoveAttributeContext");
static_assert(offsetof(FP2SplineMoveAttributeContext, BoundAttribute) == 0x000000, "Member 'FP2SplineMoveAttributeContext::BoundAttribute' has a wrong offset!");
static_assert(offsetof(FP2SplineMoveAttributeContext, Mode) == 0x000038, "Member 'FP2SplineMoveAttributeContext::Mode' has a wrong offset!");
static_assert(offsetof(FP2SplineMoveAttributeContext, Magnitude) == 0x00003C, "Member 'FP2SplineMoveAttributeContext::Magnitude' has a wrong offset!");

// ScriptStruct Game.P2SplineMoveComponentConfig
// 0x0058 (0x0058 - 0x0000)
struct FP2SplineMoveComponentConfig final
{
public:
	TArray<EMovementMode>                         ValidMovementModes;                                // 0x0000(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FGameplayTagQuery                      ValidationQuery;                                   // 0x0010(0x0048)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
};
static_assert(alignof(FP2SplineMoveComponentConfig) == 0x000008, "Wrong alignment on FP2SplineMoveComponentConfig");
static_assert(sizeof(FP2SplineMoveComponentConfig) == 0x000058, "Wrong size on FP2SplineMoveComponentConfig");
static_assert(offsetof(FP2SplineMoveComponentConfig, ValidMovementModes) == 0x000000, "Member 'FP2SplineMoveComponentConfig::ValidMovementModes' has a wrong offset!");
static_assert(offsetof(FP2SplineMoveComponentConfig, ValidationQuery) == 0x000010, "Member 'FP2SplineMoveComponentConfig::ValidationQuery' has a wrong offset!");

// ScriptStruct Game.P2SplineMoveInputContext
// 0x0008 (0x0008 - 0x0000)
struct alignas(0x04) FP2SplineMoveInputContext final
{
public:
	uint8                                         Pad_0[0x8];                                        // 0x0000(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FP2SplineMoveInputContext) == 0x000004, "Wrong alignment on FP2SplineMoveInputContext");
static_assert(sizeof(FP2SplineMoveInputContext) == 0x000008, "Wrong size on FP2SplineMoveInputContext");

// ScriptStruct Game.P2SplineMoveActivationContext
// 0x0020 (0x0020 - 0x0000)
struct FP2SplineMoveActivationContext final
{
public:
	class AP2SplineMoveActor*                     Actor;                                             // 0x0000(0x0008)(ZeroConstructor, Transient, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USplineComponent*                       SelectedSpline;                                    // 0x0008(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           ActivationTag;                                     // 0x0010(0x0008)(Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsForwardDirection;                               // 0x0018(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19[0x3];                                       // 0x0019(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         LateralOffset;                                     // 0x001C(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FP2SplineMoveActivationContext) == 0x000008, "Wrong alignment on FP2SplineMoveActivationContext");
static_assert(sizeof(FP2SplineMoveActivationContext) == 0x000020, "Wrong size on FP2SplineMoveActivationContext");
static_assert(offsetof(FP2SplineMoveActivationContext, Actor) == 0x000000, "Member 'FP2SplineMoveActivationContext::Actor' has a wrong offset!");
static_assert(offsetof(FP2SplineMoveActivationContext, SelectedSpline) == 0x000008, "Member 'FP2SplineMoveActivationContext::SelectedSpline' has a wrong offset!");
static_assert(offsetof(FP2SplineMoveActivationContext, ActivationTag) == 0x000010, "Member 'FP2SplineMoveActivationContext::ActivationTag' has a wrong offset!");
static_assert(offsetof(FP2SplineMoveActivationContext, bIsForwardDirection) == 0x000018, "Member 'FP2SplineMoveActivationContext::bIsForwardDirection' has a wrong offset!");
static_assert(offsetof(FP2SplineMoveActivationContext, LateralOffset) == 0x00001C, "Member 'FP2SplineMoveActivationContext::LateralOffset' has a wrong offset!");

// ScriptStruct Game.P2SpotLightComponentConfig
// 0x000C (0x000C - 0x0000)
struct FP2SpotLightComponentConfig final
{
public:
	int32                                         NumRadialChecks;                                   // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         NumRayLengthChecks;                                // 0x0004(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Priority;                                          // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FP2SpotLightComponentConfig) == 0x000004, "Wrong alignment on FP2SpotLightComponentConfig");
static_assert(sizeof(FP2SpotLightComponentConfig) == 0x00000C, "Wrong size on FP2SpotLightComponentConfig");
static_assert(offsetof(FP2SpotLightComponentConfig, NumRadialChecks) == 0x000000, "Member 'FP2SpotLightComponentConfig::NumRadialChecks' has a wrong offset!");
static_assert(offsetof(FP2SpotLightComponentConfig, NumRayLengthChecks) == 0x000004, "Member 'FP2SpotLightComponentConfig::NumRayLengthChecks' has a wrong offset!");
static_assert(offsetof(FP2SpotLightComponentConfig, Priority) == 0x000008, "Member 'FP2SpotLightComponentConfig::Priority' has a wrong offset!");

// ScriptStruct Game.P2SquadNumberWidgetInfo
// 0x00D8 (0x00D8 - 0x0000)
struct FP2SquadNumberWidgetInfo final
{
public:
	struct FVector2D                              PlayerSelfWidgetSize;                              // 0x0000(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              MemberWidgetSize;                                  // 0x0010(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PlayerSelfFontSize;                                // 0x0020(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MemberFontSize;                                    // 0x0024(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSlateFontInfo                         PlayerSelfFont;                                    // 0x0028(0x0058)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSlateFontInfo                         MemberFont;                                        // 0x0080(0x0058)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FP2SquadNumberWidgetInfo) == 0x000008, "Wrong alignment on FP2SquadNumberWidgetInfo");
static_assert(sizeof(FP2SquadNumberWidgetInfo) == 0x0000D8, "Wrong size on FP2SquadNumberWidgetInfo");
static_assert(offsetof(FP2SquadNumberWidgetInfo, PlayerSelfWidgetSize) == 0x000000, "Member 'FP2SquadNumberWidgetInfo::PlayerSelfWidgetSize' has a wrong offset!");
static_assert(offsetof(FP2SquadNumberWidgetInfo, MemberWidgetSize) == 0x000010, "Member 'FP2SquadNumberWidgetInfo::MemberWidgetSize' has a wrong offset!");
static_assert(offsetof(FP2SquadNumberWidgetInfo, PlayerSelfFontSize) == 0x000020, "Member 'FP2SquadNumberWidgetInfo::PlayerSelfFontSize' has a wrong offset!");
static_assert(offsetof(FP2SquadNumberWidgetInfo, MemberFontSize) == 0x000024, "Member 'FP2SquadNumberWidgetInfo::MemberFontSize' has a wrong offset!");
static_assert(offsetof(FP2SquadNumberWidgetInfo, PlayerSelfFont) == 0x000028, "Member 'FP2SquadNumberWidgetInfo::PlayerSelfFont' has a wrong offset!");
static_assert(offsetof(FP2SquadNumberWidgetInfo, MemberFont) == 0x000080, "Member 'FP2SquadNumberWidgetInfo::MemberFont' has a wrong offset!");

// ScriptStruct Game.P2ActiveBusEffectData
// 0x0028 (0x0028 - 0x0000)
struct FP2ActiveBusEffectData final
{
public:
	class UObject*                                Affected;                                          // 0x0000(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAkAudioEvent*                          StopEvent;                                         // 0x0008(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_10[0x18];                                      // 0x0010(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FP2ActiveBusEffectData) == 0x000008, "Wrong alignment on FP2ActiveBusEffectData");
static_assert(sizeof(FP2ActiveBusEffectData) == 0x000028, "Wrong size on FP2ActiveBusEffectData");
static_assert(offsetof(FP2ActiveBusEffectData, Affected) == 0x000000, "Member 'FP2ActiveBusEffectData::Affected' has a wrong offset!");
static_assert(offsetof(FP2ActiveBusEffectData, StopEvent) == 0x000008, "Member 'FP2ActiveBusEffectData::StopEvent' has a wrong offset!");

// ScriptStruct Game.P2ActiveGameplayStatusEffectData
// 0x0018 (0x0018 - 0x0000)
struct alignas(0x08) FP2ActiveGameplayStatusEffectData final
{
public:
	uint8                                         Pad_0[0x18];                                       // 0x0000(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FP2ActiveGameplayStatusEffectData) == 0x000008, "Wrong alignment on FP2ActiveGameplayStatusEffectData");
static_assert(sizeof(FP2ActiveGameplayStatusEffectData) == 0x000018, "Wrong size on FP2ActiveGameplayStatusEffectData");

// ScriptStruct Game.P2OptionGroup
// 0x0038 (0x0038 - 0x0000)
struct FP2OptionGroup final
{
public:
	class FString                                 OptionGroupId;                                     // 0x0000(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FText                                   OptionGroupName;                                   // 0x0010(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TArray<struct FP2OptionSubGroup>              OptionSubGroups;                                   // 0x0028(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, ContainsInstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(FP2OptionGroup) == 0x000008, "Wrong alignment on FP2OptionGroup");
static_assert(sizeof(FP2OptionGroup) == 0x000038, "Wrong size on FP2OptionGroup");
static_assert(offsetof(FP2OptionGroup, OptionGroupId) == 0x000000, "Member 'FP2OptionGroup::OptionGroupId' has a wrong offset!");
static_assert(offsetof(FP2OptionGroup, OptionGroupName) == 0x000010, "Member 'FP2OptionGroup::OptionGroupName' has a wrong offset!");
static_assert(offsetof(FP2OptionGroup, OptionSubGroups) == 0x000028, "Member 'FP2OptionGroup::OptionSubGroups' has a wrong offset!");

// ScriptStruct Game.P2TargetData_AttachTo
// 0x0050 (0x0058 - 0x0008)
struct FP2TargetData_AttachTo final : public FGameplayAbilityTargetData
{
public:
	class USceneComponent*                        AttachPoint;                                       // 0x0008(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USceneComponent*                        DetachStart;                                       // 0x0010(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USceneComponent*                        DetachTargetPoint;                                 // 0x0018(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USceneComponent*                        ApproachPoint;                                     // 0x0020(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsInstant;                                        // 0x0028(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_29[0x3];                                       // 0x0029(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTag                           MountMontageTag_Out;                               // 0x002C(0x0008)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           MountMontageTag_In;                                // 0x0034(0x0008)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           InsideMontageTag;                                  // 0x003C(0x0008)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           UnmountMontageTag_Out;                             // 0x0044(0x0008)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           UnmountMontageTag_In;                              // 0x004C(0x0008)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_54[0x4];                                       // 0x0054(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FP2TargetData_AttachTo) == 0x000008, "Wrong alignment on FP2TargetData_AttachTo");
static_assert(sizeof(FP2TargetData_AttachTo) == 0x000058, "Wrong size on FP2TargetData_AttachTo");
static_assert(offsetof(FP2TargetData_AttachTo, AttachPoint) == 0x000008, "Member 'FP2TargetData_AttachTo::AttachPoint' has a wrong offset!");
static_assert(offsetof(FP2TargetData_AttachTo, DetachStart) == 0x000010, "Member 'FP2TargetData_AttachTo::DetachStart' has a wrong offset!");
static_assert(offsetof(FP2TargetData_AttachTo, DetachTargetPoint) == 0x000018, "Member 'FP2TargetData_AttachTo::DetachTargetPoint' has a wrong offset!");
static_assert(offsetof(FP2TargetData_AttachTo, ApproachPoint) == 0x000020, "Member 'FP2TargetData_AttachTo::ApproachPoint' has a wrong offset!");
static_assert(offsetof(FP2TargetData_AttachTo, bIsInstant) == 0x000028, "Member 'FP2TargetData_AttachTo::bIsInstant' has a wrong offset!");
static_assert(offsetof(FP2TargetData_AttachTo, MountMontageTag_Out) == 0x00002C, "Member 'FP2TargetData_AttachTo::MountMontageTag_Out' has a wrong offset!");
static_assert(offsetof(FP2TargetData_AttachTo, MountMontageTag_In) == 0x000034, "Member 'FP2TargetData_AttachTo::MountMontageTag_In' has a wrong offset!");
static_assert(offsetof(FP2TargetData_AttachTo, InsideMontageTag) == 0x00003C, "Member 'FP2TargetData_AttachTo::InsideMontageTag' has a wrong offset!");
static_assert(offsetof(FP2TargetData_AttachTo, UnmountMontageTag_Out) == 0x000044, "Member 'FP2TargetData_AttachTo::UnmountMontageTag_Out' has a wrong offset!");
static_assert(offsetof(FP2TargetData_AttachTo, UnmountMontageTag_In) == 0x00004C, "Member 'FP2TargetData_AttachTo::UnmountMontageTag_In' has a wrong offset!");

// ScriptStruct Game.P2TargetData_Consumable
// 0x0010 (0x0018 - 0x0008)
struct FP2TargetData_Consumable final : public FGameplayAbilityTargetData
{
public:
	uint8                                         Pad_8[0x10];                                       // 0x0008(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FP2TargetData_Consumable) == 0x000008, "Wrong alignment on FP2TargetData_Consumable");
static_assert(sizeof(FP2TargetData_Consumable) == 0x000018, "Wrong size on FP2TargetData_Consumable");

// ScriptStruct Game.P2TargetData_Explosion
// 0x0030 (0x0038 - 0x0008)
struct FP2TargetData_Explosion final : public FGameplayAbilityTargetData
{
public:
	class AActor*                                 SourceActor;                                       // 0x0008(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCurveFloat*                            WaterDistanceDamageCurve;                          // 0x0010(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_18[0x20];                                      // 0x0018(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FP2TargetData_Explosion) == 0x000008, "Wrong alignment on FP2TargetData_Explosion");
static_assert(sizeof(FP2TargetData_Explosion) == 0x000038, "Wrong size on FP2TargetData_Explosion");
static_assert(offsetof(FP2TargetData_Explosion, SourceActor) == 0x000008, "Member 'FP2TargetData_Explosion::SourceActor' has a wrong offset!");
static_assert(offsetof(FP2TargetData_Explosion, WaterDistanceDamageCurve) == 0x000010, "Member 'FP2TargetData_Explosion::WaterDistanceDamageCurve' has a wrong offset!");

// ScriptStruct Game.P2TargetData_FireWeapon
// 0x00B8 (0x00C0 - 0x0008)
struct FP2TargetData_FireWeapon final : public FGameplayAbilityTargetData
{
public:
	uint8                                         Pad_8[0x8];                                        // 0x0008(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayAbilityTargetingLocationInfo  SourceLocation;                                    // 0x0010(0x00A0)(BlueprintVisible, ContainsInstancedReference, NativeAccessSpecifierPublic)
	float                                         TotalHeatAdded;                                    // 0x00B0(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_B4[0xC];                                       // 0x00B4(0x000C)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FP2TargetData_FireWeapon) == 0x000010, "Wrong alignment on FP2TargetData_FireWeapon");
static_assert(sizeof(FP2TargetData_FireWeapon) == 0x0000C0, "Wrong size on FP2TargetData_FireWeapon");
static_assert(offsetof(FP2TargetData_FireWeapon, SourceLocation) == 0x000010, "Member 'FP2TargetData_FireWeapon::SourceLocation' has a wrong offset!");
static_assert(offsetof(FP2TargetData_FireWeapon, TotalHeatAdded) == 0x0000B0, "Member 'FP2TargetData_FireWeapon::TotalHeatAdded' has a wrong offset!");

// ScriptStruct Game.P2TargetData_HitScan
// 0x00F0 (0x00F8 - 0x0008)
struct FP2TargetData_HitScan final : public FGameplayAbilityTargetData
{
public:
	struct FHitResult                             HitResult;                                         // 0x0008(0x00E8)(BlueprintVisible, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	float                                         TotalHeatAdded;                                    // 0x00F0(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TimeInAir;                                         // 0x00F4(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FP2TargetData_HitScan) == 0x000008, "Wrong alignment on FP2TargetData_HitScan");
static_assert(sizeof(FP2TargetData_HitScan) == 0x0000F8, "Wrong size on FP2TargetData_HitScan");
static_assert(offsetof(FP2TargetData_HitScan, HitResult) == 0x000008, "Member 'FP2TargetData_HitScan::HitResult' has a wrong offset!");
static_assert(offsetof(FP2TargetData_HitScan, TotalHeatAdded) == 0x0000F0, "Member 'FP2TargetData_HitScan::TotalHeatAdded' has a wrong offset!");
static_assert(offsetof(FP2TargetData_HitScan, TimeInAir) == 0x0000F4, "Member 'FP2TargetData_HitScan::TimeInAir' has a wrong offset!");

// ScriptStruct Game.P2TargetData_MoveItem
// 0x0018 (0x0030 - 0x0018)
struct FP2TargetData_MoveItem final : public FP2TargetData_ItemAction
{
public:
	uint8                                         Pad_18[0x18];                                      // 0x0018(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FP2TargetData_MoveItem) == 0x000008, "Wrong alignment on FP2TargetData_MoveItem");
static_assert(sizeof(FP2TargetData_MoveItem) == 0x000030, "Wrong size on FP2TargetData_MoveItem");

// ScriptStruct Game.P2TargetData_InventoryMagazineAction
// 0x0030 (0x0048 - 0x0018)
struct FP2TargetData_InventoryMagazineAction final : public FP2TargetData_ItemAction
{
public:
	uint8                                         Pad_18[0x30];                                      // 0x0018(0x0030)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FP2TargetData_InventoryMagazineAction) == 0x000008, "Wrong alignment on FP2TargetData_InventoryMagazineAction");
static_assert(sizeof(FP2TargetData_InventoryMagazineAction) == 0x000048, "Wrong size on FP2TargetData_InventoryMagazineAction");

// ScriptStruct Game.P2TargetData_InventoryUnequipItem
// 0x0018 (0x0030 - 0x0018)
struct FP2TargetData_InventoryUnequipItem final : public FP2TargetData_ItemAction
{
public:
	uint8                                         Pad_18[0x18];                                      // 0x0018(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FP2TargetData_InventoryUnequipItem) == 0x000008, "Wrong alignment on FP2TargetData_InventoryUnequipItem");
static_assert(sizeof(FP2TargetData_InventoryUnequipItem) == 0x000030, "Wrong size on FP2TargetData_InventoryUnequipItem");

// ScriptStruct Game.P2TargetData_InventoryEmptyItem
// 0x0008 (0x0020 - 0x0018)
struct FP2TargetData_InventoryEmptyItem final : public FP2TargetData_ItemAction
{
public:
	uint8                                         Pad_18[0x8];                                       // 0x0018(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FP2TargetData_InventoryEmptyItem) == 0x000008, "Wrong alignment on FP2TargetData_InventoryEmptyItem");
static_assert(sizeof(FP2TargetData_InventoryEmptyItem) == 0x000020, "Wrong size on FP2TargetData_InventoryEmptyItem");

// ScriptStruct Game.P2TargetData_InventoryEquipmentSwapAction
// 0x0010 (0x0028 - 0x0018)
struct FP2TargetData_InventoryEquipmentSwapAction final : public FP2TargetData_ItemAction
{
public:
	uint8                                         Pad_18[0x10];                                      // 0x0018(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FP2TargetData_InventoryEquipmentSwapAction) == 0x000008, "Wrong alignment on FP2TargetData_InventoryEquipmentSwapAction");
static_assert(sizeof(FP2TargetData_InventoryEquipmentSwapAction) == 0x000028, "Wrong size on FP2TargetData_InventoryEquipmentSwapAction");

// ScriptStruct Game.P2TargetData_SearchItems
// 0x0010 (0x0018 - 0x0008)
struct FP2TargetData_SearchItems final : public FGameplayAbilityTargetData
{
public:
	uint8                                         Pad_8[0x10];                                       // 0x0008(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FP2TargetData_SearchItems) == 0x000008, "Wrong alignment on FP2TargetData_SearchItems");
static_assert(sizeof(FP2TargetData_SearchItems) == 0x000018, "Wrong size on FP2TargetData_SearchItems");

// ScriptStruct Game.P2TargetData_MoveAction
// 0x0020 (0x0028 - 0x0008)
struct FP2TargetData_MoveAction final : public FGameplayAbilityTargetData
{
public:
	struct FMoveActionExecData                    ExecData;                                          // 0x0008(0x0020)(Transient, NativeAccessSpecifierPublic)
};
static_assert(alignof(FP2TargetData_MoveAction) == 0x000008, "Wrong alignment on FP2TargetData_MoveAction");
static_assert(sizeof(FP2TargetData_MoveAction) == 0x000028, "Wrong size on FP2TargetData_MoveAction");
static_assert(offsetof(FP2TargetData_MoveAction, ExecData) == 0x000008, "Member 'FP2TargetData_MoveAction::ExecData' has a wrong offset!");

// ScriptStruct Game.P2TargetData_Ping
// 0x0038 (0x0040 - 0x0008)
struct FP2TargetData_Ping final : public FGameplayAbilityTargetData
{
public:
	class UObject*                                PingTarget;                                        // 0x0008(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsEnemyPing;                                       // 0x0010(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EP2PingType                                   PingType;                                          // 0x0011(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_12[0x6];                                       // 0x0012(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	class AActor*                                 Instigator;                                        // 0x0018(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector_NetQuantize                    Location;                                          // 0x0020(0x0018)(Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         SquadIndex;                                        // 0x0038(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3C[0x4];                                       // 0x003C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FP2TargetData_Ping) == 0x000008, "Wrong alignment on FP2TargetData_Ping");
static_assert(sizeof(FP2TargetData_Ping) == 0x000040, "Wrong size on FP2TargetData_Ping");
static_assert(offsetof(FP2TargetData_Ping, PingTarget) == 0x000008, "Member 'FP2TargetData_Ping::PingTarget' has a wrong offset!");
static_assert(offsetof(FP2TargetData_Ping, IsEnemyPing) == 0x000010, "Member 'FP2TargetData_Ping::IsEnemyPing' has a wrong offset!");
static_assert(offsetof(FP2TargetData_Ping, PingType) == 0x000011, "Member 'FP2TargetData_Ping::PingType' has a wrong offset!");
static_assert(offsetof(FP2TargetData_Ping, Instigator) == 0x000018, "Member 'FP2TargetData_Ping::Instigator' has a wrong offset!");
static_assert(offsetof(FP2TargetData_Ping, Location) == 0x000020, "Member 'FP2TargetData_Ping::Location' has a wrong offset!");
static_assert(offsetof(FP2TargetData_Ping, SquadIndex) == 0x000038, "Member 'FP2TargetData_Ping::SquadIndex' has a wrong offset!");

// ScriptStruct Game.P2TargetData_ReloadSpecificAmmo
// 0x0008 (0x0010 - 0x0008)
struct FP2TargetData_ReloadSpecificAmmo final : public FGameplayAbilityTargetData
{
public:
	uint8                                         Pad_8[0x8];                                        // 0x0008(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FP2TargetData_ReloadSpecificAmmo) == 0x000008, "Wrong alignment on FP2TargetData_ReloadSpecificAmmo");
static_assert(sizeof(FP2TargetData_ReloadSpecificAmmo) == 0x000010, "Wrong size on FP2TargetData_ReloadSpecificAmmo");

// ScriptStruct Game.P2TargetData_SingleLocation
// 0x00A8 (0x00B0 - 0x0008)
struct FP2TargetData_SingleLocation final : public FGameplayAbilityTargetData
{
public:
	uint8                                         Pad_8[0x8];                                        // 0x0008(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayAbilityTargetingLocationInfo  Location;                                          // 0x0010(0x00A0)(Edit, BlueprintVisible, ContainsInstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(FP2TargetData_SingleLocation) == 0x000010, "Wrong alignment on FP2TargetData_SingleLocation");
static_assert(sizeof(FP2TargetData_SingleLocation) == 0x0000B0, "Wrong size on FP2TargetData_SingleLocation");
static_assert(offsetof(FP2TargetData_SingleLocation, Location) == 0x000010, "Member 'FP2TargetData_SingleLocation::Location' has a wrong offset!");

// ScriptStruct Game.P2TargetData_ThrowStart
// 0x0008 (0x0010 - 0x0008)
struct FP2TargetData_ThrowStart final : public FGameplayAbilityTargetData
{
public:
	uint8                                         Pad_8[0x8];                                        // 0x0008(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FP2TargetData_ThrowStart) == 0x000008, "Wrong alignment on FP2TargetData_ThrowStart");
static_assert(sizeof(FP2TargetData_ThrowStart) == 0x000010, "Wrong size on FP2TargetData_ThrowStart");

// ScriptStruct Game.P2TargetData_Vault
// 0x0060 (0x0068 - 0x0008)
struct FP2TargetData_Vault final : public FGameplayAbilityTargetData
{
public:
	uint8                                         Pad_8[0x48];                                       // 0x0008(0x0048)(Fixing Size After Last Property [ Dumper-7 ])
	class AActor*                                 BaseActor;                                         // 0x0050(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FVector>                        BaseLocations;                                     // 0x0058(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPublic)
};
static_assert(alignof(FP2TargetData_Vault) == 0x000008, "Wrong alignment on FP2TargetData_Vault");
static_assert(sizeof(FP2TargetData_Vault) == 0x000068, "Wrong size on FP2TargetData_Vault");
static_assert(offsetof(FP2TargetData_Vault, BaseActor) == 0x000050, "Member 'FP2TargetData_Vault::BaseActor' has a wrong offset!");
static_assert(offsetof(FP2TargetData_Vault, BaseLocations) == 0x000058, "Member 'FP2TargetData_Vault::BaseLocations' has a wrong offset!");

// ScriptStruct Game.LaserTargetingRegion
// 0x0010 (0x0010 - 0x0000)
struct FLaserTargetingRegion final
{
public:
	struct FVector2f                              Min;                                               // 0x0000(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2f                              Max;                                               // 0x0008(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FLaserTargetingRegion) == 0x000004, "Wrong alignment on FLaserTargetingRegion");
static_assert(sizeof(FLaserTargetingRegion) == 0x000010, "Wrong size on FLaserTargetingRegion");
static_assert(offsetof(FLaserTargetingRegion, Min) == 0x000000, "Member 'FLaserTargetingRegion::Min' has a wrong offset!");
static_assert(offsetof(FLaserTargetingRegion, Max) == 0x000008, "Member 'FLaserTargetingRegion::Max' has a wrong offset!");

// ScriptStruct Game.P2SquadMemberInfo
// 0x0030 (0x0030 - 0x0000)
struct FP2SquadMemberInfo final
{
public:
	class FString                                 AccountID;                                         // 0x0000(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, RepSkip, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 AccountName;                                       // 0x0010(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EP2SquadUserStatus                            Status;                                            // 0x0020(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_21[0x3];                                       // 0x0021(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         MemberIndex;                                       // 0x0024(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AP2PlayerState*                         PlayerState;                                       // 0x0028(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, RepSkip, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FP2SquadMemberInfo) == 0x000008, "Wrong alignment on FP2SquadMemberInfo");
static_assert(sizeof(FP2SquadMemberInfo) == 0x000030, "Wrong size on FP2SquadMemberInfo");
static_assert(offsetof(FP2SquadMemberInfo, AccountID) == 0x000000, "Member 'FP2SquadMemberInfo::AccountID' has a wrong offset!");
static_assert(offsetof(FP2SquadMemberInfo, AccountName) == 0x000010, "Member 'FP2SquadMemberInfo::AccountName' has a wrong offset!");
static_assert(offsetof(FP2SquadMemberInfo, Status) == 0x000020, "Member 'FP2SquadMemberInfo::Status' has a wrong offset!");
static_assert(offsetof(FP2SquadMemberInfo, MemberIndex) == 0x000024, "Member 'FP2SquadMemberInfo::MemberIndex' has a wrong offset!");
static_assert(offsetof(FP2SquadMemberInfo, PlayerState) == 0x000028, "Member 'FP2SquadMemberInfo::PlayerState' has a wrong offset!");

// ScriptStruct Game.P2TeamTrackingInfo
// 0x0018 (0x0018 - 0x0000)
struct FP2TeamTrackingInfo final
{
public:
	class AP2TeamStatePublic*                     PublicTeamState;                                   // 0x0000(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AP2TeamStatePrivate*                    PrivateTeamState;                                  // 0x0008(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AP2TeamStateNPC*                        NPCTeamState;                                      // 0x0010(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FP2TeamTrackingInfo) == 0x000008, "Wrong alignment on FP2TeamTrackingInfo");
static_assert(sizeof(FP2TeamTrackingInfo) == 0x000018, "Wrong size on FP2TeamTrackingInfo");
static_assert(offsetof(FP2TeamTrackingInfo, PublicTeamState) == 0x000000, "Member 'FP2TeamTrackingInfo::PublicTeamState' has a wrong offset!");
static_assert(offsetof(FP2TeamTrackingInfo, PrivateTeamState) == 0x000008, "Member 'FP2TeamTrackingInfo::PrivateTeamState' has a wrong offset!");
static_assert(offsetof(FP2TeamTrackingInfo, NPCTeamState) == 0x000010, "Member 'FP2TeamTrackingInfo::NPCTeamState' has a wrong offset!");

// ScriptStruct Game.P2MovementStepData
// 0x0038 (0x0038 - 0x0000)
struct FP2MovementStepData final
{
public:
	struct FVector                                Location;                                          // 0x0000(0x0018)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Velocity;                                          // 0x0018(0x0018)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint16                                        SimStep;                                           // 0x0030(0x0002)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bSimulationIsActive;                               // 0x0032(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bImpact;                                           // 0x0033(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_34[0x4];                                       // 0x0034(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FP2MovementStepData) == 0x000008, "Wrong alignment on FP2MovementStepData");
static_assert(sizeof(FP2MovementStepData) == 0x000038, "Wrong size on FP2MovementStepData");
static_assert(offsetof(FP2MovementStepData, Location) == 0x000000, "Member 'FP2MovementStepData::Location' has a wrong offset!");
static_assert(offsetof(FP2MovementStepData, Velocity) == 0x000018, "Member 'FP2MovementStepData::Velocity' has a wrong offset!");
static_assert(offsetof(FP2MovementStepData, SimStep) == 0x000030, "Member 'FP2MovementStepData::SimStep' has a wrong offset!");
static_assert(offsetof(FP2MovementStepData, bSimulationIsActive) == 0x000032, "Member 'FP2MovementStepData::bSimulationIsActive' has a wrong offset!");
static_assert(offsetof(FP2MovementStepData, bImpact) == 0x000033, "Member 'FP2MovementStepData::bImpact' has a wrong offset!");

// ScriptStruct Game.P2ThrowableMovementInitialState
// 0x0030 (0x0030 - 0x0000)
struct FP2ThrowableMovementInitialState final
{
public:
	struct FVector_NetQuantize                    Location;                                          // 0x0000(0x0018)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector_NetQuantize                    Velocity;                                          // 0x0018(0x0018)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FP2ThrowableMovementInitialState) == 0x000008, "Wrong alignment on FP2ThrowableMovementInitialState");
static_assert(sizeof(FP2ThrowableMovementInitialState) == 0x000030, "Wrong size on FP2ThrowableMovementInitialState");
static_assert(offsetof(FP2ThrowableMovementInitialState, Location) == 0x000000, "Member 'FP2ThrowableMovementInitialState::Location' has a wrong offset!");
static_assert(offsetof(FP2ThrowableMovementInitialState, Velocity) == 0x000018, "Member 'FP2ThrowableMovementInitialState::Velocity' has a wrong offset!");

// ScriptStruct Game.P2ContextualPointArray
// 0x0010 (0x0010 - 0x0000)
struct FP2ContextualPointArray final
{
public:
	TArray<struct FP2TargetTracePoint>            ContextualPoints;                                  // 0x0000(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FP2ContextualPointArray) == 0x000008, "Wrong alignment on FP2ContextualPointArray");
static_assert(sizeof(FP2ContextualPointArray) == 0x000010, "Wrong size on FP2ContextualPointArray");
static_assert(offsetof(FP2ContextualPointArray, ContextualPoints) == 0x000000, "Member 'FP2ContextualPointArray::ContextualPoints' has a wrong offset!");

// ScriptStruct Game.P2ContextualPointArrayWithAdaptiveLeaningTag
// 0x0050 (0x0050 - 0x0000)
struct FP2ContextualPointArrayWithAdaptiveLeaningTag final
{
public:
	TMap<struct FGameplayTag, struct FP2ContextualPointArray> ContextualPointArrayWithAdaptiveLeaning; // 0x0000(0x0050)(Edit, NativeAccessSpecifierPublic)
};
static_assert(alignof(FP2ContextualPointArrayWithAdaptiveLeaningTag) == 0x000008, "Wrong alignment on FP2ContextualPointArrayWithAdaptiveLeaningTag");
static_assert(sizeof(FP2ContextualPointArrayWithAdaptiveLeaningTag) == 0x000050, "Wrong size on FP2ContextualPointArrayWithAdaptiveLeaningTag");
static_assert(offsetof(FP2ContextualPointArrayWithAdaptiveLeaningTag, ContextualPointArrayWithAdaptiveLeaning) == 0x000000, "Member 'FP2ContextualPointArrayWithAdaptiveLeaningTag::ContextualPointArrayWithAdaptiveLeaning' has a wrong offset!");

// ScriptStruct Game.P2ConstantEffectApplicationConfig
// 0x0008 (0x0008 - 0x0000)
struct FP2ConstantEffectApplicationConfig final
{
public:
	TSubclassOf<class UGameplayEffect>            GameplayEffect;                                    // 0x0000(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FP2ConstantEffectApplicationConfig) == 0x000008, "Wrong alignment on FP2ConstantEffectApplicationConfig");
static_assert(sizeof(FP2ConstantEffectApplicationConfig) == 0x000008, "Wrong size on FP2ConstantEffectApplicationConfig");
static_assert(offsetof(FP2ConstantEffectApplicationConfig, GameplayEffect) == 0x000000, "Member 'FP2ConstantEffectApplicationConfig::GameplayEffect' has a wrong offset!");

// ScriptStruct Game.P2HighlightedWidgetInfo
// 0x0018 (0x0018 - 0x0000)
struct FP2HighlightedWidgetInfo final
{
public:
	class UWidget*                                Widget;                                            // 0x0000(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EP2WidgetHighlightType                        HighlightType;                                     // 0x0008(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UWidget*                                BorderWidget;                                      // 0x0010(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FP2HighlightedWidgetInfo) == 0x000008, "Wrong alignment on FP2HighlightedWidgetInfo");
static_assert(sizeof(FP2HighlightedWidgetInfo) == 0x000018, "Wrong size on FP2HighlightedWidgetInfo");
static_assert(offsetof(FP2HighlightedWidgetInfo, Widget) == 0x000000, "Member 'FP2HighlightedWidgetInfo::Widget' has a wrong offset!");
static_assert(offsetof(FP2HighlightedWidgetInfo, HighlightType) == 0x000008, "Member 'FP2HighlightedWidgetInfo::HighlightType' has a wrong offset!");
static_assert(offsetof(FP2HighlightedWidgetInfo, BorderWidget) == 0x000010, "Member 'FP2HighlightedWidgetInfo::BorderWidget' has a wrong offset!");

// ScriptStruct Game.P2MeleeWeaponImpulseConfig
// 0x000C (0x000C - 0x0000)
struct FP2MeleeWeaponImpulseConfig final
{
public:
	float                                         ImpulseScale;                                      // 0x0000(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ParentBonePropagationScale;                        // 0x0004(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         UpperBodyImpulseScale;                             // 0x0008(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FP2MeleeWeaponImpulseConfig) == 0x000004, "Wrong alignment on FP2MeleeWeaponImpulseConfig");
static_assert(sizeof(FP2MeleeWeaponImpulseConfig) == 0x00000C, "Wrong size on FP2MeleeWeaponImpulseConfig");
static_assert(offsetof(FP2MeleeWeaponImpulseConfig, ImpulseScale) == 0x000000, "Member 'FP2MeleeWeaponImpulseConfig::ImpulseScale' has a wrong offset!");
static_assert(offsetof(FP2MeleeWeaponImpulseConfig, ParentBonePropagationScale) == 0x000004, "Member 'FP2MeleeWeaponImpulseConfig::ParentBonePropagationScale' has a wrong offset!");
static_assert(offsetof(FP2MeleeWeaponImpulseConfig, UpperBodyImpulseScale) == 0x000008, "Member 'FP2MeleeWeaponImpulseConfig::UpperBodyImpulseScale' has a wrong offset!");

// ScriptStruct Game.P2RemapRotator
// 0x0048 (0x0048 - 0x0000)
struct FP2RemapRotator final
{
public:
	struct FVector2D                              InputRange;                                        // 0x0000(0x0010)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               OutputMin;                                         // 0x0010(0x0018)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FRotator                               OutputMax;                                         // 0x0028(0x0018)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          bClamp;                                            // 0x0040(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_41[0x7];                                       // 0x0041(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FP2RemapRotator) == 0x000008, "Wrong alignment on FP2RemapRotator");
static_assert(sizeof(FP2RemapRotator) == 0x000048, "Wrong size on FP2RemapRotator");
static_assert(offsetof(FP2RemapRotator, InputRange) == 0x000000, "Member 'FP2RemapRotator::InputRange' has a wrong offset!");
static_assert(offsetof(FP2RemapRotator, OutputMin) == 0x000010, "Member 'FP2RemapRotator::OutputMin' has a wrong offset!");
static_assert(offsetof(FP2RemapRotator, OutputMax) == 0x000028, "Member 'FP2RemapRotator::OutputMax' has a wrong offset!");
static_assert(offsetof(FP2RemapRotator, bClamp) == 0x000040, "Member 'FP2RemapRotator::bClamp' has a wrong offset!");

// ScriptStruct Game.P2MontagePlayResult
// 0x0010 (0x0010 - 0x0000)
struct alignas(0x08) FP2MontagePlayResult final
{
public:
	float                                         MontageDuration;                                   // 0x0000(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bSuccess;                                          // 0x0004(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5[0xB];                                        // 0x0005(0x000B)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FP2MontagePlayResult) == 0x000008, "Wrong alignment on FP2MontagePlayResult");
static_assert(sizeof(FP2MontagePlayResult) == 0x000010, "Wrong size on FP2MontagePlayResult");
static_assert(offsetof(FP2MontagePlayResult, MontageDuration) == 0x000000, "Member 'FP2MontagePlayResult::MontageDuration' has a wrong offset!");
static_assert(offsetof(FP2MontagePlayResult, bSuccess) == 0x000004, "Member 'FP2MontagePlayResult::bSuccess' has a wrong offset!");

// ScriptStruct Game.P2UIGameTagDisplayDataRow
// 0x0020 (0x0028 - 0x0008)
struct FP2UIGameTagDisplayDataRow final : public FTableRowBase
{
public:
	struct FGameplayTag                           ItemTag;                                           // 0x0008(0x0008)(Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FText                                   DisplayText;                                       // 0x0010(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
};
static_assert(alignof(FP2UIGameTagDisplayDataRow) == 0x000008, "Wrong alignment on FP2UIGameTagDisplayDataRow");
static_assert(sizeof(FP2UIGameTagDisplayDataRow) == 0x000028, "Wrong size on FP2UIGameTagDisplayDataRow");
static_assert(offsetof(FP2UIGameTagDisplayDataRow, ItemTag) == 0x000008, "Member 'FP2UIGameTagDisplayDataRow::ItemTag' has a wrong offset!");
static_assert(offsetof(FP2UIGameTagDisplayDataRow, DisplayText) == 0x000010, "Member 'FP2UIGameTagDisplayDataRow::DisplayText' has a wrong offset!");

// ScriptStruct Game.P2UIUseCaseDisplayDataRow
// 0x0030 (0x0038 - 0x0008)
struct FP2UIUseCaseDisplayDataRow final : public FTableRowBase
{
public:
	struct FGameplayTag                           UseCaseTag;                                        // 0x0008(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FText                                   DisplayText;                                       // 0x0010(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FLinearColor                           UseCaseBgColor;                                    // 0x0028(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FP2UIUseCaseDisplayDataRow) == 0x000008, "Wrong alignment on FP2UIUseCaseDisplayDataRow");
static_assert(sizeof(FP2UIUseCaseDisplayDataRow) == 0x000038, "Wrong size on FP2UIUseCaseDisplayDataRow");
static_assert(offsetof(FP2UIUseCaseDisplayDataRow, UseCaseTag) == 0x000008, "Member 'FP2UIUseCaseDisplayDataRow::UseCaseTag' has a wrong offset!");
static_assert(offsetof(FP2UIUseCaseDisplayDataRow, DisplayText) == 0x000010, "Member 'FP2UIUseCaseDisplayDataRow::DisplayText' has a wrong offset!");
static_assert(offsetof(FP2UIUseCaseDisplayDataRow, UseCaseBgColor) == 0x000028, "Member 'FP2UIUseCaseDisplayDataRow::UseCaseBgColor' has a wrong offset!");

// ScriptStruct Game.P2LoadoutCheckDisplayDataRow
// 0x0020 (0x0028 - 0x0008)
struct FP2LoadoutCheckDisplayDataRow final : public FTableRowBase
{
public:
	struct FGameplayTag                           LoadoutTag;                                        // 0x0008(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FText                                   DisplayText;                                       // 0x0010(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
};
static_assert(alignof(FP2LoadoutCheckDisplayDataRow) == 0x000008, "Wrong alignment on FP2LoadoutCheckDisplayDataRow");
static_assert(sizeof(FP2LoadoutCheckDisplayDataRow) == 0x000028, "Wrong size on FP2LoadoutCheckDisplayDataRow");
static_assert(offsetof(FP2LoadoutCheckDisplayDataRow, LoadoutTag) == 0x000008, "Member 'FP2LoadoutCheckDisplayDataRow::LoadoutTag' has a wrong offset!");
static_assert(offsetof(FP2LoadoutCheckDisplayDataRow, DisplayText) == 0x000010, "Member 'FP2LoadoutCheckDisplayDataRow::DisplayText' has a wrong offset!");

// ScriptStruct Game.P2KeyNameDataRow
// 0x0090 (0x0098 - 0x0008)
struct FP2KeyNameDataRow final : public FTableRowBase
{
public:
	struct FKey                                   Key;                                               // 0x0008(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FText                                   KeyName;                                           // 0x0020(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UTexture2D>              KeyTexture;                                        // 0x0038(0x0030)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UTexture2D>              KeyShadowTexture;                                  // 0x0068(0x0030)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FP2KeyNameDataRow) == 0x000008, "Wrong alignment on FP2KeyNameDataRow");
static_assert(sizeof(FP2KeyNameDataRow) == 0x000098, "Wrong size on FP2KeyNameDataRow");
static_assert(offsetof(FP2KeyNameDataRow, Key) == 0x000008, "Member 'FP2KeyNameDataRow::Key' has a wrong offset!");
static_assert(offsetof(FP2KeyNameDataRow, KeyName) == 0x000020, "Member 'FP2KeyNameDataRow::KeyName' has a wrong offset!");
static_assert(offsetof(FP2KeyNameDataRow, KeyTexture) == 0x000038, "Member 'FP2KeyNameDataRow::KeyTexture' has a wrong offset!");
static_assert(offsetof(FP2KeyNameDataRow, KeyShadowTexture) == 0x000068, "Member 'FP2KeyNameDataRow::KeyShadowTexture' has a wrong offset!");

// ScriptStruct Game.P2InputTriggerNameDataRow
// 0x0038 (0x0040 - 0x0008)
struct FP2InputTriggerNameDataRow final : public FTableRowBase
{
public:
	struct FSoftClassPath                         InputTriggerClass;                                 // 0x0008(0x0020)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FText                                   InputTriggerName;                                  // 0x0028(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
};
static_assert(alignof(FP2InputTriggerNameDataRow) == 0x000008, "Wrong alignment on FP2InputTriggerNameDataRow");
static_assert(sizeof(FP2InputTriggerNameDataRow) == 0x000040, "Wrong size on FP2InputTriggerNameDataRow");
static_assert(offsetof(FP2InputTriggerNameDataRow, InputTriggerClass) == 0x000008, "Member 'FP2InputTriggerNameDataRow::InputTriggerClass' has a wrong offset!");
static_assert(offsetof(FP2InputTriggerNameDataRow, InputTriggerName) == 0x000028, "Member 'FP2InputTriggerNameDataRow::InputTriggerName' has a wrong offset!");

// ScriptStruct Game.NotificationMessageInfo
// 0x0018 (0x0018 - 0x0000)
struct alignas(0x08) FNotificationMessageInfo final
{
public:
	uint8                                         Pad_0[0x18];                                       // 0x0000(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FNotificationMessageInfo) == 0x000008, "Wrong alignment on FNotificationMessageInfo");
static_assert(sizeof(FNotificationMessageInfo) == 0x000018, "Wrong size on FNotificationMessageInfo");

// ScriptStruct Game.BindKeyInfo
// 0x0090 (0x0090 - 0x0000)
struct FBindKeyInfo final
{
public:
	class FText                                   KeyName;                                           // 0x0000(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	class FText                                   TxtInputEvent;                                     // 0x0018(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UTexture2D>              KeyTexture;                                        // 0x0030(0x0030)(Edit, BlueprintVisible, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UTexture2D>              KeyShadowTexture;                                  // 0x0060(0x0030)(Edit, BlueprintVisible, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FBindKeyInfo) == 0x000008, "Wrong alignment on FBindKeyInfo");
static_assert(sizeof(FBindKeyInfo) == 0x000090, "Wrong size on FBindKeyInfo");
static_assert(offsetof(FBindKeyInfo, KeyName) == 0x000000, "Member 'FBindKeyInfo::KeyName' has a wrong offset!");
static_assert(offsetof(FBindKeyInfo, TxtInputEvent) == 0x000018, "Member 'FBindKeyInfo::TxtInputEvent' has a wrong offset!");
static_assert(offsetof(FBindKeyInfo, KeyTexture) == 0x000030, "Member 'FBindKeyInfo::KeyTexture' has a wrong offset!");
static_assert(offsetof(FBindKeyInfo, KeyShadowTexture) == 0x000060, "Member 'FBindKeyInfo::KeyShadowTexture' has a wrong offset!");

// ScriptStruct Game.P2BaseStoreDataRow
// 0x0008 (0x00A0 - 0x0098)
struct FP2BaseStoreDataRow : public FP2ExchangeDataRow
{
public:
	int32                                         MaxStock;                                          // 0x0098(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         RestockTime;                                       // 0x009C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FP2BaseStoreDataRow) == 0x000008, "Wrong alignment on FP2BaseStoreDataRow");
static_assert(sizeof(FP2BaseStoreDataRow) == 0x0000A0, "Wrong size on FP2BaseStoreDataRow");
static_assert(offsetof(FP2BaseStoreDataRow, MaxStock) == 0x000098, "Member 'FP2BaseStoreDataRow::MaxStock' has a wrong offset!");
static_assert(offsetof(FP2BaseStoreDataRow, RestockTime) == 0x00009C, "Member 'FP2BaseStoreDataRow::RestockTime' has a wrong offset!");

// ScriptStruct Game.P2GeneralStoreDataRow
// 0x0038 (0x00D8 - 0x00A0)
struct FP2GeneralStoreDataRow final : public FP2BaseStoreDataRow
{
public:
	int32                                         RequiredLevel;                                     // 0x00A0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A4[0x4];                                       // 0x00A4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftObjectPtr<class UP2ResearchNodeData>     ResearchRequirement;                               // 0x00A8(0x0030)(Edit, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FP2GeneralStoreDataRow) == 0x000008, "Wrong alignment on FP2GeneralStoreDataRow");
static_assert(sizeof(FP2GeneralStoreDataRow) == 0x0000D8, "Wrong size on FP2GeneralStoreDataRow");
static_assert(offsetof(FP2GeneralStoreDataRow, RequiredLevel) == 0x0000A0, "Member 'FP2GeneralStoreDataRow::RequiredLevel' has a wrong offset!");
static_assert(offsetof(FP2GeneralStoreDataRow, ResearchRequirement) == 0x0000A8, "Member 'FP2GeneralStoreDataRow::ResearchRequirement' has a wrong offset!");

// ScriptStruct Game.P2FactionStoreDataRow
// 0x0040 (0x00E0 - 0x00A0)
struct FP2FactionStoreDataRow final : public FP2BaseStoreDataRow
{
public:
	struct FGameplayTag                           FactionTag;                                        // 0x00A0(0x0008)(Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           RequiredFactionLevelTag;                           // 0x00A8(0x0008)(Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UP2ResearchNodeData>     ResearchRequirement;                               // 0x00B0(0x0030)(Edit, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FP2FactionStoreDataRow) == 0x000008, "Wrong alignment on FP2FactionStoreDataRow");
static_assert(sizeof(FP2FactionStoreDataRow) == 0x0000E0, "Wrong size on FP2FactionStoreDataRow");
static_assert(offsetof(FP2FactionStoreDataRow, FactionTag) == 0x0000A0, "Member 'FP2FactionStoreDataRow::FactionTag' has a wrong offset!");
static_assert(offsetof(FP2FactionStoreDataRow, RequiredFactionLevelTag) == 0x0000A8, "Member 'FP2FactionStoreDataRow::RequiredFactionLevelTag' has a wrong offset!");
static_assert(offsetof(FP2FactionStoreDataRow, ResearchRequirement) == 0x0000B0, "Member 'FP2FactionStoreDataRow::ResearchRequirement' has a wrong offset!");

// ScriptStruct Game.P2WeaponObstructionConfig
// 0x0200 (0x0200 - 0x0000)
struct FP2WeaponObstructionConfig final
{
public:
	float                                         WeaponOriginDistance;                              // 0x0000(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UP2TransformCurve*                      OriginStartPitchCurve;                             // 0x0008(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UP2TransformCurve*                      OriginStartPitchCurve_ADS;                         // 0x0010(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         WeaponLength;                                      // 0x0018(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         WeaponPullbackDistance;                            // 0x001C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FTransform                             StaticAdditiveTM;                                  // 0x0020(0x0060)(Edit, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FTransform                             PullbackAdditiveTM;                                // 0x0080(0x0060)(Edit, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FP2Remap                               PullbackAdditiveTM_Remap;                          // 0x00E0(0x0028)(Edit, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
	struct FP2Remap                               PullbackDistanceRemap_FPP;                         // 0x0108(0x0028)(Edit, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
	float                                         ADS_PullbackScale_FPP;                             // 0x0130(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_134[0xC];                                      // 0x0134(0x000C)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             SoftObstructionTM_FPP;                             // 0x0140(0x0060)(Edit, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FTransform                             HardObstructionTM_FPP;                             // 0x01A0(0x0060)(Edit, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FP2WeaponObstructionConfig) == 0x000010, "Wrong alignment on FP2WeaponObstructionConfig");
static_assert(sizeof(FP2WeaponObstructionConfig) == 0x000200, "Wrong size on FP2WeaponObstructionConfig");
static_assert(offsetof(FP2WeaponObstructionConfig, WeaponOriginDistance) == 0x000000, "Member 'FP2WeaponObstructionConfig::WeaponOriginDistance' has a wrong offset!");
static_assert(offsetof(FP2WeaponObstructionConfig, OriginStartPitchCurve) == 0x000008, "Member 'FP2WeaponObstructionConfig::OriginStartPitchCurve' has a wrong offset!");
static_assert(offsetof(FP2WeaponObstructionConfig, OriginStartPitchCurve_ADS) == 0x000010, "Member 'FP2WeaponObstructionConfig::OriginStartPitchCurve_ADS' has a wrong offset!");
static_assert(offsetof(FP2WeaponObstructionConfig, WeaponLength) == 0x000018, "Member 'FP2WeaponObstructionConfig::WeaponLength' has a wrong offset!");
static_assert(offsetof(FP2WeaponObstructionConfig, WeaponPullbackDistance) == 0x00001C, "Member 'FP2WeaponObstructionConfig::WeaponPullbackDistance' has a wrong offset!");
static_assert(offsetof(FP2WeaponObstructionConfig, StaticAdditiveTM) == 0x000020, "Member 'FP2WeaponObstructionConfig::StaticAdditiveTM' has a wrong offset!");
static_assert(offsetof(FP2WeaponObstructionConfig, PullbackAdditiveTM) == 0x000080, "Member 'FP2WeaponObstructionConfig::PullbackAdditiveTM' has a wrong offset!");
static_assert(offsetof(FP2WeaponObstructionConfig, PullbackAdditiveTM_Remap) == 0x0000E0, "Member 'FP2WeaponObstructionConfig::PullbackAdditiveTM_Remap' has a wrong offset!");
static_assert(offsetof(FP2WeaponObstructionConfig, PullbackDistanceRemap_FPP) == 0x000108, "Member 'FP2WeaponObstructionConfig::PullbackDistanceRemap_FPP' has a wrong offset!");
static_assert(offsetof(FP2WeaponObstructionConfig, ADS_PullbackScale_FPP) == 0x000130, "Member 'FP2WeaponObstructionConfig::ADS_PullbackScale_FPP' has a wrong offset!");
static_assert(offsetof(FP2WeaponObstructionConfig, SoftObstructionTM_FPP) == 0x000140, "Member 'FP2WeaponObstructionConfig::SoftObstructionTM_FPP' has a wrong offset!");
static_assert(offsetof(FP2WeaponObstructionConfig, HardObstructionTM_FPP) == 0x0001A0, "Member 'FP2WeaponObstructionConfig::HardObstructionTM_FPP' has a wrong offset!");

// ScriptStruct Game.PawnMovementOverrideConfig
// 0x0028 (0x0028 - 0x0000)
struct FPawnMovementOverrideConfig final
{
public:
	bool                                          bDisableVelocityRotation;                          // 0x0000(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bOverrideTrajectoryVelocity;                       // 0x0001(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2[0x6];                                        // 0x0002(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                TrajectoryVelocity;                                // 0x0008(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bZeroPastTrajectory;                               // 0x0020(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_21[0x7];                                       // 0x0021(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FPawnMovementOverrideConfig) == 0x000008, "Wrong alignment on FPawnMovementOverrideConfig");
static_assert(sizeof(FPawnMovementOverrideConfig) == 0x000028, "Wrong size on FPawnMovementOverrideConfig");
static_assert(offsetof(FPawnMovementOverrideConfig, bDisableVelocityRotation) == 0x000000, "Member 'FPawnMovementOverrideConfig::bDisableVelocityRotation' has a wrong offset!");
static_assert(offsetof(FPawnMovementOverrideConfig, bOverrideTrajectoryVelocity) == 0x000001, "Member 'FPawnMovementOverrideConfig::bOverrideTrajectoryVelocity' has a wrong offset!");
static_assert(offsetof(FPawnMovementOverrideConfig, TrajectoryVelocity) == 0x000008, "Member 'FPawnMovementOverrideConfig::TrajectoryVelocity' has a wrong offset!");
static_assert(offsetof(FPawnMovementOverrideConfig, bZeroPastTrajectory) == 0x000020, "Member 'FPawnMovementOverrideConfig::bZeroPastTrajectory' has a wrong offset!");

// ScriptStruct Game.P2UIColorData
// 0x001C (0x001C - 0x0000)
struct FP2UIColorData final
{
public:
	struct FSlateColor                            Color;                                             // 0x0000(0x0014)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	class FName                                   RichTextTagName;                                   // 0x0014(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FP2UIColorData) == 0x000004, "Wrong alignment on FP2UIColorData");
static_assert(sizeof(FP2UIColorData) == 0x00001C, "Wrong size on FP2UIColorData");
static_assert(offsetof(FP2UIColorData, Color) == 0x000000, "Member 'FP2UIColorData::Color' has a wrong offset!");
static_assert(offsetof(FP2UIColorData, RichTextTagName) == 0x000014, "Member 'FP2UIColorData::RichTextTagName' has a wrong offset!");

// ScriptStruct Game.P2ItemDurabilityColorData
// 0x0058 (0x0058 - 0x0000)
struct FP2ItemDurabilityColorData final
{
public:
	struct FGameplayTag                           ItemTag;                                           // 0x0000(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TMap<int32, struct FP2UIColorData>            DurabilityColorMap;                                // 0x0008(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
};
static_assert(alignof(FP2ItemDurabilityColorData) == 0x000008, "Wrong alignment on FP2ItemDurabilityColorData");
static_assert(sizeof(FP2ItemDurabilityColorData) == 0x000058, "Wrong size on FP2ItemDurabilityColorData");
static_assert(offsetof(FP2ItemDurabilityColorData, ItemTag) == 0x000000, "Member 'FP2ItemDurabilityColorData::ItemTag' has a wrong offset!");
static_assert(offsetof(FP2ItemDurabilityColorData, DurabilityColorMap) == 0x000008, "Member 'FP2ItemDurabilityColorData::DurabilityColorMap' has a wrong offset!");

// ScriptStruct Game.P2ItemStatChangeColorData
// 0x0038 (0x0038 - 0x0000)
struct FP2ItemStatChangeColorData final
{
public:
	struct FP2UIColorData                         PositiveColorData;                                 // 0x0000(0x001C)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FP2UIColorData                         NegativeColorData;                                 // 0x001C(0x001C)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
};
static_assert(alignof(FP2ItemStatChangeColorData) == 0x000004, "Wrong alignment on FP2ItemStatChangeColorData");
static_assert(sizeof(FP2ItemStatChangeColorData) == 0x000038, "Wrong size on FP2ItemStatChangeColorData");
static_assert(offsetof(FP2ItemStatChangeColorData, PositiveColorData) == 0x000000, "Member 'FP2ItemStatChangeColorData::PositiveColorData' has a wrong offset!");
static_assert(offsetof(FP2ItemStatChangeColorData, NegativeColorData) == 0x00001C, "Member 'FP2ItemStatChangeColorData::NegativeColorData' has a wrong offset!");

// ScriptStruct Game.P2NetworkPingWarningColorData
// 0x0024 (0x0024 - 0x0000)
struct FP2NetworkPingWarningColorData final
{
public:
	int32                                         StateLevel;                                        // 0x0000(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           NetworkPingWarningBGColor;                         // 0x0004(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           NetworkPingWarningColor;                           // 0x0014(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FP2NetworkPingWarningColorData) == 0x000004, "Wrong alignment on FP2NetworkPingWarningColorData");
static_assert(sizeof(FP2NetworkPingWarningColorData) == 0x000024, "Wrong size on FP2NetworkPingWarningColorData");
static_assert(offsetof(FP2NetworkPingWarningColorData, StateLevel) == 0x000000, "Member 'FP2NetworkPingWarningColorData::StateLevel' has a wrong offset!");
static_assert(offsetof(FP2NetworkPingWarningColorData, NetworkPingWarningBGColor) == 0x000004, "Member 'FP2NetworkPingWarningColorData::NetworkPingWarningBGColor' has a wrong offset!");
static_assert(offsetof(FP2NetworkPingWarningColorData, NetworkPingWarningColor) == 0x000014, "Member 'FP2NetworkPingWarningColorData::NetworkPingWarningColor' has a wrong offset!");

// ScriptStruct Game.P2SplineMeshControlPointInfo
// 0x0060 (0x0060 - 0x0000)
struct FP2SplineMeshControlPointInfo final
{
public:
	struct FVector                                LocationStart;                                     // 0x0000(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                TangentStart;                                      // 0x0018(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                LocationEnd;                                       // 0x0030(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                TangentEnd;                                        // 0x0048(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FP2SplineMeshControlPointInfo) == 0x000008, "Wrong alignment on FP2SplineMeshControlPointInfo");
static_assert(sizeof(FP2SplineMeshControlPointInfo) == 0x000060, "Wrong size on FP2SplineMeshControlPointInfo");
static_assert(offsetof(FP2SplineMeshControlPointInfo, LocationStart) == 0x000000, "Member 'FP2SplineMeshControlPointInfo::LocationStart' has a wrong offset!");
static_assert(offsetof(FP2SplineMeshControlPointInfo, TangentStart) == 0x000018, "Member 'FP2SplineMeshControlPointInfo::TangentStart' has a wrong offset!");
static_assert(offsetof(FP2SplineMeshControlPointInfo, LocationEnd) == 0x000030, "Member 'FP2SplineMeshControlPointInfo::LocationEnd' has a wrong offset!");
static_assert(offsetof(FP2SplineMeshControlPointInfo, TangentEnd) == 0x000048, "Member 'FP2SplineMeshControlPointInfo::TangentEnd' has a wrong offset!");

// ScriptStruct Game.P2StatusStackInfo
// 0x0038 (0x0038 - 0x0000)
struct FP2StatusStackInfo final
{
public:
	TSoftObjectPtr<class UTexture2D>              EffectIcon;                                        // 0x0000(0x0030)(Edit, BlueprintVisible, BlueprintReadOnly, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Criteria;                                          // 0x0030(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_34[0x4];                                       // 0x0034(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FP2StatusStackInfo) == 0x000008, "Wrong alignment on FP2StatusStackInfo");
static_assert(sizeof(FP2StatusStackInfo) == 0x000038, "Wrong size on FP2StatusStackInfo");
static_assert(offsetof(FP2StatusStackInfo, EffectIcon) == 0x000000, "Member 'FP2StatusStackInfo::EffectIcon' has a wrong offset!");
static_assert(offsetof(FP2StatusStackInfo, Criteria) == 0x000030, "Member 'FP2StatusStackInfo::Criteria' has a wrong offset!");

// ScriptStruct Game.P2StatusUIInfo
// 0x0110 (0x0118 - 0x0008)
struct FP2StatusUIInfo final : public FTableRowBase
{
public:
	struct FGameplayTagContainer                  StatusEffectTagContainer;                          // 0x0008(0x0020)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FGameplayTag                           ConsumptionModeTypeTag;                            // 0x0028(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayAttribute                     AttributeToCheck;                                  // 0x0030(0x0038)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TMap<EP2StatusEffectAnimType, struct FP2StatusStackInfo> EffectIconInfos;                        // 0x0068(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	class UCurveFloat*                            EffectCurve;                                       // 0x00B8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EP2UIStatusEffectSeverityCriteria             SeveritySource;                                    // 0x00C0(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsBuff;                                           // 0x00C1(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsOnlyStatus;                                     // 0x00C2(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C3[0x1];                                       // 0x00C3(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         MinExposureLevel;                                  // 0x00C4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UTexture2D>              Icon;                                              // 0x00C8(0x0030)(Edit, BlueprintVisible, BlueprintReadOnly, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTagContainer                  SourceGameplayEffectTags;                          // 0x00F8(0x0020)(NativeAccessSpecifierPublic)
};
static_assert(alignof(FP2StatusUIInfo) == 0x000008, "Wrong alignment on FP2StatusUIInfo");
static_assert(sizeof(FP2StatusUIInfo) == 0x000118, "Wrong size on FP2StatusUIInfo");
static_assert(offsetof(FP2StatusUIInfo, StatusEffectTagContainer) == 0x000008, "Member 'FP2StatusUIInfo::StatusEffectTagContainer' has a wrong offset!");
static_assert(offsetof(FP2StatusUIInfo, ConsumptionModeTypeTag) == 0x000028, "Member 'FP2StatusUIInfo::ConsumptionModeTypeTag' has a wrong offset!");
static_assert(offsetof(FP2StatusUIInfo, AttributeToCheck) == 0x000030, "Member 'FP2StatusUIInfo::AttributeToCheck' has a wrong offset!");
static_assert(offsetof(FP2StatusUIInfo, EffectIconInfos) == 0x000068, "Member 'FP2StatusUIInfo::EffectIconInfos' has a wrong offset!");
static_assert(offsetof(FP2StatusUIInfo, EffectCurve) == 0x0000B8, "Member 'FP2StatusUIInfo::EffectCurve' has a wrong offset!");
static_assert(offsetof(FP2StatusUIInfo, SeveritySource) == 0x0000C0, "Member 'FP2StatusUIInfo::SeveritySource' has a wrong offset!");
static_assert(offsetof(FP2StatusUIInfo, bIsBuff) == 0x0000C1, "Member 'FP2StatusUIInfo::bIsBuff' has a wrong offset!");
static_assert(offsetof(FP2StatusUIInfo, bIsOnlyStatus) == 0x0000C2, "Member 'FP2StatusUIInfo::bIsOnlyStatus' has a wrong offset!");
static_assert(offsetof(FP2StatusUIInfo, MinExposureLevel) == 0x0000C4, "Member 'FP2StatusUIInfo::MinExposureLevel' has a wrong offset!");
static_assert(offsetof(FP2StatusUIInfo, Icon) == 0x0000C8, "Member 'FP2StatusUIInfo::Icon' has a wrong offset!");
static_assert(offsetof(FP2StatusUIInfo, SourceGameplayEffectTags) == 0x0000F8, "Member 'FP2StatusUIInfo::SourceGameplayEffectTags' has a wrong offset!");

// ScriptStruct Game.P2InjuryStatusEffectInfo
// 0x0028 (0x0028 - 0x0000)
struct FP2InjuryStatusEffectInfo final
{
public:
	class FName                                   MatrialParamName;                                  // 0x0000(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTagContainer                  InjuryGameplayTags;                                // 0x0008(0x0020)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
};
static_assert(alignof(FP2InjuryStatusEffectInfo) == 0x000008, "Wrong alignment on FP2InjuryStatusEffectInfo");
static_assert(sizeof(FP2InjuryStatusEffectInfo) == 0x000028, "Wrong size on FP2InjuryStatusEffectInfo");
static_assert(offsetof(FP2InjuryStatusEffectInfo, MatrialParamName) == 0x000000, "Member 'FP2InjuryStatusEffectInfo::MatrialParamName' has a wrong offset!");
static_assert(offsetof(FP2InjuryStatusEffectInfo, InjuryGameplayTags) == 0x000008, "Member 'FP2InjuryStatusEffectInfo::InjuryGameplayTags' has a wrong offset!");

// ScriptStruct Game.P2ValueAndScale
// 0x0018 (0x0018 - 0x0000)
struct FP2ValueAndScale final
{
public:
	float                                         Value;                                             // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector2D                              ScaleRange;                                        // 0x0008(0x0010)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FP2ValueAndScale) == 0x000008, "Wrong alignment on FP2ValueAndScale");
static_assert(sizeof(FP2ValueAndScale) == 0x000018, "Wrong size on FP2ValueAndScale");
static_assert(offsetof(FP2ValueAndScale, Value) == 0x000000, "Member 'FP2ValueAndScale::Value' has a wrong offset!");
static_assert(offsetof(FP2ValueAndScale, ScaleRange) == 0x000008, "Member 'FP2ValueAndScale::ScaleRange' has a wrong offset!");

// ScriptStruct Game.P2RadialConfigDataRow
// 0x0038 (0x0040 - 0x0008)
struct FP2RadialConfigDataRow final : public FTableRowBase
{
public:
	int32                                         OptionIndex;                                       // 0x0008(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Priority;                                          // 0x000C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           ItemTag;                                           // 0x0010(0x0008)(Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTagContainer                  SubItemTags;                                       // 0x0018(0x0020)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	class UP2ItemData*                            ItemData;                                          // 0x0038(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FP2RadialConfigDataRow) == 0x000008, "Wrong alignment on FP2RadialConfigDataRow");
static_assert(sizeof(FP2RadialConfigDataRow) == 0x000040, "Wrong size on FP2RadialConfigDataRow");
static_assert(offsetof(FP2RadialConfigDataRow, OptionIndex) == 0x000008, "Member 'FP2RadialConfigDataRow::OptionIndex' has a wrong offset!");
static_assert(offsetof(FP2RadialConfigDataRow, Priority) == 0x00000C, "Member 'FP2RadialConfigDataRow::Priority' has a wrong offset!");
static_assert(offsetof(FP2RadialConfigDataRow, ItemTag) == 0x000010, "Member 'FP2RadialConfigDataRow::ItemTag' has a wrong offset!");
static_assert(offsetof(FP2RadialConfigDataRow, SubItemTags) == 0x000018, "Member 'FP2RadialConfigDataRow::SubItemTags' has a wrong offset!");
static_assert(offsetof(FP2RadialConfigDataRow, ItemData) == 0x000038, "Member 'FP2RadialConfigDataRow::ItemData' has a wrong offset!");

// ScriptStruct Game.P2RadialUIItemDataInfo
// 0x0018 (0x0018 - 0x0000)
struct FP2RadialUIItemDataInfo final
{
public:
	TArray<struct FP2RadialUIItemDataByPriolity>  ItemDatas;                                         // 0x0000(0x0010)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	int32                                         SelectIndex;                                       // 0x0010(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FP2RadialUIItemDataInfo) == 0x000008, "Wrong alignment on FP2RadialUIItemDataInfo");
static_assert(sizeof(FP2RadialUIItemDataInfo) == 0x000018, "Wrong size on FP2RadialUIItemDataInfo");
static_assert(offsetof(FP2RadialUIItemDataInfo, ItemDatas) == 0x000000, "Member 'FP2RadialUIItemDataInfo::ItemDatas' has a wrong offset!");
static_assert(offsetof(FP2RadialUIItemDataInfo, SelectIndex) == 0x000010, "Member 'FP2RadialUIItemDataInfo::SelectIndex' has a wrong offset!");

// ScriptStruct Game.P2RadialUIItemDataByOption
// 0x0050 (0x0050 - 0x0000)
struct FP2RadialUIItemDataByOption final
{
public:
	TMap<int32, struct FP2RadialUIItemDataInfo>   ItemDatasByPriolity;                               // 0x0000(0x0050)(Edit, BlueprintVisible, DisableEditOnInstance, NativeAccessSpecifierPublic)
};
static_assert(alignof(FP2RadialUIItemDataByOption) == 0x000008, "Wrong alignment on FP2RadialUIItemDataByOption");
static_assert(sizeof(FP2RadialUIItemDataByOption) == 0x000050, "Wrong size on FP2RadialUIItemDataByOption");
static_assert(offsetof(FP2RadialUIItemDataByOption, ItemDatasByPriolity) == 0x000000, "Member 'FP2RadialUIItemDataByOption::ItemDatasByPriolity' has a wrong offset!");

// ScriptStruct Game.P2GripAnimationData
// 0x0040 (0x0040 - 0x0000)
struct FP2GripAnimationData final
{
public:
	class UAnimSequence*                          Aim;                                               // 0x0000(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          Combat;                                            // 0x0008(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          Relaxed;                                           // 0x0010(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          CombatToAim;                                       // 0x0018(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          CombatToRelaxed;                                   // 0x0020(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          RelaxedToCombat;                                   // 0x0028(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          RelaxedToAim;                                      // 0x0030(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          AimToCombat;                                       // 0x0038(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FP2GripAnimationData) == 0x000008, "Wrong alignment on FP2GripAnimationData");
static_assert(sizeof(FP2GripAnimationData) == 0x000040, "Wrong size on FP2GripAnimationData");
static_assert(offsetof(FP2GripAnimationData, Aim) == 0x000000, "Member 'FP2GripAnimationData::Aim' has a wrong offset!");
static_assert(offsetof(FP2GripAnimationData, Combat) == 0x000008, "Member 'FP2GripAnimationData::Combat' has a wrong offset!");
static_assert(offsetof(FP2GripAnimationData, Relaxed) == 0x000010, "Member 'FP2GripAnimationData::Relaxed' has a wrong offset!");
static_assert(offsetof(FP2GripAnimationData, CombatToAim) == 0x000018, "Member 'FP2GripAnimationData::CombatToAim' has a wrong offset!");
static_assert(offsetof(FP2GripAnimationData, CombatToRelaxed) == 0x000020, "Member 'FP2GripAnimationData::CombatToRelaxed' has a wrong offset!");
static_assert(offsetof(FP2GripAnimationData, RelaxedToCombat) == 0x000028, "Member 'FP2GripAnimationData::RelaxedToCombat' has a wrong offset!");
static_assert(offsetof(FP2GripAnimationData, RelaxedToAim) == 0x000030, "Member 'FP2GripAnimationData::RelaxedToAim' has a wrong offset!");
static_assert(offsetof(FP2GripAnimationData, AimToCombat) == 0x000038, "Member 'FP2GripAnimationData::AimToCombat' has a wrong offset!");

// ScriptStruct Game.P2AssetCharacter
// 0x0018 (0x0048 - 0x0030)
struct FP2AssetCharacter final : public FP2AssetBase
{
public:
	class FString                                 Text;                                              // 0x0030(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   SlotName;                                          // 0x0040(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FP2AssetCharacter) == 0x000008, "Wrong alignment on FP2AssetCharacter");
static_assert(sizeof(FP2AssetCharacter) == 0x000048, "Wrong size on FP2AssetCharacter");
static_assert(offsetof(FP2AssetCharacter, Text) == 0x000030, "Member 'FP2AssetCharacter::Text' has a wrong offset!");
static_assert(offsetof(FP2AssetCharacter, SlotName) == 0x000040, "Member 'FP2AssetCharacter::SlotName' has a wrong offset!");

// ScriptStruct Game.P2CSOCharacterData
// 0x0048 (0x0050 - 0x0008)
struct FP2CSOCharacterData final : public FTableRowBase
{
public:
	struct FP2AssetCharacter                      AssetCharacter;                                    // 0x0008(0x0048)(Edit, NoClear, NativeAccessSpecifierPublic)
};
static_assert(alignof(FP2CSOCharacterData) == 0x000008, "Wrong alignment on FP2CSOCharacterData");
static_assert(sizeof(FP2CSOCharacterData) == 0x000050, "Wrong size on FP2CSOCharacterData");
static_assert(offsetof(FP2CSOCharacterData, AssetCharacter) == 0x000008, "Member 'FP2CSOCharacterData::AssetCharacter' has a wrong offset!");

// ScriptStruct Game.P2HealthHudInfos
// 0x0050 (0x0050 - 0x0000)
struct FP2HealthHudInfos final
{
public:
	TMap<EP2HealthHUDStatus, struct FP2HealthHudInfo> HealthHudInfos;                                // 0x0000(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
};
static_assert(alignof(FP2HealthHudInfos) == 0x000008, "Wrong alignment on FP2HealthHudInfos");
static_assert(sizeof(FP2HealthHudInfos) == 0x000050, "Wrong size on FP2HealthHudInfos");
static_assert(offsetof(FP2HealthHudInfos, HealthHudInfos) == 0x000000, "Member 'FP2HealthHudInfos::HealthHudInfos' has a wrong offset!");

// ScriptStruct Game.P2MovementOverrideParameters
// 0x0020 (0x0020 - 0x0000)
struct FP2MovementOverrideParameters final
{
public:
	float                                         MaxAccel;                                          // 0x0000(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxSpeed;                                          // 0x0004(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxSpeed_F;                                        // 0x0008(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxSpeed_R;                                        // 0x000C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCurveFloat*                            SpeedToFrictionCurve;                              // 0x0010(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCurveFloat*                            SpeedToBrakingDecelerationCurve;                   // 0x0018(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FP2MovementOverrideParameters) == 0x000008, "Wrong alignment on FP2MovementOverrideParameters");
static_assert(sizeof(FP2MovementOverrideParameters) == 0x000020, "Wrong size on FP2MovementOverrideParameters");
static_assert(offsetof(FP2MovementOverrideParameters, MaxAccel) == 0x000000, "Member 'FP2MovementOverrideParameters::MaxAccel' has a wrong offset!");
static_assert(offsetof(FP2MovementOverrideParameters, MaxSpeed) == 0x000004, "Member 'FP2MovementOverrideParameters::MaxSpeed' has a wrong offset!");
static_assert(offsetof(FP2MovementOverrideParameters, MaxSpeed_F) == 0x000008, "Member 'FP2MovementOverrideParameters::MaxSpeed_F' has a wrong offset!");
static_assert(offsetof(FP2MovementOverrideParameters, MaxSpeed_R) == 0x00000C, "Member 'FP2MovementOverrideParameters::MaxSpeed_R' has a wrong offset!");
static_assert(offsetof(FP2MovementOverrideParameters, SpeedToFrictionCurve) == 0x000010, "Member 'FP2MovementOverrideParameters::SpeedToFrictionCurve' has a wrong offset!");
static_assert(offsetof(FP2MovementOverrideParameters, SpeedToBrakingDecelerationCurve) == 0x000018, "Member 'FP2MovementOverrideParameters::SpeedToBrakingDecelerationCurve' has a wrong offset!");

// ScriptStruct Game.P2TableRow
// 0x0010 (0x0010 - 0x0000)
struct alignas(0x08) FP2TableRow final
{
public:
	uint8                                         Pad_0[0x10];                                       // 0x0000(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FP2TableRow) == 0x000008, "Wrong alignment on FP2TableRow");
static_assert(sizeof(FP2TableRow) == 0x000010, "Wrong size on FP2TableRow");

// ScriptStruct Game.P2CompassDegreeDataRow
// 0x0020 (0x0028 - 0x0008)
struct FP2CompassDegreeDataRow final : public FTableRowBase
{
public:
	float                                         MinDegree;                                         // 0x0008(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxDegree;                                         // 0x000C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FText                                   TxtDegree;                                         // 0x0010(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
};
static_assert(alignof(FP2CompassDegreeDataRow) == 0x000008, "Wrong alignment on FP2CompassDegreeDataRow");
static_assert(sizeof(FP2CompassDegreeDataRow) == 0x000028, "Wrong size on FP2CompassDegreeDataRow");
static_assert(offsetof(FP2CompassDegreeDataRow, MinDegree) == 0x000008, "Member 'FP2CompassDegreeDataRow::MinDegree' has a wrong offset!");
static_assert(offsetof(FP2CompassDegreeDataRow, MaxDegree) == 0x00000C, "Member 'FP2CompassDegreeDataRow::MaxDegree' has a wrong offset!");
static_assert(offsetof(FP2CompassDegreeDataRow, TxtDegree) == 0x000010, "Member 'FP2CompassDegreeDataRow::TxtDegree' has a wrong offset!");

// ScriptStruct Game.P2DisplayCategoryPriorityRow
// 0x0040 (0x0048 - 0x0008)
struct FP2DisplayCategoryPriorityRow final : public FTableRowBase
{
public:
	struct FGameplayTagContainer                  DisplayCategoryTag;                                // 0x0008(0x0020)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	TArray<struct FGameplayTag>                   PrimaryPriorityTags;                               // 0x0028(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FGameplayTag>                   SecondaryPriorityTags;                             // 0x0038(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FP2DisplayCategoryPriorityRow) == 0x000008, "Wrong alignment on FP2DisplayCategoryPriorityRow");
static_assert(sizeof(FP2DisplayCategoryPriorityRow) == 0x000048, "Wrong size on FP2DisplayCategoryPriorityRow");
static_assert(offsetof(FP2DisplayCategoryPriorityRow, DisplayCategoryTag) == 0x000008, "Member 'FP2DisplayCategoryPriorityRow::DisplayCategoryTag' has a wrong offset!");
static_assert(offsetof(FP2DisplayCategoryPriorityRow, PrimaryPriorityTags) == 0x000028, "Member 'FP2DisplayCategoryPriorityRow::PrimaryPriorityTags' has a wrong offset!");
static_assert(offsetof(FP2DisplayCategoryPriorityRow, SecondaryPriorityTags) == 0x000038, "Member 'FP2DisplayCategoryPriorityRow::SecondaryPriorityTags' has a wrong offset!");

// ScriptStruct Game.P2CameraState
// 0x0070 (0x0070 - 0x0000)
struct FP2CameraState final
{
public:
	struct FTransform                             Transform;                                         // 0x0000(0x0060)(Edit, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FocusDistance;                                     // 0x0060(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FOV;                                               // 0x0064(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_68[0x8];                                       // 0x0068(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FP2CameraState) == 0x000010, "Wrong alignment on FP2CameraState");
static_assert(sizeof(FP2CameraState) == 0x000070, "Wrong size on FP2CameraState");
static_assert(offsetof(FP2CameraState, Transform) == 0x000000, "Member 'FP2CameraState::Transform' has a wrong offset!");
static_assert(offsetof(FP2CameraState, FocusDistance) == 0x000060, "Member 'FP2CameraState::FocusDistance' has a wrong offset!");
static_assert(offsetof(FP2CameraState, FOV) == 0x000064, "Member 'FP2CameraState::FOV' has a wrong offset!");

// ScriptStruct Game.P2WidgetCategorySubMenuData
// 0x0040 (0x0040 - 0x0000)
struct FP2WidgetCategorySubMenuData final
{
public:
	struct FGameplayTagContainer                  Tags;                                              // 0x0000(0x0020)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	class FText                                   DisplayName;                                       // 0x0020(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	bool                                          IsWishlist;                                        // 0x0038(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_39[0x3];                                       // 0x0039(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         Count;                                             // 0x003C(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FP2WidgetCategorySubMenuData) == 0x000008, "Wrong alignment on FP2WidgetCategorySubMenuData");
static_assert(sizeof(FP2WidgetCategorySubMenuData) == 0x000040, "Wrong size on FP2WidgetCategorySubMenuData");
static_assert(offsetof(FP2WidgetCategorySubMenuData, Tags) == 0x000000, "Member 'FP2WidgetCategorySubMenuData::Tags' has a wrong offset!");
static_assert(offsetof(FP2WidgetCategorySubMenuData, DisplayName) == 0x000020, "Member 'FP2WidgetCategorySubMenuData::DisplayName' has a wrong offset!");
static_assert(offsetof(FP2WidgetCategorySubMenuData, IsWishlist) == 0x000038, "Member 'FP2WidgetCategorySubMenuData::IsWishlist' has a wrong offset!");
static_assert(offsetof(FP2WidgetCategorySubMenuData, Count) == 0x00003C, "Member 'FP2WidgetCategorySubMenuData::Count' has a wrong offset!");

// ScriptStruct Game.P2WidgetCategoryMenuData
// 0x0050 (0x0050 - 0x0000)
struct FP2WidgetCategoryMenuData final
{
public:
	struct FP2WidgetCategorySubMenuData           MainCategory;                                      // 0x0000(0x0040)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TArray<struct FP2WidgetCategorySubMenuData>   SubCategories;                                     // 0x0040(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
};
static_assert(alignof(FP2WidgetCategoryMenuData) == 0x000008, "Wrong alignment on FP2WidgetCategoryMenuData");
static_assert(sizeof(FP2WidgetCategoryMenuData) == 0x000050, "Wrong size on FP2WidgetCategoryMenuData");
static_assert(offsetof(FP2WidgetCategoryMenuData, MainCategory) == 0x000000, "Member 'FP2WidgetCategoryMenuData::MainCategory' has a wrong offset!");
static_assert(offsetof(FP2WidgetCategoryMenuData, SubCategories) == 0x000040, "Member 'FP2WidgetCategoryMenuData::SubCategories' has a wrong offset!");

// ScriptStruct Game.P2UnlockTextInfo
// 0x0028 (0x0028 - 0x0000)
struct FP2UnlockTextInfo final
{
public:
	class FText                                   UnlockText;                                        // 0x0000(0x0018)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	bool                                          bUnlocked;                                         // 0x0018(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19[0x3];                                       // 0x0019(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         Level;                                             // 0x001C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EP2UnlockContentsType                         UnlockContentsType;                                // 0x0020(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_21[0x7];                                       // 0x0021(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FP2UnlockTextInfo) == 0x000008, "Wrong alignment on FP2UnlockTextInfo");
static_assert(sizeof(FP2UnlockTextInfo) == 0x000028, "Wrong size on FP2UnlockTextInfo");
static_assert(offsetof(FP2UnlockTextInfo, UnlockText) == 0x000000, "Member 'FP2UnlockTextInfo::UnlockText' has a wrong offset!");
static_assert(offsetof(FP2UnlockTextInfo, bUnlocked) == 0x000018, "Member 'FP2UnlockTextInfo::bUnlocked' has a wrong offset!");
static_assert(offsetof(FP2UnlockTextInfo, Level) == 0x00001C, "Member 'FP2UnlockTextInfo::Level' has a wrong offset!");
static_assert(offsetof(FP2UnlockTextInfo, UnlockContentsType) == 0x000020, "Member 'FP2UnlockTextInfo::UnlockContentsType' has a wrong offset!");

// ScriptStruct Game.P2PartyActionInfo
// 0x0040 (0x0040 - 0x0000)
struct FP2PartyActionInfo final
{
public:
	class UObject*                                Instigator;                                        // 0x0000(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EP2PartyAction                                PartyAction;                                       // 0x0008(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 Sender;                                            // 0x0010(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Receiver;                                          // 0x0020(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 ExtraMessage;                                      // 0x0030(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FP2PartyActionInfo) == 0x000008, "Wrong alignment on FP2PartyActionInfo");
static_assert(sizeof(FP2PartyActionInfo) == 0x000040, "Wrong size on FP2PartyActionInfo");
static_assert(offsetof(FP2PartyActionInfo, Instigator) == 0x000000, "Member 'FP2PartyActionInfo::Instigator' has a wrong offset!");
static_assert(offsetof(FP2PartyActionInfo, PartyAction) == 0x000008, "Member 'FP2PartyActionInfo::PartyAction' has a wrong offset!");
static_assert(offsetof(FP2PartyActionInfo, Sender) == 0x000010, "Member 'FP2PartyActionInfo::Sender' has a wrong offset!");
static_assert(offsetof(FP2PartyActionInfo, Receiver) == 0x000020, "Member 'FP2PartyActionInfo::Receiver' has a wrong offset!");
static_assert(offsetof(FP2PartyActionInfo, ExtraMessage) == 0x000030, "Member 'FP2PartyActionInfo::ExtraMessage' has a wrong offset!");

// ScriptStruct Game.P2SquadContextMenuData
// 0x0038 (0x0038 - 0x0000)
struct FP2SquadContextMenuData final
{
public:
	class FText                                   PlayerName;                                        // 0x0000(0x0018)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	int32                                         PlayerLevel;                                       // 0x0018(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         PlayerPing;                                        // 0x001C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         StateNum;                                          // 0x0020(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsSquadLeader;                                    // 0x0024(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_25[0x3];                                       // 0x0025(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         MemberIndex;                                       // 0x0028(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EP2SquadManagementPlayerWidgetState           WidgetState;                                       // 0x002C(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2D[0x3];                                       // 0x002D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         WidgetUIIndex;                                     // 0x0030(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          CanKickOrLeave;                                    // 0x0034(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_35[0x3];                                       // 0x0035(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FP2SquadContextMenuData) == 0x000008, "Wrong alignment on FP2SquadContextMenuData");
static_assert(sizeof(FP2SquadContextMenuData) == 0x000038, "Wrong size on FP2SquadContextMenuData");
static_assert(offsetof(FP2SquadContextMenuData, PlayerName) == 0x000000, "Member 'FP2SquadContextMenuData::PlayerName' has a wrong offset!");
static_assert(offsetof(FP2SquadContextMenuData, PlayerLevel) == 0x000018, "Member 'FP2SquadContextMenuData::PlayerLevel' has a wrong offset!");
static_assert(offsetof(FP2SquadContextMenuData, PlayerPing) == 0x00001C, "Member 'FP2SquadContextMenuData::PlayerPing' has a wrong offset!");
static_assert(offsetof(FP2SquadContextMenuData, StateNum) == 0x000020, "Member 'FP2SquadContextMenuData::StateNum' has a wrong offset!");
static_assert(offsetof(FP2SquadContextMenuData, bIsSquadLeader) == 0x000024, "Member 'FP2SquadContextMenuData::bIsSquadLeader' has a wrong offset!");
static_assert(offsetof(FP2SquadContextMenuData, MemberIndex) == 0x000028, "Member 'FP2SquadContextMenuData::MemberIndex' has a wrong offset!");
static_assert(offsetof(FP2SquadContextMenuData, WidgetState) == 0x00002C, "Member 'FP2SquadContextMenuData::WidgetState' has a wrong offset!");
static_assert(offsetof(FP2SquadContextMenuData, WidgetUIIndex) == 0x000030, "Member 'FP2SquadContextMenuData::WidgetUIIndex' has a wrong offset!");
static_assert(offsetof(FP2SquadContextMenuData, CanKickOrLeave) == 0x000034, "Member 'FP2SquadContextMenuData::CanKickOrLeave' has a wrong offset!");

// ScriptStruct Game.P2CurrentPlayingVocalSFX
// 0x0018 (0x0018 - 0x0000)
struct FP2CurrentPlayingVocalSFX final
{
public:
	class UAkAudioEvent*                          AudioEvent;                                        // 0x0000(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_8[0x10];                                       // 0x0008(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FP2CurrentPlayingVocalSFX) == 0x000008, "Wrong alignment on FP2CurrentPlayingVocalSFX");
static_assert(sizeof(FP2CurrentPlayingVocalSFX) == 0x000018, "Wrong size on FP2CurrentPlayingVocalSFX");
static_assert(offsetof(FP2CurrentPlayingVocalSFX, AudioEvent) == 0x000000, "Member 'FP2CurrentPlayingVocalSFX::AudioEvent' has a wrong offset!");

// ScriptStruct Game.P2VocalPlaybackData
// 0x0008 (0x0008 - 0x0000)
struct alignas(0x04) FP2VocalPlaybackData final
{
public:
	uint8                                         Pad_0[0x8];                                        // 0x0000(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FP2VocalPlaybackData) == 0x000004, "Wrong alignment on FP2VocalPlaybackData");
static_assert(sizeof(FP2VocalPlaybackData) == 0x000008, "Wrong size on FP2VocalPlaybackData");

// ScriptStruct Game.P2VolumetricEffectOffsetLayer
// 0x0040 (0x0040 - 0x0000)
struct FP2VolumetricEffectOffsetLayer final
{
public:
	EP2VolumetricOffsetTexture                    OffsetTexture;                                     // 0x0000(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         OverrideMipLevel;                                  // 0x0004(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_8[0x8];                                        // 0x0008(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector4f                              Multiplier;                                        // 0x0010(0x0010)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector3f                              Tiling;                                            // 0x0020(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector3f                              Movement;                                          // 0x002C(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PreviousOffsetStrength;                            // 0x0038(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3C[0x4];                                       // 0x003C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FP2VolumetricEffectOffsetLayer) == 0x000010, "Wrong alignment on FP2VolumetricEffectOffsetLayer");
static_assert(sizeof(FP2VolumetricEffectOffsetLayer) == 0x000040, "Wrong size on FP2VolumetricEffectOffsetLayer");
static_assert(offsetof(FP2VolumetricEffectOffsetLayer, OffsetTexture) == 0x000000, "Member 'FP2VolumetricEffectOffsetLayer::OffsetTexture' has a wrong offset!");
static_assert(offsetof(FP2VolumetricEffectOffsetLayer, OverrideMipLevel) == 0x000004, "Member 'FP2VolumetricEffectOffsetLayer::OverrideMipLevel' has a wrong offset!");
static_assert(offsetof(FP2VolumetricEffectOffsetLayer, Multiplier) == 0x000010, "Member 'FP2VolumetricEffectOffsetLayer::Multiplier' has a wrong offset!");
static_assert(offsetof(FP2VolumetricEffectOffsetLayer, Tiling) == 0x000020, "Member 'FP2VolumetricEffectOffsetLayer::Tiling' has a wrong offset!");
static_assert(offsetof(FP2VolumetricEffectOffsetLayer, Movement) == 0x00002C, "Member 'FP2VolumetricEffectOffsetLayer::Movement' has a wrong offset!");
static_assert(offsetof(FP2VolumetricEffectOffsetLayer, PreviousOffsetStrength) == 0x000038, "Member 'FP2VolumetricEffectOffsetLayer::PreviousOffsetStrength' has a wrong offset!");

// ScriptStruct Game.P2VolumetricEffectNoiseLayer
// 0x0044 (0x0044 - 0x0000)
struct FP2VolumetricEffectNoiseLayer final
{
public:
	EP2VolumetricNoiseTexture                     NoiseTexture;                                      // 0x0000(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         OverrideMipLevel;                                  // 0x0004(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           NoiseColor;                                        // 0x0008(0x0010)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector3f                              MultiplyAddMin;                                    // 0x0018(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector3f                              Tiling;                                            // 0x0024(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector3f                              Movement;                                          // 0x0030(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2f                              OffsetStrength;                                    // 0x003C(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FP2VolumetricEffectNoiseLayer) == 0x000004, "Wrong alignment on FP2VolumetricEffectNoiseLayer");
static_assert(sizeof(FP2VolumetricEffectNoiseLayer) == 0x000044, "Wrong size on FP2VolumetricEffectNoiseLayer");
static_assert(offsetof(FP2VolumetricEffectNoiseLayer, NoiseTexture) == 0x000000, "Member 'FP2VolumetricEffectNoiseLayer::NoiseTexture' has a wrong offset!");
static_assert(offsetof(FP2VolumetricEffectNoiseLayer, OverrideMipLevel) == 0x000004, "Member 'FP2VolumetricEffectNoiseLayer::OverrideMipLevel' has a wrong offset!");
static_assert(offsetof(FP2VolumetricEffectNoiseLayer, NoiseColor) == 0x000008, "Member 'FP2VolumetricEffectNoiseLayer::NoiseColor' has a wrong offset!");
static_assert(offsetof(FP2VolumetricEffectNoiseLayer, MultiplyAddMin) == 0x000018, "Member 'FP2VolumetricEffectNoiseLayer::MultiplyAddMin' has a wrong offset!");
static_assert(offsetof(FP2VolumetricEffectNoiseLayer, Tiling) == 0x000024, "Member 'FP2VolumetricEffectNoiseLayer::Tiling' has a wrong offset!");
static_assert(offsetof(FP2VolumetricEffectNoiseLayer, Movement) == 0x000030, "Member 'FP2VolumetricEffectNoiseLayer::Movement' has a wrong offset!");
static_assert(offsetof(FP2VolumetricEffectNoiseLayer, OffsetStrength) == 0x00003C, "Member 'FP2VolumetricEffectNoiseLayer::OffsetStrength' has a wrong offset!");

// ScriptStruct Game.P2VolumetricTexture
// 0x0038 (0x0038 - 0x0000)
struct FP2VolumetricTexture final
{
public:
	TSoftObjectPtr<class UTexture>                Texture;                                           // 0x0000(0x0030)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MipLevel;                                          // 0x0030(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_34[0x4];                                       // 0x0034(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FP2VolumetricTexture) == 0x000008, "Wrong alignment on FP2VolumetricTexture");
static_assert(sizeof(FP2VolumetricTexture) == 0x000038, "Wrong size on FP2VolumetricTexture");
static_assert(offsetof(FP2VolumetricTexture, Texture) == 0x000000, "Member 'FP2VolumetricTexture::Texture' has a wrong offset!");
static_assert(offsetof(FP2VolumetricTexture, MipLevel) == 0x000030, "Member 'FP2VolumetricTexture::MipLevel' has a wrong offset!");

// ScriptStruct Game.P2WeaponAmmoConfig
// 0x0030 (0x0030 - 0x0000)
struct FP2WeaponAmmoConfig final
{
public:
	class UCurveFloat*                            DamageOverDistance;                                // 0x0000(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCurveFloat*                            PenetrationOverDistance;                           // 0x0008(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MuzzleVelocityOverride;                            // 0x0010(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DamageOverride;                                    // 0x0014(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DamageToArmorOverride;                             // 0x0018(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PenetrationOverride;                               // 0x001C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         GravityScaleOverride;                              // 0x0020(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DragScaleOverride;                                 // 0x0024(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bOverrideMuzzleVelocity;                           // 0x0028(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bOverrideGravityScale;                             // 0x0029(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bOverrideDragScale;                                // 0x002A(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bOverrideDamage;                                   // 0x002B(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bOverrideDamageToArmor;                            // 0x002C(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bOverridePenetration;                              // 0x002D(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2E[0x2];                                       // 0x002E(0x0002)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FP2WeaponAmmoConfig) == 0x000008, "Wrong alignment on FP2WeaponAmmoConfig");
static_assert(sizeof(FP2WeaponAmmoConfig) == 0x000030, "Wrong size on FP2WeaponAmmoConfig");
static_assert(offsetof(FP2WeaponAmmoConfig, DamageOverDistance) == 0x000000, "Member 'FP2WeaponAmmoConfig::DamageOverDistance' has a wrong offset!");
static_assert(offsetof(FP2WeaponAmmoConfig, PenetrationOverDistance) == 0x000008, "Member 'FP2WeaponAmmoConfig::PenetrationOverDistance' has a wrong offset!");
static_assert(offsetof(FP2WeaponAmmoConfig, MuzzleVelocityOverride) == 0x000010, "Member 'FP2WeaponAmmoConfig::MuzzleVelocityOverride' has a wrong offset!");
static_assert(offsetof(FP2WeaponAmmoConfig, DamageOverride) == 0x000014, "Member 'FP2WeaponAmmoConfig::DamageOverride' has a wrong offset!");
static_assert(offsetof(FP2WeaponAmmoConfig, DamageToArmorOverride) == 0x000018, "Member 'FP2WeaponAmmoConfig::DamageToArmorOverride' has a wrong offset!");
static_assert(offsetof(FP2WeaponAmmoConfig, PenetrationOverride) == 0x00001C, "Member 'FP2WeaponAmmoConfig::PenetrationOverride' has a wrong offset!");
static_assert(offsetof(FP2WeaponAmmoConfig, GravityScaleOverride) == 0x000020, "Member 'FP2WeaponAmmoConfig::GravityScaleOverride' has a wrong offset!");
static_assert(offsetof(FP2WeaponAmmoConfig, DragScaleOverride) == 0x000024, "Member 'FP2WeaponAmmoConfig::DragScaleOverride' has a wrong offset!");
static_assert(offsetof(FP2WeaponAmmoConfig, bOverrideMuzzleVelocity) == 0x000028, "Member 'FP2WeaponAmmoConfig::bOverrideMuzzleVelocity' has a wrong offset!");
static_assert(offsetof(FP2WeaponAmmoConfig, bOverrideGravityScale) == 0x000029, "Member 'FP2WeaponAmmoConfig::bOverrideGravityScale' has a wrong offset!");
static_assert(offsetof(FP2WeaponAmmoConfig, bOverrideDragScale) == 0x00002A, "Member 'FP2WeaponAmmoConfig::bOverrideDragScale' has a wrong offset!");
static_assert(offsetof(FP2WeaponAmmoConfig, bOverrideDamage) == 0x00002B, "Member 'FP2WeaponAmmoConfig::bOverrideDamage' has a wrong offset!");
static_assert(offsetof(FP2WeaponAmmoConfig, bOverrideDamageToArmor) == 0x00002C, "Member 'FP2WeaponAmmoConfig::bOverrideDamageToArmor' has a wrong offset!");
static_assert(offsetof(FP2WeaponAmmoConfig, bOverridePenetration) == 0x00002D, "Member 'FP2WeaponAmmoConfig::bOverridePenetration' has a wrong offset!");

// ScriptStruct Game.P2MapPingMessage
// 0x0050 (0x0050 - 0x0000)
struct FP2MapPingMessage final
{
public:
	struct FVector2D                              MouseLocation;                                     // 0x0000(0x0010)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FKey                                   MouseKey;                                          // 0x0010(0x0018)(HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_28[0x10];                                      // 0x0028(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                WorldLocation;                                     // 0x0038(0x0018)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FP2MapPingMessage) == 0x000008, "Wrong alignment on FP2MapPingMessage");
static_assert(sizeof(FP2MapPingMessage) == 0x000050, "Wrong size on FP2MapPingMessage");
static_assert(offsetof(FP2MapPingMessage, MouseLocation) == 0x000000, "Member 'FP2MapPingMessage::MouseLocation' has a wrong offset!");
static_assert(offsetof(FP2MapPingMessage, MouseKey) == 0x000010, "Member 'FP2MapPingMessage::MouseKey' has a wrong offset!");
static_assert(offsetof(FP2MapPingMessage, WorldLocation) == 0x000038, "Member 'FP2MapPingMessage::WorldLocation' has a wrong offset!");

// ScriptStruct Game.CharacterWeaponRelatedState
// 0x0020 (0x0020 - 0x0000)
struct alignas(0x08) FCharacterWeaponRelatedState final
{
public:
	uint8                                         Pad_0[0x20];                                       // 0x0000(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FCharacterWeaponRelatedState) == 0x000008, "Wrong alignment on FCharacterWeaponRelatedState");
static_assert(sizeof(FCharacterWeaponRelatedState) == 0x000020, "Wrong size on FCharacterWeaponRelatedState");

// ScriptStruct Game.AnimSpringCustomInput
// 0x00A0 (0x00A0 - 0x0000)
struct FAnimSpringCustomInput final
{
public:
	bool                                          bOverrideRandomGeneration;                         // 0x0000(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                Location;                                          // 0x0008(0x0018)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                LocationVelocity;                                  // 0x0020(0x0018)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Rotation;                                          // 0x0038(0x0018)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                RotationVelocity;                                  // 0x0050(0x0018)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LocationSpringStiffness;                           // 0x0068(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LocationSpringDamping;                             // 0x006C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RotationSpringStiffness;                           // 0x0070(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RotationSpringDamping;                             // 0x0074(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_78[0x8];                                       // 0x0078(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FQuat                                  OrientationQuat;                                   // 0x0080(0x0020)(Edit, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAnimSpringCustomInput) == 0x000010, "Wrong alignment on FAnimSpringCustomInput");
static_assert(sizeof(FAnimSpringCustomInput) == 0x0000A0, "Wrong size on FAnimSpringCustomInput");
static_assert(offsetof(FAnimSpringCustomInput, bOverrideRandomGeneration) == 0x000000, "Member 'FAnimSpringCustomInput::bOverrideRandomGeneration' has a wrong offset!");
static_assert(offsetof(FAnimSpringCustomInput, Location) == 0x000008, "Member 'FAnimSpringCustomInput::Location' has a wrong offset!");
static_assert(offsetof(FAnimSpringCustomInput, LocationVelocity) == 0x000020, "Member 'FAnimSpringCustomInput::LocationVelocity' has a wrong offset!");
static_assert(offsetof(FAnimSpringCustomInput, Rotation) == 0x000038, "Member 'FAnimSpringCustomInput::Rotation' has a wrong offset!");
static_assert(offsetof(FAnimSpringCustomInput, RotationVelocity) == 0x000050, "Member 'FAnimSpringCustomInput::RotationVelocity' has a wrong offset!");
static_assert(offsetof(FAnimSpringCustomInput, LocationSpringStiffness) == 0x000068, "Member 'FAnimSpringCustomInput::LocationSpringStiffness' has a wrong offset!");
static_assert(offsetof(FAnimSpringCustomInput, LocationSpringDamping) == 0x00006C, "Member 'FAnimSpringCustomInput::LocationSpringDamping' has a wrong offset!");
static_assert(offsetof(FAnimSpringCustomInput, RotationSpringStiffness) == 0x000070, "Member 'FAnimSpringCustomInput::RotationSpringStiffness' has a wrong offset!");
static_assert(offsetof(FAnimSpringCustomInput, RotationSpringDamping) == 0x000074, "Member 'FAnimSpringCustomInput::RotationSpringDamping' has a wrong offset!");
static_assert(offsetof(FAnimSpringCustomInput, OrientationQuat) == 0x000080, "Member 'FAnimSpringCustomInput::OrientationQuat' has a wrong offset!");

// ScriptStruct Game.AnimSpringGroupConfig
// 0x001C (0x001C - 0x0000)
struct FAnimSpringGroupConfig final
{
public:
	struct FGameplayTag                           DomainTag;                                         // 0x0000(0x0008)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           GroupTag;                                          // 0x0008(0x0008)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           ModifierGroupTag;                                  // 0x0010(0x0008)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCanBeInterrupted;                                 // 0x0018(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bInterruptOwnGroup;                                // 0x0019(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1A[0x2];                                       // 0x001A(0x0002)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FAnimSpringGroupConfig) == 0x000004, "Wrong alignment on FAnimSpringGroupConfig");
static_assert(sizeof(FAnimSpringGroupConfig) == 0x00001C, "Wrong size on FAnimSpringGroupConfig");
static_assert(offsetof(FAnimSpringGroupConfig, DomainTag) == 0x000000, "Member 'FAnimSpringGroupConfig::DomainTag' has a wrong offset!");
static_assert(offsetof(FAnimSpringGroupConfig, GroupTag) == 0x000008, "Member 'FAnimSpringGroupConfig::GroupTag' has a wrong offset!");
static_assert(offsetof(FAnimSpringGroupConfig, ModifierGroupTag) == 0x000010, "Member 'FAnimSpringGroupConfig::ModifierGroupTag' has a wrong offset!");
static_assert(offsetof(FAnimSpringGroupConfig, bCanBeInterrupted) == 0x000018, "Member 'FAnimSpringGroupConfig::bCanBeInterrupted' has a wrong offset!");
static_assert(offsetof(FAnimSpringGroupConfig, bInterruptOwnGroup) == 0x000019, "Member 'FAnimSpringGroupConfig::bInterruptOwnGroup' has a wrong offset!");

// ScriptStruct Game.AnimSpringRandomAxisConfig
// 0x00B0 (0x00B0 - 0x0000)
struct FAnimSpringRandomAxisConfig final
{
public:
	struct FVector2D                              LocationRangeX;                                    // 0x0000(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          LocationRangeXRandomSign;                          // 0x0010(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x7];                                       // 0x0011(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector2D                              LocationRangeY;                                    // 0x0018(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          LocationRangeYRandomSign;                          // 0x0028(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_29[0x7];                                       // 0x0029(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector2D                              LocationRangeZ;                                    // 0x0030(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          LocationRangeZRandomSign;                          // 0x0040(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_41[0x7];                                       // 0x0041(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector2D                              RotationRangeRoll;                                 // 0x0048(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          RotationRangeRollRandomSign;                       // 0x0058(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_59[0x7];                                       // 0x0059(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector2D                              RotationRangePitch;                                // 0x0060(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          RotationRangePitchRandomSign;                      // 0x0070(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_71[0x7];                                       // 0x0071(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector2D                              RotationRangeYaw;                                  // 0x0078(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          RotationRangeYawRandomSign;                        // 0x0088(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUseRandomScales;                                  // 0x0089(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_8A[0x6];                                       // 0x008A(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector2D                              LocationScaleRange;                                // 0x0090(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              RotationScaleRange;                                // 0x00A0(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAnimSpringRandomAxisConfig) == 0x000008, "Wrong alignment on FAnimSpringRandomAxisConfig");
static_assert(sizeof(FAnimSpringRandomAxisConfig) == 0x0000B0, "Wrong size on FAnimSpringRandomAxisConfig");
static_assert(offsetof(FAnimSpringRandomAxisConfig, LocationRangeX) == 0x000000, "Member 'FAnimSpringRandomAxisConfig::LocationRangeX' has a wrong offset!");
static_assert(offsetof(FAnimSpringRandomAxisConfig, LocationRangeXRandomSign) == 0x000010, "Member 'FAnimSpringRandomAxisConfig::LocationRangeXRandomSign' has a wrong offset!");
static_assert(offsetof(FAnimSpringRandomAxisConfig, LocationRangeY) == 0x000018, "Member 'FAnimSpringRandomAxisConfig::LocationRangeY' has a wrong offset!");
static_assert(offsetof(FAnimSpringRandomAxisConfig, LocationRangeYRandomSign) == 0x000028, "Member 'FAnimSpringRandomAxisConfig::LocationRangeYRandomSign' has a wrong offset!");
static_assert(offsetof(FAnimSpringRandomAxisConfig, LocationRangeZ) == 0x000030, "Member 'FAnimSpringRandomAxisConfig::LocationRangeZ' has a wrong offset!");
static_assert(offsetof(FAnimSpringRandomAxisConfig, LocationRangeZRandomSign) == 0x000040, "Member 'FAnimSpringRandomAxisConfig::LocationRangeZRandomSign' has a wrong offset!");
static_assert(offsetof(FAnimSpringRandomAxisConfig, RotationRangeRoll) == 0x000048, "Member 'FAnimSpringRandomAxisConfig::RotationRangeRoll' has a wrong offset!");
static_assert(offsetof(FAnimSpringRandomAxisConfig, RotationRangeRollRandomSign) == 0x000058, "Member 'FAnimSpringRandomAxisConfig::RotationRangeRollRandomSign' has a wrong offset!");
static_assert(offsetof(FAnimSpringRandomAxisConfig, RotationRangePitch) == 0x000060, "Member 'FAnimSpringRandomAxisConfig::RotationRangePitch' has a wrong offset!");
static_assert(offsetof(FAnimSpringRandomAxisConfig, RotationRangePitchRandomSign) == 0x000070, "Member 'FAnimSpringRandomAxisConfig::RotationRangePitchRandomSign' has a wrong offset!");
static_assert(offsetof(FAnimSpringRandomAxisConfig, RotationRangeYaw) == 0x000078, "Member 'FAnimSpringRandomAxisConfig::RotationRangeYaw' has a wrong offset!");
static_assert(offsetof(FAnimSpringRandomAxisConfig, RotationRangeYawRandomSign) == 0x000088, "Member 'FAnimSpringRandomAxisConfig::RotationRangeYawRandomSign' has a wrong offset!");
static_assert(offsetof(FAnimSpringRandomAxisConfig, bUseRandomScales) == 0x000089, "Member 'FAnimSpringRandomAxisConfig::bUseRandomScales' has a wrong offset!");
static_assert(offsetof(FAnimSpringRandomAxisConfig, LocationScaleRange) == 0x000090, "Member 'FAnimSpringRandomAxisConfig::LocationScaleRange' has a wrong offset!");
static_assert(offsetof(FAnimSpringRandomAxisConfig, RotationScaleRange) == 0x0000A0, "Member 'FAnimSpringRandomAxisConfig::RotationScaleRange' has a wrong offset!");

// ScriptStruct Game.AnimSpringPhysicalConfig
// 0x0030 (0x0030 - 0x0000)
struct FAnimSpringPhysicalConfig final
{
public:
	struct FP2ValueAndScale                       StiffnessSetup;                                    // 0x0000(0x0018)(Edit, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
	struct FP2ValueAndScale                       DampingSetup;                                      // 0x0018(0x0018)(Edit, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAnimSpringPhysicalConfig) == 0x000008, "Wrong alignment on FAnimSpringPhysicalConfig");
static_assert(sizeof(FAnimSpringPhysicalConfig) == 0x000030, "Wrong size on FAnimSpringPhysicalConfig");
static_assert(offsetof(FAnimSpringPhysicalConfig, StiffnessSetup) == 0x000000, "Member 'FAnimSpringPhysicalConfig::StiffnessSetup' has a wrong offset!");
static_assert(offsetof(FAnimSpringPhysicalConfig, DampingSetup) == 0x000018, "Member 'FAnimSpringPhysicalConfig::DampingSetup' has a wrong offset!");

// ScriptStruct Game.AnimRecoilInstance
// 0x0058 (0x0058 - 0x0000)
struct FAnimRecoilInstance final
{
public:
	uint8                                         Pad_0[0x8];                                        // 0x0000(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UAnimRecoilSimData*                     SimData;                                           // 0x0008(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_10[0x48];                                      // 0x0010(0x0048)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FAnimRecoilInstance) == 0x000008, "Wrong alignment on FAnimRecoilInstance");
static_assert(sizeof(FAnimRecoilInstance) == 0x000058, "Wrong size on FAnimRecoilInstance");
static_assert(offsetof(FAnimRecoilInstance, SimData) == 0x000008, "Member 'FAnimRecoilInstance::SimData' has a wrong offset!");

// ScriptStruct Game.AnimSpringModifierConfig
// 0x0088 (0x0088 - 0x0000)
struct FAnimSpringModifierConfig final
{
public:
	struct FVector2D                              EffectAlphaScale;                                  // 0x0000(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              PlayRateScale;                                     // 0x0010(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                LocationScale_Low;                                 // 0x0020(0x0018)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                LocationScale_High;                                // 0x0038(0x0018)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                RotationScale_Low;                                 // 0x0050(0x0018)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                RotationScale_High;                                // 0x0068(0x0018)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUseExactAnimTime;                                 // 0x0080(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_81[0x7];                                       // 0x0081(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FAnimSpringModifierConfig) == 0x000008, "Wrong alignment on FAnimSpringModifierConfig");
static_assert(sizeof(FAnimSpringModifierConfig) == 0x000088, "Wrong size on FAnimSpringModifierConfig");
static_assert(offsetof(FAnimSpringModifierConfig, EffectAlphaScale) == 0x000000, "Member 'FAnimSpringModifierConfig::EffectAlphaScale' has a wrong offset!");
static_assert(offsetof(FAnimSpringModifierConfig, PlayRateScale) == 0x000010, "Member 'FAnimSpringModifierConfig::PlayRateScale' has a wrong offset!");
static_assert(offsetof(FAnimSpringModifierConfig, LocationScale_Low) == 0x000020, "Member 'FAnimSpringModifierConfig::LocationScale_Low' has a wrong offset!");
static_assert(offsetof(FAnimSpringModifierConfig, LocationScale_High) == 0x000038, "Member 'FAnimSpringModifierConfig::LocationScale_High' has a wrong offset!");
static_assert(offsetof(FAnimSpringModifierConfig, RotationScale_Low) == 0x000050, "Member 'FAnimSpringModifierConfig::RotationScale_Low' has a wrong offset!");
static_assert(offsetof(FAnimSpringModifierConfig, RotationScale_High) == 0x000068, "Member 'FAnimSpringModifierConfig::RotationScale_High' has a wrong offset!");
static_assert(offsetof(FAnimSpringModifierConfig, bUseExactAnimTime) == 0x000080, "Member 'FAnimSpringModifierConfig::bUseExactAnimTime' has a wrong offset!");

// ScriptStruct Game.AnimSpringModifierData
// 0x0080 (0x0080 - 0x0000)
struct alignas(0x08) FAnimSpringModifierData final
{
public:
	uint8                                         Pad_0[0x80];                                       // 0x0000(0x0080)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FAnimSpringModifierData) == 0x000008, "Wrong alignment on FAnimSpringModifierData");
static_assert(sizeof(FAnimSpringModifierData) == 0x000080, "Wrong size on FAnimSpringModifierData");

// ScriptStruct Game.AnimSpringModifierCollection
// 0x0050 (0x0050 - 0x0000)
struct alignas(0x08) FAnimSpringModifierCollection final
{
public:
	uint8                                         Pad_0[0x50];                                       // 0x0000(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FAnimSpringModifierCollection) == 0x000008, "Wrong alignment on FAnimSpringModifierCollection");
static_assert(sizeof(FAnimSpringModifierCollection) == 0x000050, "Wrong size on FAnimSpringModifierCollection");

// ScriptStruct Game.AnimSpringSimulator
// 0x0070 (0x0070 - 0x0000)
struct alignas(0x10) FAnimSpringSimulator final
{
public:
	uint8                                         Pad_0[0x70];                                       // 0x0000(0x0070)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FAnimSpringSimulator) == 0x000010, "Wrong alignment on FAnimSpringSimulator");
static_assert(sizeof(FAnimSpringSimulator) == 0x000070, "Wrong size on FAnimSpringSimulator");

// ScriptStruct Game.SwayTrackInstance
// 0x0030 (0x0030 - 0x0000)
struct FSwayTrackInstance final
{
public:
	struct FSwayTrackConfig                       Config;                                            // 0x0000(0x0020)(Transient, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_20[0x10];                                      // 0x0020(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FSwayTrackInstance) == 0x000008, "Wrong alignment on FSwayTrackInstance");
static_assert(sizeof(FSwayTrackInstance) == 0x000030, "Wrong size on FSwayTrackInstance");
static_assert(offsetof(FSwayTrackInstance, Config) == 0x000000, "Member 'FSwayTrackInstance::Config' has a wrong offset!");

// ScriptStruct Game.SwayProcessor
// 0x0028 (0x0028 - 0x0000)
struct FSwayProcessor final
{
public:
	class AActor*                                 Owner;                                             // 0x0000(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UWeaponSwayData*                        SwayDataRef;                                       // 0x0008(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FSwayTrackInstance>             SwayTrackInstances;                                // 0x0010(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPublic)
	uint8                                         Pad_20[0x8];                                       // 0x0020(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FSwayProcessor) == 0x000008, "Wrong alignment on FSwayProcessor");
static_assert(sizeof(FSwayProcessor) == 0x000028, "Wrong size on FSwayProcessor");
static_assert(offsetof(FSwayProcessor, Owner) == 0x000000, "Member 'FSwayProcessor::Owner' has a wrong offset!");
static_assert(offsetof(FSwayProcessor, SwayDataRef) == 0x000008, "Member 'FSwayProcessor::SwayDataRef' has a wrong offset!");
static_assert(offsetof(FSwayProcessor, SwayTrackInstances) == 0x000010, "Member 'FSwayProcessor::SwayTrackInstances' has a wrong offset!");

// ScriptStruct Game.RecoilStanceConfig
// 0x00C8 (0x00C8 - 0x0000)
struct FRecoilStanceConfig final
{
public:
	struct FVector2D                              BaseRecoilScale;                                   // 0x0000(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         StandstillThreshold;                               // 0x0010(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<EP2StanceSpeedIndexType, struct FVector2D> SpeedStepMap;                                    // 0x0018(0x0050)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TMap<EP2StanceSpeedIndexType, struct FVector2D> ADSSpeedStepMap;                                 // 0x0068(0x0050)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	uint8                                         Pad_B8[0x10];                                      // 0x00B8(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FRecoilStanceConfig) == 0x000008, "Wrong alignment on FRecoilStanceConfig");
static_assert(sizeof(FRecoilStanceConfig) == 0x0000C8, "Wrong size on FRecoilStanceConfig");
static_assert(offsetof(FRecoilStanceConfig, BaseRecoilScale) == 0x000000, "Member 'FRecoilStanceConfig::BaseRecoilScale' has a wrong offset!");
static_assert(offsetof(FRecoilStanceConfig, StandstillThreshold) == 0x000010, "Member 'FRecoilStanceConfig::StandstillThreshold' has a wrong offset!");
static_assert(offsetof(FRecoilStanceConfig, SpeedStepMap) == 0x000018, "Member 'FRecoilStanceConfig::SpeedStepMap' has a wrong offset!");
static_assert(offsetof(FRecoilStanceConfig, ADSSpeedStepMap) == 0x000068, "Member 'FRecoilStanceConfig::ADSSpeedStepMap' has a wrong offset!");

// ScriptStruct Game.ControlRecoilState
// 0x0038 (0x0038 - 0x0000)
struct alignas(0x08) FControlRecoilState final
{
public:
	uint8                                         Pad_0[0x38];                                       // 0x0000(0x0038)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FControlRecoilState) == 0x000008, "Wrong alignment on FControlRecoilState");
static_assert(sizeof(FControlRecoilState) == 0x000038, "Wrong size on FControlRecoilState");

// ScriptStruct Game.ControlRecoilContext
// 0x0018 (0x0018 - 0x0000)
struct FControlRecoilContext final
{
public:
	uint8                                         Pad_0[0x8];                                        // 0x0000(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UControlRecoilData*                     RecoilData;                                        // 0x0008(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UP2Weapon*                              Weapon;                                            // 0x0010(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FControlRecoilContext) == 0x000008, "Wrong alignment on FControlRecoilContext");
static_assert(sizeof(FControlRecoilContext) == 0x000018, "Wrong size on FControlRecoilContext");
static_assert(offsetof(FControlRecoilContext, RecoilData) == 0x000008, "Member 'FControlRecoilContext::RecoilData' has a wrong offset!");
static_assert(offsetof(FControlRecoilContext, Weapon) == 0x000010, "Member 'FControlRecoilContext::Weapon' has a wrong offset!");

// ScriptStruct Game.TextureBitmaskData
// 0x0040 (0x0040 - 0x0000)
struct FTextureBitmaskData final
{
public:
	class UTextureTranslationData*                TranslationData;                                   // 0x0000(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         TextureWidth;                                      // 0x0008(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         TextureHeight;                                     // 0x000C(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 DataTextureBase;                                   // 0x0010(0x0010)(Edit, ZeroConstructor, EditConst, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FDateTime                              DataGenerationDate;                                // 0x0020(0x0008)(Edit, ZeroConstructor, EditConst, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int64                                         DataSize;                                          // 0x0028(0x0008)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<uint8>                                 BitMaskArray;                                      // 0x0030(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTextureBitmaskData) == 0x000008, "Wrong alignment on FTextureBitmaskData");
static_assert(sizeof(FTextureBitmaskData) == 0x000040, "Wrong size on FTextureBitmaskData");
static_assert(offsetof(FTextureBitmaskData, TranslationData) == 0x000000, "Member 'FTextureBitmaskData::TranslationData' has a wrong offset!");
static_assert(offsetof(FTextureBitmaskData, TextureWidth) == 0x000008, "Member 'FTextureBitmaskData::TextureWidth' has a wrong offset!");
static_assert(offsetof(FTextureBitmaskData, TextureHeight) == 0x00000C, "Member 'FTextureBitmaskData::TextureHeight' has a wrong offset!");
static_assert(offsetof(FTextureBitmaskData, DataTextureBase) == 0x000010, "Member 'FTextureBitmaskData::DataTextureBase' has a wrong offset!");
static_assert(offsetof(FTextureBitmaskData, DataGenerationDate) == 0x000020, "Member 'FTextureBitmaskData::DataGenerationDate' has a wrong offset!");
static_assert(offsetof(FTextureBitmaskData, DataSize) == 0x000028, "Member 'FTextureBitmaskData::DataSize' has a wrong offset!");
static_assert(offsetof(FTextureBitmaskData, BitMaskArray) == 0x000030, "Member 'FTextureBitmaskData::BitMaskArray' has a wrong offset!");

// ScriptStruct Game.RuntimeTransformCurve
// 0x0308 (0x0308 - 0x0000)
struct FRuntimeTransformCurve final
{
public:
	struct FRichCurve                             VectorCurves[0x6];                                 // 0x0000(0x0080)(NativeAccessSpecifierPublic)
	class UP2TransformCurve*                      ExternalCurve;                                     // 0x0300(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRuntimeTransformCurve) == 0x000008, "Wrong alignment on FRuntimeTransformCurve");
static_assert(sizeof(FRuntimeTransformCurve) == 0x000308, "Wrong size on FRuntimeTransformCurve");
static_assert(offsetof(FRuntimeTransformCurve, VectorCurves) == 0x000000, "Member 'FRuntimeTransformCurve::VectorCurves' has a wrong offset!");
static_assert(offsetof(FRuntimeTransformCurve, ExternalCurve) == 0x000300, "Member 'FRuntimeTransformCurve::ExternalCurve' has a wrong offset!");

// ScriptStruct Game.WeaponInertiaConfig
// 0x01D8 (0x01D8 - 0x0000)
struct FWeaponInertiaConfig final
{
public:
	class UCurveFloat*                            YawRateToYawTargetCurve;                           // 0x0000(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCurveFloat*                            PitchRateToPitchTargetCurve;                       // 0x0008(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCurveFloat*                            YawRateToRollTargetCurve;                          // 0x0010(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCurveFloat*                            YawRateToLocationXCurve;                           // 0x0018(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCurveFloat*                            PitchRateToLocationYCurve;                         // 0x0020(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCurveFloat*                            YawAccelScaleCurve;                                // 0x0028(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCurveFloat*                            PitchAccelScaleCurve;                              // 0x0030(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FP2Remap                               YawRateToYawTargetRemap;                           // 0x0038(0x0028)(Edit, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
	struct FP2Remap                               PitchRateToPitchTargetRemap;                       // 0x0060(0x0028)(Edit, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
	struct FP2Remap                               YawRateToRollTargetRemap;                          // 0x0088(0x0028)(Edit, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
	float                                         LocationInterpSpeed;                               // 0x00B0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RotationInterpSpeed;                               // 0x00B4(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              LocationPerAxisSensitivity;                        // 0x00B8(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LocationSensitivityScale;                          // 0x00C8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RotationSensitivityScale;                          // 0x00CC(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                LocationOffsetClamp;                               // 0x00D0(0x0018)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               RotationOffsetClamp;                               // 0x00E8(0x0018)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FInertiaVelocityOffsetConfig           VelocityConfig;                                    // 0x0100(0x00A8)(Edit, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          bUseInertiaLocationSpring;                         // 0x01A8(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUseInertiaRotationSpring;                         // 0x01A9(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUseVelocitySpring;                                // 0x01AA(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1AB[0x1];                                      // 0x01AB(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         InertiaLocationSpringStiffness;                    // 0x01AC(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         InertiaLocationSpringDamping;                      // 0x01B0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         InertiaRotationSpringStiffness;                    // 0x01B4(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         InertiaRotationSpringDamping;                      // 0x01B8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1BC[0x4];                                      // 0x01BC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                InertiaPivot;                                      // 0x01C0(0x0018)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FWeaponInertiaConfig) == 0x000008, "Wrong alignment on FWeaponInertiaConfig");
static_assert(sizeof(FWeaponInertiaConfig) == 0x0001D8, "Wrong size on FWeaponInertiaConfig");
static_assert(offsetof(FWeaponInertiaConfig, YawRateToYawTargetCurve) == 0x000000, "Member 'FWeaponInertiaConfig::YawRateToYawTargetCurve' has a wrong offset!");
static_assert(offsetof(FWeaponInertiaConfig, PitchRateToPitchTargetCurve) == 0x000008, "Member 'FWeaponInertiaConfig::PitchRateToPitchTargetCurve' has a wrong offset!");
static_assert(offsetof(FWeaponInertiaConfig, YawRateToRollTargetCurve) == 0x000010, "Member 'FWeaponInertiaConfig::YawRateToRollTargetCurve' has a wrong offset!");
static_assert(offsetof(FWeaponInertiaConfig, YawRateToLocationXCurve) == 0x000018, "Member 'FWeaponInertiaConfig::YawRateToLocationXCurve' has a wrong offset!");
static_assert(offsetof(FWeaponInertiaConfig, PitchRateToLocationYCurve) == 0x000020, "Member 'FWeaponInertiaConfig::PitchRateToLocationYCurve' has a wrong offset!");
static_assert(offsetof(FWeaponInertiaConfig, YawAccelScaleCurve) == 0x000028, "Member 'FWeaponInertiaConfig::YawAccelScaleCurve' has a wrong offset!");
static_assert(offsetof(FWeaponInertiaConfig, PitchAccelScaleCurve) == 0x000030, "Member 'FWeaponInertiaConfig::PitchAccelScaleCurve' has a wrong offset!");
static_assert(offsetof(FWeaponInertiaConfig, YawRateToYawTargetRemap) == 0x000038, "Member 'FWeaponInertiaConfig::YawRateToYawTargetRemap' has a wrong offset!");
static_assert(offsetof(FWeaponInertiaConfig, PitchRateToPitchTargetRemap) == 0x000060, "Member 'FWeaponInertiaConfig::PitchRateToPitchTargetRemap' has a wrong offset!");
static_assert(offsetof(FWeaponInertiaConfig, YawRateToRollTargetRemap) == 0x000088, "Member 'FWeaponInertiaConfig::YawRateToRollTargetRemap' has a wrong offset!");
static_assert(offsetof(FWeaponInertiaConfig, LocationInterpSpeed) == 0x0000B0, "Member 'FWeaponInertiaConfig::LocationInterpSpeed' has a wrong offset!");
static_assert(offsetof(FWeaponInertiaConfig, RotationInterpSpeed) == 0x0000B4, "Member 'FWeaponInertiaConfig::RotationInterpSpeed' has a wrong offset!");
static_assert(offsetof(FWeaponInertiaConfig, LocationPerAxisSensitivity) == 0x0000B8, "Member 'FWeaponInertiaConfig::LocationPerAxisSensitivity' has a wrong offset!");
static_assert(offsetof(FWeaponInertiaConfig, LocationSensitivityScale) == 0x0000C8, "Member 'FWeaponInertiaConfig::LocationSensitivityScale' has a wrong offset!");
static_assert(offsetof(FWeaponInertiaConfig, RotationSensitivityScale) == 0x0000CC, "Member 'FWeaponInertiaConfig::RotationSensitivityScale' has a wrong offset!");
static_assert(offsetof(FWeaponInertiaConfig, LocationOffsetClamp) == 0x0000D0, "Member 'FWeaponInertiaConfig::LocationOffsetClamp' has a wrong offset!");
static_assert(offsetof(FWeaponInertiaConfig, RotationOffsetClamp) == 0x0000E8, "Member 'FWeaponInertiaConfig::RotationOffsetClamp' has a wrong offset!");
static_assert(offsetof(FWeaponInertiaConfig, VelocityConfig) == 0x000100, "Member 'FWeaponInertiaConfig::VelocityConfig' has a wrong offset!");
static_assert(offsetof(FWeaponInertiaConfig, bUseInertiaLocationSpring) == 0x0001A8, "Member 'FWeaponInertiaConfig::bUseInertiaLocationSpring' has a wrong offset!");
static_assert(offsetof(FWeaponInertiaConfig, bUseInertiaRotationSpring) == 0x0001A9, "Member 'FWeaponInertiaConfig::bUseInertiaRotationSpring' has a wrong offset!");
static_assert(offsetof(FWeaponInertiaConfig, bUseVelocitySpring) == 0x0001AA, "Member 'FWeaponInertiaConfig::bUseVelocitySpring' has a wrong offset!");
static_assert(offsetof(FWeaponInertiaConfig, InertiaLocationSpringStiffness) == 0x0001AC, "Member 'FWeaponInertiaConfig::InertiaLocationSpringStiffness' has a wrong offset!");
static_assert(offsetof(FWeaponInertiaConfig, InertiaLocationSpringDamping) == 0x0001B0, "Member 'FWeaponInertiaConfig::InertiaLocationSpringDamping' has a wrong offset!");
static_assert(offsetof(FWeaponInertiaConfig, InertiaRotationSpringStiffness) == 0x0001B4, "Member 'FWeaponInertiaConfig::InertiaRotationSpringStiffness' has a wrong offset!");
static_assert(offsetof(FWeaponInertiaConfig, InertiaRotationSpringDamping) == 0x0001B8, "Member 'FWeaponInertiaConfig::InertiaRotationSpringDamping' has a wrong offset!");
static_assert(offsetof(FWeaponInertiaConfig, InertiaPivot) == 0x0001C0, "Member 'FWeaponInertiaConfig::InertiaPivot' has a wrong offset!");

// ScriptStruct Game.WeaponInertiaState
// 0x0150 (0x0150 - 0x0000)
struct FWeaponInertiaState final
{
public:
	struct FVectorRK4SpringInterpolator           LocationSpring;                                    // 0x0000(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_8[0x58];                                       // 0x0008(0x0058)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVectorRK4SpringInterpolator           RotationSpring;                                    // 0x0060(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_68[0x58];                                      // 0x0068(0x0058)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVectorRK4SpringInterpolator           VelocitySpring;                                    // 0x00C0(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C8[0x58];                                      // 0x00C8(0x0058)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                LocationInterpTarget;                              // 0x0120(0x0018)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                RotationInterpTarget;                              // 0x0138(0x0018)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FWeaponInertiaState) == 0x000008, "Wrong alignment on FWeaponInertiaState");
static_assert(sizeof(FWeaponInertiaState) == 0x000150, "Wrong size on FWeaponInertiaState");
static_assert(offsetof(FWeaponInertiaState, LocationSpring) == 0x000000, "Member 'FWeaponInertiaState::LocationSpring' has a wrong offset!");
static_assert(offsetof(FWeaponInertiaState, RotationSpring) == 0x000060, "Member 'FWeaponInertiaState::RotationSpring' has a wrong offset!");
static_assert(offsetof(FWeaponInertiaState, VelocitySpring) == 0x0000C0, "Member 'FWeaponInertiaState::VelocitySpring' has a wrong offset!");
static_assert(offsetof(FWeaponInertiaState, LocationInterpTarget) == 0x000120, "Member 'FWeaponInertiaState::LocationInterpTarget' has a wrong offset!");
static_assert(offsetof(FWeaponInertiaState, RotationInterpTarget) == 0x000138, "Member 'FWeaponInertiaState::RotationInterpTarget' has a wrong offset!");

// ScriptStruct Game.WeaponFreeAimConfig
// 0x0018 (0x0018 - 0x0000)
struct FWeaponFreeAimConfig final
{
public:
	float                                         SensitivityScale;                                  // 0x0000(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RangeScale;                                        // 0x0004(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LocationScale;                                     // 0x0008(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LocationScaleX;                                    // 0x000C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LocationScaleY;                                    // 0x0010(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         InterpSpeed;                                       // 0x0014(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FWeaponFreeAimConfig) == 0x000004, "Wrong alignment on FWeaponFreeAimConfig");
static_assert(sizeof(FWeaponFreeAimConfig) == 0x000018, "Wrong size on FWeaponFreeAimConfig");
static_assert(offsetof(FWeaponFreeAimConfig, SensitivityScale) == 0x000000, "Member 'FWeaponFreeAimConfig::SensitivityScale' has a wrong offset!");
static_assert(offsetof(FWeaponFreeAimConfig, RangeScale) == 0x000004, "Member 'FWeaponFreeAimConfig::RangeScale' has a wrong offset!");
static_assert(offsetof(FWeaponFreeAimConfig, LocationScale) == 0x000008, "Member 'FWeaponFreeAimConfig::LocationScale' has a wrong offset!");
static_assert(offsetof(FWeaponFreeAimConfig, LocationScaleX) == 0x00000C, "Member 'FWeaponFreeAimConfig::LocationScaleX' has a wrong offset!");
static_assert(offsetof(FWeaponFreeAimConfig, LocationScaleY) == 0x000010, "Member 'FWeaponFreeAimConfig::LocationScaleY' has a wrong offset!");
static_assert(offsetof(FWeaponFreeAimConfig, InterpSpeed) == 0x000014, "Member 'FWeaponFreeAimConfig::InterpSpeed' has a wrong offset!");

// ScriptStruct Game.WeaponAnimConfig3P
// 0x0008 (0x0008 - 0x0000)
struct FWeaponAnimConfig3P final
{
public:
	TSubclassOf<class UAnimInstance>              AnimLayer;                                         // 0x0000(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FWeaponAnimConfig3P) == 0x000008, "Wrong alignment on FWeaponAnimConfig3P");
static_assert(sizeof(FWeaponAnimConfig3P) == 0x000008, "Wrong size on FWeaponAnimConfig3P");
static_assert(offsetof(FWeaponAnimConfig3P, AnimLayer) == 0x000000, "Member 'FWeaponAnimConfig3P::AnimLayer' has a wrong offset!");

// ScriptStruct Game.SpreadControlRecoilInfluenceConfig
// 0x0020 (0x0020 - 0x0000)
struct FSpreadControlRecoilInfluenceConfig final
{
public:
	bool                                          bUseControlRecoilOffset;                           // 0x0000(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         HorizontalRecoilScale;                             // 0x0004(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HorizontalRecoilMax;                               // 0x0008(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         VerticalRecoilScale;                               // 0x000C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         VerticalRecoilMax;                                 // 0x0010(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RecoveryScale;                                     // 0x0014(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RecoveryMax;                                       // 0x0018(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TotalVerticalScale;                                // 0x001C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSpreadControlRecoilInfluenceConfig) == 0x000004, "Wrong alignment on FSpreadControlRecoilInfluenceConfig");
static_assert(sizeof(FSpreadControlRecoilInfluenceConfig) == 0x000020, "Wrong size on FSpreadControlRecoilInfluenceConfig");
static_assert(offsetof(FSpreadControlRecoilInfluenceConfig, bUseControlRecoilOffset) == 0x000000, "Member 'FSpreadControlRecoilInfluenceConfig::bUseControlRecoilOffset' has a wrong offset!");
static_assert(offsetof(FSpreadControlRecoilInfluenceConfig, HorizontalRecoilScale) == 0x000004, "Member 'FSpreadControlRecoilInfluenceConfig::HorizontalRecoilScale' has a wrong offset!");
static_assert(offsetof(FSpreadControlRecoilInfluenceConfig, HorizontalRecoilMax) == 0x000008, "Member 'FSpreadControlRecoilInfluenceConfig::HorizontalRecoilMax' has a wrong offset!");
static_assert(offsetof(FSpreadControlRecoilInfluenceConfig, VerticalRecoilScale) == 0x00000C, "Member 'FSpreadControlRecoilInfluenceConfig::VerticalRecoilScale' has a wrong offset!");
static_assert(offsetof(FSpreadControlRecoilInfluenceConfig, VerticalRecoilMax) == 0x000010, "Member 'FSpreadControlRecoilInfluenceConfig::VerticalRecoilMax' has a wrong offset!");
static_assert(offsetof(FSpreadControlRecoilInfluenceConfig, RecoveryScale) == 0x000014, "Member 'FSpreadControlRecoilInfluenceConfig::RecoveryScale' has a wrong offset!");
static_assert(offsetof(FSpreadControlRecoilInfluenceConfig, RecoveryMax) == 0x000018, "Member 'FSpreadControlRecoilInfluenceConfig::RecoveryMax' has a wrong offset!");
static_assert(offsetof(FSpreadControlRecoilInfluenceConfig, TotalVerticalScale) == 0x00001C, "Member 'FSpreadControlRecoilInfluenceConfig::TotalVerticalScale' has a wrong offset!");

// ScriptStruct Game.SpreadStanceConfig
// 0x0028 (0x0028 - 0x0000)
struct FSpreadStanceConfig final
{
public:
	float                                         BaseSpreadScale;                                   // 0x0000(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector2D                              MovementSpreadMapIn;                               // 0x0008(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              MovementSpreadMapOut;                              // 0x0018(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSpreadStanceConfig) == 0x000008, "Wrong alignment on FSpreadStanceConfig");
static_assert(sizeof(FSpreadStanceConfig) == 0x000028, "Wrong size on FSpreadStanceConfig");
static_assert(offsetof(FSpreadStanceConfig, BaseSpreadScale) == 0x000000, "Member 'FSpreadStanceConfig::BaseSpreadScale' has a wrong offset!");
static_assert(offsetof(FSpreadStanceConfig, MovementSpreadMapIn) == 0x000008, "Member 'FSpreadStanceConfig::MovementSpreadMapIn' has a wrong offset!");
static_assert(offsetof(FSpreadStanceConfig, MovementSpreadMapOut) == 0x000018, "Member 'FSpreadStanceConfig::MovementSpreadMapOut' has a wrong offset!");

// ScriptStruct Game.SpreadAimStateConfig
// 0x0060 (0x0060 - 0x0000)
struct FSpreadAimStateConfig final
{
public:
	float                                         BaseSpread;                                        // 0x0000(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FiringSpreadScale;                                 // 0x0004(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TMap<struct FGameplayTag, struct FSpreadStanceConfig> StanceMap;                                 // 0x0008(0x0050)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	float                                         BaseInterpSpeed;                                   // 0x0058(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FiringInterpSpeed;                                 // 0x005C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSpreadAimStateConfig) == 0x000008, "Wrong alignment on FSpreadAimStateConfig");
static_assert(sizeof(FSpreadAimStateConfig) == 0x000060, "Wrong size on FSpreadAimStateConfig");
static_assert(offsetof(FSpreadAimStateConfig, BaseSpread) == 0x000000, "Member 'FSpreadAimStateConfig::BaseSpread' has a wrong offset!");
static_assert(offsetof(FSpreadAimStateConfig, FiringSpreadScale) == 0x000004, "Member 'FSpreadAimStateConfig::FiringSpreadScale' has a wrong offset!");
static_assert(offsetof(FSpreadAimStateConfig, StanceMap) == 0x000008, "Member 'FSpreadAimStateConfig::StanceMap' has a wrong offset!");
static_assert(offsetof(FSpreadAimStateConfig, BaseInterpSpeed) == 0x000058, "Member 'FSpreadAimStateConfig::BaseInterpSpeed' has a wrong offset!");
static_assert(offsetof(FSpreadAimStateConfig, FiringInterpSpeed) == 0x00005C, "Member 'FSpreadAimStateConfig::FiringInterpSpeed' has a wrong offset!");

// ScriptStruct Game.WeaponSpreadProcessor
// 0x0020 (0x0020 - 0x0000)
struct alignas(0x04) FWeaponSpreadProcessor final
{
public:
	uint8                                         Pad_0[0x20];                                       // 0x0000(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FWeaponSpreadProcessor) == 0x000004, "Wrong alignment on FWeaponSpreadProcessor");
static_assert(sizeof(FWeaponSpreadProcessor) == 0x000020, "Wrong size on FWeaponSpreadProcessor");

// ScriptStruct Game.AdaptiveLeanRepData
// 0x0020 (0x0020 - 0x0000)
struct FAdaptiveLeanRepData final
{
public:
	EAdaptiveLeanDirection                        LeanDirection;                                     // 0x0000(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                LeanOffset;                                        // 0x0008(0x0018)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAdaptiveLeanRepData) == 0x000008, "Wrong alignment on FAdaptiveLeanRepData");
static_assert(sizeof(FAdaptiveLeanRepData) == 0x000020, "Wrong size on FAdaptiveLeanRepData");
static_assert(offsetof(FAdaptiveLeanRepData, LeanDirection) == 0x000000, "Member 'FAdaptiveLeanRepData::LeanDirection' has a wrong offset!");
static_assert(offsetof(FAdaptiveLeanRepData, LeanOffset) == 0x000008, "Member 'FAdaptiveLeanRepData::LeanOffset' has a wrong offset!");

// ScriptStruct Game.AimDownSightContext
// 0x0140 (0x0140 - 0x0000)
struct alignas(0x10) FAimDownSightContext final
{
public:
	uint8                                         Pad_0[0x130];                                      // 0x0000(0x0130)(Fixing Size After Last Property [ Dumper-7 ])
	class UP2Weapon*                              Weapon;                                            // 0x0130(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_138[0x8];                                      // 0x0138(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FAimDownSightContext) == 0x000010, "Wrong alignment on FAimDownSightContext");
static_assert(sizeof(FAimDownSightContext) == 0x000140, "Wrong size on FAimDownSightContext");
static_assert(offsetof(FAimDownSightContext, Weapon) == 0x000130, "Member 'FAimDownSightContext::Weapon' has a wrong offset!");

// ScriptStruct Game.DbnoAimProcessor
// 0x000C (0x000C - 0x0000)
struct alignas(0x04) FDbnoAimProcessor final
{
public:
	uint8                                         Pad_0[0xC];                                        // 0x0000(0x000C)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FDbnoAimProcessor) == 0x000004, "Wrong alignment on FDbnoAimProcessor");
static_assert(sizeof(FDbnoAimProcessor) == 0x00000C, "Wrong size on FDbnoAimProcessor");

// ScriptStruct Game.WeaponInertiaSpringInput
// 0x000C (0x000C - 0x0000)
struct alignas(0x04) FWeaponInertiaSpringInput final
{
public:
	uint8                                         Pad_0[0xC];                                        // 0x0000(0x000C)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FWeaponInertiaSpringInput) == 0x000004, "Wrong alignment on FWeaponInertiaSpringInput");
static_assert(sizeof(FWeaponInertiaSpringInput) == 0x00000C, "Wrong size on FWeaponInertiaSpringInput");

// ScriptStruct Game.WeaponInertiaProcessor
// 0x03C0 (0x03C0 - 0x0000)
struct alignas(0x08) FWeaponInertiaProcessor final
{
public:
	uint8                                         Pad_0[0x3C0];                                      // 0x0000(0x03C0)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FWeaponInertiaProcessor) == 0x000008, "Wrong alignment on FWeaponInertiaProcessor");
static_assert(sizeof(FWeaponInertiaProcessor) == 0x0003C0, "Wrong size on FWeaponInertiaProcessor");

// ScriptStruct Game.P2GameplayCueNotify_AkEventSet
// 0x0080 (0x0080 - 0x0000)
struct FP2GameplayCueNotify_AkEventSet final
{
public:
	struct FAkEventSlotConfig                     Default;                                           // 0x0000(0x0030)(Edit, BlueprintVisible, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
	TMap<struct FGameplayTag, struct FP2GameplayCueNotify_AkEventVariation> EventMap;                // 0x0030(0x0050)(Edit, BlueprintVisible, DisableEditOnInstance, NativeAccessSpecifierPublic)
};
static_assert(alignof(FP2GameplayCueNotify_AkEventSet) == 0x000008, "Wrong alignment on FP2GameplayCueNotify_AkEventSet");
static_assert(sizeof(FP2GameplayCueNotify_AkEventSet) == 0x000080, "Wrong size on FP2GameplayCueNotify_AkEventSet");
static_assert(offsetof(FP2GameplayCueNotify_AkEventSet, Default) == 0x000000, "Member 'FP2GameplayCueNotify_AkEventSet::Default' has a wrong offset!");
static_assert(offsetof(FP2GameplayCueNotify_AkEventSet, EventMap) == 0x000030, "Member 'FP2GameplayCueNotify_AkEventSet::EventMap' has a wrong offset!");

// ScriptStruct Game.P2GameplayCue_DecalRow
// 0x0058 (0x0060 - 0x0008)
struct FP2GameplayCue_DecalRow final : public FTableRowBase
{
public:
	struct FP2GameplayCueNotify_MaterialSet       Value;                                             // 0x0008(0x0058)(Edit, BlueprintVisible, DisableEditOnInstance, NativeAccessSpecifierPublic)
};
static_assert(alignof(FP2GameplayCue_DecalRow) == 0x000008, "Wrong alignment on FP2GameplayCue_DecalRow");
static_assert(sizeof(FP2GameplayCue_DecalRow) == 0x000060, "Wrong size on FP2GameplayCue_DecalRow");
static_assert(offsetof(FP2GameplayCue_DecalRow, Value) == 0x000008, "Member 'FP2GameplayCue_DecalRow::Value' has a wrong offset!");

// ScriptStruct Game.P2GameplayCue_NiagaraRow
// 0x0058 (0x0060 - 0x0008)
struct FP2GameplayCue_NiagaraRow final : public FTableRowBase
{
public:
	struct FP2GameplayCueNotify_NiagaraSet        Value;                                             // 0x0008(0x0058)(Edit, BlueprintVisible, DisableEditOnInstance, NativeAccessSpecifierPublic)
};
static_assert(alignof(FP2GameplayCue_NiagaraRow) == 0x000008, "Wrong alignment on FP2GameplayCue_NiagaraRow");
static_assert(sizeof(FP2GameplayCue_NiagaraRow) == 0x000060, "Wrong size on FP2GameplayCue_NiagaraRow");
static_assert(offsetof(FP2GameplayCue_NiagaraRow, Value) == 0x000008, "Member 'FP2GameplayCue_NiagaraRow::Value' has a wrong offset!");

// ScriptStruct Game.P2GameplayCue_AkEventRow
// 0x0080 (0x0088 - 0x0008)
struct FP2GameplayCue_AkEventRow final : public FTableRowBase
{
public:
	struct FP2GameplayCueNotify_AkEventSet        Value;                                             // 0x0008(0x0080)(Edit, BlueprintVisible, DisableEditOnInstance, NativeAccessSpecifierPublic)
};
static_assert(alignof(FP2GameplayCue_AkEventRow) == 0x000008, "Wrong alignment on FP2GameplayCue_AkEventRow");
static_assert(sizeof(FP2GameplayCue_AkEventRow) == 0x000088, "Wrong size on FP2GameplayCue_AkEventRow");
static_assert(offsetof(FP2GameplayCue_AkEventRow, Value) == 0x000008, "Member 'FP2GameplayCue_AkEventRow::Value' has a wrong offset!");

// ScriptStruct Game.P2GameplayCueNotify_SoundInfo
// 0x0128 (0x0128 - 0x0000)
struct FP2GameplayCueNotify_SoundInfo
{
public:
	struct FP2GameplayCueNotify_SpawnCondition    SpawnConditionOverride;                            // 0x0000(0x0048)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FP2GameplayCueNotify_PlacementInfo     PlacementInfoOverride;                             // 0x0048(0x0040)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
	struct FGameplayTag                           AkComponentTag;                                    // 0x0088(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FP2GameplayCueNotify_AkEventSet        SoundEvent;                                        // 0x0090(0x0080)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FDataRegistryId                        SoundEventInDataRegistry;                          // 0x0110(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverrideSpawnCondition : 1;                       // 0x0120(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bOverridePlacementInfo : 1;                        // 0x0120(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bUseDataRegistry : 1;                              // 0x0120(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bCheckAttenuation : 1;                             // 0x0120(0x0001)(BitIndex: 0x03, PropSize: 0x0001 (Edit, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bCheckOverlappingEvents : 1;                       // 0x0120(0x0001)(BitIndex: 0x04, PropSize: 0x0001 (Edit, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_121[0x7];                                      // 0x0121(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FP2GameplayCueNotify_SoundInfo) == 0x000008, "Wrong alignment on FP2GameplayCueNotify_SoundInfo");
static_assert(sizeof(FP2GameplayCueNotify_SoundInfo) == 0x000128, "Wrong size on FP2GameplayCueNotify_SoundInfo");
static_assert(offsetof(FP2GameplayCueNotify_SoundInfo, SpawnConditionOverride) == 0x000000, "Member 'FP2GameplayCueNotify_SoundInfo::SpawnConditionOverride' has a wrong offset!");
static_assert(offsetof(FP2GameplayCueNotify_SoundInfo, PlacementInfoOverride) == 0x000048, "Member 'FP2GameplayCueNotify_SoundInfo::PlacementInfoOverride' has a wrong offset!");
static_assert(offsetof(FP2GameplayCueNotify_SoundInfo, AkComponentTag) == 0x000088, "Member 'FP2GameplayCueNotify_SoundInfo::AkComponentTag' has a wrong offset!");
static_assert(offsetof(FP2GameplayCueNotify_SoundInfo, SoundEvent) == 0x000090, "Member 'FP2GameplayCueNotify_SoundInfo::SoundEvent' has a wrong offset!");
static_assert(offsetof(FP2GameplayCueNotify_SoundInfo, SoundEventInDataRegistry) == 0x000110, "Member 'FP2GameplayCueNotify_SoundInfo::SoundEventInDataRegistry' has a wrong offset!");

// ScriptStruct Game.P2GameplayCueNotify_SoundLoopInfo
// 0x0038 (0x0160 - 0x0128)
struct FP2GameplayCueNotify_SoundLoopInfo final : public FP2GameplayCueNotify_SoundInfo
{
public:
	struct FAkEventSlotConfig                     StopSoundEvent;                                    // 0x0128(0x0030)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	float                                         LoopingFadeOutDuration;                            // 0x0158(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bUseAkEventToStopLoop : 1;                         // 0x015C(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bPlayOnActiveViewTarget : 1;                       // 0x015C(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_15D[0x3];                                      // 0x015D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FP2GameplayCueNotify_SoundLoopInfo) == 0x000008, "Wrong alignment on FP2GameplayCueNotify_SoundLoopInfo");
static_assert(sizeof(FP2GameplayCueNotify_SoundLoopInfo) == 0x000160, "Wrong size on FP2GameplayCueNotify_SoundLoopInfo");
static_assert(offsetof(FP2GameplayCueNotify_SoundLoopInfo, StopSoundEvent) == 0x000128, "Member 'FP2GameplayCueNotify_SoundLoopInfo::StopSoundEvent' has a wrong offset!");
static_assert(offsetof(FP2GameplayCueNotify_SoundLoopInfo, LoopingFadeOutDuration) == 0x000158, "Member 'FP2GameplayCueNotify_SoundLoopInfo::LoopingFadeOutDuration' has a wrong offset!");

// ScriptStruct Game.P2GameplayCueNotify_ForceFeedbackInfo
// 0x00A8 (0x00A8 - 0x0000)
struct FP2GameplayCueNotify_ForceFeedbackInfo final
{
public:
	struct FP2GameplayCueNotify_SpawnCondition    SpawnConditionOverride;                            // 0x0000(0x0048)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FP2GameplayCueNotify_PlacementInfo     PlacementInfoOverride;                             // 0x0048(0x0040)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
	class UForceFeedbackEffect*                   ForceFeedbackEffect;                               // 0x0088(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   ForceFeedbackTag;                                  // 0x0090(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bIsLooping : 1;                                    // 0x0098(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bOverrideSpawnCondition : 1;                       // 0x0098(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bOverridePlacementInfo : 1;                        // 0x0098(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bPlayInWorld : 1;                                  // 0x0098(0x0001)(BitIndex: 0x03, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_99[0x3];                                       // 0x0099(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         WorldIntensity;                                    // 0x009C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UForceFeedbackAttenuation*              WorldAttenuation;                                  // 0x00A0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FP2GameplayCueNotify_ForceFeedbackInfo) == 0x000008, "Wrong alignment on FP2GameplayCueNotify_ForceFeedbackInfo");
static_assert(sizeof(FP2GameplayCueNotify_ForceFeedbackInfo) == 0x0000A8, "Wrong size on FP2GameplayCueNotify_ForceFeedbackInfo");
static_assert(offsetof(FP2GameplayCueNotify_ForceFeedbackInfo, SpawnConditionOverride) == 0x000000, "Member 'FP2GameplayCueNotify_ForceFeedbackInfo::SpawnConditionOverride' has a wrong offset!");
static_assert(offsetof(FP2GameplayCueNotify_ForceFeedbackInfo, PlacementInfoOverride) == 0x000048, "Member 'FP2GameplayCueNotify_ForceFeedbackInfo::PlacementInfoOverride' has a wrong offset!");
static_assert(offsetof(FP2GameplayCueNotify_ForceFeedbackInfo, ForceFeedbackEffect) == 0x000088, "Member 'FP2GameplayCueNotify_ForceFeedbackInfo::ForceFeedbackEffect' has a wrong offset!");
static_assert(offsetof(FP2GameplayCueNotify_ForceFeedbackInfo, ForceFeedbackTag) == 0x000090, "Member 'FP2GameplayCueNotify_ForceFeedbackInfo::ForceFeedbackTag' has a wrong offset!");
static_assert(offsetof(FP2GameplayCueNotify_ForceFeedbackInfo, WorldIntensity) == 0x00009C, "Member 'FP2GameplayCueNotify_ForceFeedbackInfo::WorldIntensity' has a wrong offset!");
static_assert(offsetof(FP2GameplayCueNotify_ForceFeedbackInfo, WorldAttenuation) == 0x0000A0, "Member 'FP2GameplayCueNotify_ForceFeedbackInfo::WorldAttenuation' has a wrong offset!");

// ScriptStruct Game.P2GameplayCueNotify_DecalInfo
// 0x0128 (0x0128 - 0x0000)
struct FP2GameplayCueNotify_DecalInfo final
{
public:
	struct FP2GameplayCueNotify_SpawnCondition    SpawnConditionOverride;                            // 0x0000(0x0048)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FP2GameplayCueNotify_PlacementInfo     PlacementInfoOverride;                             // 0x0048(0x0040)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
	struct FP2GameplayCueNotify_MaterialSet       DecalMaterial;                                     // 0x0088(0x0058)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FDataRegistryId                        DecalMaterialInDataRegistry;                       // 0x00E0(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              DecalSizeRandomRange;                              // 0x00F0(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              DecalScale;                                        // 0x0100(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DecalThickness;                                    // 0x0110(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MinDistanceToSpawn;                                // 0x0114(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bAlignFootstep : 1;                                // 0x0118(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bEnforceMinDistance : 1;                           // 0x0118(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bUseDataRegistry : 1;                              // 0x0118(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bFlipY : 1;                                        // 0x0118(0x0001)(BitIndex: 0x03, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bFlipZ : 1;                                        // 0x0118(0x0001)(BitIndex: 0x04, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bOverrideSpawnCondition : 1;                       // 0x0118(0x0001)(BitIndex: 0x05, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bOverridePlacementInfo : 1;                        // 0x0118(0x0001)(BitIndex: 0x06, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bOverrideFadeOut : 1;                              // 0x0118(0x0001)(BitIndex: 0x07, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_119[0x3];                                      // 0x0119(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         FadeOutStartDelay;                                 // 0x011C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FadeOutDuration;                                   // 0x0120(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_124[0x4];                                      // 0x0124(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FP2GameplayCueNotify_DecalInfo) == 0x000008, "Wrong alignment on FP2GameplayCueNotify_DecalInfo");
static_assert(sizeof(FP2GameplayCueNotify_DecalInfo) == 0x000128, "Wrong size on FP2GameplayCueNotify_DecalInfo");
static_assert(offsetof(FP2GameplayCueNotify_DecalInfo, SpawnConditionOverride) == 0x000000, "Member 'FP2GameplayCueNotify_DecalInfo::SpawnConditionOverride' has a wrong offset!");
static_assert(offsetof(FP2GameplayCueNotify_DecalInfo, PlacementInfoOverride) == 0x000048, "Member 'FP2GameplayCueNotify_DecalInfo::PlacementInfoOverride' has a wrong offset!");
static_assert(offsetof(FP2GameplayCueNotify_DecalInfo, DecalMaterial) == 0x000088, "Member 'FP2GameplayCueNotify_DecalInfo::DecalMaterial' has a wrong offset!");
static_assert(offsetof(FP2GameplayCueNotify_DecalInfo, DecalMaterialInDataRegistry) == 0x0000E0, "Member 'FP2GameplayCueNotify_DecalInfo::DecalMaterialInDataRegistry' has a wrong offset!");
static_assert(offsetof(FP2GameplayCueNotify_DecalInfo, DecalSizeRandomRange) == 0x0000F0, "Member 'FP2GameplayCueNotify_DecalInfo::DecalSizeRandomRange' has a wrong offset!");
static_assert(offsetof(FP2GameplayCueNotify_DecalInfo, DecalScale) == 0x000100, "Member 'FP2GameplayCueNotify_DecalInfo::DecalScale' has a wrong offset!");
static_assert(offsetof(FP2GameplayCueNotify_DecalInfo, DecalThickness) == 0x000110, "Member 'FP2GameplayCueNotify_DecalInfo::DecalThickness' has a wrong offset!");
static_assert(offsetof(FP2GameplayCueNotify_DecalInfo, MinDistanceToSpawn) == 0x000114, "Member 'FP2GameplayCueNotify_DecalInfo::MinDistanceToSpawn' has a wrong offset!");
static_assert(offsetof(FP2GameplayCueNotify_DecalInfo, FadeOutStartDelay) == 0x00011C, "Member 'FP2GameplayCueNotify_DecalInfo::FadeOutStartDelay' has a wrong offset!");
static_assert(offsetof(FP2GameplayCueNotify_DecalInfo, FadeOutDuration) == 0x000120, "Member 'FP2GameplayCueNotify_DecalInfo::FadeOutDuration' has a wrong offset!");

// ScriptStruct Game.P2GameplayCueNotify_BurstEffects
// 0x03E0 (0x03E0 - 0x0000)
struct FP2GameplayCueNotify_BurstEffects final
{
public:
	TArray<struct FP2GameplayCueNotify_ParticleInfo> BurstParticles;                                 // 0x0000(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	TArray<struct FP2GameplayCueNotify_SoundInfo> BurstSounds;                                       // 0x0010(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FP2GameplayCueNotify_CameraShakeInfo   BurstCameraShake;                                  // 0x0020(0x00B8)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FP2GameplayCueNotify_CameraLensEffectInfo BurstCameraLensEffect;                          // 0x00D8(0x00A0)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FP2GameplayCueNotify_ForceFeedbackInfo BurstForceFeedback;                                // 0x0178(0x00A8)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FP2GameplayCueNotify_DecalInfo         BurstDecal;                                        // 0x0220(0x0128)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FP2GameplayCueNotify_ShockwaveInfo     BurstShockwave;                                    // 0x0348(0x0098)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
};
static_assert(alignof(FP2GameplayCueNotify_BurstEffects) == 0x000008, "Wrong alignment on FP2GameplayCueNotify_BurstEffects");
static_assert(sizeof(FP2GameplayCueNotify_BurstEffects) == 0x0003E0, "Wrong size on FP2GameplayCueNotify_BurstEffects");
static_assert(offsetof(FP2GameplayCueNotify_BurstEffects, BurstParticles) == 0x000000, "Member 'FP2GameplayCueNotify_BurstEffects::BurstParticles' has a wrong offset!");
static_assert(offsetof(FP2GameplayCueNotify_BurstEffects, BurstSounds) == 0x000010, "Member 'FP2GameplayCueNotify_BurstEffects::BurstSounds' has a wrong offset!");
static_assert(offsetof(FP2GameplayCueNotify_BurstEffects, BurstCameraShake) == 0x000020, "Member 'FP2GameplayCueNotify_BurstEffects::BurstCameraShake' has a wrong offset!");
static_assert(offsetof(FP2GameplayCueNotify_BurstEffects, BurstCameraLensEffect) == 0x0000D8, "Member 'FP2GameplayCueNotify_BurstEffects::BurstCameraLensEffect' has a wrong offset!");
static_assert(offsetof(FP2GameplayCueNotify_BurstEffects, BurstForceFeedback) == 0x000178, "Member 'FP2GameplayCueNotify_BurstEffects::BurstForceFeedback' has a wrong offset!");
static_assert(offsetof(FP2GameplayCueNotify_BurstEffects, BurstDecal) == 0x000220, "Member 'FP2GameplayCueNotify_BurstEffects::BurstDecal' has a wrong offset!");
static_assert(offsetof(FP2GameplayCueNotify_BurstEffects, BurstShockwave) == 0x000348, "Member 'FP2GameplayCueNotify_BurstEffects::BurstShockwave' has a wrong offset!");

// ScriptStruct Game.P2GameplayCueNotify_LoopingEffects
// 0x0220 (0x0220 - 0x0000)
struct FP2GameplayCueNotify_LoopingEffects final
{
public:
	TArray<struct FP2GameplayCueNotify_ParticleInfo> LoopingParticles;                               // 0x0000(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	TArray<struct FP2GameplayCueNotify_SoundLoopInfo> LoopingSounds;                                 // 0x0010(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FP2GameplayCueNotify_CameraShakeInfo   LoopingCameraShake;                                // 0x0020(0x00B8)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FP2GameplayCueNotify_CameraLensEffectInfo LoopingCameraLensEffect;                        // 0x00D8(0x00A0)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FP2GameplayCueNotify_ForceFeedbackInfo LoopingForceFeedback;                              // 0x0178(0x00A8)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
};
static_assert(alignof(FP2GameplayCueNotify_LoopingEffects) == 0x000008, "Wrong alignment on FP2GameplayCueNotify_LoopingEffects");
static_assert(sizeof(FP2GameplayCueNotify_LoopingEffects) == 0x000220, "Wrong size on FP2GameplayCueNotify_LoopingEffects");
static_assert(offsetof(FP2GameplayCueNotify_LoopingEffects, LoopingParticles) == 0x000000, "Member 'FP2GameplayCueNotify_LoopingEffects::LoopingParticles' has a wrong offset!");
static_assert(offsetof(FP2GameplayCueNotify_LoopingEffects, LoopingSounds) == 0x000010, "Member 'FP2GameplayCueNotify_LoopingEffects::LoopingSounds' has a wrong offset!");
static_assert(offsetof(FP2GameplayCueNotify_LoopingEffects, LoopingCameraShake) == 0x000020, "Member 'FP2GameplayCueNotify_LoopingEffects::LoopingCameraShake' has a wrong offset!");
static_assert(offsetof(FP2GameplayCueNotify_LoopingEffects, LoopingCameraLensEffect) == 0x0000D8, "Member 'FP2GameplayCueNotify_LoopingEffects::LoopingCameraLensEffect' has a wrong offset!");
static_assert(offsetof(FP2GameplayCueNotify_LoopingEffects, LoopingForceFeedback) == 0x000178, "Member 'FP2GameplayCueNotify_LoopingEffects::LoopingForceFeedback' has a wrong offset!");

}

