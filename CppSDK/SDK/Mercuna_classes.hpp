#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: Mercuna

#include "Basic.hpp"

#include "Mercuna_structs.hpp"
#include "CoreUObject_structs.hpp"
#include "CoreUObject_classes.hpp"
#include "Engine_structs.hpp"
#include "Engine_classes.hpp"
#include "AIModule_structs.hpp"
#include "AIModule_classes.hpp"
#include "StructUtils_structs.hpp"
#include "PhysicsCore_classes.hpp"


namespace SDK
{

// Class Mercuna.Mercuna2DQueryTest
// 0x0008 (0x0210 - 0x0208)
class UMercuna2DQueryTest : public UEnvQueryTest
{
public:
	uint8                                         Pad_208[0x8];                                      // 0x0208(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"Mercuna2DQueryTest">();
	}
	static class UMercuna2DQueryTest* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UMercuna2DQueryTest>();
	}
};
static_assert(alignof(UMercuna2DQueryTest) == 0x000008, "Wrong alignment on UMercuna2DQueryTest");
static_assert(sizeof(UMercuna2DQueryTest) == 0x000210, "Wrong size on UMercuna2DQueryTest");

// Class Mercuna.EnvQueryTest_Mercuna2D_Project
// 0x0048 (0x0258 - 0x0210)
class UEnvQueryTest_Mercuna2D_Project : public UMercuna2DQueryTest
{
public:
	TSubclassOf<class APawn>                      AgentClass;                                        // 0x0210(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FAIDataProviderFloatValue              MaxProjectionDistance;                             // 0x0218(0x0038)(Edit, DisableEditOnInstance, ContainsInstancedReference, NativeAccessSpecifierPublic)
	EMercunaProjectionType                        ProjectionType;                                    // 0x0250(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_251[0x7];                                      // 0x0251(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"EnvQueryTest_Mercuna2D_Project">();
	}
	static class UEnvQueryTest_Mercuna2D_Project* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UEnvQueryTest_Mercuna2D_Project>();
	}
};
static_assert(alignof(UEnvQueryTest_Mercuna2D_Project) == 0x000008, "Wrong alignment on UEnvQueryTest_Mercuna2D_Project");
static_assert(sizeof(UEnvQueryTest_Mercuna2D_Project) == 0x000258, "Wrong size on UEnvQueryTest_Mercuna2D_Project");
static_assert(offsetof(UEnvQueryTest_Mercuna2D_Project, AgentClass) == 0x000210, "Member 'UEnvQueryTest_Mercuna2D_Project::AgentClass' has a wrong offset!");
static_assert(offsetof(UEnvQueryTest_Mercuna2D_Project, MaxProjectionDistance) == 0x000218, "Member 'UEnvQueryTest_Mercuna2D_Project::MaxProjectionDistance' has a wrong offset!");
static_assert(offsetof(UEnvQueryTest_Mercuna2D_Project, ProjectionType) == 0x000250, "Member 'UEnvQueryTest_Mercuna2D_Project::ProjectionType' has a wrong offset!");

// Class Mercuna.EnvQueryTest_MercunaGround_Project
// 0x0000 (0x0258 - 0x0258)
class UEnvQueryTest_MercunaGround_Project final : public UEnvQueryTest_Mercuna2D_Project
{
public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"EnvQueryTest_MercunaGround_Project">();
	}
	static class UEnvQueryTest_MercunaGround_Project* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UEnvQueryTest_MercunaGround_Project>();
	}
};
static_assert(alignof(UEnvQueryTest_MercunaGround_Project) == 0x000008, "Wrong alignment on UEnvQueryTest_MercunaGround_Project");
static_assert(sizeof(UEnvQueryTest_MercunaGround_Project) == 0x000258, "Wrong size on UEnvQueryTest_MercunaGround_Project");

// Class Mercuna.MercunaNavigationComponent
// 0x00D0 (0x0190 - 0x00C0)
class UMercunaNavigationComponent : public UActorComponent
{
public:
	TMulticastInlineDelegate<void(const struct FAIRequestID& RequestID, const EMercunaMoveResult Result)> OnMoveCompleted; // 0x00C0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_D0[0x14];                                      // 0x00D0(0x0014)(Fixing Size After Last Property [ Dumper-7 ])
	EMercunaAvoidanceMode                         AvoidanceMode;                                     // 0x00E4(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_E5[0x3];                                       // 0x00E5(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FMercunaContextualSteeringActorParameters DefaultContextSteeringParameters;               // 0x00E8(0x0010)(Edit, NoDestructor, Protected, NativeAccessSpecifierProtected)
	TMap<TSubclassOf<class AActor>, struct FMercunaContextualSteeringActorParameters> ContextSteeringParameters; // 0x00F8(0x0050)(Edit, Protected, NativeAccessSpecifierProtected)
	bool                                          DynamicAvoidance;                                  // 0x0148(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_149[0x3];                                      // 0x0149(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         AvoidanceWeightMultiplier;                         // 0x014C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FMercunaUsageSpec                      UsageSpec;                                         // 0x0150(0x0008)(Edit, NoDestructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_158[0x30];                                     // 0x0158(0x0030)(Fixing Size After Last Property [ Dumper-7 ])
	class AController*                            CurrentController;                                 // 0x0188(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"MercunaNavigationComponent">();
	}
	static class UMercunaNavigationComponent* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UMercunaNavigationComponent>();
	}
};
static_assert(alignof(UMercunaNavigationComponent) == 0x000008, "Wrong alignment on UMercunaNavigationComponent");
static_assert(sizeof(UMercunaNavigationComponent) == 0x000190, "Wrong size on UMercunaNavigationComponent");
static_assert(offsetof(UMercunaNavigationComponent, OnMoveCompleted) == 0x0000C0, "Member 'UMercunaNavigationComponent::OnMoveCompleted' has a wrong offset!");
static_assert(offsetof(UMercunaNavigationComponent, AvoidanceMode) == 0x0000E4, "Member 'UMercunaNavigationComponent::AvoidanceMode' has a wrong offset!");
static_assert(offsetof(UMercunaNavigationComponent, DefaultContextSteeringParameters) == 0x0000E8, "Member 'UMercunaNavigationComponent::DefaultContextSteeringParameters' has a wrong offset!");
static_assert(offsetof(UMercunaNavigationComponent, ContextSteeringParameters) == 0x0000F8, "Member 'UMercunaNavigationComponent::ContextSteeringParameters' has a wrong offset!");
static_assert(offsetof(UMercunaNavigationComponent, DynamicAvoidance) == 0x000148, "Member 'UMercunaNavigationComponent::DynamicAvoidance' has a wrong offset!");
static_assert(offsetof(UMercunaNavigationComponent, AvoidanceWeightMultiplier) == 0x00014C, "Member 'UMercunaNavigationComponent::AvoidanceWeightMultiplier' has a wrong offset!");
static_assert(offsetof(UMercunaNavigationComponent, UsageSpec) == 0x000150, "Member 'UMercunaNavigationComponent::UsageSpec' has a wrong offset!");
static_assert(offsetof(UMercunaNavigationComponent, CurrentController) == 0x000188, "Member 'UMercunaNavigationComponent::CurrentController' has a wrong offset!");

// Class Mercuna.Mercuna3DNavigationComponent
// 0x0070 (0x0200 - 0x0190)
class UMercuna3DNavigationComponent : public UMercunaNavigationComponent
{
public:
	struct FMercuna3DNavigationConfiguration      Configuration;                                     // 0x0190(0x001C)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_1AC[0x4];                                      // 0x01AC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class AMercunaNavOctree*                      NavOctree;                                         // 0x01B0(0x0008)(Edit, ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bAutomaticRadius;                                  // 0x01B8(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1B9[0x3];                                      // 0x01B9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         NavigationRadius;                                  // 0x01BC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          Pathfinding;                                       // 0x01C0(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1C1[0x3F];                                     // 0x01C1(0x003F)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void AddDestinationLocation(const struct FVector& NextDestination)	 // 0x48475fc;
	void CancelLookAt()	 // 0x48476d8;
	void CancelMovement()	 // 0x48476ec;
	void ClearAvoidanceExclusions()	 // 0x1203138;
	void Configure(const struct FMercuna3DNavigationConfiguration& NewConfiguration)	 // 0x4847720;
	void ConfigureMovement(bool bUsePathfinding, EMercunaAvoidanceMode NewAvoidanceMode)	 // 0x4847804;
	void GetPathInfo(bool* Valid, float* DistanceToEnd)	 // 0x484796c;
	float GetRemainingPathLength()	 // 0x4847a4c;
	void InvalidateContextualSteeringParams()	 // 0x476124c;
	void InvalidateContextualSteeringParamsAgainstActor(class AActor* Actor)	 // 0x4847c20;
	void IsReachable(const struct FVector& Point, bool* Success, class UObject* WorldContextObject, const struct FLatentActionInfo& LatentInfo)	 // 0x4847ce4;
	void LookAlongAcceleration(float MaxPitch)	 // 0x4847f2c;
	void LookAt(class AActor* Actor, float MaxPitch)	 // 0x4847ff0;
	void LookInDirection(const struct FVector& Direction, float MaxPitch)	 // 0x4848130;
	void MoveToActor(class AActor* Actor, float EndDistance, float Speed, bool UsePartialPath)	 // 0x48489e0;
	void MoveToLocation(const struct FVector& Destination, float EndDistance, float Speed, bool UsePartialPath)	 // 0x4848f10;
	void MoveToLocations(const TArray<struct FVector>& Destinations, float EndDistance, float Speed, bool UsePartialPath)	 // 0x4849554;
	bool OverrideSpeedMultiplier(const float NewSpeedMultiplier)	 // 0x4849c64;
	void PauseNavigation()	 // 0x4849d3c;
	void ResumeNavigation()	 // 0x4849db0;
	void SetAvoidanceAgainst(class AActor* Actor, bool Enable)	 // 0x4849dc4;
	void SetNavOctree(class AMercunaNavOctree* NavOctree_0)	 // 0x4849fc8;
	void SetNavOctreeToBest()	 // 0x484a088;
	void SetUsageSpec(const struct FMercunaUsageSpec& NewUsageSpec)	 // 0x484a09c;
	void Stop()	 // 0x484a160;
	void TrackActor(class AActor* Actor, float Distance, float Speed, const struct FVector& Offset)	 // 0x484a174;

	class AMercunaNavOctree* GetNavOctree() const	 // 0x4847954;
	const struct FMercunaUsageSpec GetUsageSpec() const	 // 0x4847a78;

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"Mercuna3DNavigationComponent">();
	}
	static class UMercuna3DNavigationComponent* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UMercuna3DNavigationComponent>();
	}
};
static_assert(alignof(UMercuna3DNavigationComponent) == 0x000008, "Wrong alignment on UMercuna3DNavigationComponent");
static_assert(sizeof(UMercuna3DNavigationComponent) == 0x000200, "Wrong size on UMercuna3DNavigationComponent");
static_assert(offsetof(UMercuna3DNavigationComponent, Configuration) == 0x000190, "Member 'UMercuna3DNavigationComponent::Configuration' has a wrong offset!");
static_assert(offsetof(UMercuna3DNavigationComponent, NavOctree) == 0x0001B0, "Member 'UMercuna3DNavigationComponent::NavOctree' has a wrong offset!");
static_assert(offsetof(UMercuna3DNavigationComponent, bAutomaticRadius) == 0x0001B8, "Member 'UMercuna3DNavigationComponent::bAutomaticRadius' has a wrong offset!");
static_assert(offsetof(UMercuna3DNavigationComponent, NavigationRadius) == 0x0001BC, "Member 'UMercuna3DNavigationComponent::NavigationRadius' has a wrong offset!");
static_assert(offsetof(UMercuna3DNavigationComponent, Pathfinding) == 0x0001C0, "Member 'UMercuna3DNavigationComponent::Pathfinding' has a wrong offset!");

// Class Mercuna.MercunaNavLink
// 0x0230 (0x04E0 - 0x02B0)
#pragma pack(push, 0x1)
class alignas(0x10) AMercunaNavLink : public AActor
{
public:
	struct FMercunaNavigationLink                 Link;                                              // 0x02B0(0x00E0)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, ExposeOnSpawn, NativeAccessSpecifierPublic)
	struct FMercunaSupportedAgentTypes            SupportedAgentTypes;                               // 0x0390(0x00A8)(Edit, BlueprintVisible, BlueprintReadOnly, ExposeOnSpawn, NativeAccessSpecifierPublic)
	bool                                          bAutoRotation;                                     // 0x0438(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_439[0x3];                                      // 0x0439(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   TypeTag;                                           // 0x043C(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_444[0x4];                                      // 0x0444(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TMulticastInlineDelegate<void(class APawn* Pawn, EMercunaNavigationLinkDirection Direction, const struct FVector& Destination)> OnNavLinkStart; // 0x0448(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	bool                                          bApplyToAllNavGrids;                               // 0x0458(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_459[0x7];                                      // 0x0459(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class AMercunaNavGraph2D*                     NavGrid;                                           // 0x0460(0x0008)(Edit, ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FMercunaUsageTypes                     UsageTypes;                                        // 0x0468(0x0004)(Edit, NoDestructor, AdvancedDisplay, Protected, NativeAccessSpecifierProtected)
	bool                                          bEnabled;                                          // 0x046C(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bInterGridLink;                                    // 0x046D(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_46E[0x2];                                      // 0x046E(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftObjectPtr<class AMercunaNavGraph2D>      LeftNavGrid;                                       // 0x0470(0x0030)(Edit, AdvancedDisplay, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftObjectPtr<class AMercunaNavGraph2D>      RightNavGrid;                                      // 0x04A0(0x0030)(Edit, AdvancedDisplay, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_4D0[0x8];                                      // 0x04D0(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void AddBetweenNavGrids(class AMercunaNavGraph2D* LeftNavGrid_0, class AMercunaNavGraph2D* RightNavGrid_0)	 // 0x485fba0;
	void AddToAllGrids()	 // 0x4860128;
	void AddToNavGrid(class AMercunaNavGraph2D* NavGrid_0)	 // 0x486087c;
	void ReceiveNavLinkEnd(class APawn* Pawn)	 // 0xae1e64;
	void ReceiveNavLinkStart(class APawn* Pawn, EMercunaNavigationLinkDirection Direction, const struct FVector& Destination)	 // 0xae1e64;
	void SetEnabled(bool bEnabled_0, const class FString& Reason)	 // 0x48647e4;

	struct FVector GetLeftPosition() const	 // 0x4862cc0;
	struct FRotator GetLeftRotation() const	 // 0x4862cf8;
	struct FTransform GetLeftTransform() const	 // 0x4862d30;
	struct FVector GetRightPosition() const	 // 0x4862dac;
	struct FRotator GetRightRotation() const	 // 0x4862de4;
	struct FTransform GetRightTransform() const	 // 0x4862e1c;
	bool InUse() const	 // 0x4862f0c;

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"MercunaNavLink">();
	}
	static class AMercunaNavLink* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<AMercunaNavLink>();
	}
};
#pragma pack(pop)
static_assert(alignof(AMercunaNavLink) == 0x000010, "Wrong alignment on AMercunaNavLink");
static_assert(sizeof(AMercunaNavLink) == 0x0004E0, "Wrong size on AMercunaNavLink");
static_assert(offsetof(AMercunaNavLink, Link) == 0x0002B0, "Member 'AMercunaNavLink::Link' has a wrong offset!");
static_assert(offsetof(AMercunaNavLink, SupportedAgentTypes) == 0x000390, "Member 'AMercunaNavLink::SupportedAgentTypes' has a wrong offset!");
static_assert(offsetof(AMercunaNavLink, bAutoRotation) == 0x000438, "Member 'AMercunaNavLink::bAutoRotation' has a wrong offset!");
static_assert(offsetof(AMercunaNavLink, TypeTag) == 0x00043C, "Member 'AMercunaNavLink::TypeTag' has a wrong offset!");
static_assert(offsetof(AMercunaNavLink, OnNavLinkStart) == 0x000448, "Member 'AMercunaNavLink::OnNavLinkStart' has a wrong offset!");
static_assert(offsetof(AMercunaNavLink, bApplyToAllNavGrids) == 0x000458, "Member 'AMercunaNavLink::bApplyToAllNavGrids' has a wrong offset!");
static_assert(offsetof(AMercunaNavLink, NavGrid) == 0x000460, "Member 'AMercunaNavLink::NavGrid' has a wrong offset!");
static_assert(offsetof(AMercunaNavLink, UsageTypes) == 0x000468, "Member 'AMercunaNavLink::UsageTypes' has a wrong offset!");
static_assert(offsetof(AMercunaNavLink, bEnabled) == 0x00046C, "Member 'AMercunaNavLink::bEnabled' has a wrong offset!");
static_assert(offsetof(AMercunaNavLink, bInterGridLink) == 0x00046D, "Member 'AMercunaNavLink::bInterGridLink' has a wrong offset!");
static_assert(offsetof(AMercunaNavLink, LeftNavGrid) == 0x000470, "Member 'AMercunaNavLink::LeftNavGrid' has a wrong offset!");
static_assert(offsetof(AMercunaNavLink, RightNavGrid) == 0x0004A0, "Member 'AMercunaNavLink::RightNavGrid' has a wrong offset!");

// Class Mercuna.MercunaGroundTask_MoveTo
// 0x00A8 (0x0118 - 0x0070)
class UMercunaGroundTask_MoveTo final : public UAITask
{
public:
	TMulticastInlineDelegate<void()>              OnRequestFailed;                                   // 0x0070(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, Protected, NativeAccessSpecifierProtected)
	TMulticastInlineDelegate<void(EMercunaMoveResult Result, class AAIController* AIController)> OnMoveFinished; // 0x0080(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_90[0x88];                                      // 0x0090(0x0088)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UMercunaGroundTask_MoveTo* MoveTo(class AAIController* Controller, const struct FVector& GoalLocation, class AActor* GoalActor, float EndDistance, bool AcceptPartialPath, bool bLockAILogic)	 // 0x485b450;

	void OnMoveComplete(const struct FAIRequestID& RequestID, EMercunaMoveResult Result)	 // 0x48499e0;

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"MercunaGroundTask_MoveTo">();
	}
	static class UMercunaGroundTask_MoveTo* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UMercunaGroundTask_MoveTo>();
	}
};
static_assert(alignof(UMercunaGroundTask_MoveTo) == 0x000008, "Wrong alignment on UMercunaGroundTask_MoveTo");
static_assert(sizeof(UMercunaGroundTask_MoveTo) == 0x000118, "Wrong size on UMercunaGroundTask_MoveTo");
static_assert(offsetof(UMercunaGroundTask_MoveTo, OnRequestFailed) == 0x000070, "Member 'UMercunaGroundTask_MoveTo::OnRequestFailed' has a wrong offset!");
static_assert(offsetof(UMercunaGroundTask_MoveTo, OnMoveFinished) == 0x000080, "Member 'UMercunaGroundTask_MoveTo::OnMoveFinished' has a wrong offset!");

// Class Mercuna.BTTask_MercunaGround_MoveTo
// 0x0010 (0x00A8 - 0x0098)
class UBTTask_MercunaGround_MoveTo : public UBTTask_BlackboardBase
{
public:
	float                                         Speed;                                             // 0x0098(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         EndDistance;                                       // 0x009C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bObserveBlackboardValue : 1;                       // 0x00A0(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bAllowPartialPath : 1;                             // 0x00A0(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bAvoidTargetActor : 1;                             // 0x00A0(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Edit, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_A1[0x7];                                       // 0x00A1(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"BTTask_MercunaGround_MoveTo">();
	}
	static class UBTTask_MercunaGround_MoveTo* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UBTTask_MercunaGround_MoveTo>();
	}
};
static_assert(alignof(UBTTask_MercunaGround_MoveTo) == 0x000008, "Wrong alignment on UBTTask_MercunaGround_MoveTo");
static_assert(sizeof(UBTTask_MercunaGround_MoveTo) == 0x0000A8, "Wrong size on UBTTask_MercunaGround_MoveTo");
static_assert(offsetof(UBTTask_MercunaGround_MoveTo, Speed) == 0x000098, "Member 'UBTTask_MercunaGround_MoveTo::Speed' has a wrong offset!");
static_assert(offsetof(UBTTask_MercunaGround_MoveTo, EndDistance) == 0x00009C, "Member 'UBTTask_MercunaGround_MoveTo::EndDistance' has a wrong offset!");

// Class Mercuna.Mercuna3DMoveToProxy
// 0x0070 (0x00A0 - 0x0030)
class UMercuna3DMoveToProxy final : public UBlueprintAsyncActionBase
{
public:
	TMulticastInlineDelegate<void()>              OnSuccess;                                         // 0x0030(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void()>              OnFailure;                                         // 0x0040(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	class APawn*                                  Pawn;                                              // 0x0050(0x0008)(ZeroConstructor, Transient, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_58[0x48];                                      // 0x0058(0x0048)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UMercuna3DMoveToProxy* MoveToActor(class UObject* WorldContextObject, class APawn* Pawn_0, class AActor* Actor, float EndDistance, float Speed, bool UsePartialPath)	 // 0x48486ac;
	static class UMercuna3DMoveToProxy* MoveToLocation(class UObject* WorldContextObject, class APawn* Pawn_0, const struct FVector& Destination, float EndDistance, float Speed, bool UsePartialPath)	 // 0x4848c18;
	static class UMercuna3DMoveToProxy* MoveToLocations(class UObject* WorldContextObject, class APawn* Pawn_0, const TArray<struct FVector>& Destinations, float EndDistance, float Speed, bool UsePartialPath)	 // 0x4849128;

	void OnMoveComplete(const struct FAIRequestID& RequestID, EMercunaMoveResult Result)	 // 0x48498a0;

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"Mercuna3DMoveToProxy">();
	}
	static class UMercuna3DMoveToProxy* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UMercuna3DMoveToProxy>();
	}
};
static_assert(alignof(UMercuna3DMoveToProxy) == 0x000008, "Wrong alignment on UMercuna3DMoveToProxy");
static_assert(sizeof(UMercuna3DMoveToProxy) == 0x0000A0, "Wrong size on UMercuna3DMoveToProxy");
static_assert(offsetof(UMercuna3DMoveToProxy, OnSuccess) == 0x000030, "Member 'UMercuna3DMoveToProxy::OnSuccess' has a wrong offset!");
static_assert(offsetof(UMercuna3DMoveToProxy, OnFailure) == 0x000040, "Member 'UMercuna3DMoveToProxy::OnFailure' has a wrong offset!");
static_assert(offsetof(UMercuna3DMoveToProxy, Pawn) == 0x000050, "Member 'UMercuna3DMoveToProxy::Pawn' has a wrong offset!");

// Class Mercuna.Mercuna3DQueryTest
// 0x0000 (0x0208 - 0x0208)
class UMercuna3DQueryTest : public UEnvQueryTest
{
public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"Mercuna3DQueryTest">();
	}
	static class UMercuna3DQueryTest* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UMercuna3DQueryTest>();
	}
};
static_assert(alignof(UMercuna3DQueryTest) == 0x000008, "Wrong alignment on UMercuna3DQueryTest");
static_assert(sizeof(UMercuna3DQueryTest) == 0x000208, "Wrong size on UMercuna3DQueryTest");

// Class Mercuna.EnvQueryTest_Mercuna3D_ProjectInDir
// 0x0088 (0x0290 - 0x0208)
class UEnvQueryTest_Mercuna3D_ProjectInDir final : public UMercuna3DQueryTest
{
public:
	struct FAIDataProviderFloatValue              MaxProjectDistance;                                // 0x0208(0x0038)(Edit, DisableEditOnInstance, ContainsInstancedReference, NativeAccessSpecifierPublic)
	struct FAIDataProviderBoolValue               ProjectToNavigable;                                // 0x0240(0x0038)(Edit, DisableEditOnInstance, ContainsInstancedReference, NativeAccessSpecifierPublic)
	struct FVector                                ProjectDirection;                                  // 0x0278(0x0018)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"EnvQueryTest_Mercuna3D_ProjectInDir">();
	}
	static class UEnvQueryTest_Mercuna3D_ProjectInDir* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UEnvQueryTest_Mercuna3D_ProjectInDir>();
	}
};
static_assert(alignof(UEnvQueryTest_Mercuna3D_ProjectInDir) == 0x000008, "Wrong alignment on UEnvQueryTest_Mercuna3D_ProjectInDir");
static_assert(sizeof(UEnvQueryTest_Mercuna3D_ProjectInDir) == 0x000290, "Wrong size on UEnvQueryTest_Mercuna3D_ProjectInDir");
static_assert(offsetof(UEnvQueryTest_Mercuna3D_ProjectInDir, MaxProjectDistance) == 0x000208, "Member 'UEnvQueryTest_Mercuna3D_ProjectInDir::MaxProjectDistance' has a wrong offset!");
static_assert(offsetof(UEnvQueryTest_Mercuna3D_ProjectInDir, ProjectToNavigable) == 0x000240, "Member 'UEnvQueryTest_Mercuna3D_ProjectInDir::ProjectToNavigable' has a wrong offset!");
static_assert(offsetof(UEnvQueryTest_Mercuna3D_ProjectInDir, ProjectDirection) == 0x000278, "Member 'UEnvQueryTest_Mercuna3D_ProjectInDir::ProjectDirection' has a wrong offset!");

// Class Mercuna.Mercuna2DNavigationComponent
// 0x00C0 (0x0250 - 0x0190)
class UMercuna2DNavigationComponent : public UMercunaNavigationComponent
{
public:
	TMulticastInlineDelegate<void(const struct FVector& StartPosition, const struct FVector& EndPosition, const struct FVector& SuggestedLaunchVelocity)> OnJumpStarted; // 0x0190(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	class UActorComponent*                        MovementComponent;                                 // 0x01A0(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1A8[0x58];                                     // 0x01A8(0x0058)(Fixing Size After Last Property [ Dumper-7 ])
	struct FInstancedStruct                       QueryFilter;                                       // 0x0200(0x0010)(Edit, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_210[0x40];                                     // 0x0210(0x0040)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"Mercuna2DNavigationComponent">();
	}
	static class UMercuna2DNavigationComponent* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UMercuna2DNavigationComponent>();
	}
};
static_assert(alignof(UMercuna2DNavigationComponent) == 0x000008, "Wrong alignment on UMercuna2DNavigationComponent");
static_assert(sizeof(UMercuna2DNavigationComponent) == 0x000250, "Wrong size on UMercuna2DNavigationComponent");
static_assert(offsetof(UMercuna2DNavigationComponent, OnJumpStarted) == 0x000190, "Member 'UMercuna2DNavigationComponent::OnJumpStarted' has a wrong offset!");
static_assert(offsetof(UMercuna2DNavigationComponent, MovementComponent) == 0x0001A0, "Member 'UMercuna2DNavigationComponent::MovementComponent' has a wrong offset!");
static_assert(offsetof(UMercuna2DNavigationComponent, QueryFilter) == 0x000200, "Member 'UMercuna2DNavigationComponent::QueryFilter' has a wrong offset!");

// Class Mercuna.MercunaGroundNavigationComponent
// 0x0080 (0x02D0 - 0x0250)
class UMercunaGroundNavigationComponent : public UMercuna2DNavigationComponent
{
public:
	TMulticastInlineDelegate<void()>              OnSwimStarted;                                     // 0x0250(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void()>              OnSwimStopped;                                     // 0x0260(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	class AMercunaNavGroundGrid*                  NavGrid;                                           // 0x0270(0x0008)(Edit, ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FMercunaGroundAgentType                AgentType;                                         // 0x0278(0x000C)(Edit, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bAutomaticSteeringParameters;                      // 0x0284(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_285[0x3];                                      // 0x0285(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FMercunaGroundNavigationSteeringParameters SteeringParameters;                            // 0x0288(0x0020)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, Protected, NativeAccessSpecifierProtected)
	bool                                          bSetCharacterControllerRotation;                   // 0x02A8(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2A9[0x3];                                      // 0x02A9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FMercunaGroundNavigationConfiguration  Configuration;                                     // 0x02AC(0x001C)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_2C8[0x8];                                      // 0x02C8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void AddDestinationLocation(const struct FVector& NextDestination, bool bSmoothTransition)	 // 0x484d898;
	void CancelMovement()	 // 0x48476ec;
	void ClearAvoidanceExclusions()	 // 0x1203138;
	void Configure(const struct FMercunaGroundNavigationConfiguration& NewConfiguration)	 // 0x484da00;
	void ConfigureMovement(EMercunaAvoidanceMode NewAvoidanceMode)	 // 0x484daac;
	void ConfigureSteering(const struct FMercunaGroundNavigationSteeringParameters& NewSteering)	 // 0x484db6c;
	struct FVector GetLookDirection()	 // 0x484dd14;
	void GetPathInfo(bool* Valid, float* DistanceToEnd)	 // 0x484796c;
	float GetRemainingPathLength()	 // 0x4847a4c;
	void InvalidateContextualSteeringParams()	 // 0x476124c;
	void InvalidateContextualSteeringParamsAgainstActor(class AActor* Actor)	 // 0x4847c20;
	void MoveToActor(class AActor* Actor, float EndDistance, float Speed, bool UsePartialPath)	 // 0x484e7f4;
	void MoveToLocation(const struct FVector& Destination, const struct FVector& EndDirection, float EndDistance, float Speed, bool UsePartialPath)	 // 0x484edc8;
	void MoveToLocations(const TArray<struct FVector>& Destinations, const struct FVector& EndDirection, float EndDistance, float Speed, bool UsePartialPath)	 // 0x484f59c;
	void NavLinkComplete()	 // 0x484f9dc;
	bool OverrideSpeedMultiplier(const float NewSpeedMultiplier)	 // 0x4849c64;
	void PauseNavigation()	 // 0x484fc74;
	void ResumeNavigation()	 // 0x484fc8c;
	void SetAgentType(const struct FMercunaGroundAgentType& NewAgentType)	 // 0x484fca4;
	void SetAvoidanceAgainst(class AActor* Actor, bool Enable)	 // 0x4849dc4;
	void SetNavGrid(class AMercunaNavGroundGrid* NavGrid_0)	 // 0x484fd80;
	void SetNavGridToBest()	 // 0x484fe40;
	void SetUsageSpec(const struct FMercunaUsageSpec& NewUsageSpec)	 // 0x484a09c;
	void Stop()	 // 0x484fe54;
	void TrackActor(class AActor* Actor, float Distance, float Speed, const struct FVector& Offset, bool UsePartialPath)	 // 0x484fe78;
	void UpdateDynamicSteeringParams(const struct FMercunaGroundNavigationDynamicSteeringParameters& NewDynamicSteeringParams)	 // 0x485050c;

	struct FMercunaGroundNavigationConfiguration GetConfiguration() const	 // 0x484dc28;
	struct FMercunaGroundNavigationDynamicSteeringParameters GetDynamicSteeringParameters() const	 // 0x484dc5c;
	struct FVector GetLastInputVector() const	 // 0x484dcec;
	class AMercunaNavGroundGrid* GetNavGrid() const	 // 0x484dd50;
	void GetNextNavLink(bool* bNextNavLinkFound, float* DistanceToNextNavLink, float* TimeToNextNavLink, struct FVector* TraversalStart, struct FVector* TraversalEnd, bool* bIsAutoGenerated, class AMercunaNavLink** NavLink, struct FMercunaAutoNavLink* AutoGeneratedNavLink, float MaxLookAhead) const	 // 0x484dd68;
	struct FMercunaGroundNavigationSteeringParameters GetSteeringParameters() const	 // 0x484e138;
	EMerNavigationTrajectory GetTrajectory(struct FTrajectorySampleRange* TrajectorySampleRange, float LookAhead, int32 SampleRate, bool ReturnAbsoluteTimes) const	 // 0x484e160;
	const struct FMercunaUsageSpec GetUsageSpec() const	 // 0x4847a78;

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"MercunaGroundNavigationComponent">();
	}
	static class UMercunaGroundNavigationComponent* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UMercunaGroundNavigationComponent>();
	}
};
static_assert(alignof(UMercunaGroundNavigationComponent) == 0x000008, "Wrong alignment on UMercunaGroundNavigationComponent");
static_assert(sizeof(UMercunaGroundNavigationComponent) == 0x0002D0, "Wrong size on UMercunaGroundNavigationComponent");
static_assert(offsetof(UMercunaGroundNavigationComponent, OnSwimStarted) == 0x000250, "Member 'UMercunaGroundNavigationComponent::OnSwimStarted' has a wrong offset!");
static_assert(offsetof(UMercunaGroundNavigationComponent, OnSwimStopped) == 0x000260, "Member 'UMercunaGroundNavigationComponent::OnSwimStopped' has a wrong offset!");
static_assert(offsetof(UMercunaGroundNavigationComponent, NavGrid) == 0x000270, "Member 'UMercunaGroundNavigationComponent::NavGrid' has a wrong offset!");
static_assert(offsetof(UMercunaGroundNavigationComponent, AgentType) == 0x000278, "Member 'UMercunaGroundNavigationComponent::AgentType' has a wrong offset!");
static_assert(offsetof(UMercunaGroundNavigationComponent, bAutomaticSteeringParameters) == 0x000284, "Member 'UMercunaGroundNavigationComponent::bAutomaticSteeringParameters' has a wrong offset!");
static_assert(offsetof(UMercunaGroundNavigationComponent, SteeringParameters) == 0x000288, "Member 'UMercunaGroundNavigationComponent::SteeringParameters' has a wrong offset!");
static_assert(offsetof(UMercunaGroundNavigationComponent, bSetCharacterControllerRotation) == 0x0002A8, "Member 'UMercunaGroundNavigationComponent::bSetCharacterControllerRotation' has a wrong offset!");
static_assert(offsetof(UMercunaGroundNavigationComponent, Configuration) == 0x0002AC, "Member 'UMercunaGroundNavigationComponent::Configuration' has a wrong offset!");

// Class Mercuna.Mercuna2DQueryGenerator
// 0x0010 (0x0060 - 0x0050)
class UMercuna2DQueryGenerator : public UEnvQueryGenerator
{
public:
	TSubclassOf<class APawn>                      AgentClass;                                        // 0x0050(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_58[0x8];                                       // 0x0058(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"Mercuna2DQueryGenerator">();
	}
	static class UMercuna2DQueryGenerator* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UMercuna2DQueryGenerator>();
	}
};
static_assert(alignof(UMercuna2DQueryGenerator) == 0x000008, "Wrong alignment on UMercuna2DQueryGenerator");
static_assert(sizeof(UMercuna2DQueryGenerator) == 0x000060, "Wrong size on UMercuna2DQueryGenerator");
static_assert(offsetof(UMercuna2DQueryGenerator, AgentClass) == 0x000050, "Member 'UMercuna2DQueryGenerator::AgentClass' has a wrong offset!");

// Class Mercuna.EnvQueryGenerator_Mercuna_2DNavGrid
// 0x00E8 (0x0148 - 0x0060)
class UEnvQueryGenerator_Mercuna_2DNavGrid : public UMercuna2DQueryGenerator
{
public:
	struct FAIDataProviderFloatValue              MaxDistance;                                       // 0x0060(0x0038)(Edit, DisableEditOnInstance, ContainsInstancedReference, NativeAccessSpecifierPublic)
	struct FAIDataProviderBoolValue               MaxDistanceIsPathDistance;                         // 0x0098(0x0038)(Edit, DisableEditOnInstance, ContainsInstancedReference, NativeAccessSpecifierPublic)
	struct FAIDataProviderFloatValue              SpaceBetween;                                      // 0x00D0(0x0038)(Edit, DisableEditOnInstance, ContainsInstancedReference, NativeAccessSpecifierPublic)
	TSubclassOf<class UEnvQueryContext>           Centre;                                            // 0x0108(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FAIDataProviderBoolValue               AlignPointsToCenter;                               // 0x0110(0x0038)(Edit, DisableEditOnInstance, ContainsInstancedReference, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"EnvQueryGenerator_Mercuna_2DNavGrid">();
	}
	static class UEnvQueryGenerator_Mercuna_2DNavGrid* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UEnvQueryGenerator_Mercuna_2DNavGrid>();
	}
};
static_assert(alignof(UEnvQueryGenerator_Mercuna_2DNavGrid) == 0x000008, "Wrong alignment on UEnvQueryGenerator_Mercuna_2DNavGrid");
static_assert(sizeof(UEnvQueryGenerator_Mercuna_2DNavGrid) == 0x000148, "Wrong size on UEnvQueryGenerator_Mercuna_2DNavGrid");
static_assert(offsetof(UEnvQueryGenerator_Mercuna_2DNavGrid, MaxDistance) == 0x000060, "Member 'UEnvQueryGenerator_Mercuna_2DNavGrid::MaxDistance' has a wrong offset!");
static_assert(offsetof(UEnvQueryGenerator_Mercuna_2DNavGrid, MaxDistanceIsPathDistance) == 0x000098, "Member 'UEnvQueryGenerator_Mercuna_2DNavGrid::MaxDistanceIsPathDistance' has a wrong offset!");
static_assert(offsetof(UEnvQueryGenerator_Mercuna_2DNavGrid, SpaceBetween) == 0x0000D0, "Member 'UEnvQueryGenerator_Mercuna_2DNavGrid::SpaceBetween' has a wrong offset!");
static_assert(offsetof(UEnvQueryGenerator_Mercuna_2DNavGrid, Centre) == 0x000108, "Member 'UEnvQueryGenerator_Mercuna_2DNavGrid::Centre' has a wrong offset!");
static_assert(offsetof(UEnvQueryGenerator_Mercuna_2DNavGrid, AlignPointsToCenter) == 0x000110, "Member 'UEnvQueryGenerator_Mercuna_2DNavGrid::AlignPointsToCenter' has a wrong offset!");

// Class Mercuna.EnvQueryGenerator_Mercuna_GroundNavGrid
// 0x0008 (0x0150 - 0x0148)
class UEnvQueryGenerator_Mercuna_GroundNavGrid final : public UEnvQueryGenerator_Mercuna_2DNavGrid
{
public:
	EMercunaNavLinkQueryMode                      FollowNavLinks;                                    // 0x0148(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_149[0x7];                                      // 0x0149(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"EnvQueryGenerator_Mercuna_GroundNavGrid">();
	}
	static class UEnvQueryGenerator_Mercuna_GroundNavGrid* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UEnvQueryGenerator_Mercuna_GroundNavGrid>();
	}
};
static_assert(alignof(UEnvQueryGenerator_Mercuna_GroundNavGrid) == 0x000008, "Wrong alignment on UEnvQueryGenerator_Mercuna_GroundNavGrid");
static_assert(sizeof(UEnvQueryGenerator_Mercuna_GroundNavGrid) == 0x000150, "Wrong size on UEnvQueryGenerator_Mercuna_GroundNavGrid");
static_assert(offsetof(UEnvQueryGenerator_Mercuna_GroundNavGrid, FollowNavLinks) == 0x000148, "Member 'UEnvQueryGenerator_Mercuna_GroundNavGrid::FollowNavLinks' has a wrong offset!");

// Class Mercuna.MercunaNavGraph
// 0x01F0 (0x04A0 - 0x02B0)
class AMercunaNavGraph : public AActor
{
public:
	float                                         CellSize;                                          // 0x02B0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECollisionChannel                             GeometryCollisionChannel;                          // 0x02B4(0x0001)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2B5[0x3];                                      // 0x02B5(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   ExcludeTag;                                        // 0x02B8(0x0008)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bNeverSave;                                        // 0x02C0(0x0001)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAllowNavGraphMerging;                             // 0x02C1(0x0001)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDisablePartitionOfNavData;                        // 0x02C2(0x0001)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C3[0x1];                                      // 0x02C3(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	struct FIntVector                             GenerationBoxesPerChunk;                           // 0x02C4(0x000C)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bRecordGeometryCollectionStatistics;               // 0x02D0(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2D1[0xF];                                      // 0x02D1(0x000F)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bBuildAsSublevel;                                  // 0x02E0(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bUsingChunks;                                      // 0x02E1(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bNeedsRebuild;                                     // 0x02E2(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2E3[0xD];                                      // 0x02E3(0x000D)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             BuildTransform;                                    // 0x02F0(0x0060)(IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_350[0xF8];                                     // 0x0350(0x00F8)(Fixing Size After Last Property [ Dumper-7 ])
	class UMerNavGraphRenderingComponent*         MerNavGraphRenderingComponent;                     // 0x0448(0x0008)(Edit, ExportObject, ZeroConstructor, Transient, EditConst, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_450[0x50];                                     // 0x0450(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SaveToFile(const class FString& Filename) const	 // 0x485d030;

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"MercunaNavGraph">();
	}
	static class AMercunaNavGraph* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<AMercunaNavGraph>();
	}
};
static_assert(alignof(AMercunaNavGraph) == 0x000010, "Wrong alignment on AMercunaNavGraph");
static_assert(sizeof(AMercunaNavGraph) == 0x0004A0, "Wrong size on AMercunaNavGraph");
static_assert(offsetof(AMercunaNavGraph, CellSize) == 0x0002B0, "Member 'AMercunaNavGraph::CellSize' has a wrong offset!");
static_assert(offsetof(AMercunaNavGraph, GeometryCollisionChannel) == 0x0002B4, "Member 'AMercunaNavGraph::GeometryCollisionChannel' has a wrong offset!");
static_assert(offsetof(AMercunaNavGraph, ExcludeTag) == 0x0002B8, "Member 'AMercunaNavGraph::ExcludeTag' has a wrong offset!");
static_assert(offsetof(AMercunaNavGraph, bNeverSave) == 0x0002C0, "Member 'AMercunaNavGraph::bNeverSave' has a wrong offset!");
static_assert(offsetof(AMercunaNavGraph, bAllowNavGraphMerging) == 0x0002C1, "Member 'AMercunaNavGraph::bAllowNavGraphMerging' has a wrong offset!");
static_assert(offsetof(AMercunaNavGraph, bDisablePartitionOfNavData) == 0x0002C2, "Member 'AMercunaNavGraph::bDisablePartitionOfNavData' has a wrong offset!");
static_assert(offsetof(AMercunaNavGraph, GenerationBoxesPerChunk) == 0x0002C4, "Member 'AMercunaNavGraph::GenerationBoxesPerChunk' has a wrong offset!");
static_assert(offsetof(AMercunaNavGraph, bRecordGeometryCollectionStatistics) == 0x0002D0, "Member 'AMercunaNavGraph::bRecordGeometryCollectionStatistics' has a wrong offset!");
static_assert(offsetof(AMercunaNavGraph, bBuildAsSublevel) == 0x0002E0, "Member 'AMercunaNavGraph::bBuildAsSublevel' has a wrong offset!");
static_assert(offsetof(AMercunaNavGraph, bUsingChunks) == 0x0002E1, "Member 'AMercunaNavGraph::bUsingChunks' has a wrong offset!");
static_assert(offsetof(AMercunaNavGraph, bNeedsRebuild) == 0x0002E2, "Member 'AMercunaNavGraph::bNeedsRebuild' has a wrong offset!");
static_assert(offsetof(AMercunaNavGraph, BuildTransform) == 0x0002F0, "Member 'AMercunaNavGraph::BuildTransform' has a wrong offset!");
static_assert(offsetof(AMercunaNavGraph, MerNavGraphRenderingComponent) == 0x000448, "Member 'AMercunaNavGraph::MerNavGraphRenderingComponent' has a wrong offset!");

// Class Mercuna.EnvQueryTest_Mercuna2D_PathLength
// 0x0080 (0x0290 - 0x0210)
class UEnvQueryTest_Mercuna2D_PathLength : public UMercuna2DQueryTest
{
public:
	TSubclassOf<class APawn>                      AgentClass;                                        // 0x0210(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FAIDataProviderFloatValue              MaxPathDistance;                                   // 0x0218(0x0038)(Edit, DisableEditOnInstance, ContainsInstancedReference, NativeAccessSpecifierPublic)
	struct FAIDataProviderFloatValue              ClampDistance;                                     // 0x0250(0x0038)(Edit, DisableEditOnInstance, ContainsInstancedReference, NativeAccessSpecifierPublic)
	TSubclassOf<class UEnvQueryContext>           Context;                                           // 0x0288(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"EnvQueryTest_Mercuna2D_PathLength">();
	}
	static class UEnvQueryTest_Mercuna2D_PathLength* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UEnvQueryTest_Mercuna2D_PathLength>();
	}
};
static_assert(alignof(UEnvQueryTest_Mercuna2D_PathLength) == 0x000008, "Wrong alignment on UEnvQueryTest_Mercuna2D_PathLength");
static_assert(sizeof(UEnvQueryTest_Mercuna2D_PathLength) == 0x000290, "Wrong size on UEnvQueryTest_Mercuna2D_PathLength");
static_assert(offsetof(UEnvQueryTest_Mercuna2D_PathLength, AgentClass) == 0x000210, "Member 'UEnvQueryTest_Mercuna2D_PathLength::AgentClass' has a wrong offset!");
static_assert(offsetof(UEnvQueryTest_Mercuna2D_PathLength, MaxPathDistance) == 0x000218, "Member 'UEnvQueryTest_Mercuna2D_PathLength::MaxPathDistance' has a wrong offset!");
static_assert(offsetof(UEnvQueryTest_Mercuna2D_PathLength, ClampDistance) == 0x000250, "Member 'UEnvQueryTest_Mercuna2D_PathLength::ClampDistance' has a wrong offset!");
static_assert(offsetof(UEnvQueryTest_Mercuna2D_PathLength, Context) == 0x000288, "Member 'UEnvQueryTest_Mercuna2D_PathLength::Context' has a wrong offset!");

// Class Mercuna.EnvQueryTest_MercunaGround_PathLength
// 0x0008 (0x0298 - 0x0290)
class UEnvQueryTest_MercunaGround_PathLength final : public UEnvQueryTest_Mercuna2D_PathLength
{
public:
	EMercunaNavLinkQueryMode                      FollowNavLinks;                                    // 0x0290(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_291[0x7];                                      // 0x0291(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"EnvQueryTest_MercunaGround_PathLength">();
	}
	static class UEnvQueryTest_MercunaGround_PathLength* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UEnvQueryTest_MercunaGround_PathLength>();
	}
};
static_assert(alignof(UEnvQueryTest_MercunaGround_PathLength) == 0x000008, "Wrong alignment on UEnvQueryTest_MercunaGround_PathLength");
static_assert(sizeof(UEnvQueryTest_MercunaGround_PathLength) == 0x000298, "Wrong size on UEnvQueryTest_MercunaGround_PathLength");
static_assert(offsetof(UEnvQueryTest_MercunaGround_PathLength, FollowNavLinks) == 0x000290, "Member 'UEnvQueryTest_MercunaGround_PathLength::FollowNavLinks' has a wrong offset!");

// Class Mercuna.MercunaNavGraph2D
// 0x01B0 (0x0650 - 0x04A0)
#pragma pack(push, 0x1)
class alignas(0x10) AMercunaNavGraph2D : public AMercunaNavGraph
{
public:
	bool                                          bUsePhysicalMaterials;                             // 0x04A0(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4A1[0x7];                                      // 0x04A1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UPhysicalMaterial*>              PhysicalMaterialPriorities;                        // 0x04A8(0x0010)(Edit, ZeroConstructor, AdvancedDisplay, UObjectWrapper, NativeAccessSpecifierPublic)
	struct FMercunaSupportedAgentTypes            SupportedAgentTypes;                               // 0x04B8(0x00A8)(Edit, BlueprintVisible, BlueprintReadOnly, Config, ExposeOnSpawn, NativeAccessSpecifierPublic)
	bool                                          bUseNavSeeds;                                      // 0x0560(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_561[0x7];                                      // 0x0561(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TMulticastInlineDelegate<void()>              OnBeforeEditorBuild;                               // 0x0568(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NonPIEDuplicateTransient, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(bool Success)>  OnBuildComplete;                                   // 0x0578(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NonPIEDuplicateTransient, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(const class AActor* Volume, bool Success)> OnRebuildComplete;      // 0x0588(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NonPIEDuplicateTransient, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void()>              OnLoadComplete;                                    // 0x0598(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NonPIEDuplicateTransient, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(const struct FBox& Bounds)> OnChunkAdded;                          // 0x05A8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NonPIEDuplicateTransient, NativeAccessSpecifierPublic)
	EMerGridDebugDrawMode                         DebugDrawMode;                                     // 0x05B8(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EMerGridDebugDrawSubmode                      DebugDrawSubmode;                                  // 0x05B9(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_5BA[0x2];                                      // 0x05BA(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	struct FMercunaAgentType                      DebugDrawAgentType;                                // 0x05BC(0x000C)(Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<TSoftObjectPtr<class AMercunaNavLink>> NavLinks;                                          // 0x05C8(0x0010)(ZeroConstructor, Protected, UObjectWrapper, NativeAccessSpecifierProtected)
	uint32                                        NextMaterialId;                                    // 0x05D8(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_5DC[0x4];                                      // 0x05DC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<class UPhysicalMaterial*, uint32>        SurfaceMaterials;                                  // 0x05E0(0x0050)(Protected, NativeAccessSpecifierProtected)
	struct FVector                                NavLinkBorder;                                     // 0x0630(0x0018)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"MercunaNavGraph2D">();
	}
	static class AMercunaNavGraph2D* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<AMercunaNavGraph2D>();
	}
};
#pragma pack(pop)
static_assert(alignof(AMercunaNavGraph2D) == 0x000010, "Wrong alignment on AMercunaNavGraph2D");
static_assert(sizeof(AMercunaNavGraph2D) == 0x000650, "Wrong size on AMercunaNavGraph2D");
static_assert(offsetof(AMercunaNavGraph2D, bUsePhysicalMaterials) == 0x0004A0, "Member 'AMercunaNavGraph2D::bUsePhysicalMaterials' has a wrong offset!");
static_assert(offsetof(AMercunaNavGraph2D, PhysicalMaterialPriorities) == 0x0004A8, "Member 'AMercunaNavGraph2D::PhysicalMaterialPriorities' has a wrong offset!");
static_assert(offsetof(AMercunaNavGraph2D, SupportedAgentTypes) == 0x0004B8, "Member 'AMercunaNavGraph2D::SupportedAgentTypes' has a wrong offset!");
static_assert(offsetof(AMercunaNavGraph2D, bUseNavSeeds) == 0x000560, "Member 'AMercunaNavGraph2D::bUseNavSeeds' has a wrong offset!");
static_assert(offsetof(AMercunaNavGraph2D, OnBeforeEditorBuild) == 0x000568, "Member 'AMercunaNavGraph2D::OnBeforeEditorBuild' has a wrong offset!");
static_assert(offsetof(AMercunaNavGraph2D, OnBuildComplete) == 0x000578, "Member 'AMercunaNavGraph2D::OnBuildComplete' has a wrong offset!");
static_assert(offsetof(AMercunaNavGraph2D, OnRebuildComplete) == 0x000588, "Member 'AMercunaNavGraph2D::OnRebuildComplete' has a wrong offset!");
static_assert(offsetof(AMercunaNavGraph2D, OnLoadComplete) == 0x000598, "Member 'AMercunaNavGraph2D::OnLoadComplete' has a wrong offset!");
static_assert(offsetof(AMercunaNavGraph2D, OnChunkAdded) == 0x0005A8, "Member 'AMercunaNavGraph2D::OnChunkAdded' has a wrong offset!");
static_assert(offsetof(AMercunaNavGraph2D, DebugDrawMode) == 0x0005B8, "Member 'AMercunaNavGraph2D::DebugDrawMode' has a wrong offset!");
static_assert(offsetof(AMercunaNavGraph2D, DebugDrawSubmode) == 0x0005B9, "Member 'AMercunaNavGraph2D::DebugDrawSubmode' has a wrong offset!");
static_assert(offsetof(AMercunaNavGraph2D, DebugDrawAgentType) == 0x0005BC, "Member 'AMercunaNavGraph2D::DebugDrawAgentType' has a wrong offset!");
static_assert(offsetof(AMercunaNavGraph2D, NavLinks) == 0x0005C8, "Member 'AMercunaNavGraph2D::NavLinks' has a wrong offset!");
static_assert(offsetof(AMercunaNavGraph2D, NextMaterialId) == 0x0005D8, "Member 'AMercunaNavGraph2D::NextMaterialId' has a wrong offset!");
static_assert(offsetof(AMercunaNavGraph2D, SurfaceMaterials) == 0x0005E0, "Member 'AMercunaNavGraph2D::SurfaceMaterials' has a wrong offset!");
static_assert(offsetof(AMercunaNavGraph2D, NavLinkBorder) == 0x000630, "Member 'AMercunaNavGraph2D::NavLinkBorder' has a wrong offset!");

// Class Mercuna.MercunaNavGroundGrid
// 0x0040 (0x0690 - 0x0650)
#pragma pack(push, 0x1)
class alignas(0x10) AMercunaNavGroundGrid : public AMercunaNavGraph2D
{
public:
	bool                                          bCutOutStationaryObstacles;                        // 0x0648(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bGenerateJumpLinks;                                // 0x0649(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bWaterEnabled;                                     // 0x064A(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIgnoreCurbsDuringAutoJumpGeneration;              // 0x064B(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, IsPlainOldData, NoDestructor, AdvancedDisplay, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bSubCellRasterization;                             // 0x064C(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_64D[0x3];                                      // 0x064D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         RoughSurfacePerchFraction;                         // 0x0650(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bOverrideCellHeight;                               // 0x0654(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, IsPlainOldData, NoDestructor, AdvancedDisplay, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_655[0x3];                                      // 0x0655(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         CellHeightOverride;                                // 0x0658(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, IsPlainOldData, NoDestructor, AdvancedDisplay, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         NavInvokerUpdateFrequency;                         // 0x065C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FMercunaNavInvoker>             NavInvokers;                                       // 0x0660(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	TArray<class AMercunaNavInvokerVolume*>       NavInvokerVolumes;                                 // 0x0670(0x0010)(ZeroConstructor, Transient, UObjectWrapper, NativeAccessSpecifierPrivate)
	uint8                                         Pad_680[0x8];                                      // 0x0680(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Build(const TArray<struct FVector>& PriorityPositions)	 // 0x48535fc;
	void Create()	 // 0x17c7f2c;
	void DisableAutoGenNavLinksByIdentifier(const TArray<struct FMercunaNavLinkIdentifier>& Identifiers)	 // 0x4853d0c;
	void DisableAutoGenNavLinksInVolume(const struct FMercunaGroundAgentType& AgentType, const struct FBox& Volume)	 // 0x4853da8;
	void EnableAutoGenNavLinksByIdentifier(const TArray<struct FMercunaNavLinkIdentifier>& Identifiers)	 // 0x4853e98;
	void EnableAutoGenNavLinksInVolume(const struct FMercunaGroundAgentType& AgentType, const struct FBox& Volume)	 // 0x4853f34;
	class UMercunaPath* FindPathToLocation(const struct FMercunaGroundAgentType& AgentType, const TDelegate<void(EMercunaPathEvent PathEvent)>& OnPathUpdated, const struct FVector& Start, const struct FVector& StartDir, const struct FVector& End, float MinTurnRadius, float IdealTurnRadius, float MaxSpeed, bool AllowPartial, float MaxPathLength, float SlopePenalty, const struct FMercunaUsageSpec& UsageSpec)	 // 0x4854024;
	class UMercunaPath* FindPathToLocations(const struct FMercunaGroundAgentType& AgentType, const TDelegate<void(EMercunaPathEvent PathEvent)>& OnPathUpdated, const struct FVector& Start, const struct FVector& StartDir, const TArray<struct FVector>& Destinations, float MinTurnRadius, float IdealTurnRadius, float MaxSpeed, bool AllowPartial, float MaxPathLength, float SlopePenalty, const struct FMercunaUsageSpec& UsageSpec)	 // 0x4854a5c;
	class UMercunaSmoothPath* FindSmoothPathToLocation(const struct FMercunaGroundAgentType& AgentType, const TDelegate<void(EMercunaPathEvent PathEvent)>& OnPathUpdated, const struct FVector& Start, const struct FVector& StartDir, const struct FVector& End, float MinTurnRadius, float IdealTurnRadius, float MaxSpeed, float MaxSpeedReverse, bool AllowPartial, float MaxPathLength, float SlopePenalty, const struct FMercunaUsageSpec& UsageSpec)	 // 0x4855404;
	class UMercunaSmoothPath* FindSmoothPathToLocations(const struct FMercunaGroundAgentType& AgentType, const TDelegate<void(EMercunaPathEvent PathEvent)>& OnPathUpdated, const struct FVector& Start, const struct FVector& StartDir, const TArray<struct FVector>& Destinations, float MinTurnRadius, float IdealTurnRadius, float MaxSpeed, float MaxSpeedReverse, bool AllowPartial, float MaxPathLength, float SlopePenalty, const struct FMercunaUsageSpec& UsageSpec)	 // 0x4855f1c;
	void GenerateRandomPointsInBox(const struct FMercunaGroundAgentType& AgentType, const struct FBox& Volume, int32 NumPoints, TArray<struct FVector>* Results, const struct FRotator& Rotator, const struct FMercunaUsageSpec& UsageSpec, bool bIgnoreStationaryObstacles)	 // 0x48570d0;
	void RebuildChanges()	 // 0x485c824;
	void RebuildVolume(const class AActor* Volume, bool bApplyNavSeeds)	 // 0x485c83c;
	void RebuildVolumes(const TArray<struct FBox>& Volumes, bool bMergeVolumes, bool bOnlyUnbuilt, bool bApplyNavSeeds)	 // 0x485c984;
	void RegisterNavInvoker(class AActor* Actor, class FName AgentType, float GenerationRadius, float RemovalRadius)	 // 0x485ccf0;
	void UnregisterNavInvoker(class AActor* Actor)	 // 0x485d930;
	void UpdateAutoGenNavLinks(const TArray<struct FMercunaAutoNavLinkForUpdate>& LinksToUpdate)	 // 0x485da1c;

	void ClampToNavigable(const struct FMercunaGroundAgentType& AgentType, const struct FVector& Position, float SearchRadius, float HeightRange, bool* bResult, struct FVector* ClampedPosition, struct FMercunaUsageTypes* ClampedUsageTypes, const struct FMercunaUsageSpec& UsageSpec, bool bIgnoreStationaryObstacles) const	 // 0x485369c;
	void GenerateRandomPoints(const struct FMercunaGroundAgentType& AgentType, const struct FVector& Position, float MaxDistance, int32 NumPoints, TArray<struct FVector>* Results, bool MaxDistanceIsPathDistance, EMercunaNavLinkQueryMode FollowNavLinks, const struct FMercunaUsageSpec& UsageSpec, bool bIgnoreStationaryObstacles) const	 // 0x48569ac;
	void GetAutoGenNavLinksInVolume(const struct FMercunaGroundAgentType& AgentType, const struct FBox& Volume, TArray<struct FMercunaAutoNavLink>* Results) const	 // 0x48578d8;
	void GetClosestNavMeshEdge(const struct FMercunaGroundAgentType& AgentType, const struct FVector& Position, bool* bResult, struct FMercunaNavMeshEdge* ClosestEdge, struct FVector* ClosestPoint, const float MaxDistance, bool MaxDistanceIsPathDistance, EMercunaNavLinkQueryMode FollowNavLinks, const struct FMercunaUsageSpec& UsageSpec, bool bIgnoreStationaryObstacles) const	 // 0x4857a38;
	void GetClosestPosInWater(const struct FMercunaGroundAgentType& AgentType, const struct FVector& Position, bool* bResult, struct FVector* ClosestPosition, float MaxPathDistance, EMercunaNavLinkQueryMode FollowNavLinks, const struct FMercunaUsageSpec& UsageSpec, bool bIgnoreStationaryObstacles) const	 // 0x48581ec;
	void GetClosestPosOutOfWater(const struct FMercunaGroundAgentType& AgentType, const struct FVector& Position, bool* bResult, struct FVector* ClosestPosition, float MaxPathDistance, EMercunaNavLinkQueryMode FollowNavLinks, const struct FMercunaUsageSpec& UsageSpec, bool bIgnoreStationaryObstacles) const	 // 0x4858840;
	void GetNavMeshEdges(const struct FMercunaGroundAgentType& AgentType, const struct FVector& Position, const float MaxRadius, TArray<struct FMercunaNavMeshEdge>* NavMeshEdges, EMercunaNavLinkQueryMode FollowNavLinks, const struct FMercunaUsageSpec& UsageSpec, bool bIgnoreStationaryObstacles) const	 // 0x4858e94;
	int32 GetNumBoxesBuilding() const	 // 0x48593b8;
	void GetWaterEdges(const struct FMercunaGroundAgentType& AgentType, const struct FVector& Position, float MaxPathDistance, TArray<struct FMercunaNavEdge>* Edges, EMercunaNavLinkQueryMode FollowNavLinks, const struct FMercunaUsageSpec& UsageSpec, bool bIgnoreStationaryObstacles) const	 // 0x4859494;
	bool IsAnyWorkInProgress() const	 // 0x48599f0;
	bool IsBuilding() const	 // 0x4859a18;
	bool IsBuilt(const struct FMercunaGroundAgentType& AgentType, const struct FVector& Pos) const	 // 0x4859a40;
	bool IsBuiltWithinBox(const struct FMercunaGroundAgentType& AgentType, const struct FBox& Box) const	 // 0x4859ba0;
	void IsNavigable(const struct FMercunaGroundAgentType& AgentType, const struct FVector& Position, bool* bResult, const struct FMercunaUsageSpec& UsageSpec, bool bIgnoreStationaryObstacles) const	 // 0x4859ca0;
	void IsNavigableMulti(const struct FMercunaGroundAgentType& AgentType, const TArray<struct FVector>& Positions, TArray<bool>* Results, const struct FMercunaUsageSpec& UsageSpec, bool bIgnoreStationaryObstacles) const	 // 0x485a0bc;
	bool IsReachable(const struct FMercunaGroundAgentType& AgentType, const struct FVector& From, const struct FVector& To, float MaxPathLength, EMercunaNavLinkQueryMode FollowNavLinks, const struct FMercunaUsageSpec& UsageSpec, bool bIgnoreStationaryObstacles) const	 // 0x485a414;
	void IsReachableLatent(const struct FMercunaGroundAgentType& AgentType, const struct FVector& From, const TArray<struct FVector>& To, TArray<bool>* Result, TArray<struct FVector>* ClampedTo, class UObject* WorldContextObject, const struct FLatentActionInfo& LatentInfo, float MaxPathLength, float FromSearchRadius, float ToSearchRadius, EMercunaNavLinkQueryMode FollowNavLinks, const struct FMercunaUsageSpec& UsageSpec, bool bIgnoreStationaryObstacles) const	 // 0x485aa34;
	void ProjectToNavigable(const struct FMercunaGroundAgentType& AgentType, const struct FVector& Position, EMercunaProjectionDirection Direction, bool* bResult, struct FVector* ProjectedPosition, float SearchHeight, const struct FMercunaUsageSpec& UsageSpec, bool bIgnoreStationaryObstacles) const	 // 0x485bc7c;
	void Raycast(const struct FMercunaGroundAgentType& AgentType, const struct FVector& From, const struct FVector& To, bool* bRayHit, struct FVector* HitPosition, const struct FMercunaUsageSpec& UsageSpec, bool bIgnoreStationaryObstacles) const	 // 0x485c2bc;
	void SaveToObjFile(const struct FMercunaGroundAgentType& AgentType, bool bDrawPolyMesh) const	 // 0x485d110;

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"MercunaNavGroundGrid">();
	}
	static class AMercunaNavGroundGrid* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<AMercunaNavGroundGrid>();
	}
};
#pragma pack(pop)
static_assert(alignof(AMercunaNavGroundGrid) == 0x000010, "Wrong alignment on AMercunaNavGroundGrid");
static_assert(sizeof(AMercunaNavGroundGrid) == 0x000690, "Wrong size on AMercunaNavGroundGrid");
static_assert(offsetof(AMercunaNavGroundGrid, bCutOutStationaryObstacles) == 0x000648, "Member 'AMercunaNavGroundGrid::bCutOutStationaryObstacles' has a wrong offset!");
static_assert(offsetof(AMercunaNavGroundGrid, bGenerateJumpLinks) == 0x000649, "Member 'AMercunaNavGroundGrid::bGenerateJumpLinks' has a wrong offset!");
static_assert(offsetof(AMercunaNavGroundGrid, bWaterEnabled) == 0x00064A, "Member 'AMercunaNavGroundGrid::bWaterEnabled' has a wrong offset!");
static_assert(offsetof(AMercunaNavGroundGrid, bIgnoreCurbsDuringAutoJumpGeneration) == 0x00064B, "Member 'AMercunaNavGroundGrid::bIgnoreCurbsDuringAutoJumpGeneration' has a wrong offset!");
static_assert(offsetof(AMercunaNavGroundGrid, bSubCellRasterization) == 0x00064C, "Member 'AMercunaNavGroundGrid::bSubCellRasterization' has a wrong offset!");
static_assert(offsetof(AMercunaNavGroundGrid, RoughSurfacePerchFraction) == 0x000650, "Member 'AMercunaNavGroundGrid::RoughSurfacePerchFraction' has a wrong offset!");
static_assert(offsetof(AMercunaNavGroundGrid, bOverrideCellHeight) == 0x000654, "Member 'AMercunaNavGroundGrid::bOverrideCellHeight' has a wrong offset!");
static_assert(offsetof(AMercunaNavGroundGrid, CellHeightOverride) == 0x000658, "Member 'AMercunaNavGroundGrid::CellHeightOverride' has a wrong offset!");
static_assert(offsetof(AMercunaNavGroundGrid, NavInvokerUpdateFrequency) == 0x00065C, "Member 'AMercunaNavGroundGrid::NavInvokerUpdateFrequency' has a wrong offset!");
static_assert(offsetof(AMercunaNavGroundGrid, NavInvokers) == 0x000660, "Member 'AMercunaNavGroundGrid::NavInvokers' has a wrong offset!");
static_assert(offsetof(AMercunaNavGroundGrid, NavInvokerVolumes) == 0x000670, "Member 'AMercunaNavGroundGrid::NavInvokerVolumes' has a wrong offset!");

// Class Mercuna.MercunaObstacleComponent
// 0x0030 (0x0310 - 0x02E0)
class UMercunaObstacleComponent : public USceneComponent
{
public:
	bool                                          bAutomatic;                                        // 0x02E0(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EMercunaObstacleType                          Type;                                              // 0x02E1(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2E2[0x2];                                      // 0x02E2(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         SphereRadius;                                      // 0x02E4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                BoxSize;                                           // 0x02E8(0x0018)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CylinderRadius;                                    // 0x0300(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CylinderHeight;                                    // 0x0304(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EMercunaObstacleMovementType                  MovementType;                                      // 0x0308(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EMercunaObstacleReaction                      DefaultReaction;                                   // 0x0309(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCutOutWhenStationary;                             // 0x030A(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_30B[0x1];                                      // 0x030B(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         StationaryThresholdTime;                           // 0x030C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	void OnCharacterMovementModeChanged(class ACharacter* Character, EMovementMode PrevMovementMode, uint8 PreviousCustomMode)	 // 0x1155dd8;
	void UpdateMovementType(const EMercunaObstacleMovementType& NewMovementType)	 // 0x486b940;

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"MercunaObstacleComponent">();
	}
	static class UMercunaObstacleComponent* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UMercunaObstacleComponent>();
	}
};
static_assert(alignof(UMercunaObstacleComponent) == 0x000010, "Wrong alignment on UMercunaObstacleComponent");
static_assert(sizeof(UMercunaObstacleComponent) == 0x000310, "Wrong size on UMercunaObstacleComponent");
static_assert(offsetof(UMercunaObstacleComponent, bAutomatic) == 0x0002E0, "Member 'UMercunaObstacleComponent::bAutomatic' has a wrong offset!");
static_assert(offsetof(UMercunaObstacleComponent, Type) == 0x0002E1, "Member 'UMercunaObstacleComponent::Type' has a wrong offset!");
static_assert(offsetof(UMercunaObstacleComponent, SphereRadius) == 0x0002E4, "Member 'UMercunaObstacleComponent::SphereRadius' has a wrong offset!");
static_assert(offsetof(UMercunaObstacleComponent, BoxSize) == 0x0002E8, "Member 'UMercunaObstacleComponent::BoxSize' has a wrong offset!");
static_assert(offsetof(UMercunaObstacleComponent, CylinderRadius) == 0x000300, "Member 'UMercunaObstacleComponent::CylinderRadius' has a wrong offset!");
static_assert(offsetof(UMercunaObstacleComponent, CylinderHeight) == 0x000304, "Member 'UMercunaObstacleComponent::CylinderHeight' has a wrong offset!");
static_assert(offsetof(UMercunaObstacleComponent, MovementType) == 0x000308, "Member 'UMercunaObstacleComponent::MovementType' has a wrong offset!");
static_assert(offsetof(UMercunaObstacleComponent, DefaultReaction) == 0x000309, "Member 'UMercunaObstacleComponent::DefaultReaction' has a wrong offset!");
static_assert(offsetof(UMercunaObstacleComponent, bCutOutWhenStationary) == 0x00030A, "Member 'UMercunaObstacleComponent::bCutOutWhenStationary' has a wrong offset!");
static_assert(offsetof(UMercunaObstacleComponent, StationaryThresholdTime) == 0x00030C, "Member 'UMercunaObstacleComponent::StationaryThresholdTime' has a wrong offset!");

// Class Mercuna.EnvQueryTest_Mercuna2D_Navigable
// 0x0008 (0x0218 - 0x0210)
class UEnvQueryTest_Mercuna2D_Navigable : public UMercuna2DQueryTest
{
public:
	TSubclassOf<class APawn>                      AgentClass;                                        // 0x0210(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"EnvQueryTest_Mercuna2D_Navigable">();
	}
	static class UEnvQueryTest_Mercuna2D_Navigable* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UEnvQueryTest_Mercuna2D_Navigable>();
	}
};
static_assert(alignof(UEnvQueryTest_Mercuna2D_Navigable) == 0x000008, "Wrong alignment on UEnvQueryTest_Mercuna2D_Navigable");
static_assert(sizeof(UEnvQueryTest_Mercuna2D_Navigable) == 0x000218, "Wrong size on UEnvQueryTest_Mercuna2D_Navigable");
static_assert(offsetof(UEnvQueryTest_Mercuna2D_Navigable, AgentClass) == 0x000210, "Member 'UEnvQueryTest_Mercuna2D_Navigable::AgentClass' has a wrong offset!");

// Class Mercuna.MercunaVolumeComponent
// 0x0020 (0x05D0 - 0x05B0)
class UMercunaVolumeComponent : public UPrimitiveComponent
{
public:
	uint8                                         Pad_5A8[0x10];                                     // 0x05A8(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                Size;                                              // 0x05B8(0x0018)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"MercunaVolumeComponent">();
	}
	static class UMercunaVolumeComponent* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UMercunaVolumeComponent>();
	}
};
static_assert(alignof(UMercunaVolumeComponent) == 0x000010, "Wrong alignment on UMercunaVolumeComponent");
static_assert(sizeof(UMercunaVolumeComponent) == 0x0005D0, "Wrong size on UMercunaVolumeComponent");
static_assert(offsetof(UMercunaVolumeComponent, Size) == 0x0005B8, "Member 'UMercunaVolumeComponent::Size' has a wrong offset!");

// Class Mercuna.MercunaNavVolume
// 0x0018 (0x02C8 - 0x02B0)
class AMercunaNavVolume : public AActor
{
public:
	class UMercunaVolumeComponent*                VolumeComponent;                                   // 0x02B0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          PreciseBoundaries;                                 // 0x02B8(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2B9[0x7];                                      // 0x02B9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class AMercunaNavGraph*                       NavGraphPtr;                                       // 0x02C0(0x0008)(ZeroConstructor, Transient, NonTransactional, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void SetNavigationRotation(const struct FRotator& Rotation)	 // 0x486b790;
	void SetSize(const struct FVector& Size)	 // 0x486b83c;

	struct FVector GetSize() const	 // 0x4859418;

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"MercunaNavVolume">();
	}
	static class AMercunaNavVolume* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<AMercunaNavVolume>();
	}
};
static_assert(alignof(AMercunaNavVolume) == 0x000008, "Wrong alignment on AMercunaNavVolume");
static_assert(sizeof(AMercunaNavVolume) == 0x0002C8, "Wrong size on AMercunaNavVolume");
static_assert(offsetof(AMercunaNavVolume, VolumeComponent) == 0x0002B0, "Member 'AMercunaNavVolume::VolumeComponent' has a wrong offset!");
static_assert(offsetof(AMercunaNavVolume, PreciseBoundaries) == 0x0002B8, "Member 'AMercunaNavVolume::PreciseBoundaries' has a wrong offset!");
static_assert(offsetof(AMercunaNavVolume, NavGraphPtr) == 0x0002C0, "Member 'AMercunaNavVolume::NavGraphPtr' has a wrong offset!");

// Class Mercuna.MercunaNavModifierComponent
// 0x0010 (0x05E0 - 0x05D0)
class UMercunaNavModifierComponent : public UMercunaVolumeComponent
{
public:
	bool                                          bEnabled;                                          // 0x05D0(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_5D1[0x3];                                      // 0x05D1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FMercunaModifier                       Modifier;                                          // 0x05D4(0x0008)(Edit, NoDestructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_5DC[0x4];                                      // 0x05DC(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SetCostMultiplier(float NewCostMultiplier)	 // 0x4864720;
	void SetEnabled(bool Enabled)	 // 0x4864a3c;
	void SetSize(const struct FVector& NewSize)	 // 0x4864c70;
	void SetUsageTypes(const struct FMercunaUsageTypes& NewUsageTypes)	 // 0x4864e84;

	struct FVector GetSize() const	 // 0x4862ed0;

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"MercunaNavModifierComponent">();
	}
	static class UMercunaNavModifierComponent* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UMercunaNavModifierComponent>();
	}
};
static_assert(alignof(UMercunaNavModifierComponent) == 0x000010, "Wrong alignment on UMercunaNavModifierComponent");
static_assert(sizeof(UMercunaNavModifierComponent) == 0x0005E0, "Wrong size on UMercunaNavModifierComponent");
static_assert(offsetof(UMercunaNavModifierComponent, bEnabled) == 0x0005D0, "Member 'UMercunaNavModifierComponent::bEnabled' has a wrong offset!");
static_assert(offsetof(UMercunaNavModifierComponent, Modifier) == 0x0005D4, "Member 'UMercunaNavModifierComponent::Modifier' has a wrong offset!");

// Class Mercuna.EnvQueryTest_Mercuna3D_Clamp
// 0x0038 (0x0240 - 0x0208)
class UEnvQueryTest_Mercuna3D_Clamp final : public UMercuna3DQueryTest
{
public:
	struct FAIDataProviderFloatValue              MaxSearchRadius;                                   // 0x0208(0x0038)(Edit, DisableEditOnInstance, ContainsInstancedReference, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"EnvQueryTest_Mercuna3D_Clamp">();
	}
	static class UEnvQueryTest_Mercuna3D_Clamp* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UEnvQueryTest_Mercuna3D_Clamp>();
	}
};
static_assert(alignof(UEnvQueryTest_Mercuna3D_Clamp) == 0x000008, "Wrong alignment on UEnvQueryTest_Mercuna3D_Clamp");
static_assert(sizeof(UEnvQueryTest_Mercuna3D_Clamp) == 0x000240, "Wrong size on UEnvQueryTest_Mercuna3D_Clamp");
static_assert(offsetof(UEnvQueryTest_Mercuna3D_Clamp, MaxSearchRadius) == 0x000208, "Member 'UEnvQueryTest_Mercuna3D_Clamp::MaxSearchRadius' has a wrong offset!");

// Class Mercuna.MercunaNavGridModifierComponent
// 0x00A0 (0x0680 - 0x05E0)
#pragma pack(push, 0x1)
class alignas(0x10) UMercunaNavGridModifierComponent : public UMercunaNavModifierComponent
{
public:
	TSoftObjectPtr<class AMercunaNavGraph2D>      NavGrid;                                           // 0x05E0(0x0030)(Edit, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EMercunaModifierVolumeShape                   Shape;                                             // 0x0610(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_611[0x7];                                      // 0x0611(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FVector2D>                      PrismVertices;                                     // 0x0618(0x0010)(ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	TMap<struct FMercunaAgentType, struct FMercunaModifier> PerAgentTypeModifiers;                   // 0x0628(0x0050)(Edit, Protected, NativeAccessSpecifierProtected)

public:
	void AddToGrid(class AMercunaNavGraph2D* NewNavGrid, bool bRebuildGraph)	 // 0x4853478;
	void OverrideCostMultiplier(const struct FMercunaAgentType& AgentType, float NewCostMultiplier)	 // 0x485b91c;
	void OverrideUsageTypes(const struct FMercunaAgentType& AgentType, const struct FMercunaUsageTypes& NewUsageTypes)	 // 0x485bb90;
	void RemoveFromGrid(bool bRebuildGraph)	 // 0x485cf6c;
	void SetPrismVertices(const TArray<struct FVector2D>& NewVertices)	 // 0x485d4a4;
	void SetShape(EMercunaModifierVolumeShape NewShape)	 // 0x485d610;

	EMercunaModifierVolumeShape GetShape() const	 // 0x4859400;

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"MercunaNavGridModifierComponent">();
	}
	static class UMercunaNavGridModifierComponent* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UMercunaNavGridModifierComponent>();
	}
};
#pragma pack(pop)
static_assert(alignof(UMercunaNavGridModifierComponent) == 0x000010, "Wrong alignment on UMercunaNavGridModifierComponent");
static_assert(sizeof(UMercunaNavGridModifierComponent) == 0x000680, "Wrong size on UMercunaNavGridModifierComponent");
static_assert(offsetof(UMercunaNavGridModifierComponent, NavGrid) == 0x0005E0, "Member 'UMercunaNavGridModifierComponent::NavGrid' has a wrong offset!");
static_assert(offsetof(UMercunaNavGridModifierComponent, Shape) == 0x000610, "Member 'UMercunaNavGridModifierComponent::Shape' has a wrong offset!");
static_assert(offsetof(UMercunaNavGridModifierComponent, PrismVertices) == 0x000618, "Member 'UMercunaNavGridModifierComponent::PrismVertices' has a wrong offset!");
static_assert(offsetof(UMercunaNavGridModifierComponent, PerAgentTypeModifiers) == 0x000628, "Member 'UMercunaNavGridModifierComponent::PerAgentTypeModifiers' has a wrong offset!");

// Class Mercuna.Mercuna3DTrackActorProxy
// 0x0048 (0x0078 - 0x0030)
class UMercuna3DTrackActorProxy final : public UBlueprintAsyncActionBase
{
public:
	TMulticastInlineDelegate<void()>              OnFailure;                                         // 0x0030(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	class APawn*                                  Pawn;                                              // 0x0040(0x0008)(ZeroConstructor, Transient, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_48[0x30];                                      // 0x0048(0x0030)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UMercuna3DTrackActorProxy* TrackActor(class UObject* WorldContextObject, class APawn* Pawn_0, class AActor* Actor, float Distance, float Speed, const struct FVector& Offset)	 // 0x484a3bc;

	void OnMoveComplete(const struct FAIRequestID& RequestID, EMercunaMoveResult Result)	 // 0x4849b24;

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"Mercuna3DTrackActorProxy">();
	}
	static class UMercuna3DTrackActorProxy* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UMercuna3DTrackActorProxy>();
	}
};
static_assert(alignof(UMercuna3DTrackActorProxy) == 0x000008, "Wrong alignment on UMercuna3DTrackActorProxy");
static_assert(sizeof(UMercuna3DTrackActorProxy) == 0x000078, "Wrong size on UMercuna3DTrackActorProxy");
static_assert(offsetof(UMercuna3DTrackActorProxy, OnFailure) == 0x000030, "Member 'UMercuna3DTrackActorProxy::OnFailure' has a wrong offset!");
static_assert(offsetof(UMercuna3DTrackActorProxy, Pawn) == 0x000040, "Member 'UMercuna3DTrackActorProxy::Pawn' has a wrong offset!");

// Class Mercuna.Mercuna3DTask_MoveTo
// 0x0098 (0x0108 - 0x0070)
class UMercuna3DTask_MoveTo final : public UAITask
{
public:
	TMulticastInlineDelegate<void()>              OnRequestFailed;                                   // 0x0070(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, Protected, NativeAccessSpecifierProtected)
	TMulticastInlineDelegate<void(EMercunaMoveResult Result, class AAIController* AIController)> OnMoveFinished; // 0x0080(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_90[0x78];                                      // 0x0090(0x0078)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UMercuna3DTask_MoveTo* MoveTo(class AAIController* Controller, const struct FVector& GoalLocation, class AActor* GoalActor, float EndDistance, bool AcceptPartialPath, bool bLockAILogic)	 // 0x4848368;

	void OnMoveComplete(const struct FAIRequestID& RequestID, EMercunaMoveResult Result)	 // 0x48499e0;

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"Mercuna3DTask_MoveTo">();
	}
	static class UMercuna3DTask_MoveTo* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UMercuna3DTask_MoveTo>();
	}
};
static_assert(alignof(UMercuna3DTask_MoveTo) == 0x000008, "Wrong alignment on UMercuna3DTask_MoveTo");
static_assert(sizeof(UMercuna3DTask_MoveTo) == 0x000108, "Wrong size on UMercuna3DTask_MoveTo");
static_assert(offsetof(UMercuna3DTask_MoveTo, OnRequestFailed) == 0x000070, "Member 'UMercuna3DTask_MoveTo::OnRequestFailed' has a wrong offset!");
static_assert(offsetof(UMercuna3DTask_MoveTo, OnMoveFinished) == 0x000080, "Member 'UMercuna3DTask_MoveTo::OnMoveFinished' has a wrong offset!");

// Class Mercuna.MercunaBlueprintLibrary
// 0x0000 (0x0028 - 0x0028)
class UMercunaBlueprintLibrary final : public UBlueprintFunctionLibrary
{
public:
	static void ClearDebugActor()	 // 0x4847700;
	static bool HasUsageType(const struct FMercunaUsageTypes& UsageTypes, class FName UsageTypeName)	 // 0x4847a90;
	static void MercunaFlushLog()	 // 0x4848290;
	static void MercunaLog(const class FString& Message)	 // 0x48482b0;
	static void SetDebugActor(class AActor* Actor)	 // 0x4849f0c;

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"MercunaBlueprintLibrary">();
	}
	static class UMercunaBlueprintLibrary* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UMercunaBlueprintLibrary>();
	}
};
static_assert(alignof(UMercunaBlueprintLibrary) == 0x000008, "Wrong alignment on UMercunaBlueprintLibrary");
static_assert(sizeof(UMercunaBlueprintLibrary) == 0x000028, "Wrong size on UMercunaBlueprintLibrary");

// Class Mercuna.BTDecorator_Mercuna3D_Reachable
// 0x0058 (0x00C0 - 0x0068)
class UBTDecorator_Mercuna3D_Reachable final : public UBTDecorator
{
public:
	struct FBlackboardKeySelector                 Source;                                            // 0x0068(0x0028)(Edit, Protected, NativeAccessSpecifierProtected)
	struct FBlackboardKeySelector                 Destination;                                       // 0x0090(0x0028)(Edit, Protected, NativeAccessSpecifierProtected)
	float                                         MaxPathLength;                                     // 0x00B8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_BC[0x4];                                       // 0x00BC(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"BTDecorator_Mercuna3D_Reachable">();
	}
	static class UBTDecorator_Mercuna3D_Reachable* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UBTDecorator_Mercuna3D_Reachable>();
	}
};
static_assert(alignof(UBTDecorator_Mercuna3D_Reachable) == 0x000008, "Wrong alignment on UBTDecorator_Mercuna3D_Reachable");
static_assert(sizeof(UBTDecorator_Mercuna3D_Reachable) == 0x0000C0, "Wrong size on UBTDecorator_Mercuna3D_Reachable");
static_assert(offsetof(UBTDecorator_Mercuna3D_Reachable, Source) == 0x000068, "Member 'UBTDecorator_Mercuna3D_Reachable::Source' has a wrong offset!");
static_assert(offsetof(UBTDecorator_Mercuna3D_Reachable, Destination) == 0x000090, "Member 'UBTDecorator_Mercuna3D_Reachable::Destination' has a wrong offset!");
static_assert(offsetof(UBTDecorator_Mercuna3D_Reachable, MaxPathLength) == 0x0000B8, "Member 'UBTDecorator_Mercuna3D_Reachable::MaxPathLength' has a wrong offset!");

// Class Mercuna.BTTask_Mercuna3D_MoveTo
// 0x0010 (0x00A8 - 0x0098)
class UBTTask_Mercuna3D_MoveTo final : public UBTTask_BlackboardBase
{
public:
	float                                         Speed;                                             // 0x0098(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         EndDistance;                                       // 0x009C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bObserveBlackboardValue : 1;                       // 0x00A0(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bAllowPartialPath : 1;                             // 0x00A0(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bAvoidTargetActor : 1;                             // 0x00A0(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Edit, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_A1[0x7];                                       // 0x00A1(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"BTTask_Mercuna3D_MoveTo">();
	}
	static class UBTTask_Mercuna3D_MoveTo* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UBTTask_Mercuna3D_MoveTo>();
	}
};
static_assert(alignof(UBTTask_Mercuna3D_MoveTo) == 0x000008, "Wrong alignment on UBTTask_Mercuna3D_MoveTo");
static_assert(sizeof(UBTTask_Mercuna3D_MoveTo) == 0x0000A8, "Wrong size on UBTTask_Mercuna3D_MoveTo");
static_assert(offsetof(UBTTask_Mercuna3D_MoveTo, Speed) == 0x000098, "Member 'UBTTask_Mercuna3D_MoveTo::Speed' has a wrong offset!");
static_assert(offsetof(UBTTask_Mercuna3D_MoveTo, EndDistance) == 0x00009C, "Member 'UBTTask_Mercuna3D_MoveTo::EndDistance' has a wrong offset!");

// Class Mercuna.BTTask_MercunaSurface_MoveTo
// 0x0010 (0x00A8 - 0x0098)
class UBTTask_MercunaSurface_MoveTo final : public UBTTask_BlackboardBase
{
public:
	float                                         Speed;                                             // 0x0098(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         EndDistance;                                       // 0x009C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bObserveBlackboardValue : 1;                       // 0x00A0(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bAllowPartialPath : 1;                             // 0x00A0(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bAvoidTargetActor : 1;                             // 0x00A0(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Edit, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bUseEndActorOrientation : 1;                       // 0x00A0(0x0001)(BitIndex: 0x03, PropSize: 0x0001 (Edit, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_A1[0x7];                                       // 0x00A1(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"BTTask_MercunaSurface_MoveTo">();
	}
	static class UBTTask_MercunaSurface_MoveTo* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UBTTask_MercunaSurface_MoveTo>();
	}
};
static_assert(alignof(UBTTask_MercunaSurface_MoveTo) == 0x000008, "Wrong alignment on UBTTask_MercunaSurface_MoveTo");
static_assert(sizeof(UBTTask_MercunaSurface_MoveTo) == 0x0000A8, "Wrong size on UBTTask_MercunaSurface_MoveTo");
static_assert(offsetof(UBTTask_MercunaSurface_MoveTo, Speed) == 0x000098, "Member 'UBTTask_MercunaSurface_MoveTo::Speed' has a wrong offset!");
static_assert(offsetof(UBTTask_MercunaSurface_MoveTo, EndDistance) == 0x00009C, "Member 'UBTTask_MercunaSurface_MoveTo::EndDistance' has a wrong offset!");

// Class Mercuna.EnvQueryGenerator_Mercuna_2DRandom
// 0x00B0 (0x0110 - 0x0060)
class UEnvQueryGenerator_Mercuna_2DRandom : public UMercuna2DQueryGenerator
{
public:
	struct FAIDataProviderFloatValue              MaxDistance;                                       // 0x0060(0x0038)(Edit, DisableEditOnInstance, ContainsInstancedReference, NativeAccessSpecifierPublic)
	struct FAIDataProviderBoolValue               MaxDistanceIsPathDistance;                         // 0x0098(0x0038)(Edit, DisableEditOnInstance, ContainsInstancedReference, NativeAccessSpecifierPublic)
	struct FAIDataProviderIntValue                NumberOfPoints;                                    // 0x00D0(0x0038)(Edit, DisableEditOnInstance, ContainsInstancedReference, NativeAccessSpecifierPublic)
	TSubclassOf<class UEnvQueryContext>           Centre;                                            // 0x0108(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"EnvQueryGenerator_Mercuna_2DRandom">();
	}
	static class UEnvQueryGenerator_Mercuna_2DRandom* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UEnvQueryGenerator_Mercuna_2DRandom>();
	}
};
static_assert(alignof(UEnvQueryGenerator_Mercuna_2DRandom) == 0x000008, "Wrong alignment on UEnvQueryGenerator_Mercuna_2DRandom");
static_assert(sizeof(UEnvQueryGenerator_Mercuna_2DRandom) == 0x000110, "Wrong size on UEnvQueryGenerator_Mercuna_2DRandom");
static_assert(offsetof(UEnvQueryGenerator_Mercuna_2DRandom, MaxDistance) == 0x000060, "Member 'UEnvQueryGenerator_Mercuna_2DRandom::MaxDistance' has a wrong offset!");
static_assert(offsetof(UEnvQueryGenerator_Mercuna_2DRandom, MaxDistanceIsPathDistance) == 0x000098, "Member 'UEnvQueryGenerator_Mercuna_2DRandom::MaxDistanceIsPathDistance' has a wrong offset!");
static_assert(offsetof(UEnvQueryGenerator_Mercuna_2DRandom, NumberOfPoints) == 0x0000D0, "Member 'UEnvQueryGenerator_Mercuna_2DRandom::NumberOfPoints' has a wrong offset!");
static_assert(offsetof(UEnvQueryGenerator_Mercuna_2DRandom, Centre) == 0x000108, "Member 'UEnvQueryGenerator_Mercuna_2DRandom::Centre' has a wrong offset!");

// Class Mercuna.EnvQueryGenerator_Mercuna_Sphere
// 0x00F0 (0x0140 - 0x0050)
class UEnvQueryGenerator_Mercuna_Sphere final : public UEnvQueryGenerator
{
public:
	struct FAIDataProviderFloatValue              InnerRadius;                                       // 0x0050(0x0038)(Edit, DisableEditOnInstance, ContainsInstancedReference, NativeAccessSpecifierPublic)
	struct FAIDataProviderFloatValue              OuterRadius;                                       // 0x0088(0x0038)(Edit, DisableEditOnInstance, ContainsInstancedReference, NativeAccessSpecifierPublic)
	struct FAIDataProviderIntValue                NumberOfShells;                                    // 0x00C0(0x0038)(Edit, DisableEditOnInstance, ContainsInstancedReference, NativeAccessSpecifierPublic)
	struct FAIDataProviderIntValue                PointsPerShell;                                    // 0x00F8(0x0038)(Edit, DisableEditOnInstance, ContainsInstancedReference, NativeAccessSpecifierPublic)
	EMercunaPointDistribution                     Distribution;                                      // 0x0130(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_131[0x7];                                      // 0x0131(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class UEnvQueryContext>           Center;                                            // 0x0138(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"EnvQueryGenerator_Mercuna_Sphere">();
	}
	static class UEnvQueryGenerator_Mercuna_Sphere* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UEnvQueryGenerator_Mercuna_Sphere>();
	}
};
static_assert(alignof(UEnvQueryGenerator_Mercuna_Sphere) == 0x000008, "Wrong alignment on UEnvQueryGenerator_Mercuna_Sphere");
static_assert(sizeof(UEnvQueryGenerator_Mercuna_Sphere) == 0x000140, "Wrong size on UEnvQueryGenerator_Mercuna_Sphere");
static_assert(offsetof(UEnvQueryGenerator_Mercuna_Sphere, InnerRadius) == 0x000050, "Member 'UEnvQueryGenerator_Mercuna_Sphere::InnerRadius' has a wrong offset!");
static_assert(offsetof(UEnvQueryGenerator_Mercuna_Sphere, OuterRadius) == 0x000088, "Member 'UEnvQueryGenerator_Mercuna_Sphere::OuterRadius' has a wrong offset!");
static_assert(offsetof(UEnvQueryGenerator_Mercuna_Sphere, NumberOfShells) == 0x0000C0, "Member 'UEnvQueryGenerator_Mercuna_Sphere::NumberOfShells' has a wrong offset!");
static_assert(offsetof(UEnvQueryGenerator_Mercuna_Sphere, PointsPerShell) == 0x0000F8, "Member 'UEnvQueryGenerator_Mercuna_Sphere::PointsPerShell' has a wrong offset!");
static_assert(offsetof(UEnvQueryGenerator_Mercuna_Sphere, Distribution) == 0x000130, "Member 'UEnvQueryGenerator_Mercuna_Sphere::Distribution' has a wrong offset!");
static_assert(offsetof(UEnvQueryGenerator_Mercuna_Sphere, Center) == 0x000138, "Member 'UEnvQueryGenerator_Mercuna_Sphere::Center' has a wrong offset!");

// Class Mercuna.EnvQueryGenerator_Mercuna_3DRing
// 0x0190 (0x01E0 - 0x0050)
class UEnvQueryGenerator_Mercuna_3DRing final : public UEnvQueryGenerator
{
public:
	struct FAIDataProviderFloatValue              InnerRadius;                                       // 0x0050(0x0038)(Edit, DisableEditOnInstance, ContainsInstancedReference, NativeAccessSpecifierPublic)
	struct FAIDataProviderFloatValue              OuterRadius;                                       // 0x0088(0x0038)(Edit, DisableEditOnInstance, ContainsInstancedReference, NativeAccessSpecifierPublic)
	struct FAIDataProviderIntValue                NumberOfRings;                                     // 0x00C0(0x0038)(Edit, DisableEditOnInstance, ContainsInstancedReference, NativeAccessSpecifierPublic)
	struct FAIDataProviderIntValue                PointsPerRing;                                     // 0x00F8(0x0038)(Edit, DisableEditOnInstance, ContainsInstancedReference, NativeAccessSpecifierPublic)
	struct FAIDataProviderFloatValue              MinHeight;                                         // 0x0130(0x0038)(Edit, DisableEditOnInstance, ContainsInstancedReference, NativeAccessSpecifierPublic)
	struct FAIDataProviderFloatValue              MaxHeight;                                         // 0x0168(0x0038)(Edit, DisableEditOnInstance, ContainsInstancedReference, NativeAccessSpecifierPublic)
	struct FAIDataProviderIntValue                NumberOfLayers;                                    // 0x01A0(0x0038)(Edit, DisableEditOnInstance, ContainsInstancedReference, NativeAccessSpecifierPublic)
	TSubclassOf<class UEnvQueryContext>           Center;                                            // 0x01D8(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"EnvQueryGenerator_Mercuna_3DRing">();
	}
	static class UEnvQueryGenerator_Mercuna_3DRing* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UEnvQueryGenerator_Mercuna_3DRing>();
	}
};
static_assert(alignof(UEnvQueryGenerator_Mercuna_3DRing) == 0x000008, "Wrong alignment on UEnvQueryGenerator_Mercuna_3DRing");
static_assert(sizeof(UEnvQueryGenerator_Mercuna_3DRing) == 0x0001E0, "Wrong size on UEnvQueryGenerator_Mercuna_3DRing");
static_assert(offsetof(UEnvQueryGenerator_Mercuna_3DRing, InnerRadius) == 0x000050, "Member 'UEnvQueryGenerator_Mercuna_3DRing::InnerRadius' has a wrong offset!");
static_assert(offsetof(UEnvQueryGenerator_Mercuna_3DRing, OuterRadius) == 0x000088, "Member 'UEnvQueryGenerator_Mercuna_3DRing::OuterRadius' has a wrong offset!");
static_assert(offsetof(UEnvQueryGenerator_Mercuna_3DRing, NumberOfRings) == 0x0000C0, "Member 'UEnvQueryGenerator_Mercuna_3DRing::NumberOfRings' has a wrong offset!");
static_assert(offsetof(UEnvQueryGenerator_Mercuna_3DRing, PointsPerRing) == 0x0000F8, "Member 'UEnvQueryGenerator_Mercuna_3DRing::PointsPerRing' has a wrong offset!");
static_assert(offsetof(UEnvQueryGenerator_Mercuna_3DRing, MinHeight) == 0x000130, "Member 'UEnvQueryGenerator_Mercuna_3DRing::MinHeight' has a wrong offset!");
static_assert(offsetof(UEnvQueryGenerator_Mercuna_3DRing, MaxHeight) == 0x000168, "Member 'UEnvQueryGenerator_Mercuna_3DRing::MaxHeight' has a wrong offset!");
static_assert(offsetof(UEnvQueryGenerator_Mercuna_3DRing, NumberOfLayers) == 0x0001A0, "Member 'UEnvQueryGenerator_Mercuna_3DRing::NumberOfLayers' has a wrong offset!");
static_assert(offsetof(UEnvQueryGenerator_Mercuna_3DRing, Center) == 0x0001D8, "Member 'UEnvQueryGenerator_Mercuna_3DRing::Center' has a wrong offset!");

// Class Mercuna.EnvQueryGenerator_Mercuna_GroundRandom
// 0x0008 (0x0118 - 0x0110)
class UEnvQueryGenerator_Mercuna_GroundRandom final : public UEnvQueryGenerator_Mercuna_2DRandom
{
public:
	EMercunaNavLinkQueryMode                      FollowNavLinks;                                    // 0x0110(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_111[0x7];                                      // 0x0111(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"EnvQueryGenerator_Mercuna_GroundRandom">();
	}
	static class UEnvQueryGenerator_Mercuna_GroundRandom* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UEnvQueryGenerator_Mercuna_GroundRandom>();
	}
};
static_assert(alignof(UEnvQueryGenerator_Mercuna_GroundRandom) == 0x000008, "Wrong alignment on UEnvQueryGenerator_Mercuna_GroundRandom");
static_assert(sizeof(UEnvQueryGenerator_Mercuna_GroundRandom) == 0x000118, "Wrong size on UEnvQueryGenerator_Mercuna_GroundRandom");
static_assert(offsetof(UEnvQueryGenerator_Mercuna_GroundRandom, FollowNavLinks) == 0x000110, "Member 'UEnvQueryGenerator_Mercuna_GroundRandom::FollowNavLinks' has a wrong offset!");

// Class Mercuna.EnvQueryTest_Mercuna2D_Reachable
// 0x0080 (0x0290 - 0x0210)
class UEnvQueryTest_Mercuna2D_Reachable : public UMercuna2DQueryTest
{
public:
	TSubclassOf<class APawn>                      AgentClass;                                        // 0x0210(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FAIDataProviderFloatValue              MaxPathLength;                                     // 0x0218(0x0038)(Edit, DisableEditOnInstance, ContainsInstancedReference, NativeAccessSpecifierPublic)
	struct FAIDataProviderFloatValue              ClampDistance;                                     // 0x0250(0x0038)(Edit, DisableEditOnInstance, ContainsInstancedReference, NativeAccessSpecifierPublic)
	TSubclassOf<class UEnvQueryContext>           Context;                                           // 0x0288(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"EnvQueryTest_Mercuna2D_Reachable">();
	}
	static class UEnvQueryTest_Mercuna2D_Reachable* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UEnvQueryTest_Mercuna2D_Reachable>();
	}
};
static_assert(alignof(UEnvQueryTest_Mercuna2D_Reachable) == 0x000008, "Wrong alignment on UEnvQueryTest_Mercuna2D_Reachable");
static_assert(sizeof(UEnvQueryTest_Mercuna2D_Reachable) == 0x000290, "Wrong size on UEnvQueryTest_Mercuna2D_Reachable");
static_assert(offsetof(UEnvQueryTest_Mercuna2D_Reachable, AgentClass) == 0x000210, "Member 'UEnvQueryTest_Mercuna2D_Reachable::AgentClass' has a wrong offset!");
static_assert(offsetof(UEnvQueryTest_Mercuna2D_Reachable, MaxPathLength) == 0x000218, "Member 'UEnvQueryTest_Mercuna2D_Reachable::MaxPathLength' has a wrong offset!");
static_assert(offsetof(UEnvQueryTest_Mercuna2D_Reachable, ClampDistance) == 0x000250, "Member 'UEnvQueryTest_Mercuna2D_Reachable::ClampDistance' has a wrong offset!");
static_assert(offsetof(UEnvQueryTest_Mercuna2D_Reachable, Context) == 0x000288, "Member 'UEnvQueryTest_Mercuna2D_Reachable::Context' has a wrong offset!");

// Class Mercuna.EnvQueryTest_Mercuna2D_NavRaycast
// 0x0010 (0x0220 - 0x0210)
class UEnvQueryTest_Mercuna2D_NavRaycast : public UMercuna2DQueryTest
{
public:
	TSubclassOf<class APawn>                      AgentClass;                                        // 0x0210(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UEnvQueryContext>           Context;                                           // 0x0218(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"EnvQueryTest_Mercuna2D_NavRaycast">();
	}
	static class UEnvQueryTest_Mercuna2D_NavRaycast* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UEnvQueryTest_Mercuna2D_NavRaycast>();
	}
};
static_assert(alignof(UEnvQueryTest_Mercuna2D_NavRaycast) == 0x000008, "Wrong alignment on UEnvQueryTest_Mercuna2D_NavRaycast");
static_assert(sizeof(UEnvQueryTest_Mercuna2D_NavRaycast) == 0x000220, "Wrong size on UEnvQueryTest_Mercuna2D_NavRaycast");
static_assert(offsetof(UEnvQueryTest_Mercuna2D_NavRaycast, AgentClass) == 0x000210, "Member 'UEnvQueryTest_Mercuna2D_NavRaycast::AgentClass' has a wrong offset!");
static_assert(offsetof(UEnvQueryTest_Mercuna2D_NavRaycast, Context) == 0x000218, "Member 'UEnvQueryTest_Mercuna2D_NavRaycast::Context' has a wrong offset!");

// Class Mercuna.EnvQueryTest_Mercuna3D_NavigableVolume
// 0x0000 (0x0208 - 0x0208)
class UEnvQueryTest_Mercuna3D_NavigableVolume final : public UMercuna3DQueryTest
{
public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"EnvQueryTest_Mercuna3D_NavigableVolume">();
	}
	static class UEnvQueryTest_Mercuna3D_NavigableVolume* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UEnvQueryTest_Mercuna3D_NavigableVolume>();
	}
};
static_assert(alignof(UEnvQueryTest_Mercuna3D_NavigableVolume) == 0x000008, "Wrong alignment on UEnvQueryTest_Mercuna3D_NavigableVolume");
static_assert(sizeof(UEnvQueryTest_Mercuna3D_NavigableVolume) == 0x000208, "Wrong size on UEnvQueryTest_Mercuna3D_NavigableVolume");

// Class Mercuna.EnvQueryTest_Mercuna3D_Reachable
// 0x0048 (0x0250 - 0x0208)
class UEnvQueryTest_Mercuna3D_Reachable final : public UMercuna3DQueryTest
{
public:
	struct FAIDataProviderFloatValue              MaxPathLength;                                     // 0x0208(0x0038)(Edit, DisableEditOnInstance, ContainsInstancedReference, NativeAccessSpecifierPublic)
	TSubclassOf<class UEnvQueryContext>           Context;                                           // 0x0240(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUseAccuratePathLength;                            // 0x0248(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_249[0x7];                                      // 0x0249(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"EnvQueryTest_Mercuna3D_Reachable">();
	}
	static class UEnvQueryTest_Mercuna3D_Reachable* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UEnvQueryTest_Mercuna3D_Reachable>();
	}
};
static_assert(alignof(UEnvQueryTest_Mercuna3D_Reachable) == 0x000008, "Wrong alignment on UEnvQueryTest_Mercuna3D_Reachable");
static_assert(sizeof(UEnvQueryTest_Mercuna3D_Reachable) == 0x000250, "Wrong size on UEnvQueryTest_Mercuna3D_Reachable");
static_assert(offsetof(UEnvQueryTest_Mercuna3D_Reachable, MaxPathLength) == 0x000208, "Member 'UEnvQueryTest_Mercuna3D_Reachable::MaxPathLength' has a wrong offset!");
static_assert(offsetof(UEnvQueryTest_Mercuna3D_Reachable, Context) == 0x000240, "Member 'UEnvQueryTest_Mercuna3D_Reachable::Context' has a wrong offset!");
static_assert(offsetof(UEnvQueryTest_Mercuna3D_Reachable, bUseAccuratePathLength) == 0x000248, "Member 'UEnvQueryTest_Mercuna3D_Reachable::bUseAccuratePathLength' has a wrong offset!");

// Class Mercuna.EnvQueryTest_Mercuna3D_NavRaycast
// 0x0008 (0x0210 - 0x0208)
class UEnvQueryTest_Mercuna3D_NavRaycast final : public UMercuna3DQueryTest
{
public:
	TSubclassOf<class UEnvQueryContext>           Context;                                           // 0x0208(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"EnvQueryTest_Mercuna3D_NavRaycast">();
	}
	static class UEnvQueryTest_Mercuna3D_NavRaycast* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UEnvQueryTest_Mercuna3D_NavRaycast>();
	}
};
static_assert(alignof(UEnvQueryTest_Mercuna3D_NavRaycast) == 0x000008, "Wrong alignment on UEnvQueryTest_Mercuna3D_NavRaycast");
static_assert(sizeof(UEnvQueryTest_Mercuna3D_NavRaycast) == 0x000210, "Wrong size on UEnvQueryTest_Mercuna3D_NavRaycast");
static_assert(offsetof(UEnvQueryTest_Mercuna3D_NavRaycast, Context) == 0x000208, "Member 'UEnvQueryTest_Mercuna3D_NavRaycast::Context' has a wrong offset!");

// Class Mercuna.EnvQueryTest_MercunaGround_Navigable
// 0x0000 (0x0218 - 0x0218)
class UEnvQueryTest_MercunaGround_Navigable final : public UEnvQueryTest_Mercuna2D_Navigable
{
public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"EnvQueryTest_MercunaGround_Navigable">();
	}
	static class UEnvQueryTest_MercunaGround_Navigable* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UEnvQueryTest_MercunaGround_Navigable>();
	}
};
static_assert(alignof(UEnvQueryTest_MercunaGround_Navigable) == 0x000008, "Wrong alignment on UEnvQueryTest_MercunaGround_Navigable");
static_assert(sizeof(UEnvQueryTest_MercunaGround_Navigable) == 0x000218, "Wrong size on UEnvQueryTest_MercunaGround_Navigable");

// Class Mercuna.EnvQueryTest_MercunaGround_Reachable
// 0x0008 (0x0298 - 0x0290)
class UEnvQueryTest_MercunaGround_Reachable final : public UEnvQueryTest_Mercuna2D_Reachable
{
public:
	EMercunaNavLinkQueryMode                      FollowNavLinks;                                    // 0x0290(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_291[0x7];                                      // 0x0291(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"EnvQueryTest_MercunaGround_Reachable">();
	}
	static class UEnvQueryTest_MercunaGround_Reachable* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UEnvQueryTest_MercunaGround_Reachable>();
	}
};
static_assert(alignof(UEnvQueryTest_MercunaGround_Reachable) == 0x000008, "Wrong alignment on UEnvQueryTest_MercunaGround_Reachable");
static_assert(sizeof(UEnvQueryTest_MercunaGround_Reachable) == 0x000298, "Wrong size on UEnvQueryTest_MercunaGround_Reachable");
static_assert(offsetof(UEnvQueryTest_MercunaGround_Reachable, FollowNavLinks) == 0x000290, "Member 'UEnvQueryTest_MercunaGround_Reachable::FollowNavLinks' has a wrong offset!");

// Class Mercuna.EnvQueryTest_MercunaGround_NavRaycast
// 0x0000 (0x0220 - 0x0220)
class UEnvQueryTest_MercunaGround_NavRaycast final : public UEnvQueryTest_Mercuna2D_NavRaycast
{
public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"EnvQueryTest_MercunaGround_NavRaycast">();
	}
	static class UEnvQueryTest_MercunaGround_NavRaycast* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UEnvQueryTest_MercunaGround_NavRaycast>();
	}
};
static_assert(alignof(UEnvQueryTest_MercunaGround_NavRaycast) == 0x000008, "Wrong alignment on UEnvQueryTest_MercunaGround_NavRaycast");
static_assert(sizeof(UEnvQueryTest_MercunaGround_NavRaycast) == 0x000220, "Wrong size on UEnvQueryTest_MercunaGround_NavRaycast");

// Class Mercuna.EnvQueryTest_MercunaSurface_Navigable
// 0x0000 (0x0218 - 0x0218)
class UEnvQueryTest_MercunaSurface_Navigable final : public UEnvQueryTest_Mercuna2D_Navigable
{
public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"EnvQueryTest_MercunaSurface_Navigable">();
	}
	static class UEnvQueryTest_MercunaSurface_Navigable* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UEnvQueryTest_MercunaSurface_Navigable>();
	}
};
static_assert(alignof(UEnvQueryTest_MercunaSurface_Navigable) == 0x000008, "Wrong alignment on UEnvQueryTest_MercunaSurface_Navigable");
static_assert(sizeof(UEnvQueryTest_MercunaSurface_Navigable) == 0x000218, "Wrong size on UEnvQueryTest_MercunaSurface_Navigable");

// Class Mercuna.EnvQueryTest_MercunaSurface_Reachable
// 0x0050 (0x02E0 - 0x0290)
class UEnvQueryTest_MercunaSurface_Reachable final : public UEnvQueryTest_Mercuna2D_Reachable
{
public:
	struct FVector                                UpDirection;                                       // 0x0290(0x0018)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FAIDataProviderBoolValue               FollowNavLinks;                                    // 0x02A8(0x0038)(Edit, DisableEditOnInstance, ContainsInstancedReference, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"EnvQueryTest_MercunaSurface_Reachable">();
	}
	static class UEnvQueryTest_MercunaSurface_Reachable* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UEnvQueryTest_MercunaSurface_Reachable>();
	}
};
static_assert(alignof(UEnvQueryTest_MercunaSurface_Reachable) == 0x000008, "Wrong alignment on UEnvQueryTest_MercunaSurface_Reachable");
static_assert(sizeof(UEnvQueryTest_MercunaSurface_Reachable) == 0x0002E0, "Wrong size on UEnvQueryTest_MercunaSurface_Reachable");
static_assert(offsetof(UEnvQueryTest_MercunaSurface_Reachable, UpDirection) == 0x000290, "Member 'UEnvQueryTest_MercunaSurface_Reachable::UpDirection' has a wrong offset!");
static_assert(offsetof(UEnvQueryTest_MercunaSurface_Reachable, FollowNavLinks) == 0x0002A8, "Member 'UEnvQueryTest_MercunaSurface_Reachable::FollowNavLinks' has a wrong offset!");

// Class Mercuna.EnvQueryTest_MercunaSurface_PathLength
// 0x0050 (0x02E0 - 0x0290)
class UEnvQueryTest_MercunaSurface_PathLength final : public UEnvQueryTest_Mercuna2D_PathLength
{
public:
	struct FVector                                UpDirection;                                       // 0x0290(0x0018)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FAIDataProviderBoolValue               FollowNavLinks;                                    // 0x02A8(0x0038)(Edit, DisableEditOnInstance, ContainsInstancedReference, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"EnvQueryTest_MercunaSurface_PathLength">();
	}
	static class UEnvQueryTest_MercunaSurface_PathLength* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UEnvQueryTest_MercunaSurface_PathLength>();
	}
};
static_assert(alignof(UEnvQueryTest_MercunaSurface_PathLength) == 0x000008, "Wrong alignment on UEnvQueryTest_MercunaSurface_PathLength");
static_assert(sizeof(UEnvQueryTest_MercunaSurface_PathLength) == 0x0002E0, "Wrong size on UEnvQueryTest_MercunaSurface_PathLength");
static_assert(offsetof(UEnvQueryTest_MercunaSurface_PathLength, UpDirection) == 0x000290, "Member 'UEnvQueryTest_MercunaSurface_PathLength::UpDirection' has a wrong offset!");
static_assert(offsetof(UEnvQueryTest_MercunaSurface_PathLength, FollowNavLinks) == 0x0002A8, "Member 'UEnvQueryTest_MercunaSurface_PathLength::FollowNavLinks' has a wrong offset!");

// Class Mercuna.EnvQueryTest_MercunaSurface_NavRaycast
// 0x0000 (0x0220 - 0x0220)
class UEnvQueryTest_MercunaSurface_NavRaycast final : public UEnvQueryTest_Mercuna2D_NavRaycast
{
public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"EnvQueryTest_MercunaSurface_NavRaycast">();
	}
	static class UEnvQueryTest_MercunaSurface_NavRaycast* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UEnvQueryTest_MercunaSurface_NavRaycast>();
	}
};
static_assert(alignof(UEnvQueryTest_MercunaSurface_NavRaycast) == 0x000008, "Wrong alignment on UEnvQueryTest_MercunaSurface_NavRaycast");
static_assert(sizeof(UEnvQueryTest_MercunaSurface_NavRaycast) == 0x000220, "Wrong size on UEnvQueryTest_MercunaSurface_NavRaycast");

// Class Mercuna.EnvQueryTest_MercunaSurface_Project
// 0x0020 (0x0278 - 0x0258)
class UEnvQueryTest_MercunaSurface_Project final : public UEnvQueryTest_Mercuna2D_Project
{
public:
	TSubclassOf<class UEnvQueryContext>           Context;                                           // 0x0258(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                ProjectionDirection;                               // 0x0260(0x0018)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"EnvQueryTest_MercunaSurface_Project">();
	}
	static class UEnvQueryTest_MercunaSurface_Project* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UEnvQueryTest_MercunaSurface_Project>();
	}
};
static_assert(alignof(UEnvQueryTest_MercunaSurface_Project) == 0x000008, "Wrong alignment on UEnvQueryTest_MercunaSurface_Project");
static_assert(sizeof(UEnvQueryTest_MercunaSurface_Project) == 0x000278, "Wrong size on UEnvQueryTest_MercunaSurface_Project");
static_assert(offsetof(UEnvQueryTest_MercunaSurface_Project, Context) == 0x000258, "Member 'UEnvQueryTest_MercunaSurface_Project::Context' has a wrong offset!");
static_assert(offsetof(UEnvQueryTest_MercunaSurface_Project, ProjectionDirection) == 0x000260, "Member 'UEnvQueryTest_MercunaSurface_Project::ProjectionDirection' has a wrong offset!");

// Class Mercuna.EnvQueryGenerator_Mercuna_SurfaceRandom
// 0x0050 (0x0160 - 0x0110)
class UEnvQueryGenerator_Mercuna_SurfaceRandom final : public UEnvQueryGenerator_Mercuna_2DRandom
{
public:
	struct FVector                                UpDirection;                                       // 0x0110(0x0018)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FAIDataProviderBoolValue               FollowNavLinks;                                    // 0x0128(0x0038)(Edit, DisableEditOnInstance, ContainsInstancedReference, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"EnvQueryGenerator_Mercuna_SurfaceRandom">();
	}
	static class UEnvQueryGenerator_Mercuna_SurfaceRandom* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UEnvQueryGenerator_Mercuna_SurfaceRandom>();
	}
};
static_assert(alignof(UEnvQueryGenerator_Mercuna_SurfaceRandom) == 0x000008, "Wrong alignment on UEnvQueryGenerator_Mercuna_SurfaceRandom");
static_assert(sizeof(UEnvQueryGenerator_Mercuna_SurfaceRandom) == 0x000160, "Wrong size on UEnvQueryGenerator_Mercuna_SurfaceRandom");
static_assert(offsetof(UEnvQueryGenerator_Mercuna_SurfaceRandom, UpDirection) == 0x000110, "Member 'UEnvQueryGenerator_Mercuna_SurfaceRandom::UpDirection' has a wrong offset!");
static_assert(offsetof(UEnvQueryGenerator_Mercuna_SurfaceRandom, FollowNavLinks) == 0x000128, "Member 'UEnvQueryGenerator_Mercuna_SurfaceRandom::FollowNavLinks' has a wrong offset!");

// Class Mercuna.EnvQueryGenerator_Mercuna_SurfaceGrid
// 0x0050 (0x0198 - 0x0148)
class UEnvQueryGenerator_Mercuna_SurfaceGrid final : public UEnvQueryGenerator_Mercuna_2DNavGrid
{
public:
	struct FVector                                UpDirection;                                       // 0x0148(0x0018)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FAIDataProviderBoolValue               FollowNavLinks;                                    // 0x0160(0x0038)(Edit, DisableEditOnInstance, ContainsInstancedReference, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"EnvQueryGenerator_Mercuna_SurfaceGrid">();
	}
	static class UEnvQueryGenerator_Mercuna_SurfaceGrid* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UEnvQueryGenerator_Mercuna_SurfaceGrid>();
	}
};
static_assert(alignof(UEnvQueryGenerator_Mercuna_SurfaceGrid) == 0x000008, "Wrong alignment on UEnvQueryGenerator_Mercuna_SurfaceGrid");
static_assert(sizeof(UEnvQueryGenerator_Mercuna_SurfaceGrid) == 0x000198, "Wrong size on UEnvQueryGenerator_Mercuna_SurfaceGrid");
static_assert(offsetof(UEnvQueryGenerator_Mercuna_SurfaceGrid, UpDirection) == 0x000148, "Member 'UEnvQueryGenerator_Mercuna_SurfaceGrid::UpDirection' has a wrong offset!");
static_assert(offsetof(UEnvQueryGenerator_Mercuna_SurfaceGrid, FollowNavLinks) == 0x000160, "Member 'UEnvQueryGenerator_Mercuna_SurfaceGrid::FollowNavLinks' has a wrong offset!");

// Class Mercuna.MercunaGroundMoveToProxy
// 0x0090 (0x00C0 - 0x0030)
class UMercunaGroundMoveToProxy final : public UBlueprintAsyncActionBase
{
public:
	TMulticastInlineDelegate<void()>              OnSuccess;                                         // 0x0030(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void()>              OnFailure;                                         // 0x0040(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	class APawn*                                  Pawn;                                              // 0x0050(0x0008)(ZeroConstructor, Transient, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_58[0x68];                                      // 0x0058(0x0068)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UMercunaGroundMoveToProxy* MoveToActor(class UObject* WorldContextObject, class APawn* Pawn_0, class AActor* Actor, float EndDistance, float Speed, bool UsePartialPath)	 // 0x484e4c0;
	static class UMercunaGroundMoveToProxy* MoveToLocation(class UObject* WorldContextObject, class APawn* Pawn_0, const struct FVector& Destination, float EndDistance, float Speed, bool UsePartialPath, const struct FVector& EndDirection)	 // 0x484ea2c;
	static class UMercunaGroundMoveToProxy* MoveToLocations(class UObject* WorldContextObject, class APawn* Pawn_0, const TArray<struct FVector>& Destinations, float EndDistance, float Speed, bool UsePartialPath, const struct FVector& EndDirection)	 // 0x484f07c;

	void OnMoveComplete(const struct FAIRequestID& RequestID, EMercunaMoveResult Result)	 // 0x484f9f4;

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"MercunaGroundMoveToProxy">();
	}
	static class UMercunaGroundMoveToProxy* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UMercunaGroundMoveToProxy>();
	}
};
static_assert(alignof(UMercunaGroundMoveToProxy) == 0x000008, "Wrong alignment on UMercunaGroundMoveToProxy");
static_assert(sizeof(UMercunaGroundMoveToProxy) == 0x0000C0, "Wrong size on UMercunaGroundMoveToProxy");
static_assert(offsetof(UMercunaGroundMoveToProxy, OnSuccess) == 0x000030, "Member 'UMercunaGroundMoveToProxy::OnSuccess' has a wrong offset!");
static_assert(offsetof(UMercunaGroundMoveToProxy, OnFailure) == 0x000040, "Member 'UMercunaGroundMoveToProxy::OnFailure' has a wrong offset!");
static_assert(offsetof(UMercunaGroundMoveToProxy, Pawn) == 0x000050, "Member 'UMercunaGroundMoveToProxy::Pawn' has a wrong offset!");

// Class Mercuna.MercunaGroundTrackActorProxy
// 0x0048 (0x0078 - 0x0030)
class UMercunaGroundTrackActorProxy final : public UBlueprintAsyncActionBase
{
public:
	TMulticastInlineDelegate<void()>              OnFailure;                                         // 0x0030(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	class APawn*                                  Pawn;                                              // 0x0040(0x0008)(ZeroConstructor, Transient, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_48[0x30];                                      // 0x0048(0x0030)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UMercunaGroundTrackActorProxy* TrackActor(class UObject* WorldContextObject, class APawn* Pawn_0, class AActor* Actor, float Distance, float Speed, const struct FVector& Offset, bool UsePartialPath)	 // 0x4850144;

	void OnMoveComplete(const struct FAIRequestID& RequestID, EMercunaMoveResult Result)	 // 0x484fb34;

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"MercunaGroundTrackActorProxy">();
	}
	static class UMercunaGroundTrackActorProxy* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UMercunaGroundTrackActorProxy>();
	}
};
static_assert(alignof(UMercunaGroundTrackActorProxy) == 0x000008, "Wrong alignment on UMercunaGroundTrackActorProxy");
static_assert(sizeof(UMercunaGroundTrackActorProxy) == 0x000078, "Wrong size on UMercunaGroundTrackActorProxy");
static_assert(offsetof(UMercunaGroundTrackActorProxy, OnFailure) == 0x000030, "Member 'UMercunaGroundTrackActorProxy::OnFailure' has a wrong offset!");
static_assert(offsetof(UMercunaGroundTrackActorProxy, Pawn) == 0x000040, "Member 'UMercunaGroundTrackActorProxy::Pawn' has a wrong offset!");

// Class Mercuna.MercunaGroundNavInvokerComponent
// 0x00C0 (0x0180 - 0x00C0)
class UMercunaGroundNavInvokerComponent final : public UActorComponent
{
public:
	bool                                          bAutomatic;                                        // 0x00C0(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C1[0x7];                                       // 0x00C1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class AMercunaNavGroundGrid*                  NavGrid;                                           // 0x00C8(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FMercunaSupportedAgentTypes            AgentTypes;                                        // 0x00D0(0x00A8)(Edit, NativeAccessSpecifierPublic)
	float                                         GenerationRadius;                                  // 0x0178(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RemovalRadius;                                     // 0x017C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"MercunaGroundNavInvokerComponent">();
	}
	static class UMercunaGroundNavInvokerComponent* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UMercunaGroundNavInvokerComponent>();
	}
};
static_assert(alignof(UMercunaGroundNavInvokerComponent) == 0x000008, "Wrong alignment on UMercunaGroundNavInvokerComponent");
static_assert(sizeof(UMercunaGroundNavInvokerComponent) == 0x000180, "Wrong size on UMercunaGroundNavInvokerComponent");
static_assert(offsetof(UMercunaGroundNavInvokerComponent, bAutomatic) == 0x0000C0, "Member 'UMercunaGroundNavInvokerComponent::bAutomatic' has a wrong offset!");
static_assert(offsetof(UMercunaGroundNavInvokerComponent, NavGrid) == 0x0000C8, "Member 'UMercunaGroundNavInvokerComponent::NavGrid' has a wrong offset!");
static_assert(offsetof(UMercunaGroundNavInvokerComponent, AgentTypes) == 0x0000D0, "Member 'UMercunaGroundNavInvokerComponent::AgentTypes' has a wrong offset!");
static_assert(offsetof(UMercunaGroundNavInvokerComponent, GenerationRadius) == 0x000178, "Member 'UMercunaGroundNavInvokerComponent::GenerationRadius' has a wrong offset!");
static_assert(offsetof(UMercunaGroundNavInvokerComponent, RemovalRadius) == 0x00017C, "Member 'UMercunaGroundNavInvokerComponent::RemovalRadius' has a wrong offset!");

// Class Mercuna.MercunaNavExclusionVolume
// 0x0020 (0x02D0 - 0x02B0)
class AMercunaNavExclusionVolume final : public AActor
{
public:
	class UMercunaVolumeComponent*                VolumeComponent;                                   // 0x02B0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bApplyToAllNavGraphs;                              // 0x02B8(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2B9[0x7];                                      // 0x02B9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class AMercunaNavGraph*                       NavGraph;                                          // 0x02C0(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	EMercunaNavigationExclusionType               ExclusionType;                                     // 0x02C8(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2C9[0x7];                                      // 0x02C9(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void AddToAllGraphs()	 // 0x4852f18;
	void AddToGraph(class AMercunaNavGraph* NavGraph_0)	 // 0x4852f2c;
	void RemoveFromGraphs()	 // 0x485cf28;
	void SetSize(const struct FVector& Size)	 // 0x485d6d8;

	struct FVector GetSize() const	 // 0x4859418;

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"MercunaNavExclusionVolume">();
	}
	static class AMercunaNavExclusionVolume* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<AMercunaNavExclusionVolume>();
	}
};
static_assert(alignof(AMercunaNavExclusionVolume) == 0x000008, "Wrong alignment on AMercunaNavExclusionVolume");
static_assert(sizeof(AMercunaNavExclusionVolume) == 0x0002D0, "Wrong size on AMercunaNavExclusionVolume");
static_assert(offsetof(AMercunaNavExclusionVolume, VolumeComponent) == 0x0002B0, "Member 'AMercunaNavExclusionVolume::VolumeComponent' has a wrong offset!");
static_assert(offsetof(AMercunaNavExclusionVolume, bApplyToAllNavGraphs) == 0x0002B8, "Member 'AMercunaNavExclusionVolume::bApplyToAllNavGraphs' has a wrong offset!");
static_assert(offsetof(AMercunaNavExclusionVolume, NavGraph) == 0x0002C0, "Member 'AMercunaNavExclusionVolume::NavGraph' has a wrong offset!");
static_assert(offsetof(AMercunaNavExclusionVolume, ExclusionType) == 0x0002C8, "Member 'AMercunaNavExclusionVolume::ExclusionType' has a wrong offset!");

// Class Mercuna.MercunaNavGridModifierVolume
// 0x0008 (0x02B8 - 0x02B0)
class AMercunaNavGridModifierVolume final : public AActor
{
public:
	class UMercunaNavGridModifierComponent*       VolumeComponent;                                   // 0x02B0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void AddToGrid(class AMercunaNavGraph2D* NavGrid)	 // 0x485300c;
	void OverrideCostMultiplier(const struct FMercunaAgentType& AgentType, float NewCostMultiplier)	 // 0x485b794;
	void OverrideUsageTypes(const struct FMercunaAgentType& AgentType, const struct FMercunaUsageTypes& NewUsageTypes)	 // 0x485baa0;
	void RemoveFromGrid()	 // 0x485cf3c;
	void SetCostMultiplier(float NewCostMultiplier)	 // 0x485d270;
	void SetEnabled(bool Enabled)	 // 0x485d338;
	void SetPrismVertices(const TArray<struct FVector2D>& NewVertices)	 // 0x485d400;
	void SetShape(EMercunaModifierVolumeShape NewShape)	 // 0x485d544;
	void SetSize(const struct FVector& Size)	 // 0x485d7bc;
	void SetUsageTypes(const struct FMercunaUsageTypes& NewUsageTypes)	 // 0x485d898;

	EMercunaModifierVolumeShape GetShape() const	 // 0x48593e0;
	struct FVector GetSize() const	 // 0x4859450;

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"MercunaNavGridModifierVolume">();
	}
	static class AMercunaNavGridModifierVolume* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<AMercunaNavGridModifierVolume>();
	}
};
static_assert(alignof(AMercunaNavGridModifierVolume) == 0x000008, "Wrong alignment on AMercunaNavGridModifierVolume");
static_assert(sizeof(AMercunaNavGridModifierVolume) == 0x0002B8, "Wrong size on AMercunaNavGridModifierVolume");
static_assert(offsetof(AMercunaNavGridModifierVolume, VolumeComponent) == 0x0002B0, "Member 'AMercunaNavGridModifierVolume::VolumeComponent' has a wrong offset!");

// Class Mercuna.MercunaNavTestingActor
// 0x0078 (0x0328 - 0x02B0)
class AMercunaNavTestingActor : public AActor
{
public:
	bool                                          bDrawDebugPath;                                    // 0x02B0(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2B1[0x3];                                      // 0x02B1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	uint8                                         bSearchStart : 1;                                  // 0x02B4(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_2B5[0x3];                                      // 0x02B5(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FMercunaUsageSpec                      UsageSpec;                                         // 0x02B8(0x0008)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	float                                         MaxPathLength;                                     // 0x02C0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAllowPartialPath;                                 // 0x02C4(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C5[0x3];                                      // 0x02C5(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	uint8                                         bContinuouslyRepath : 1;                           // 0x02C8(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bRaycast : 1;                                      // 0x02C8(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_2C9[0x3];                                      // 0x02C9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bAutomaticRepath;                                  // 0x02CC(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2CD[0x3];                                      // 0x02CD(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 PathStatus;                                        // 0x02D0(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, EditConst, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bPathExist : 1;                                    // 0x02E0(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, Transient, EditConst, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bPathIsPartial : 1;                                // 0x02E0(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, Transient, EditConst, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bPathIsOutOfNodes : 1;                             // 0x02E0(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, Transient, EditConst, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_2E1[0x3];                                      // 0x02E1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         PathLength;                                        // 0x02E4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         PathSections;                                      // 0x02E8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PathFindTime;                                      // 0x02EC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         PathNodesUsed;                                     // 0x02F0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         PathFindRepeats;                                   // 0x02F4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDisplayAverageTime;                               // 0x02F8(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2F9[0x7];                                      // 0x02F9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class USphereComponent*                       SphereComponent;                                   // 0x0300(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UMercunaPath*                           Path;                                              // 0x0308(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class AMercunaNavGraph*                       NavGraph;                                          // 0x0310(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_318[0x10];                                     // 0x0318(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnNavGraphBuildComplete(bool Success)	 // 0x486a634;
	void OnPathUpdate(EMercunaPathEvent PathEvent)	 // 0x486a6f0;
	void PathfindLatent(bool* Result, class UObject* WorldContextObject, const struct FLatentActionInfo& LatentInfo, bool bAllowPartial)	 // 0x486a7b0;
	void Repath()	 // 0x486b5e0;

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"MercunaNavTestingActor">();
	}
	static class AMercunaNavTestingActor* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<AMercunaNavTestingActor>();
	}
};
static_assert(alignof(AMercunaNavTestingActor) == 0x000008, "Wrong alignment on AMercunaNavTestingActor");
static_assert(sizeof(AMercunaNavTestingActor) == 0x000328, "Wrong size on AMercunaNavTestingActor");
static_assert(offsetof(AMercunaNavTestingActor, bDrawDebugPath) == 0x0002B0, "Member 'AMercunaNavTestingActor::bDrawDebugPath' has a wrong offset!");
static_assert(offsetof(AMercunaNavTestingActor, UsageSpec) == 0x0002B8, "Member 'AMercunaNavTestingActor::UsageSpec' has a wrong offset!");
static_assert(offsetof(AMercunaNavTestingActor, MaxPathLength) == 0x0002C0, "Member 'AMercunaNavTestingActor::MaxPathLength' has a wrong offset!");
static_assert(offsetof(AMercunaNavTestingActor, bAllowPartialPath) == 0x0002C4, "Member 'AMercunaNavTestingActor::bAllowPartialPath' has a wrong offset!");
static_assert(offsetof(AMercunaNavTestingActor, bAutomaticRepath) == 0x0002CC, "Member 'AMercunaNavTestingActor::bAutomaticRepath' has a wrong offset!");
static_assert(offsetof(AMercunaNavTestingActor, PathStatus) == 0x0002D0, "Member 'AMercunaNavTestingActor::PathStatus' has a wrong offset!");
static_assert(offsetof(AMercunaNavTestingActor, PathLength) == 0x0002E4, "Member 'AMercunaNavTestingActor::PathLength' has a wrong offset!");
static_assert(offsetof(AMercunaNavTestingActor, PathSections) == 0x0002E8, "Member 'AMercunaNavTestingActor::PathSections' has a wrong offset!");
static_assert(offsetof(AMercunaNavTestingActor, PathFindTime) == 0x0002EC, "Member 'AMercunaNavTestingActor::PathFindTime' has a wrong offset!");
static_assert(offsetof(AMercunaNavTestingActor, PathNodesUsed) == 0x0002F0, "Member 'AMercunaNavTestingActor::PathNodesUsed' has a wrong offset!");
static_assert(offsetof(AMercunaNavTestingActor, PathFindRepeats) == 0x0002F4, "Member 'AMercunaNavTestingActor::PathFindRepeats' has a wrong offset!");
static_assert(offsetof(AMercunaNavTestingActor, bDisplayAverageTime) == 0x0002F8, "Member 'AMercunaNavTestingActor::bDisplayAverageTime' has a wrong offset!");
static_assert(offsetof(AMercunaNavTestingActor, SphereComponent) == 0x000300, "Member 'AMercunaNavTestingActor::SphereComponent' has a wrong offset!");
static_assert(offsetof(AMercunaNavTestingActor, Path) == 0x000308, "Member 'AMercunaNavTestingActor::Path' has a wrong offset!");
static_assert(offsetof(AMercunaNavTestingActor, NavGraph) == 0x000310, "Member 'AMercunaNavTestingActor::NavGraph' has a wrong offset!");

// Class Mercuna.MercunaNavGridTestingActor
// 0x0080 (0x03A8 - 0x0328)
class AMercunaNavGridTestingActor final : public AMercunaNavTestingActor
{
public:
	struct FMercunaAgentType                      AgentType;                                         // 0x0328(0x000C)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_334[0x4];                                      // 0x0334(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class AMercunaNavGridTestingActor*            OtherActor;                                        // 0x0338(0x0008)(Edit, ZeroConstructor, NonTransactional, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class AMercunaNavGraph2D>      NavGrid;                                           // 0x0340(0x0030)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FInstancedStruct                       NavFilter;                                         // 0x0370(0x0010)(Edit, NativeAccessSpecifierPublic)
	float                                         MinTurnRadius;                                     // 0x0380(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         IdealTurnRadius;                                   // 0x0384(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxSpeed;                                          // 0x0388(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         InitialSpeed;                                      // 0x038C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SlopePenalty;                                      // 0x0390(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUseEndDirection;                                  // 0x0394(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_395[0x3];                                      // 0x0395(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	TMulticastInlineDelegate<void()>              OnPathUpdated;                                     // 0x0398(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NonPIEDuplicateTransient, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"MercunaNavGridTestingActor">();
	}
	static class AMercunaNavGridTestingActor* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<AMercunaNavGridTestingActor>();
	}
};
static_assert(alignof(AMercunaNavGridTestingActor) == 0x000008, "Wrong alignment on AMercunaNavGridTestingActor");
static_assert(sizeof(AMercunaNavGridTestingActor) == 0x0003A8, "Wrong size on AMercunaNavGridTestingActor");
static_assert(offsetof(AMercunaNavGridTestingActor, AgentType) == 0x000328, "Member 'AMercunaNavGridTestingActor::AgentType' has a wrong offset!");
static_assert(offsetof(AMercunaNavGridTestingActor, OtherActor) == 0x000338, "Member 'AMercunaNavGridTestingActor::OtherActor' has a wrong offset!");
static_assert(offsetof(AMercunaNavGridTestingActor, NavGrid) == 0x000340, "Member 'AMercunaNavGridTestingActor::NavGrid' has a wrong offset!");
static_assert(offsetof(AMercunaNavGridTestingActor, NavFilter) == 0x000370, "Member 'AMercunaNavGridTestingActor::NavFilter' has a wrong offset!");
static_assert(offsetof(AMercunaNavGridTestingActor, MinTurnRadius) == 0x000380, "Member 'AMercunaNavGridTestingActor::MinTurnRadius' has a wrong offset!");
static_assert(offsetof(AMercunaNavGridTestingActor, IdealTurnRadius) == 0x000384, "Member 'AMercunaNavGridTestingActor::IdealTurnRadius' has a wrong offset!");
static_assert(offsetof(AMercunaNavGridTestingActor, MaxSpeed) == 0x000388, "Member 'AMercunaNavGridTestingActor::MaxSpeed' has a wrong offset!");
static_assert(offsetof(AMercunaNavGridTestingActor, InitialSpeed) == 0x00038C, "Member 'AMercunaNavGridTestingActor::InitialSpeed' has a wrong offset!");
static_assert(offsetof(AMercunaNavGridTestingActor, SlopePenalty) == 0x000390, "Member 'AMercunaNavGridTestingActor::SlopePenalty' has a wrong offset!");
static_assert(offsetof(AMercunaNavGridTestingActor, bUseEndDirection) == 0x000394, "Member 'AMercunaNavGridTestingActor::bUseEndDirection' has a wrong offset!");
static_assert(offsetof(AMercunaNavGridTestingActor, OnPathUpdated) == 0x000398, "Member 'AMercunaNavGridTestingActor::OnPathUpdated' has a wrong offset!");

// Class Mercuna.MercunaNavGridVolume
// 0x0030 (0x02F8 - 0x02C8)
class AMercunaNavGridVolume final : public AMercunaNavVolume
{
public:
	TSoftObjectPtr<class AMercunaNavGraph2D>      NavGrid;                                           // 0x02C8(0x0030)(Edit, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void AddToGrid(class AMercunaNavGraph2D* NavGrid_0)	 // 0x4853104;
	void RemoveFromGrid()	 // 0x485cf58;

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"MercunaNavGridVolume">();
	}
	static class AMercunaNavGridVolume* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<AMercunaNavGridVolume>();
	}
};
static_assert(alignof(AMercunaNavGridVolume) == 0x000008, "Wrong alignment on AMercunaNavGridVolume");
static_assert(sizeof(AMercunaNavGridVolume) == 0x0002F8, "Wrong size on AMercunaNavGridVolume");
static_assert(offsetof(AMercunaNavGridVolume, NavGrid) == 0x0002C8, "Member 'AMercunaNavGridVolume::NavGrid' has a wrong offset!");

// Class Mercuna.MercunaNavigationSystem
// 0x0000 (0x0028 - 0x0028)
class UMercunaNavigationSystem final : public UNavigationSystemBase
{
public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"MercunaNavigationSystem">();
	}
	static class UMercunaNavigationSystem* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UMercunaNavigationSystem>();
	}
};
static_assert(alignof(UMercunaNavigationSystem) == 0x000008, "Wrong alignment on UMercunaNavigationSystem");
static_assert(sizeof(UMercunaNavigationSystem) == 0x000028, "Wrong size on UMercunaNavigationSystem");

// Class Mercuna.MercunaNavInvokerVolume
// 0x0018 (0x02C8 - 0x02B0)
class AMercunaNavInvokerVolume final : public AActor
{
public:
	class UMercunaVolumeComponent*                VolumeComponent;                                   // 0x02B0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class AMercunaNavGroundGrid*                  NavGrid;                                           // 0x02B8(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	EMercunaInvokerVolumeType                     Type;                                              // 0x02C0(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2C1[0x7];                                      // 0x02C1(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void AddToGrid(class AMercunaNavGroundGrid* NavGrid_0)	 // 0x4860760;
	void SetSize(const struct FVector& Size)	 // 0x485d7bc;
	void SetType(const EMercunaInvokerVolumeType& Type_0)	 // 0x4864d48;

	struct FVector GetSize() const	 // 0x4859450;

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"MercunaNavInvokerVolume">();
	}
	static class AMercunaNavInvokerVolume* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<AMercunaNavInvokerVolume>();
	}
};
static_assert(alignof(AMercunaNavInvokerVolume) == 0x000008, "Wrong alignment on AMercunaNavInvokerVolume");
static_assert(sizeof(AMercunaNavInvokerVolume) == 0x0002C8, "Wrong size on AMercunaNavInvokerVolume");
static_assert(offsetof(AMercunaNavInvokerVolume, VolumeComponent) == 0x0002B0, "Member 'AMercunaNavInvokerVolume::VolumeComponent' has a wrong offset!");
static_assert(offsetof(AMercunaNavInvokerVolume, NavGrid) == 0x0002B8, "Member 'AMercunaNavInvokerVolume::NavGrid' has a wrong offset!");
static_assert(offsetof(AMercunaNavInvokerVolume, Type) == 0x0002C0, "Member 'AMercunaNavInvokerVolume::Type' has a wrong offset!");

// Class Mercuna.MercunaNavModifierVolume
// 0x0048 (0x02F8 - 0x02B0)
class AMercunaNavModifierVolume final : public AActor
{
public:
	TSoftObjectPtr<class AMercunaNavGraph>        NavGraph;                                          // 0x02B0(0x0030)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UMercunaVolumeComponent*                VolumeComponent;                                   // 0x02E0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bEnabled;                                          // 0x02E8(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2E9[0x3];                                      // 0x02E9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         CostMultiplier;                                    // 0x02EC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FMercunaUsageTypes                     UsageTypes;                                        // 0x02F0(0x0004)(Edit, NoDestructor, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2F4[0x4];                                      // 0x02F4(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void AddToGraph(class AMercunaNavGraph* NavGraph_0)	 // 0x486013c;
	void RemoveFromGraph()	 // 0x4864648;
	void SetCostMultiplier(float NewCostMultiplier)	 // 0x486465c;
	void SetEnabled(bool Enabled)	 // 0x4864950;
	void SetSize(const struct FVector& Size)	 // 0x4864b8c;
	void SetUsageTypes(const struct FMercunaUsageTypes& NewUsageTypes)	 // 0x4864dd4;

	struct FVector GetSize() const	 // 0x4862e98;

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"MercunaNavModifierVolume">();
	}
	static class AMercunaNavModifierVolume* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<AMercunaNavModifierVolume>();
	}
};
static_assert(alignof(AMercunaNavModifierVolume) == 0x000008, "Wrong alignment on AMercunaNavModifierVolume");
static_assert(sizeof(AMercunaNavModifierVolume) == 0x0002F8, "Wrong size on AMercunaNavModifierVolume");
static_assert(offsetof(AMercunaNavModifierVolume, NavGraph) == 0x0002B0, "Member 'AMercunaNavModifierVolume::NavGraph' has a wrong offset!");
static_assert(offsetof(AMercunaNavModifierVolume, VolumeComponent) == 0x0002E0, "Member 'AMercunaNavModifierVolume::VolumeComponent' has a wrong offset!");
static_assert(offsetof(AMercunaNavModifierVolume, bEnabled) == 0x0002E8, "Member 'AMercunaNavModifierVolume::bEnabled' has a wrong offset!");
static_assert(offsetof(AMercunaNavModifierVolume, CostMultiplier) == 0x0002EC, "Member 'AMercunaNavModifierVolume::CostMultiplier' has a wrong offset!");
static_assert(offsetof(AMercunaNavModifierVolume, UsageTypes) == 0x0002F0, "Member 'AMercunaNavModifierVolume::UsageTypes' has a wrong offset!");

// Class Mercuna.MercunaNavOctree
// 0x0090 (0x0530 - 0x04A0)
class AMercunaNavOctree final : public AMercunaNavGraph
{
public:
	int32                                         MinPawnRadius;                                     // 0x04A0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MaxPawnRadius;                                     // 0x04A4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bRestrictToSurfaces;                               // 0x04A8(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, IsPlainOldData, NoDestructor, AdvancedDisplay, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bRecordOctreeDeltas;                               // 0x04A9(0x0001)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4AA[0x6];                                      // 0x04AA(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	TMulticastInlineDelegate<void(bool Success)>  OnBuildLowResReady;                                // 0x04B0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(bool Success)>  OnBuildComplete;                                   // 0x04C0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NonPIEDuplicateTransient, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(const class AActor* Volume, bool Success)> OnRebuildComplete;      // 0x04D0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NonPIEDuplicateTransient, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(const class AActor* Volume, bool Success)> OnRebuildLowResReady;   // 0x04E0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NonPIEDuplicateTransient, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void()>              OnLoadComplete;                                    // 0x04F0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NonPIEDuplicateTransient, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void()>              OnShortRangeLoadComplete;                          // 0x0500(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NonPIEDuplicateTransient, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(const struct FBox& Bounds)> OnChunkAdded;                          // 0x0510(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NonPIEDuplicateTransient, NativeAccessSpecifierPublic)
	EMerOctreeDebugDrawMode                       DebugDrawMode;                                     // 0x0520(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_521[0xF];                                      // 0x0521(0x000F)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Build(const TArray<struct FVector>& PriorityPositions)	 // 0x48535fc;
	void ClampToNavigable(const struct FVector& Position, float NavigationRadius, float SearchRadius, struct FVector* ClampedPosition, bool* Result)	 // 0x4860b80;
	class UMercunaPath* FindPathToActor(const TDelegate<void(EMercunaPathEvent PathEvent)>& OnPathUpdated, const struct FVector& Start, class AActor* GoalActor, float NavigationRadius, bool AllowPartial, float MaxPathLength, float HeightChangePenalty)	 // 0x4860de0;
	class UMercunaPath* FindPathToLocation(const TDelegate<void(EMercunaPathEvent PathEvent)>& OnPathUpdated, const struct FVector& Start, const struct FVector& End, float NavigationRadius, bool AllowPartial, float MaxPathLength, float HeightChangePenalty)	 // 0x48613e4;
	class UMercunaPath* FindPathToLocations(const TDelegate<void(EMercunaPathEvent PathEvent)>& OnPathUpdated, const struct FVector& Start, const TArray<struct FVector>& Destinations, float NavigationRadius, bool AllowPartial, float MaxPathLength, float HeightChangePenalty)	 // 0x4861a00;
	class UMercunaSmoothPath* FindSmoothPathToLocation(const TDelegate<void(EMercunaPathEvent PathEvent)>& OnPathUpdated, const struct FVector& Start, const struct FVector& End, float NavigationRadius, float MaxSpeed, float MaxAcceleration, bool AllowPartial, float MaxPathLength)	 // 0x4861f74;
	class UMercunaSmoothPath* FindSmoothPathToLocations(const TDelegate<void(EMercunaPathEvent PathEvent)>& OnPathUpdated, const struct FVector& Start, const TArray<struct FVector>& Destinations, float NavigationRadius, float MaxSpeed, float MaxAcceleration, bool AllowPartial, float MaxPathLength)	 // 0x486266c;
	void IsNavigable(const struct FVector& Position, float NavigationRadius, bool* Result)	 // 0x4862f24;
	void IsNavigableMulti(const TArray<struct FVector>& Positions, float NavigationRadius, TArray<bool>* Results)	 // 0x48630bc;
	bool IsReachable(const struct FVector& Start, const struct FVector& End, float NavigationRadius, float MaxPathLength)	 // 0x4863284;
	void IsReachableLatent(const struct FVector& Start, const TArray<struct FVector>& EndPos, float NavigationRadius, TArray<bool>* Result, TArray<struct FVector>* ClampedPos, class UObject* WorldContextObject, const struct FLatentActionInfo& LatentInfo, float MaxPathLength, bool AccuratePathLength, float StartSearchRadius, float EndSearchRadius)	 // 0x48634f4;
	void Raycast(const struct FVector& Start, const struct FVector& End, float NavigationRadius, struct FVector* HitPosition, bool* RayHit)	 // 0x4863d58;
	void RebuildChanges(bool StagedBuild, bool RemoveUnseeded)	 // 0x4863fc8;
	void RebuildVolume(const class AActor* Volume, bool StagedBuild, bool RemoveUnseeded)	 // 0x4864118;
	void RebuildVolumes(const TArray<struct FBox>& Volumes, bool bStagedBuild, bool bRemoveUnseeded, bool bMergeVolumes)	 // 0x48642e4;
	void SetNavigationRotation(const struct FRotator& Rotation)	 // 0x4864b00;

	bool IsBuilding() const	 // 0x4859a18;

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"MercunaNavOctree">();
	}
	static class AMercunaNavOctree* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<AMercunaNavOctree>();
	}
};
static_assert(alignof(AMercunaNavOctree) == 0x000010, "Wrong alignment on AMercunaNavOctree");
static_assert(sizeof(AMercunaNavOctree) == 0x000530, "Wrong size on AMercunaNavOctree");
static_assert(offsetof(AMercunaNavOctree, MinPawnRadius) == 0x0004A0, "Member 'AMercunaNavOctree::MinPawnRadius' has a wrong offset!");
static_assert(offsetof(AMercunaNavOctree, MaxPawnRadius) == 0x0004A4, "Member 'AMercunaNavOctree::MaxPawnRadius' has a wrong offset!");
static_assert(offsetof(AMercunaNavOctree, bRestrictToSurfaces) == 0x0004A8, "Member 'AMercunaNavOctree::bRestrictToSurfaces' has a wrong offset!");
static_assert(offsetof(AMercunaNavOctree, bRecordOctreeDeltas) == 0x0004A9, "Member 'AMercunaNavOctree::bRecordOctreeDeltas' has a wrong offset!");
static_assert(offsetof(AMercunaNavOctree, OnBuildLowResReady) == 0x0004B0, "Member 'AMercunaNavOctree::OnBuildLowResReady' has a wrong offset!");
static_assert(offsetof(AMercunaNavOctree, OnBuildComplete) == 0x0004C0, "Member 'AMercunaNavOctree::OnBuildComplete' has a wrong offset!");
static_assert(offsetof(AMercunaNavOctree, OnRebuildComplete) == 0x0004D0, "Member 'AMercunaNavOctree::OnRebuildComplete' has a wrong offset!");
static_assert(offsetof(AMercunaNavOctree, OnRebuildLowResReady) == 0x0004E0, "Member 'AMercunaNavOctree::OnRebuildLowResReady' has a wrong offset!");
static_assert(offsetof(AMercunaNavOctree, OnLoadComplete) == 0x0004F0, "Member 'AMercunaNavOctree::OnLoadComplete' has a wrong offset!");
static_assert(offsetof(AMercunaNavOctree, OnShortRangeLoadComplete) == 0x000500, "Member 'AMercunaNavOctree::OnShortRangeLoadComplete' has a wrong offset!");
static_assert(offsetof(AMercunaNavOctree, OnChunkAdded) == 0x000510, "Member 'AMercunaNavOctree::OnChunkAdded' has a wrong offset!");
static_assert(offsetof(AMercunaNavOctree, DebugDrawMode) == 0x000520, "Member 'AMercunaNavOctree::DebugDrawMode' has a wrong offset!");

// Class Mercuna.MercunaNavOctreeModifierComponent
// 0x0030 (0x0610 - 0x05E0)
class UMercunaNavOctreeModifierComponent final : public UMercunaNavModifierComponent
{
public:
	TSoftObjectPtr<class AMercunaNavOctree>       NavOctree;                                         // 0x05E0(0x0030)(Edit, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void AddToOctree(class AMercunaNavOctree* NewNavOctree)	 // 0x48666a0;
	void RemoveFromOctree()	 // 0x486b5cc;

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"MercunaNavOctreeModifierComponent">();
	}
	static class UMercunaNavOctreeModifierComponent* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UMercunaNavOctreeModifierComponent>();
	}
};
static_assert(alignof(UMercunaNavOctreeModifierComponent) == 0x000010, "Wrong alignment on UMercunaNavOctreeModifierComponent");
static_assert(sizeof(UMercunaNavOctreeModifierComponent) == 0x000610, "Wrong size on UMercunaNavOctreeModifierComponent");
static_assert(offsetof(UMercunaNavOctreeModifierComponent, NavOctree) == 0x0005E0, "Member 'UMercunaNavOctreeModifierComponent::NavOctree' has a wrong offset!");

// Class Mercuna.MercunaNavOctreeModifierVolume
// 0x0008 (0x02B8 - 0x02B0)
class AMercunaNavOctreeModifierVolume final : public AActor
{
public:
	class UMercunaNavOctreeModifierComponent*     VolumeComponent;                                   // 0x02B0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void AddToOctree(class AMercunaNavOctree* NavOctree)	 // 0x485300c;
	void RemoveFromOctree()	 // 0x485cf3c;
	void SetCostMultiplier(float NewCostMultiplier)	 // 0x485d270;
	void SetEnabled(bool Enabled)	 // 0x485d338;
	void SetSize(const struct FVector& Size)	 // 0x485d7bc;
	void SetUsageTypes(const struct FMercunaUsageTypes& NewUsageTypes)	 // 0x485d898;

	struct FVector GetSize() const	 // 0x4859450;

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"MercunaNavOctreeModifierVolume">();
	}
	static class AMercunaNavOctreeModifierVolume* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<AMercunaNavOctreeModifierVolume>();
	}
};
static_assert(alignof(AMercunaNavOctreeModifierVolume) == 0x000008, "Wrong alignment on AMercunaNavOctreeModifierVolume");
static_assert(sizeof(AMercunaNavOctreeModifierVolume) == 0x0002B8, "Wrong size on AMercunaNavOctreeModifierVolume");
static_assert(offsetof(AMercunaNavOctreeModifierVolume, VolumeComponent) == 0x0002B0, "Member 'AMercunaNavOctreeModifierVolume::VolumeComponent' has a wrong offset!");

// Class Mercuna.MercunaNavOctreeTestingActor
// 0x0028 (0x0350 - 0x0328)
class AMercunaNavOctreeTestingActor final : public AMercunaNavTestingActor
{
public:
	class AMercunaNavOctreeTestingActor*          OtherActor;                                        // 0x0328(0x0008)(Edit, ZeroConstructor, NonTransactional, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Radius;                                            // 0x0330(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HeightChangePenalty;                               // 0x0334(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxSpeed;                                          // 0x0338(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxAcceleration;                                   // 0x033C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void()>              OnPathUpdated;                                     // 0x0340(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NonPIEDuplicateTransient, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"MercunaNavOctreeTestingActor">();
	}
	static class AMercunaNavOctreeTestingActor* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<AMercunaNavOctreeTestingActor>();
	}
};
static_assert(alignof(AMercunaNavOctreeTestingActor) == 0x000008, "Wrong alignment on AMercunaNavOctreeTestingActor");
static_assert(sizeof(AMercunaNavOctreeTestingActor) == 0x000350, "Wrong size on AMercunaNavOctreeTestingActor");
static_assert(offsetof(AMercunaNavOctreeTestingActor, OtherActor) == 0x000328, "Member 'AMercunaNavOctreeTestingActor::OtherActor' has a wrong offset!");
static_assert(offsetof(AMercunaNavOctreeTestingActor, Radius) == 0x000330, "Member 'AMercunaNavOctreeTestingActor::Radius' has a wrong offset!");
static_assert(offsetof(AMercunaNavOctreeTestingActor, HeightChangePenalty) == 0x000334, "Member 'AMercunaNavOctreeTestingActor::HeightChangePenalty' has a wrong offset!");
static_assert(offsetof(AMercunaNavOctreeTestingActor, MaxSpeed) == 0x000338, "Member 'AMercunaNavOctreeTestingActor::MaxSpeed' has a wrong offset!");
static_assert(offsetof(AMercunaNavOctreeTestingActor, MaxAcceleration) == 0x00033C, "Member 'AMercunaNavOctreeTestingActor::MaxAcceleration' has a wrong offset!");
static_assert(offsetof(AMercunaNavOctreeTestingActor, OnPathUpdated) == 0x000340, "Member 'AMercunaNavOctreeTestingActor::OnPathUpdated' has a wrong offset!");

// Class Mercuna.MercunaNavOctreeVolume
// 0x0038 (0x0300 - 0x02C8)
class AMercunaNavOctreeVolume final : public AMercunaNavVolume
{
public:
	TSoftObjectPtr<class AMercunaNavOctree>       NavOctree;                                         // 0x02C8(0x0030)(Edit, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EMercunaLevelOfDetail                         LOD;                                               // 0x02F8(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          FullDetailBuild;                                   // 0x02F9(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2FA[0x6];                                      // 0x02FA(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void AddToOctree(class AMercunaNavOctree* NavOctree_0)	 // 0x4853104;
	void RemoveFromOctree()	 // 0x485cf58;

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"MercunaNavOctreeVolume">();
	}
	static class AMercunaNavOctreeVolume* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<AMercunaNavOctreeVolume>();
	}
};
static_assert(alignof(AMercunaNavOctreeVolume) == 0x000008, "Wrong alignment on AMercunaNavOctreeVolume");
static_assert(sizeof(AMercunaNavOctreeVolume) == 0x000300, "Wrong size on AMercunaNavOctreeVolume");
static_assert(offsetof(AMercunaNavOctreeVolume, NavOctree) == 0x0002C8, "Member 'AMercunaNavOctreeVolume::NavOctree' has a wrong offset!");
static_assert(offsetof(AMercunaNavOctreeVolume, LOD) == 0x0002F8, "Member 'AMercunaNavOctreeVolume::LOD' has a wrong offset!");
static_assert(offsetof(AMercunaNavOctreeVolume, FullDetailBuild) == 0x0002F9, "Member 'AMercunaNavOctreeVolume::FullDetailBuild' has a wrong offset!");

// Class Mercuna.MercunaNavSeed
// 0x0000 (0x02B0 - 0x02B0)
class AMercunaNavSeed final : public AActor
{
public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"MercunaNavSeed">();
	}
	static class AMercunaNavSeed* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<AMercunaNavSeed>();
	}
};
static_assert(alignof(AMercunaNavSeed) == 0x000008, "Wrong alignment on AMercunaNavSeed");
static_assert(sizeof(AMercunaNavSeed) == 0x0002B0, "Wrong size on AMercunaNavSeed");

// Class Mercuna.MercunaNavSurfaceGrid
// 0x0000 (0x0650 - 0x0650)
class AMercunaNavSurfaceGrid final : public AMercunaNavGraph2D
{
public:
	void Build(const TArray<struct FVector>& PriorityPositions)	 // 0x48535fc;
	class UMercunaPath* FindPathToLocation(const struct FMercunaSurfaceAgentType& AgentType, const TDelegate<void(EMercunaPathEvent PathEvent)>& OnPathUpdated, const struct FVector& Start, const struct FVector& StartUp, const struct FVector& End, float IdealTurnRadius, float MaxSpeed, bool AllowPartial, float MaxPathLength, const struct FMercunaUsageSpec& UsageSpec)	 // 0x4866ed8;
	class UMercunaPath* FindPathToLocations(const struct FMercunaSurfaceAgentType& AgentType, const TDelegate<void(EMercunaPathEvent PathEvent)>& OnPathUpdated, const struct FVector& Start, const struct FVector& StartUp, const TArray<struct FVector>& Destinations, float IdealTurnRadius, float MaxSpeed, bool AllowPartial, float MaxPathLength, const struct FMercunaUsageSpec& UsageSpec)	 // 0x486774c;
	class UMercunaSmoothPath* FindSmoothPathToLocation(const struct FMercunaSurfaceAgentType& AgentType, const TDelegate<void(EMercunaPathEvent PathEvent)>& OnPathUpdated, const struct FVector& Start, const struct FVector& StartUp, const struct FVector& End, float IdealTurnRadius, float MaxSpeed, bool AllowPartial, float MaxPathLength, const struct FMercunaUsageSpec& UsageSpec)	 // 0x4867f14;
	class UMercunaSmoothPath* FindSmoothPathToLocations(const struct FMercunaSurfaceAgentType& AgentType, const TDelegate<void(EMercunaPathEvent PathEvent)>& OnPathUpdated, const struct FVector& Start, const struct FVector& StartUp, const TArray<struct FVector>& Destinations, float IdealTurnRadius, float MaxSpeed, bool AllowPartial, float MaxPathLength, const struct FMercunaUsageSpec& UsageSpec)	 // 0x4868788;
	void RebuildChanges()	 // 0x485c824;
	void RebuildVolume(const class AActor* Volume, bool bApplyNavSeeds)	 // 0x485c83c;
	void RebuildVolumes(const TArray<struct FBox>& Volumes, bool bMergeVolumes, bool bOnlyUnbuilt, bool bApplyNavSeeds)	 // 0x485c984;

	void ClampToNavigable(const struct FMercunaSurfaceAgentType& AgentType, const struct FVector& Position, const struct FVector& Up, float SearchRadius, float HeightRange, bool* bResult, struct FVector* ClampedPosition, struct FVector* ClampedUp, struct FMercunaUsageTypes* ClampedUsageTypes, const struct FMercunaUsageSpec& UsageSpec) const	 // 0x4866794;
	int32 GetNumBoxesBuilding() const	 // 0x48593b8;
	bool IsAnyWorkInProgress() const	 // 0x48599f0;
	bool IsBuilding() const	 // 0x4859a18;
	bool IsBuilt(const struct FMercunaSurfaceAgentType& AgentType, const struct FVector& Pos) const	 // 0x4868f50;
	bool IsBuiltWithinBox(const struct FMercunaSurfaceAgentType& AgentType, const struct FBox& Box) const	 // 0x48690b0;
	void IsNavigable(const struct FMercunaSurfaceAgentType& AgentType, const struct FVector& Position, const struct FVector& Up, bool* bResult, const struct FMercunaUsageSpec& UsageSpec) const	 // 0x48691b0;
	bool IsReachable(const struct FMercunaSurfaceAgentType& AgentType, const struct FVector& From, const struct FVector& FromUp, const struct FVector& To, float MaxPathLength, EMercunaNavLinkQueryMode FollowNavLinks, const struct FMercunaUsageSpec& UsageSpec) const	 // 0x48695e0;
	void IsReachableLatent(const struct FMercunaSurfaceAgentType& AgentType, const struct FVector& From, const struct FVector& FromUp, const TArray<struct FVector>& To, TArray<bool>* Result, TArray<struct FVector>* ClampedTo, class UObject* WorldContextObject, const struct FLatentActionInfo& LatentInfo, float MaxPathLength, float FromSearchRadius, float ToSearchRadius, EMercunaNavLinkQueryMode FollowNavLinks, const struct FMercunaUsageSpec& UsageSpec) const	 // 0x4869c18;
	void ProjectToNavigable(const struct FMercunaSurfaceAgentType& AgentType, const struct FVector& Position, const struct FVector& Up, EMercunaProjectionDirection Direction, bool* bResult, struct FVector* ProjectedPosition, float SearchDistance, const struct FMercunaUsageSpec& UsageSpec) const	 // 0x486a9ec;
	void Raycast(const struct FMercunaSurfaceAgentType& AgentType, const struct FVector& From, const struct FVector& FromUp, const struct FVector& To, bool* bRayHit, struct FVector* HitPosition, const struct FMercunaUsageSpec& UsageSpec) const	 // 0x486b044;
	void SaveToObjFile(const struct FMercunaSurfaceAgentType& AgentType, bool bDrawPolyMesh) const	 // 0x486b630;

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"MercunaNavSurfaceGrid">();
	}
	static class AMercunaNavSurfaceGrid* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<AMercunaNavSurfaceGrid>();
	}
};
static_assert(alignof(AMercunaNavSurfaceGrid) == 0x000010, "Wrong alignment on AMercunaNavSurfaceGrid");
static_assert(sizeof(AMercunaNavSurfaceGrid) == 0x000650, "Wrong size on AMercunaNavSurfaceGrid");

// Class Mercuna.MercunaOctreeClampToNavigableProxy
// 0x0048 (0x0078 - 0x0030)
class UMercunaOctreeClampToNavigableProxy final : public UBlueprintAsyncActionBase
{
public:
	TMulticastInlineDelegate<void(const struct FVector& ClampedPosition)> OnSuccess;                 // 0x0030(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(const struct FVector& ClampedPosition)> OnFailure;                 // 0x0040(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	class UObject*                                WorldContextObject;                                // 0x0050(0x0008)(ZeroConstructor, Transient, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_58[0x20];                                      // 0x0058(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UMercunaOctreeClampToNavigableProxy* ClampToNavigable(class UObject* WorldContextObject_0, const struct FVector& Position, float NavigationRadius, float SearchRadius)	 // 0x486f108;

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"MercunaOctreeClampToNavigableProxy">();
	}
	static class UMercunaOctreeClampToNavigableProxy* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UMercunaOctreeClampToNavigableProxy>();
	}
};
static_assert(alignof(UMercunaOctreeClampToNavigableProxy) == 0x000008, "Wrong alignment on UMercunaOctreeClampToNavigableProxy");
static_assert(sizeof(UMercunaOctreeClampToNavigableProxy) == 0x000078, "Wrong size on UMercunaOctreeClampToNavigableProxy");
static_assert(offsetof(UMercunaOctreeClampToNavigableProxy, OnSuccess) == 0x000030, "Member 'UMercunaOctreeClampToNavigableProxy::OnSuccess' has a wrong offset!");
static_assert(offsetof(UMercunaOctreeClampToNavigableProxy, OnFailure) == 0x000040, "Member 'UMercunaOctreeClampToNavigableProxy::OnFailure' has a wrong offset!");
static_assert(offsetof(UMercunaOctreeClampToNavigableProxy, WorldContextObject) == 0x000050, "Member 'UMercunaOctreeClampToNavigableProxy::WorldContextObject' has a wrong offset!");

// Class Mercuna.MercunaOctreeRaycastProxy
// 0x0060 (0x0090 - 0x0030)
class UMercunaOctreeRaycastProxy final : public UBlueprintAsyncActionBase
{
public:
	TMulticastInlineDelegate<void(const struct FVector& HitPosition)> OnNoHit;                       // 0x0030(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(const struct FVector& HitPosition)> OnHit;                         // 0x0040(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	class UObject*                                WorldContextObject;                                // 0x0050(0x0008)(ZeroConstructor, Transient, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_58[0x38];                                      // 0x0058(0x0038)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UMercunaOctreeRaycastProxy* NavigationRaycast(class UObject* WorldContextObject_0, const struct FVector& Start, const struct FVector& End, float NavigationRadius)	 // 0x48718dc;

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"MercunaOctreeRaycastProxy">();
	}
	static class UMercunaOctreeRaycastProxy* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UMercunaOctreeRaycastProxy>();
	}
};
static_assert(alignof(UMercunaOctreeRaycastProxy) == 0x000008, "Wrong alignment on UMercunaOctreeRaycastProxy");
static_assert(sizeof(UMercunaOctreeRaycastProxy) == 0x000090, "Wrong size on UMercunaOctreeRaycastProxy");
static_assert(offsetof(UMercunaOctreeRaycastProxy, OnNoHit) == 0x000030, "Member 'UMercunaOctreeRaycastProxy::OnNoHit' has a wrong offset!");
static_assert(offsetof(UMercunaOctreeRaycastProxy, OnHit) == 0x000040, "Member 'UMercunaOctreeRaycastProxy::OnHit' has a wrong offset!");
static_assert(offsetof(UMercunaOctreeRaycastProxy, WorldContextObject) == 0x000050, "Member 'UMercunaOctreeRaycastProxy::WorldContextObject' has a wrong offset!");

// Class Mercuna.MercunaPath
// 0x0018 (0x0040 - 0x0028)
class UMercunaPath : public UObject
{
public:
	TDelegate<void(EMercunaPathEvent PathEvent)>  PathUpdated;                                       // 0x0028(0x0010)(ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_38[0x8];                                       // 0x0038(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Invalidate()	 // 0x486fef4;

	void GetDebugInfo(int32* nodesUsed, bool* bOutOfNodes, float* queryTime) const	 // 0x486f55c;
	int32 GetNumPoints() const	 // 0x486fa50;
	float GetPathLength() const	 // 0x486fa74;
	struct FVector GetPoint(int32 I) const	 // 0x486fa9c;
	class FString GetStatus() const	 // 0x486fdac;
	bool IsPartial() const	 // 0x486ff08;
	bool IsReady() const	 // 0x486ff2c;
	bool IsValid() const	 // 0x486ff50;

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"MercunaPath">();
	}
	static class UMercunaPath* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UMercunaPath>();
	}
};
static_assert(alignof(UMercunaPath) == 0x000008, "Wrong alignment on UMercunaPath");
static_assert(sizeof(UMercunaPath) == 0x000040, "Wrong size on UMercunaPath");
static_assert(offsetof(UMercunaPath, PathUpdated) == 0x000028, "Member 'UMercunaPath::PathUpdated' has a wrong offset!");

// Class Mercuna.MercunaPhysicalMaterial
// 0x0008 (0x0090 - 0x0088)
class UMercunaPhysicalMaterial final : public UPhysicalMaterial
{
public:
	float                                         CostMultiplier;                                    // 0x0088(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_8C[0x4];                                       // 0x008C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"MercunaPhysicalMaterial">();
	}
	static class UMercunaPhysicalMaterial* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UMercunaPhysicalMaterial>();
	}
};
static_assert(alignof(UMercunaPhysicalMaterial) == 0x000008, "Wrong alignment on UMercunaPhysicalMaterial");
static_assert(sizeof(UMercunaPhysicalMaterial) == 0x000090, "Wrong size on UMercunaPhysicalMaterial");
static_assert(offsetof(UMercunaPhysicalMaterial, CostMultiplier) == 0x000088, "Member 'UMercunaPhysicalMaterial::CostMultiplier' has a wrong offset!");

// Class Mercuna.MercunaSmoothPath
// 0x0000 (0x0040 - 0x0040)
class UMercunaSmoothPath final : public UMercunaPath
{
public:
	struct FVector GetPosition(const float Length) const	 // 0x486fb7c;
	TArray<struct FSplinePoint> GetSplinePoints(const struct FTransform& RelativeTo) const	 // 0x486fc60;
	struct FVector GetTangent(const float Length) const	 // 0x486fe10;

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"MercunaSmoothPath">();
	}
	static class UMercunaSmoothPath* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UMercunaSmoothPath>();
	}
};
static_assert(alignof(UMercunaSmoothPath) == 0x000008, "Wrong alignment on UMercunaSmoothPath");
static_assert(sizeof(UMercunaSmoothPath) == 0x000040, "Wrong size on UMercunaSmoothPath");

// Class Mercuna.MercunaSurfaceMoveToProxy
// 0x0090 (0x00C0 - 0x0030)
class UMercunaSurfaceMoveToProxy final : public UBlueprintAsyncActionBase
{
public:
	TMulticastInlineDelegate<void()>              OnSuccess;                                         // 0x0030(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void()>              OnFailure;                                         // 0x0040(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	class APawn*                                  Pawn;                                              // 0x0050(0x0008)(ZeroConstructor, Transient, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_58[0x68];                                      // 0x0058(0x0068)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UMercunaSurfaceMoveToProxy* MoveToActor(class UObject* WorldContextObject, class APawn* Pawn_0, class AActor* Actor, float EndDistance, float Speed, bool UsePartialPath, bool UseEndActorOrientation)	 // 0x48702b8;
	static class UMercunaSurfaceMoveToProxy* MoveToLocation(class UObject* WorldContextObject, class APawn* Pawn_0, const struct FVector& Destination, float EndDistance, float Speed, bool UsePartialPath, const struct FVector& EndDirection)	 // 0x487092c;
	static class UMercunaSurfaceMoveToProxy* MoveToLocations(class UObject* WorldContextObject, class APawn* Pawn_0, const TArray<struct FVector>& Destinations, float EndDistance, float Speed, bool UsePartialPath, const struct FVector& EndDirection)	 // 0x4870f7c;

	void OnMoveComplete(const struct FAIRequestID& RequestID, EMercunaMoveResult Result)	 // 0x4871b38;

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"MercunaSurfaceMoveToProxy">();
	}
	static class UMercunaSurfaceMoveToProxy* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UMercunaSurfaceMoveToProxy>();
	}
};
static_assert(alignof(UMercunaSurfaceMoveToProxy) == 0x000008, "Wrong alignment on UMercunaSurfaceMoveToProxy");
static_assert(sizeof(UMercunaSurfaceMoveToProxy) == 0x0000C0, "Wrong size on UMercunaSurfaceMoveToProxy");
static_assert(offsetof(UMercunaSurfaceMoveToProxy, OnSuccess) == 0x000030, "Member 'UMercunaSurfaceMoveToProxy::OnSuccess' has a wrong offset!");
static_assert(offsetof(UMercunaSurfaceMoveToProxy, OnFailure) == 0x000040, "Member 'UMercunaSurfaceMoveToProxy::OnFailure' has a wrong offset!");
static_assert(offsetof(UMercunaSurfaceMoveToProxy, Pawn) == 0x000050, "Member 'UMercunaSurfaceMoveToProxy::Pawn' has a wrong offset!");

// Class Mercuna.MercunaSurfaceTrackActorProxy
// 0x0048 (0x0078 - 0x0030)
class UMercunaSurfaceTrackActorProxy final : public UBlueprintAsyncActionBase
{
public:
	TMulticastInlineDelegate<void()>              OnFailure;                                         // 0x0030(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	class APawn*                                  Pawn;                                              // 0x0040(0x0008)(ZeroConstructor, Transient, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_48[0x30];                                      // 0x0048(0x0030)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UMercunaSurfaceTrackActorProxy* TrackActor(class UObject* WorldContextObject, class APawn* Pawn_0, class AActor* Actor, float Distance, float Speed, const struct FVector& Offset, bool UsePartialPath, bool UseEndActorOrientation)	 // 0x48722c4;

	void OnMoveComplete(const struct FAIRequestID& RequestID, EMercunaMoveResult Result)	 // 0x4871c78;

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"MercunaSurfaceTrackActorProxy">();
	}
	static class UMercunaSurfaceTrackActorProxy* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UMercunaSurfaceTrackActorProxy>();
	}
};
static_assert(alignof(UMercunaSurfaceTrackActorProxy) == 0x000008, "Wrong alignment on UMercunaSurfaceTrackActorProxy");
static_assert(sizeof(UMercunaSurfaceTrackActorProxy) == 0x000078, "Wrong size on UMercunaSurfaceTrackActorProxy");
static_assert(offsetof(UMercunaSurfaceTrackActorProxy, OnFailure) == 0x000030, "Member 'UMercunaSurfaceTrackActorProxy::OnFailure' has a wrong offset!");
static_assert(offsetof(UMercunaSurfaceTrackActorProxy, Pawn) == 0x000040, "Member 'UMercunaSurfaceTrackActorProxy::Pawn' has a wrong offset!");

// Class Mercuna.MercunaSurfaceNavigationComponent
// 0x0040 (0x0290 - 0x0250)
class UMercunaSurfaceNavigationComponent final : public UMercuna2DNavigationComponent
{
public:
	class AMercunaNavSurfaceGrid*                 NavSurfaceGrid;                                    // 0x0250(0x0008)(Edit, ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FMercunaSurfaceAgentType               AgentType;                                         // 0x0258(0x000C)(Edit, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bAutomaticSteeringParameters;                      // 0x0264(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_265[0x3];                                      // 0x0265(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FMercunaSurfaceNavigationSteeringParameters SteeringParameters;                           // 0x0268(0x0014)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, Protected, NativeAccessSpecifierProtected)
	struct FMercunaSurfaceNavigationConfiguration Configuration;                                     // 0x027C(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_28C[0x4];                                      // 0x028C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void AddDestinationLocation(const struct FVector& NextDestination, bool bSmoothTransition)	 // 0x484d898;
	void CancelMovement()	 // 0x486f0e8;
	void ClearAvoidanceExclusions()	 // 0x1203138;
	void Configure(const struct FMercunaSurfaceNavigationConfiguration& NewConfiguration)	 // 0x486f34c;
	void ConfigureMovement(EMercunaAvoidanceMode NewAvoidanceMode)	 // 0x486f3e4;
	void ConfigureSteering(const struct FMercunaSurfaceNavigationSteeringParameters& NewSteering)	 // 0x486f4a4;
	struct FVector GetLookDirection()	 // 0x484dd14;
	void GetPathInfo(bool* Valid, float* DistanceToEnd)	 // 0x484796c;
	float GetRemainingPathLength()	 // 0x4847a4c;
	void InvalidateContextualSteeringParams()	 // 0x476124c;
	void InvalidateContextualSteeringParamsAgainstActor(class AActor* Actor)	 // 0x4847c20;
	void MoveToActor(class AActor* Actor, float EndDistance, float Speed, bool UsePartialPath, bool bUseEndActorOrientation)	 // 0x4870664;
	void MoveToLocation(const struct FVector& Destination, const struct FVector& EndDirection, float EndDistance, float Speed, bool UsePartialPath)	 // 0x4870cc8;
	void MoveToLocations(const TArray<struct FVector>& Destinations, const struct FVector& EndDirection, float EndDistance, float Speed, bool UsePartialPath)	 // 0x487149c;
	void NavLinkComplete()	 // 0x484f9dc;
	bool OverrideSpeedMultiplier(const float NewSpeedMultiplier)	 // 0x4849c64;
	void PauseNavigation()	 // 0x484fc74;
	void ResumeNavigation()	 // 0x484fc8c;
	void SetAgentType(const struct FMercunaSurfaceAgentType& NewAgentType)	 // 0x4871db8;
	void SetAvoidanceAgainst(class AActor* Actor, bool Enable)	 // 0x4849dc4;
	void SetNavGrid(class AMercunaNavSurfaceGrid* NavSurfaceGrid_0)	 // 0x4871e94;
	void SetNavGridToBest()	 // 0x4871f54;
	void SetUsageSpec(const struct FMercunaUsageSpec& NewUsageSpec)	 // 0x484a09c;
	void Stop()	 // 0x484fe54;
	void TrackActor(class AActor* Actor, float Distance, float Speed, const struct FVector& Offset, bool UsePartialPath, bool bUseEndActorOrientation)	 // 0x4871f68;
	void UpdateDynamicSteeringParams(const struct FMercunaSurfaceNavigationDynamicSteeringParameters& NewDynamicSteeringParams)	 // 0x4872704;

	struct FMercunaSurfaceNavigationConfiguration GetConfiguration() const	 // 0x486f540;
	struct FMercunaSurfaceNavigationDynamicSteeringParameters GetDynamicSteeringParameters() const	 // 0x486f684;
	struct FVector GetLastRequestedMoveVelocity() const	 // 0x486f718;
	class AMercunaNavSurfaceGrid* GetNavGrid() const	 // 0x486f740;
	void GetNextNavLink(bool* bNextNavLinkFound, float* DistanceToNextNavLink, float* TimeToNextNavLink, struct FVector* TraversalStart, struct FVector* TraversalEnd, class AMercunaNavLink** NavLink, float MaxLookAhead) const	 // 0x486f758;
	struct FMercunaSurfaceNavigationSteeringParameters GetSteeringParameters() const	 // 0x486fdec;
	const struct FMercunaUsageSpec GetUsageSpec() const	 // 0x4847a78;

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"MercunaSurfaceNavigationComponent">();
	}
	static class UMercunaSurfaceNavigationComponent* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UMercunaSurfaceNavigationComponent>();
	}
};
static_assert(alignof(UMercunaSurfaceNavigationComponent) == 0x000008, "Wrong alignment on UMercunaSurfaceNavigationComponent");
static_assert(sizeof(UMercunaSurfaceNavigationComponent) == 0x000290, "Wrong size on UMercunaSurfaceNavigationComponent");
static_assert(offsetof(UMercunaSurfaceNavigationComponent, NavSurfaceGrid) == 0x000250, "Member 'UMercunaSurfaceNavigationComponent::NavSurfaceGrid' has a wrong offset!");
static_assert(offsetof(UMercunaSurfaceNavigationComponent, AgentType) == 0x000258, "Member 'UMercunaSurfaceNavigationComponent::AgentType' has a wrong offset!");
static_assert(offsetof(UMercunaSurfaceNavigationComponent, bAutomaticSteeringParameters) == 0x000264, "Member 'UMercunaSurfaceNavigationComponent::bAutomaticSteeringParameters' has a wrong offset!");
static_assert(offsetof(UMercunaSurfaceNavigationComponent, SteeringParameters) == 0x000268, "Member 'UMercunaSurfaceNavigationComponent::SteeringParameters' has a wrong offset!");
static_assert(offsetof(UMercunaSurfaceNavigationComponent, Configuration) == 0x00027C, "Member 'UMercunaSurfaceNavigationComponent::Configuration' has a wrong offset!");

// Class Mercuna.MercunaSurfaceTask_MoveTo
// 0x00B0 (0x0120 - 0x0070)
class UMercunaSurfaceTask_MoveTo final : public UAITask
{
public:
	TMulticastInlineDelegate<void()>              OnRequestFailed;                                   // 0x0070(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, Protected, NativeAccessSpecifierProtected)
	TMulticastInlineDelegate<void(EMercunaMoveResult Result, class AAIController* AIController)> OnMoveFinished; // 0x0080(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_90[0x90];                                      // 0x0090(0x0090)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UMercunaSurfaceTask_MoveTo* MoveTo(class AAIController* Controller, const struct FVector& GoalLocation, class AActor* GoalActor, float EndDistance, bool AcceptPartialPath, bool bLockAILogic)	 // 0x486ff74;

	void OnMoveComplete(const struct FAIRequestID& RequestID, EMercunaMoveResult Result)	 // 0x48499e0;

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"MercunaSurfaceTask_MoveTo">();
	}
	static class UMercunaSurfaceTask_MoveTo* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UMercunaSurfaceTask_MoveTo>();
	}
};
static_assert(alignof(UMercunaSurfaceTask_MoveTo) == 0x000008, "Wrong alignment on UMercunaSurfaceTask_MoveTo");
static_assert(sizeof(UMercunaSurfaceTask_MoveTo) == 0x000120, "Wrong size on UMercunaSurfaceTask_MoveTo");
static_assert(offsetof(UMercunaSurfaceTask_MoveTo, OnRequestFailed) == 0x000070, "Member 'UMercunaSurfaceTask_MoveTo::OnRequestFailed' has a wrong offset!");
static_assert(offsetof(UMercunaSurfaceTask_MoveTo, OnMoveFinished) == 0x000080, "Member 'UMercunaSurfaceTask_MoveTo::OnMoveFinished' has a wrong offset!");

// Class Mercuna.MerEntitySubsystem
// 0x0018 (0x0058 - 0x0040)
class UMerEntitySubsystem final : public UTickableWorldSubsystem
{
public:
	uint8                                         Pad_40[0x18];                                      // 0x0040(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"MerEntitySubsystem">();
	}
	static class UMerEntitySubsystem* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UMerEntitySubsystem>();
	}
};
static_assert(alignof(UMerEntitySubsystem) == 0x000008, "Wrong alignment on UMerEntitySubsystem");
static_assert(sizeof(UMerEntitySubsystem) == 0x000058, "Wrong size on UMerEntitySubsystem");

// Class Mercuna.MerNavDataChunk
// 0x0110 (0x03C0 - 0x02B0)
class AMerNavDataChunk final : public AActor
{
public:
	uint8                                         Pad_2B0[0x10];                                     // 0x02B0(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftObjectPtr<class AMercunaNavGraph>        NavGraph;                                          // 0x02C0(0x0030)(Edit, EditConst, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class AMercunaNavGraph*                       NavGraphPtr;                                       // 0x02F0(0x0008)(ZeroConstructor, Transient, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TMap<class UPhysicalMaterial*, uint32>        SurfaceMaterials;                                  // 0x02F8(0x0050)(NativeAccessSpecifierPrivate)
	struct FBox                                   DataChunkBounds;                                   // 0x0348(0x0038)(ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPrivate)
	struct FIntVector                             DataChunkCoords;                                   // 0x0380(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_38C[0x14];                                     // 0x038C(0x0014)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                RelativePosition;                                  // 0x03A0(0x0018)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         CRC;                                               // 0x03B8(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_3BC[0x4];                                      // 0x03BC(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"MerNavDataChunk">();
	}
	static class AMerNavDataChunk* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<AMerNavDataChunk>();
	}
};
static_assert(alignof(AMerNavDataChunk) == 0x000008, "Wrong alignment on AMerNavDataChunk");
static_assert(sizeof(AMerNavDataChunk) == 0x0003C0, "Wrong size on AMerNavDataChunk");
static_assert(offsetof(AMerNavDataChunk, NavGraph) == 0x0002C0, "Member 'AMerNavDataChunk::NavGraph' has a wrong offset!");
static_assert(offsetof(AMerNavDataChunk, NavGraphPtr) == 0x0002F0, "Member 'AMerNavDataChunk::NavGraphPtr' has a wrong offset!");
static_assert(offsetof(AMerNavDataChunk, SurfaceMaterials) == 0x0002F8, "Member 'AMerNavDataChunk::SurfaceMaterials' has a wrong offset!");
static_assert(offsetof(AMerNavDataChunk, DataChunkBounds) == 0x000348, "Member 'AMerNavDataChunk::DataChunkBounds' has a wrong offset!");
static_assert(offsetof(AMerNavDataChunk, DataChunkCoords) == 0x000380, "Member 'AMerNavDataChunk::DataChunkCoords' has a wrong offset!");
static_assert(offsetof(AMerNavDataChunk, RelativePosition) == 0x0003A0, "Member 'AMerNavDataChunk::RelativePosition' has a wrong offset!");
static_assert(offsetof(AMerNavDataChunk, CRC) == 0x0003B8, "Member 'AMerNavDataChunk::CRC' has a wrong offset!");

// Class Mercuna.MerNavGraphRenderingComponent
// 0x0020 (0x05D0 - 0x05B0)
class UMerNavGraphRenderingComponent : public UPrimitiveComponent
{
public:
	bool                                          bDrawChunkBounds;                                  // 0x05A8(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_5A9[0x7];                                      // 0x05A9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UMaterialInterface*>             Materials;                                         // 0x05B0(0x0010)(ZeroConstructor, Protected, UObjectWrapper, NativeAccessSpecifierProtected)
	uint8                                         Pad_5C0[0x10];                                     // 0x05C0(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"MerNavGraphRenderingComponent">();
	}
	static class UMerNavGraphRenderingComponent* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UMerNavGraphRenderingComponent>();
	}
};
static_assert(alignof(UMerNavGraphRenderingComponent) == 0x000010, "Wrong alignment on UMerNavGraphRenderingComponent");
static_assert(sizeof(UMerNavGraphRenderingComponent) == 0x0005D0, "Wrong size on UMerNavGraphRenderingComponent");
static_assert(offsetof(UMerNavGraphRenderingComponent, bDrawChunkBounds) == 0x0005A8, "Member 'UMerNavGraphRenderingComponent::bDrawChunkBounds' has a wrong offset!");
static_assert(offsetof(UMerNavGraphRenderingComponent, Materials) == 0x0005B0, "Member 'UMerNavGraphRenderingComponent::Materials' has a wrong offset!");

// Class Mercuna.MerNavGridRenderingComponent
// 0x0020 (0x05F0 - 0x05D0)
class UMerNavGridRenderingComponent final : public UMerNavGraphRenderingComponent
{
public:
	bool                                          bDrawPolygons;                                     // 0x05D0(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bDrawPolygonLabels;                                // 0x05D1(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bDrawGenerationBoxes;                              // 0x05D2(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bDrawAutoJumpLinks;                                // 0x05D3(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         DrawDistance;                                      // 0x05D4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_5D8[0x18];                                     // 0x05D8(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"MerNavGridRenderingComponent">();
	}
	static class UMerNavGridRenderingComponent* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UMerNavGridRenderingComponent>();
	}
};
static_assert(alignof(UMerNavGridRenderingComponent) == 0x000010, "Wrong alignment on UMerNavGridRenderingComponent");
static_assert(sizeof(UMerNavGridRenderingComponent) == 0x0005F0, "Wrong size on UMerNavGridRenderingComponent");
static_assert(offsetof(UMerNavGridRenderingComponent, bDrawPolygons) == 0x0005D0, "Member 'UMerNavGridRenderingComponent::bDrawPolygons' has a wrong offset!");
static_assert(offsetof(UMerNavGridRenderingComponent, bDrawPolygonLabels) == 0x0005D1, "Member 'UMerNavGridRenderingComponent::bDrawPolygonLabels' has a wrong offset!");
static_assert(offsetof(UMerNavGridRenderingComponent, bDrawGenerationBoxes) == 0x0005D2, "Member 'UMerNavGridRenderingComponent::bDrawGenerationBoxes' has a wrong offset!");
static_assert(offsetof(UMerNavGridRenderingComponent, bDrawAutoJumpLinks) == 0x0005D3, "Member 'UMerNavGridRenderingComponent::bDrawAutoJumpLinks' has a wrong offset!");
static_assert(offsetof(UMerNavGridRenderingComponent, DrawDistance) == 0x0005D4, "Member 'UMerNavGridRenderingComponent::DrawDistance' has a wrong offset!");

// Class Mercuna.MerNavLinkRenderingComponent
// 0x0000 (0x05B0 - 0x05B0)
class UMerNavLinkRenderingComponent final : public UPrimitiveComponent
{
public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"MerNavLinkRenderingComponent">();
	}
	static class UMerNavLinkRenderingComponent* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UMerNavLinkRenderingComponent>();
	}
};
static_assert(alignof(UMerNavLinkRenderingComponent) == 0x000010, "Wrong alignment on UMerNavLinkRenderingComponent");
static_assert(sizeof(UMerNavLinkRenderingComponent) == 0x0005B0, "Wrong size on UMerNavLinkRenderingComponent");

// Class Mercuna.MerNavOctreeRenderingComponent
// 0x0010 (0x05E0 - 0x05D0)
class UMerNavOctreeRenderingComponent final : public UMerNavGraphRenderingComponent
{
public:
	int32                                         DrawDistance;                                      // 0x05D0(0x0004)(Edit, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_5D4[0xC];                                      // 0x05D4(0x000C)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"MerNavOctreeRenderingComponent">();
	}
	static class UMerNavOctreeRenderingComponent* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UMerNavOctreeRenderingComponent>();
	}
};
static_assert(alignof(UMerNavOctreeRenderingComponent) == 0x000010, "Wrong alignment on UMerNavOctreeRenderingComponent");
static_assert(sizeof(UMerNavOctreeRenderingComponent) == 0x0005E0, "Wrong size on UMerNavOctreeRenderingComponent");
static_assert(offsetof(UMerNavOctreeRenderingComponent, DrawDistance) == 0x0005D0, "Member 'UMerNavOctreeRenderingComponent::DrawDistance' has a wrong offset!");

// Class Mercuna.MerSettings
// 0x0100 (0x0128 - 0x0028)
class UMerSettings final : public UObject
{
public:
	float                                         DebugLengthScale;                                  // 0x0028(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAlwaysShowErrors;                                 // 0x002C(0x0001)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2D[0x3];                                       // 0x002D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class FName>                           ModifierUsageTypes;                                // 0x0030(0x0010)(Edit, ZeroConstructor, Config, NativeAccessSpecifierPublic)
	TMap<class FName, struct FMercunaGroundAgentProperties> GroundAgentTypes;                        // 0x0040(0x0050)(Edit, Config, NativeAccessSpecifierPublic)
	TMap<class FName, struct FMercunaSurfaceAgentProperties> SurfaceAgentTypes;                      // 0x0090(0x0050)(Edit, Config, NativeAccessSpecifierPublic)
	bool                                          bAutoLinkNavVolumesWithGraphs;                     // 0x00E0(0x0001)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EMercunaNavGraphVolumeOrientation             AlignGraphAndVolumeOrientations;                   // 0x00E1(0x0001)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_E2[0x6];                                       // 0x00E2(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	double                                        GeometryCollectionTimePerFrame;                    // 0x00E8(0x0008)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bLoadNavigationOnClient;                           // 0x00F0(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_F1[0x3];                                       // 0x00F1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         SingleThreadedJobTimePerFrame;                     // 0x00F4(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EMercunaWorkerThreadType                      WorkerThreadType;                                  // 0x00F8(0x0001)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_F9[0x3];                                       // 0x00F9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         NumMercunaWorkThreads;                             // 0x00FC(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIgnoreStepForHeightClearance;                     // 0x0100(0x0001)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bWarnIfSubLevelNavGraphsNotBuiltInPersistentLevel; // 0x0101(0x0001)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAllowNavGraphMerging;                             // 0x0102(0x0001)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_103[0x1];                                      // 0x0103(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         OctreeCellSize;                                    // 0x0104(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MinPawnRadius;                                     // 0x0108(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MaxPawnRadius;                                     // 0x010C(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_110[0x18];                                     // 0x0110(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"MerSettings">();
	}
	static class UMerSettings* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UMerSettings>();
	}
};
static_assert(alignof(UMerSettings) == 0x000008, "Wrong alignment on UMerSettings");
static_assert(sizeof(UMerSettings) == 0x000128, "Wrong size on UMerSettings");
static_assert(offsetof(UMerSettings, DebugLengthScale) == 0x000028, "Member 'UMerSettings::DebugLengthScale' has a wrong offset!");
static_assert(offsetof(UMerSettings, bAlwaysShowErrors) == 0x00002C, "Member 'UMerSettings::bAlwaysShowErrors' has a wrong offset!");
static_assert(offsetof(UMerSettings, ModifierUsageTypes) == 0x000030, "Member 'UMerSettings::ModifierUsageTypes' has a wrong offset!");
static_assert(offsetof(UMerSettings, GroundAgentTypes) == 0x000040, "Member 'UMerSettings::GroundAgentTypes' has a wrong offset!");
static_assert(offsetof(UMerSettings, SurfaceAgentTypes) == 0x000090, "Member 'UMerSettings::SurfaceAgentTypes' has a wrong offset!");
static_assert(offsetof(UMerSettings, bAutoLinkNavVolumesWithGraphs) == 0x0000E0, "Member 'UMerSettings::bAutoLinkNavVolumesWithGraphs' has a wrong offset!");
static_assert(offsetof(UMerSettings, AlignGraphAndVolumeOrientations) == 0x0000E1, "Member 'UMerSettings::AlignGraphAndVolumeOrientations' has a wrong offset!");
static_assert(offsetof(UMerSettings, GeometryCollectionTimePerFrame) == 0x0000E8, "Member 'UMerSettings::GeometryCollectionTimePerFrame' has a wrong offset!");
static_assert(offsetof(UMerSettings, bLoadNavigationOnClient) == 0x0000F0, "Member 'UMerSettings::bLoadNavigationOnClient' has a wrong offset!");
static_assert(offsetof(UMerSettings, SingleThreadedJobTimePerFrame) == 0x0000F4, "Member 'UMerSettings::SingleThreadedJobTimePerFrame' has a wrong offset!");
static_assert(offsetof(UMerSettings, WorkerThreadType) == 0x0000F8, "Member 'UMerSettings::WorkerThreadType' has a wrong offset!");
static_assert(offsetof(UMerSettings, NumMercunaWorkThreads) == 0x0000FC, "Member 'UMerSettings::NumMercunaWorkThreads' has a wrong offset!");
static_assert(offsetof(UMerSettings, bIgnoreStepForHeightClearance) == 0x000100, "Member 'UMerSettings::bIgnoreStepForHeightClearance' has a wrong offset!");
static_assert(offsetof(UMerSettings, bWarnIfSubLevelNavGraphsNotBuiltInPersistentLevel) == 0x000101, "Member 'UMerSettings::bWarnIfSubLevelNavGraphsNotBuiltInPersistentLevel' has a wrong offset!");
static_assert(offsetof(UMerSettings, bAllowNavGraphMerging) == 0x000102, "Member 'UMerSettings::bAllowNavGraphMerging' has a wrong offset!");
static_assert(offsetof(UMerSettings, OctreeCellSize) == 0x000104, "Member 'UMerSettings::OctreeCellSize' has a wrong offset!");
static_assert(offsetof(UMerSettings, MinPawnRadius) == 0x000108, "Member 'UMerSettings::MinPawnRadius' has a wrong offset!");
static_assert(offsetof(UMerSettings, MaxPawnRadius) == 0x00010C, "Member 'UMerSettings::MaxPawnRadius' has a wrong offset!");

// Class Mercuna.MerEditorSettings
// 0x0078 (0x00A0 - 0x0028)
class UMerEditorSettings final : public UObject
{
public:
	bool                                          bEnableExtraLogging;                               // 0x0028(0x0001)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bFlushMercunaLogFileOnWrite;                       // 0x0029(0x0001)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2A[0x2];                                       // 0x002A(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	struct FMerOctreeEditorSettings               OctreeEditorSettings;                              // 0x002C(0x0030)(Edit, Config, NoDestructor, NativeAccessSpecifierPublic)
	struct FMerGridEditorSettings                 GridEditorSettings;                                // 0x005C(0x0028)(Edit, Config, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_84[0x1C];                                      // 0x0084(0x001C)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"MerEditorSettings">();
	}
	static class UMerEditorSettings* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UMerEditorSettings>();
	}
};
static_assert(alignof(UMerEditorSettings) == 0x000008, "Wrong alignment on UMerEditorSettings");
static_assert(sizeof(UMerEditorSettings) == 0x0000A0, "Wrong size on UMerEditorSettings");
static_assert(offsetof(UMerEditorSettings, bEnableExtraLogging) == 0x000028, "Member 'UMerEditorSettings::bEnableExtraLogging' has a wrong offset!");
static_assert(offsetof(UMerEditorSettings, bFlushMercunaLogFileOnWrite) == 0x000029, "Member 'UMerEditorSettings::bFlushMercunaLogFileOnWrite' has a wrong offset!");
static_assert(offsetof(UMerEditorSettings, OctreeEditorSettings) == 0x00002C, "Member 'UMerEditorSettings::OctreeEditorSettings' has a wrong offset!");
static_assert(offsetof(UMerEditorSettings, GridEditorSettings) == 0x00005C, "Member 'UMerEditorSettings::GridEditorSettings' has a wrong offset!");

}

