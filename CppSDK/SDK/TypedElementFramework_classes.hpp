#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: TypedElementFramework

#include "Basic.hpp"

#include "CoreUObject_classes.hpp"


namespace SDK
{

// Class TypedElementFramework.TypedElementDataStorageCompatibilityInterface
// 0x0000 (0x0000 - 0x0000)
class ITypedElementDataStorageCompatibilityInterface final
{
public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"TypedElementDataStorageCompatibilityInterface">();
	}
	static class ITypedElementDataStorageCompatibilityInterface* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<ITypedElementDataStorageCompatibilityInterface>();
	}

	class UObject* AsUObject()	 // 0x0
	{
		return reinterpret_cast<UObject*>(this);
	}
	const class UObject* AsUObject() const	 // 0x0
	{
		return reinterpret_cast<const UObject*>(this);
	}
};
static_assert(alignof(ITypedElementDataStorageCompatibilityInterface) == 0x000001, "Wrong alignment on ITypedElementDataStorageCompatibilityInterface");
static_assert(sizeof(ITypedElementDataStorageCompatibilityInterface) == 0x000001, "Wrong size on ITypedElementDataStorageCompatibilityInterface");

// Class TypedElementFramework.TypedElementDataStorageInterface
// 0x0000 (0x0000 - 0x0000)
class ITypedElementDataStorageInterface final
{
public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"TypedElementDataStorageInterface">();
	}
	static class ITypedElementDataStorageInterface* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<ITypedElementDataStorageInterface>();
	}

	class UObject* AsUObject()	 // 0x0
	{
		return reinterpret_cast<UObject*>(this);
	}
	const class UObject* AsUObject() const	 // 0x0
	{
		return reinterpret_cast<const UObject*>(this);
	}
};
static_assert(alignof(ITypedElementDataStorageInterface) == 0x000001, "Wrong alignment on ITypedElementDataStorageInterface");
static_assert(sizeof(ITypedElementDataStorageInterface) == 0x000001, "Wrong size on ITypedElementDataStorageInterface");

// Class TypedElementFramework.TypedElementDataStorageUiInterface
// 0x0000 (0x0000 - 0x0000)
class ITypedElementDataStorageUiInterface final
{
public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"TypedElementDataStorageUiInterface">();
	}
	static class ITypedElementDataStorageUiInterface* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<ITypedElementDataStorageUiInterface>();
	}

	class UObject* AsUObject()	 // 0x0
	{
		return reinterpret_cast<UObject*>(this);
	}
	const class UObject* AsUObject() const	 // 0x0
	{
		return reinterpret_cast<const UObject*>(this);
	}
};
static_assert(alignof(ITypedElementDataStorageUiInterface) == 0x000001, "Wrong alignment on ITypedElementDataStorageUiInterface");
static_assert(sizeof(ITypedElementDataStorageUiInterface) == 0x000001, "Wrong size on ITypedElementDataStorageUiInterface");

// Class TypedElementFramework.TypedElementHandleLibrary
// 0x0000 (0x0028 - 0x0028)
class UTypedElementHandleLibrary final : public UObject
{
public:
	static bool Equal(const struct FScriptTypedElementHandle& LHS, const struct FScriptTypedElementHandle& RHS)	 // 0x6454efc;
	static bool IsSet(const struct FScriptTypedElementHandle& ElementHandle)	 // 0x6455f2c;
	static bool NotEqual(const struct FScriptTypedElementHandle& LHS, const struct FScriptTypedElementHandle& RHS)	 // 0x6456234;
	static void Release(struct FScriptTypedElementHandle& ElementHandle)	 // 0x645653c;

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"TypedElementHandleLibrary">();
	}
	static class UTypedElementHandleLibrary* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UTypedElementHandleLibrary>();
	}
};
static_assert(alignof(UTypedElementHandleLibrary) == 0x000008, "Wrong alignment on UTypedElementHandleLibrary");
static_assert(sizeof(UTypedElementHandleLibrary) == 0x000028, "Wrong size on UTypedElementHandleLibrary");

// Class TypedElementFramework.TypedElementListLibrary
// 0x0000 (0x0028 - 0x0028)
class UTypedElementListLibrary final : public UObject
{
public:
	static bool Add(const struct FScriptTypedElementListProxy& ElementList, const struct FScriptTypedElementHandle& ElementHandle)	 // 0x6453b8c;
	static void Append(const struct FScriptTypedElementListProxy& ElementList, const TArray<struct FScriptTypedElementHandle>& ElementHandles)	 // 0x6453e04;
	static void AppendList(const struct FScriptTypedElementListProxy& ElementList, const struct FScriptTypedElementListProxy& OtherElementList)	 // 0x6454044;
	static struct FScriptTypedElementListProxy Clone(const struct FScriptTypedElementListProxy& ElementList)	 // 0x64543e8;
	static bool Contains(const struct FScriptTypedElementListProxy& ElementList, const struct FScriptTypedElementHandle& ElementHandle)	 // 0x645452c;
	static int32 CountElements(const struct FScriptTypedElementListProxy& ElementList, const TSubclassOf<class IInterface> BaseInterfaceType)	 // 0x64547a8;
	static int32 CountElementsOfType(const struct FScriptTypedElementListProxy& ElementList, const class FName ElementTypeName)	 // 0x6454a14;
	static struct FScriptTypedElementListProxy CreateScriptElementList(class UTypedElementRegistry* Registry)	 // 0x6454c6c;
	static void Empty(const struct FScriptTypedElementListProxy& ElementList, const int32 Slack)	 // 0x6454d54;
	static struct FScriptTypedElementHandle GetElementHandleAt(const struct FScriptTypedElementListProxy& ElementList, const int32 Index_0)	 // 0x6455108;
	static TArray<struct FScriptTypedElementHandle> GetElementHandles(const struct FScriptTypedElementListProxy& ElementList, const TSubclassOf<class IInterface> BaseInterfaceType)	 // 0x64552c8;
	static class UObject* GetElementInterface(const struct FScriptTypedElementListProxy& ElementList, const struct FScriptTypedElementHandle& ElementHandle, const TSubclassOf<class IInterface> BaseInterfaceType)	 // 0x645549c;
	static bool HasElements(const struct FScriptTypedElementListProxy& ElementList, const TSubclassOf<class IInterface> BaseInterfaceType)	 // 0x6455a60;
	static bool HasElementsOfType(const struct FScriptTypedElementListProxy& ElementList, const class FName ElementTypeName)	 // 0x6455cd0;
	static bool IsValidIndex(const struct FScriptTypedElementListProxy& ElementList, const int32 Index_0)	 // 0x6455fdc;
	static int32 Num(const struct FScriptTypedElementListProxy& ElementList)	 // 0x6456360;
	static bool Remove(const struct FScriptTypedElementListProxy& ElementList, const struct FScriptTypedElementHandle& ElementHandle)	 // 0x64565e0;
	static void Reserve(const struct FScriptTypedElementListProxy& ElementList, const int32 Size)	 // 0x645684c;
	static void Reset(const struct FScriptTypedElementListProxy& ElementList)	 // 0x6456aec;
	static void Shrink(const struct FScriptTypedElementListProxy& ElementList)	 // 0x6456ebc;

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"TypedElementListLibrary">();
	}
	static class UTypedElementListLibrary* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UTypedElementListLibrary>();
	}
};
static_assert(alignof(UTypedElementListLibrary) == 0x000008, "Wrong alignment on UTypedElementListLibrary");
static_assert(sizeof(UTypedElementListLibrary) == 0x000028, "Wrong size on UTypedElementListLibrary");

// Class TypedElementFramework.TypedElementCounterInterface
// 0x0000 (0x0000 - 0x0000)
class ITypedElementCounterInterface final
{
public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"TypedElementCounterInterface">();
	}
	static class ITypedElementCounterInterface* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<ITypedElementCounterInterface>();
	}

	class UObject* AsUObject()	 // 0x0
	{
		return reinterpret_cast<UObject*>(this);
	}
	const class UObject* AsUObject() const	 // 0x0
	{
		return reinterpret_cast<const UObject*>(this);
	}
};
static_assert(alignof(ITypedElementCounterInterface) == 0x000001, "Wrong alignment on ITypedElementCounterInterface");
static_assert(sizeof(ITypedElementCounterInterface) == 0x000001, "Wrong size on ITypedElementCounterInterface");

// Class TypedElementFramework.TypedElementRegistry
// 0x0950 (0x0978 - 0x0028)
class UTypedElementRegistry final : public UObject
{
public:
	uint8                                         Pad_28[0x950];                                     // 0x0028(0x0950)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UTypedElementRegistry* GetInstance()	 // 0x6455988;

	class UObject* GetElementInterface(const struct FScriptTypedElementHandle& InElementHandle, const TSubclassOf<class IInterface> InBaseInterfaceType) const	 // 0x64557d0;

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"TypedElementRegistry">();
	}
	static class UTypedElementRegistry* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UTypedElementRegistry>();
	}
};
static_assert(alignof(UTypedElementRegistry) == 0x000008, "Wrong alignment on UTypedElementRegistry");
static_assert(sizeof(UTypedElementRegistry) == 0x000978, "Wrong size on UTypedElementRegistry");

// Class TypedElementFramework.TestTypedElementInterfaceA
// 0x0000 (0x0000 - 0x0000)
class ITestTypedElementInterfaceA final
{
public:
	class FText GetDisplayName(const struct FScriptTypedElementHandle& InElementHandle)	 // 0x6455028;
	bool SetDisplayName(const struct FScriptTypedElementHandle& InElementHandle, const class FText& InNewName, bool bNotify)	 // 0x6456c14;

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"TestTypedElementInterfaceA">();
	}
	static class ITestTypedElementInterfaceA* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<ITestTypedElementInterfaceA>();
	}

	class UObject* AsUObject()	 // 0x0
	{
		return reinterpret_cast<UObject*>(this);
	}
	const class UObject* AsUObject() const	 // 0x0
	{
		return reinterpret_cast<const UObject*>(this);
	}
};
static_assert(alignof(ITestTypedElementInterfaceA) == 0x000001, "Wrong alignment on ITestTypedElementInterfaceA");
static_assert(sizeof(ITestTypedElementInterfaceA) == 0x000001, "Wrong size on ITestTypedElementInterfaceA");

// Class TypedElementFramework.TestTypedElementInterfaceB
// 0x0000 (0x0000 - 0x0000)
class ITestTypedElementInterfaceB final
{
public:
	bool MarkAsTested(const struct FScriptTypedElementHandle& InElementHandle)	 // 0x64559ac;

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"TestTypedElementInterfaceB">();
	}
	static class ITestTypedElementInterfaceB* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<ITestTypedElementInterfaceB>();
	}

	class UObject* AsUObject()	 // 0x0
	{
		return reinterpret_cast<UObject*>(this);
	}
	const class UObject* AsUObject() const	 // 0x0
	{
		return reinterpret_cast<const UObject*>(this);
	}
};
static_assert(alignof(ITestTypedElementInterfaceB) == 0x000001, "Wrong alignment on ITestTypedElementInterfaceB");
static_assert(sizeof(ITestTypedElementInterfaceB) == 0x000001, "Wrong size on ITestTypedElementInterfaceB");

// Class TypedElementFramework.TestTypedElementInterfaceC
// 0x0000 (0x0000 - 0x0000)
class ITestTypedElementInterfaceC final
{
public:
	bool GetIsTested(const struct FScriptTypedElementHandle& InElementHandle) const	 // 0x64559ac;

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"TestTypedElementInterfaceC">();
	}
	static class ITestTypedElementInterfaceC* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<ITestTypedElementInterfaceC>();
	}

	class UObject* AsUObject()	 // 0x0
	{
		return reinterpret_cast<UObject*>(this);
	}
	const class UObject* AsUObject() const	 // 0x0
	{
		return reinterpret_cast<const UObject*>(this);
	}
};
static_assert(alignof(ITestTypedElementInterfaceC) == 0x000001, "Wrong alignment on ITestTypedElementInterfaceC");
static_assert(sizeof(ITestTypedElementInterfaceC) == 0x000001, "Wrong size on ITestTypedElementInterfaceC");

// Class TypedElementFramework.TestTypedElementInterfaceA_ImplTyped
// 0x0008 (0x0030 - 0x0028)
class UTestTypedElementInterfaceA_ImplTyped final : public UObject
{
public:
	uint8                                         Pad_28[0x8];                                       // 0x0028(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"TestTypedElementInterfaceA_ImplTyped">();
	}
	static class UTestTypedElementInterfaceA_ImplTyped* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UTestTypedElementInterfaceA_ImplTyped>();
	}
};
static_assert(alignof(UTestTypedElementInterfaceA_ImplTyped) == 0x000008, "Wrong alignment on UTestTypedElementInterfaceA_ImplTyped");
static_assert(sizeof(UTestTypedElementInterfaceA_ImplTyped) == 0x000030, "Wrong size on UTestTypedElementInterfaceA_ImplTyped");

// Class TypedElementFramework.TestTypedElementInterfaceA_ImplUntyped
// 0x0008 (0x0030 - 0x0028)
class UTestTypedElementInterfaceA_ImplUntyped final : public UObject
{
public:
	uint8                                         Pad_28[0x8];                                       // 0x0028(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"TestTypedElementInterfaceA_ImplUntyped">();
	}
	static class UTestTypedElementInterfaceA_ImplUntyped* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UTestTypedElementInterfaceA_ImplUntyped>();
	}
};
static_assert(alignof(UTestTypedElementInterfaceA_ImplUntyped) == 0x000008, "Wrong alignment on UTestTypedElementInterfaceA_ImplUntyped");
static_assert(sizeof(UTestTypedElementInterfaceA_ImplUntyped) == 0x000030, "Wrong size on UTestTypedElementInterfaceA_ImplUntyped");

// Class TypedElementFramework.TestTypedElementInterfaceBAndC_Typed
// 0x0010 (0x0038 - 0x0028)
class UTestTypedElementInterfaceBAndC_Typed final : public UObject
{
public:
	uint8                                         Pad_28[0x10];                                      // 0x0028(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"TestTypedElementInterfaceBAndC_Typed">();
	}
	static class UTestTypedElementInterfaceBAndC_Typed* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UTestTypedElementInterfaceBAndC_Typed>();
	}
};
static_assert(alignof(UTestTypedElementInterfaceBAndC_Typed) == 0x000008, "Wrong alignment on UTestTypedElementInterfaceBAndC_Typed");
static_assert(sizeof(UTestTypedElementInterfaceBAndC_Typed) == 0x000038, "Wrong size on UTestTypedElementInterfaceBAndC_Typed");

}

