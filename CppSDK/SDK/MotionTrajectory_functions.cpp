#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: MotionTrajectory

#include "Basic.hpp"

#include "MotionTrajectory_classes.hpp"
#include "MotionTrajectory_parameters.hpp"


namespace SDK
{

// Function MotionTrajectory.MotionTrajectoryComponent.GetHistory
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FTrajectorySampleRange           ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

struct FTrajectorySampleRange UMotionTrajectoryComponent::GetHistory() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MotionTrajectoryComponent", "GetHistory");

	Params::MotionTrajectoryComponent_GetHistory Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function MotionTrajectory.MotionTrajectoryComponent.GetTrajectory
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FTrajectorySampleRange           ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

struct FTrajectorySampleRange UMotionTrajectoryComponent::GetTrajectory() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MotionTrajectoryComponent", "GetTrajectory");

	Params::MotionTrajectoryComponent_GetTrajectory Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function MotionTrajectory.MotionTrajectoryComponent.GetTrajectoryWithSettings
// (Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const struct FMotionTrajectorySettings& Settings                                               (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// bool                                    bIncludeHistory                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FTrajectorySampleRange           ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

struct FTrajectorySampleRange UMotionTrajectoryComponent::GetTrajectoryWithSettings(const struct FMotionTrajectorySettings& Settings, bool bIncludeHistory) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MotionTrajectoryComponent", "GetTrajectoryWithSettings");

	Params::MotionTrajectoryComponent_GetTrajectoryWithSettings Parms{};

	Parms.Settings = std::move(Settings);
	Parms.bIncludeHistory = bIncludeHistory;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function MotionTrajectory.CharacterMovementTrajectoryComponent.OnMovementUpdated
// (Final, Native, Protected, HasDefaults)
// Parameters:
// float                                   DeltaSeconds                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FVector&                   OldLocation                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FVector&                   OldVelocity                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCharacterMovementTrajectoryComponent::OnMovementUpdated(float DeltaSeconds, const struct FVector& OldLocation, const struct FVector& OldVelocity)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterMovementTrajectoryComponent", "OnMovementUpdated");

	Params::CharacterMovementTrajectoryComponent_OnMovementUpdated Parms{};

	Parms.DeltaSeconds = DeltaSeconds;
	Parms.OldLocation = std::move(OldLocation);
	Parms.OldVelocity = std::move(OldVelocity);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function MotionTrajectory.MotionTrajectoryBlueprintLibrary.DebugDrawTrajectory
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// const class AActor*                     Actor                                                  (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FTransform&                WorldTransform                                         (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FTrajectorySampleRange&    Trajectory                                             (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// const struct FLinearColor&              PredictionColor                                        (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FLinearColor&              HistoryColor                                           (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   TransformScale                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   TransformThickness                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ArrowScale                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ArrowSize                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ArrowThickness                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMotionTrajectoryBlueprintLibrary::DebugDrawTrajectory(const class AActor* Actor, const struct FTransform& WorldTransform, const struct FTrajectorySampleRange& Trajectory, const struct FLinearColor& PredictionColor, const struct FLinearColor& HistoryColor, float TransformScale, float TransformThickness, float ArrowScale, float ArrowSize, float ArrowThickness)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MotionTrajectoryBlueprintLibrary", "DebugDrawTrajectory");

	Params::MotionTrajectoryBlueprintLibrary_DebugDrawTrajectory Parms{};

	Parms.Actor = Actor;
	Parms.WorldTransform = std::move(WorldTransform);
	Parms.Trajectory = std::move(Trajectory);
	Parms.PredictionColor = std::move(PredictionColor);
	Parms.HistoryColor = std::move(HistoryColor);
	Parms.TransformScale = TransformScale;
	Parms.TransformThickness = TransformThickness;
	Parms.ArrowScale = ArrowScale;
	Parms.ArrowSize = ArrowSize;
	Parms.ArrowThickness = ArrowThickness;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function MotionTrajectory.MotionTrajectoryBlueprintLibrary.FlattenTrajectory2D
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const struct FTrajectorySampleRange&    Trajectory                                             (Parm, NativeAccessSpecifierPublic)
// struct FTrajectorySampleRange           ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

struct FTrajectorySampleRange UMotionTrajectoryBlueprintLibrary::FlattenTrajectory2D(const struct FTrajectorySampleRange& Trajectory)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MotionTrajectoryBlueprintLibrary", "FlattenTrajectory2D");

	Params::MotionTrajectoryBlueprintLibrary_FlattenTrajectory2D Parms{};

	Parms.Trajectory = std::move(Trajectory);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function MotionTrajectory.MotionTrajectoryBlueprintLibrary.IsConstantSpeedTrajectory
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// const struct FTrajectorySampleRange&    Trajectory                                             (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// float                                   Speed                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Tolerance                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UMotionTrajectoryBlueprintLibrary::IsConstantSpeedTrajectory(const struct FTrajectorySampleRange& Trajectory, float Speed, float Tolerance)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MotionTrajectoryBlueprintLibrary", "IsConstantSpeedTrajectory");

	Params::MotionTrajectoryBlueprintLibrary_IsConstantSpeedTrajectory Parms{};

	Parms.Trajectory = std::move(Trajectory);
	Parms.Speed = Speed;
	Parms.Tolerance = Tolerance;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function MotionTrajectory.MotionTrajectoryBlueprintLibrary.IsStartingTrajectory
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// const struct FTrajectorySampleRange&    Trajectory                                             (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// float                                   MoveMinSpeed                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   IdleMaxSpeed                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UMotionTrajectoryBlueprintLibrary::IsStartingTrajectory(const struct FTrajectorySampleRange& Trajectory, float MoveMinSpeed, float IdleMaxSpeed)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MotionTrajectoryBlueprintLibrary", "IsStartingTrajectory");

	Params::MotionTrajectoryBlueprintLibrary_IsStartingTrajectory Parms{};

	Parms.Trajectory = std::move(Trajectory);
	Parms.MoveMinSpeed = MoveMinSpeed;
	Parms.IdleMaxSpeed = IdleMaxSpeed;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function MotionTrajectory.MotionTrajectoryBlueprintLibrary.IsStoppingTrajectory
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// const struct FTrajectorySampleRange&    Trajectory                                             (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// float                                   MoveMinSpeed                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   IdleMaxSpeed                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UMotionTrajectoryBlueprintLibrary::IsStoppingTrajectory(const struct FTrajectorySampleRange& Trajectory, float MoveMinSpeed, float IdleMaxSpeed)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MotionTrajectoryBlueprintLibrary", "IsStoppingTrajectory");

	Params::MotionTrajectoryBlueprintLibrary_IsStoppingTrajectory Parms{};

	Parms.Trajectory = std::move(Trajectory);
	Parms.MoveMinSpeed = MoveMinSpeed;
	Parms.IdleMaxSpeed = IdleMaxSpeed;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function MotionTrajectory.MotionTrajectoryBlueprintLibrary.MakeTrajectoryRelativeToComponent
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const struct FTrajectorySampleRange&    ActorTrajectory                                        (Parm, NativeAccessSpecifierPublic)
// const class USceneComponent*            Component                                              (ConstParm, Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FTrajectorySampleRange           ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

struct FTrajectorySampleRange UMotionTrajectoryBlueprintLibrary::MakeTrajectoryRelativeToComponent(const struct FTrajectorySampleRange& ActorTrajectory, const class USceneComponent* Component)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MotionTrajectoryBlueprintLibrary", "MakeTrajectoryRelativeToComponent");

	Params::MotionTrajectoryBlueprintLibrary_MakeTrajectoryRelativeToComponent Parms{};

	Parms.ActorTrajectory = std::move(ActorTrajectory);
	Parms.Component = Component;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function MotionTrajectory.MotionTrajectoryBlueprintLibrary.RotateTrajectory
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// const struct FTrajectorySampleRange&    Trajectory                                             (Parm, NativeAccessSpecifierPublic)
// const struct FQuat&                     Rotation                                               (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FTrajectorySampleRange           ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

struct FTrajectorySampleRange UMotionTrajectoryBlueprintLibrary::RotateTrajectory(const struct FTrajectorySampleRange& Trajectory, const struct FQuat& Rotation)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MotionTrajectoryBlueprintLibrary", "RotateTrajectory");

	Params::MotionTrajectoryBlueprintLibrary_RotateTrajectory Parms{};

	Parms.Trajectory = std::move(Trajectory);
	Parms.Rotation = std::move(Rotation);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}

}

