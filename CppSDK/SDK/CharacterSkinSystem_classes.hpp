#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: CharacterSkinSystem

#include "Basic.hpp"

#include "CoreUObject_structs.hpp"
#include "CoreUObject_classes.hpp"
#include "Engine_structs.hpp"
#include "Engine_classes.hpp"
#include "CharacterSkinSystem_structs.hpp"


namespace SDK
{

// Class CharacterSkinSystem.CustomizableSlotTable
// 0x00C0 (0x00F0 - 0x0030)
class UCustomizableSlotTable final : public UDataAsset
{
public:
	TArray<class FName>                           SlotOrder;                                         // 0x0030(0x0010)(Edit, BlueprintVisible, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	class FName                                   PrefixCacheRange;                                  // 0x0040(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FIsolateConfig                         IsolateConfig;                                     // 0x0048(0x0058)(Edit, BlueprintVisible, Protected, NativeAccessSpecifierProtected)
	TMap<class FName, int32>                      OrderMap;                                          // 0x00A0(0x0050)(NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"CustomizableSlotTable">();
	}
	static class UCustomizableSlotTable* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UCustomizableSlotTable>();
	}
};
static_assert(alignof(UCustomizableSlotTable) == 0x000008, "Wrong alignment on UCustomizableSlotTable");
static_assert(sizeof(UCustomizableSlotTable) == 0x0000F0, "Wrong size on UCustomizableSlotTable");
static_assert(offsetof(UCustomizableSlotTable, SlotOrder) == 0x000030, "Member 'UCustomizableSlotTable::SlotOrder' has a wrong offset!");
static_assert(offsetof(UCustomizableSlotTable, PrefixCacheRange) == 0x000040, "Member 'UCustomizableSlotTable::PrefixCacheRange' has a wrong offset!");
static_assert(offsetof(UCustomizableSlotTable, IsolateConfig) == 0x000048, "Member 'UCustomizableSlotTable::IsolateConfig' has a wrong offset!");
static_assert(offsetof(UCustomizableSlotTable, OrderMap) == 0x0000A0, "Member 'UCustomizableSlotTable::OrderMap' has a wrong offset!");

// Class CharacterSkinSystem.BaseSkinCommand
// 0x0120 (0x0148 - 0x0028)
class UBaseSkinCommand : public UObject
{
public:
	uint8                                         Pad_28[0x70];                                      // 0x0028(0x0070)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bGenerateDebugMesh;                                // 0x0098(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_99[0x7];                                       // 0x0099(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TSet<int32>                                   OnlyRunInSpecificLODs;                             // 0x00A0(0x0050)(Edit, BlueprintVisible, Protected, NativeAccessSpecifierProtected)
	TSet<int32>                                   BlockRunInSpecificLODs;                            // 0x00F0(0x0050)(Edit, BlueprintVisible, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_140[0x8];                                      // 0x0140(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"BaseSkinCommand">();
	}
	static class UBaseSkinCommand* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UBaseSkinCommand>();
	}
};
static_assert(alignof(UBaseSkinCommand) == 0x000008, "Wrong alignment on UBaseSkinCommand");
static_assert(sizeof(UBaseSkinCommand) == 0x000148, "Wrong size on UBaseSkinCommand");
static_assert(offsetof(UBaseSkinCommand, bGenerateDebugMesh) == 0x000098, "Member 'UBaseSkinCommand::bGenerateDebugMesh' has a wrong offset!");
static_assert(offsetof(UBaseSkinCommand, OnlyRunInSpecificLODs) == 0x0000A0, "Member 'UBaseSkinCommand::OnlyRunInSpecificLODs' has a wrong offset!");
static_assert(offsetof(UBaseSkinCommand, BlockRunInSpecificLODs) == 0x0000F0, "Member 'UBaseSkinCommand::BlockRunInSpecificLODs' has a wrong offset!");

// Class CharacterSkinSystem.CharacterSkinCommandEditorInterface
// 0x0000 (0x0000 - 0x0000)
class ICharacterSkinCommandEditorInterface final
{
public:
	void GetPrimitiveGizmoInfos(TArray<struct FPrimitiveGizmoInfo>* GizmoInfos)	 // 0x43eee98;

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"CharacterSkinCommandEditorInterface">();
	}
	static class ICharacterSkinCommandEditorInterface* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<ICharacterSkinCommandEditorInterface>();
	}

	class UObject* AsUObject()	 // 0x0
	{
		return reinterpret_cast<UObject*>(this);
	}
	const class UObject* AsUObject() const	 // 0x0
	{
		return reinterpret_cast<const UObject*>(this);
	}
};
static_assert(alignof(ICharacterSkinCommandEditorInterface) == 0x000001, "Wrong alignment on ICharacterSkinCommandEditorInterface");
static_assert(sizeof(ICharacterSkinCommandEditorInterface) == 0x000001, "Wrong size on ICharacterSkinCommandEditorInterface");

// Class CharacterSkinSystem.CharacterSkinComponent
// 0x00A0 (0x0380 - 0x02E0)
class UCharacterSkinComponent final : public USceneComponent
{
public:
	TMulticastInlineDelegate<void(class USkeletalMesh* OutputMesh)> OnAsyncSkinPipelineCompleted;    // 0x02E0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, Protected, NativeAccessSpecifierProtected)
	class UCustomizableSlotTable*                 SlotTable;                                         // 0x02F0(0x0008)(Edit, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class UCustomizableSkinObject*>        SkinObjects;                                       // 0x02F8(0x0010)(Edit, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	class USkeletalMesh*                          ReferenceMesh;                                     // 0x0308(0x0008)(Edit, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USkeletalMeshLODSettings*               OverrideLODSettings;                               // 0x0310(0x0008)(Edit, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bOverrideSamplingInfo;                             // 0x0318(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_319[0x7];                                      // 0x0319(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FSkeletalMeshSamplingInfo              OverrideSamplingInfo;                              // 0x0320(0x0030)(Edit, Protected, NativeAccessSpecifierProtected)
	EPipelineCachingPriority                      CachingPriority;                                   // 0x0350(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIsCacheEnabled;                                   // 0x0351(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_352[0x2];                                      // 0x0352(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         SpawnTimeMinLOD;                                   // 0x0354(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_358[0x28];                                     // 0x0358(0x0028)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	bool AddSkinObject(class UCustomizableSkinObject* InSkinObject)	 // 0x43eeb1c;
	void ClearSkinObjects()	 // 0x43eec4c;
	bool RemoveSkinObject(class FName InSlotName)	 // 0x43eef30;
	bool StartAsyncSkinUpdate()	 // 0x43ef000;
	class USkeletalMesh* StartSkinUpdate()	 // 0x43ef024;

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"CharacterSkinComponent">();
	}
	static class UCharacterSkinComponent* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UCharacterSkinComponent>();
	}
};
static_assert(alignof(UCharacterSkinComponent) == 0x000010, "Wrong alignment on UCharacterSkinComponent");
static_assert(sizeof(UCharacterSkinComponent) == 0x000380, "Wrong size on UCharacterSkinComponent");
static_assert(offsetof(UCharacterSkinComponent, OnAsyncSkinPipelineCompleted) == 0x0002E0, "Member 'UCharacterSkinComponent::OnAsyncSkinPipelineCompleted' has a wrong offset!");
static_assert(offsetof(UCharacterSkinComponent, SlotTable) == 0x0002F0, "Member 'UCharacterSkinComponent::SlotTable' has a wrong offset!");
static_assert(offsetof(UCharacterSkinComponent, SkinObjects) == 0x0002F8, "Member 'UCharacterSkinComponent::SkinObjects' has a wrong offset!");
static_assert(offsetof(UCharacterSkinComponent, ReferenceMesh) == 0x000308, "Member 'UCharacterSkinComponent::ReferenceMesh' has a wrong offset!");
static_assert(offsetof(UCharacterSkinComponent, OverrideLODSettings) == 0x000310, "Member 'UCharacterSkinComponent::OverrideLODSettings' has a wrong offset!");
static_assert(offsetof(UCharacterSkinComponent, bOverrideSamplingInfo) == 0x000318, "Member 'UCharacterSkinComponent::bOverrideSamplingInfo' has a wrong offset!");
static_assert(offsetof(UCharacterSkinComponent, OverrideSamplingInfo) == 0x000320, "Member 'UCharacterSkinComponent::OverrideSamplingInfo' has a wrong offset!");
static_assert(offsetof(UCharacterSkinComponent, CachingPriority) == 0x000350, "Member 'UCharacterSkinComponent::CachingPriority' has a wrong offset!");
static_assert(offsetof(UCharacterSkinComponent, bIsCacheEnabled) == 0x000351, "Member 'UCharacterSkinComponent::bIsCacheEnabled' has a wrong offset!");
static_assert(offsetof(UCharacterSkinComponent, SpawnTimeMinLOD) == 0x000354, "Member 'UCharacterSkinComponent::SpawnTimeMinLOD' has a wrong offset!");

// Class CharacterSkinSystem.CharacterSkinDebugUserData
// 0x0010 (0x0038 - 0x0028)
class UCharacterSkinDebugUserData final : public UAssetUserData
{
public:
	uint8                                         Pad_28[0x10];                                      // 0x0028(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"CharacterSkinDebugUserData">();
	}
	static class UCharacterSkinDebugUserData* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UCharacterSkinDebugUserData>();
	}
};
static_assert(alignof(UCharacterSkinDebugUserData) == 0x000008, "Wrong alignment on UCharacterSkinDebugUserData");
static_assert(sizeof(UCharacterSkinDebugUserData) == 0x000038, "Wrong size on UCharacterSkinDebugUserData");

// Class CharacterSkinSystem.CharacterSkinSubsystem
// 0x0050 (0x0080 - 0x0030)
class UCharacterSkinSubsystem final : public UGameInstanceSubsystem
{
public:
	int32                                         HighPriorityCacheLimit;                            // 0x0030(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         NormalPriorityCacheLimit;                          // 0x0034(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         LowPriorityCacheLimit;                             // 0x0038(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         BakeTaskLimit;                                     // 0x003C(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_40[0x40];                                      // 0x0040(0x0040)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"CharacterSkinSubsystem">();
	}
	static class UCharacterSkinSubsystem* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UCharacterSkinSubsystem>();
	}
};
static_assert(alignof(UCharacterSkinSubsystem) == 0x000008, "Wrong alignment on UCharacterSkinSubsystem");
static_assert(sizeof(UCharacterSkinSubsystem) == 0x000080, "Wrong size on UCharacterSkinSubsystem");
static_assert(offsetof(UCharacterSkinSubsystem, HighPriorityCacheLimit) == 0x000030, "Member 'UCharacterSkinSubsystem::HighPriorityCacheLimit' has a wrong offset!");
static_assert(offsetof(UCharacterSkinSubsystem, NormalPriorityCacheLimit) == 0x000034, "Member 'UCharacterSkinSubsystem::NormalPriorityCacheLimit' has a wrong offset!");
static_assert(offsetof(UCharacterSkinSubsystem, LowPriorityCacheLimit) == 0x000038, "Member 'UCharacterSkinSubsystem::LowPriorityCacheLimit' has a wrong offset!");
static_assert(offsetof(UCharacterSkinSubsystem, BakeTaskLimit) == 0x00003C, "Member 'UCharacterSkinSubsystem::BakeTaskLimit' has a wrong offset!");

// Class CharacterSkinSystem.CharacterSystemTestFunctionLibrary
// 0x0000 (0x0028 - 0x0028)
class UCharacterSystemTestFunctionLibrary final : public UBlueprintFunctionLibrary
{
public:
	static bool CompareWithSavedMesh(class USkeletalMesh* TargetMesh, class USkeletalMesh* SavedMesh, const struct FGeometryScriptIsSameMeshOptions& OPTIONS, class FString* OutErrorMessage)	 // 0x43eec60;
	static bool ValidateBoneWeight(class USkeletalMesh* TargetMesh, class FString* OutErrorMessage)	 // 0x43ef048;

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"CharacterSystemTestFunctionLibrary">();
	}
	static class UCharacterSystemTestFunctionLibrary* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UCharacterSystemTestFunctionLibrary>();
	}
};
static_assert(alignof(UCharacterSystemTestFunctionLibrary) == 0x000008, "Wrong alignment on UCharacterSystemTestFunctionLibrary");
static_assert(sizeof(UCharacterSystemTestFunctionLibrary) == 0x000028, "Wrong size on UCharacterSystemTestFunctionLibrary");

// Class CharacterSkinSystem.CustomizableSkinObject
// 0x0038 (0x0060 - 0x0028)
class UCustomizableSkinObject final : public UObject
{
public:
	TArray<struct FSkinCommand>                   SkinCommands;                                      // 0x0028(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<class UCustomizableSlotTable*>         SlotTables;                                        // 0x0038(0x0010)(Edit, BlueprintVisible, ZeroConstructor, AssetRegistrySearchable, Protected, UObjectWrapper, NativeAccessSpecifierProtected)
	class FName                                   SlotName;                                          // 0x0048(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, AssetRegistrySearchable, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FGuid                                  Identifier;                                        // 0x0050(0x0010)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"CustomizableSkinObject">();
	}
	static class UCustomizableSkinObject* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UCustomizableSkinObject>();
	}
};
static_assert(alignof(UCustomizableSkinObject) == 0x000008, "Wrong alignment on UCustomizableSkinObject");
static_assert(sizeof(UCustomizableSkinObject) == 0x000060, "Wrong size on UCustomizableSkinObject");
static_assert(offsetof(UCustomizableSkinObject, SkinCommands) == 0x000028, "Member 'UCustomizableSkinObject::SkinCommands' has a wrong offset!");
static_assert(offsetof(UCustomizableSkinObject, SlotTables) == 0x000038, "Member 'UCustomizableSkinObject::SlotTables' has a wrong offset!");
static_assert(offsetof(UCustomizableSkinObject, SlotName) == 0x000048, "Member 'UCustomizableSkinObject::SlotName' has a wrong offset!");
static_assert(offsetof(UCustomizableSkinObject, Identifier) == 0x000050, "Member 'UCustomizableSkinObject::Identifier' has a wrong offset!");

// Class CharacterSkinSystem.CustomSkinCommand
// 0x0000 (0x0148 - 0x0148)
class UCustomSkinCommand final : public UBaseSkinCommand
{
public:
	bool OnExecuteCommand(TArray<class UDynamicMesh*>& LODMeshes, TArray<struct FSkinOperationMeshMaterial>& Materials)	 // 0xae1e64;
	class UDynamicMesh* OnExecuteCommandForEachLOD(class UDynamicMesh* LODMesh, TArray<struct FSkinOperationMeshMaterial>& Materials, int32 CurrentLOD, TArray<struct FGeometryScriptingExtrasDebugMeshInfo>* OutputDebugMeshes)	 // 0xae1e64;
	void OnPrepareCommand()	 // 0xae1e64;

	class FText OnDisplayName() const	 // 0xae1e64;
	bool OnIsAllowFirstCommand() const	 // 0xae1e64;
	bool OnIsSkipCommand() const	 // 0xae1e64;

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"CustomSkinCommand">();
	}
	static class UCustomSkinCommand* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UCustomSkinCommand>();
	}
};
static_assert(alignof(UCustomSkinCommand) == 0x000008, "Wrong alignment on UCustomSkinCommand");
static_assert(sizeof(UCustomSkinCommand) == 0x000148, "Wrong size on UCustomSkinCommand");

// Class CharacterSkinSystem.CutMeshCommand
// 0x00A0 (0x01E8 - 0x0148)
class UCutMeshCommand final : public UBaseSkinCommand
{
public:
	class UStaticMesh*                            CageMesh;                                          // 0x0148(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	ECutMeshCommandType                           CuttingOpType;                                     // 0x0150(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_151[0x7];                                      // 0x0151(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FConvertToSkinOperationMeshParams      ConvertParams;                                     // 0x0158(0x0050)(Edit, BlueprintVisible, Protected, NativeAccessSpecifierProtected)
	bool                                          bMirrorCommand;                                    // 0x01A8(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1A9[0x7];                                      // 0x01A9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FSkinCommandMirrorSettings             MirrorSettings;                                    // 0x01B0(0x0030)(Edit, BlueprintVisible, Protected, NativeAccessSpecifierProtected)
	EBooleanOperationType                         OpMode;                                            // 0x01E0(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bFillHole;                                         // 0x01E1(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bFastIntersection;                                 // 0x01E2(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bAllowSelfOcclude;                                 // 0x01E3(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bDeferRemove;                                      // 0x01E4(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1E5[0x3];                                      // 0x01E5(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"CutMeshCommand">();
	}
	static class UCutMeshCommand* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UCutMeshCommand>();
	}
};
static_assert(alignof(UCutMeshCommand) == 0x000008, "Wrong alignment on UCutMeshCommand");
static_assert(sizeof(UCutMeshCommand) == 0x0001E8, "Wrong size on UCutMeshCommand");
static_assert(offsetof(UCutMeshCommand, CageMesh) == 0x000148, "Member 'UCutMeshCommand::CageMesh' has a wrong offset!");
static_assert(offsetof(UCutMeshCommand, CuttingOpType) == 0x000150, "Member 'UCutMeshCommand::CuttingOpType' has a wrong offset!");
static_assert(offsetof(UCutMeshCommand, ConvertParams) == 0x000158, "Member 'UCutMeshCommand::ConvertParams' has a wrong offset!");
static_assert(offsetof(UCutMeshCommand, bMirrorCommand) == 0x0001A8, "Member 'UCutMeshCommand::bMirrorCommand' has a wrong offset!");
static_assert(offsetof(UCutMeshCommand, MirrorSettings) == 0x0001B0, "Member 'UCutMeshCommand::MirrorSettings' has a wrong offset!");
static_assert(offsetof(UCutMeshCommand, OpMode) == 0x0001E0, "Member 'UCutMeshCommand::OpMode' has a wrong offset!");
static_assert(offsetof(UCutMeshCommand, bFillHole) == 0x0001E1, "Member 'UCutMeshCommand::bFillHole' has a wrong offset!");
static_assert(offsetof(UCutMeshCommand, bFastIntersection) == 0x0001E2, "Member 'UCutMeshCommand::bFastIntersection' has a wrong offset!");
static_assert(offsetof(UCutMeshCommand, bAllowSelfOcclude) == 0x0001E3, "Member 'UCutMeshCommand::bAllowSelfOcclude' has a wrong offset!");
static_assert(offsetof(UCutMeshCommand, bDeferRemove) == 0x0001E4, "Member 'UCutMeshCommand::bDeferRemove' has a wrong offset!");

// Class CharacterSkinSystem.CylinderDeformCommand
// 0x0128 (0x0270 - 0x0148)
class UCylinderDeformCommand final : public UBaseSkinCommand
{
public:
	class FName                                   AttachedBoneName;                                  // 0x0148(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIgnoreAttachedBoneRotation;                       // 0x0150(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_151[0xF];                                      // 0x0151(0x000F)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             RelativeTransform;                                 // 0x0160(0x0060)(Edit, BlueprintVisible, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bMirrorCommand;                                    // 0x01C0(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1C1[0x7];                                      // 0x01C1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FSkinCommandMirrorSettings             MirrorSettings;                                    // 0x01C8(0x0030)(Edit, BlueprintVisible, Protected, NativeAccessSpecifierProtected)
	float                                         CylinderRadius;                                    // 0x01F8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         CylinderHeight;                                    // 0x01FC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         TopScale;                                          // 0x0200(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MidSectionScale;                                   // 0x0204(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         BottomScale;                                       // 0x0208(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MidSectionRatio;                                   // 0x020C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FTransform                             BaseTransform;                                     // 0x0210(0x0060)(IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"CylinderDeformCommand">();
	}
	static class UCylinderDeformCommand* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UCylinderDeformCommand>();
	}
};
static_assert(alignof(UCylinderDeformCommand) == 0x000010, "Wrong alignment on UCylinderDeformCommand");
static_assert(sizeof(UCylinderDeformCommand) == 0x000270, "Wrong size on UCylinderDeformCommand");
static_assert(offsetof(UCylinderDeformCommand, AttachedBoneName) == 0x000148, "Member 'UCylinderDeformCommand::AttachedBoneName' has a wrong offset!");
static_assert(offsetof(UCylinderDeformCommand, bIgnoreAttachedBoneRotation) == 0x000150, "Member 'UCylinderDeformCommand::bIgnoreAttachedBoneRotation' has a wrong offset!");
static_assert(offsetof(UCylinderDeformCommand, RelativeTransform) == 0x000160, "Member 'UCylinderDeformCommand::RelativeTransform' has a wrong offset!");
static_assert(offsetof(UCylinderDeformCommand, bMirrorCommand) == 0x0001C0, "Member 'UCylinderDeformCommand::bMirrorCommand' has a wrong offset!");
static_assert(offsetof(UCylinderDeformCommand, MirrorSettings) == 0x0001C8, "Member 'UCylinderDeformCommand::MirrorSettings' has a wrong offset!");
static_assert(offsetof(UCylinderDeformCommand, CylinderRadius) == 0x0001F8, "Member 'UCylinderDeformCommand::CylinderRadius' has a wrong offset!");
static_assert(offsetof(UCylinderDeformCommand, CylinderHeight) == 0x0001FC, "Member 'UCylinderDeformCommand::CylinderHeight' has a wrong offset!");
static_assert(offsetof(UCylinderDeformCommand, TopScale) == 0x000200, "Member 'UCylinderDeformCommand::TopScale' has a wrong offset!");
static_assert(offsetof(UCylinderDeformCommand, MidSectionScale) == 0x000204, "Member 'UCylinderDeformCommand::MidSectionScale' has a wrong offset!");
static_assert(offsetof(UCylinderDeformCommand, BottomScale) == 0x000208, "Member 'UCylinderDeformCommand::BottomScale' has a wrong offset!");
static_assert(offsetof(UCylinderDeformCommand, MidSectionRatio) == 0x00020C, "Member 'UCylinderDeformCommand::MidSectionRatio' has a wrong offset!");
static_assert(offsetof(UCylinderDeformCommand, BaseTransform) == 0x000210, "Member 'UCylinderDeformCommand::BaseTransform' has a wrong offset!");

// Class CharacterSkinSystem.DuplicateLODCommand
// 0x0068 (0x01B0 - 0x0148)
class UDuplicateLODCommand final : public UBaseSkinCommand
{
public:
	int32                                         SourceLODIndex;                                    // 0x0148(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bInsertMode;                                       // 0x014C(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_14D[0x3];                                      // 0x014D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FDuplicatedLODInsertInfo>       TargetLODInsertIndices;                            // 0x0150(0x0010)(Edit, BlueprintVisible, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	TSet<int32>                                   TargetLODIndices;                                  // 0x0160(0x0050)(Edit, BlueprintVisible, Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"DuplicateLODCommand">();
	}
	static class UDuplicateLODCommand* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UDuplicateLODCommand>();
	}
};
static_assert(alignof(UDuplicateLODCommand) == 0x000008, "Wrong alignment on UDuplicateLODCommand");
static_assert(sizeof(UDuplicateLODCommand) == 0x0001B0, "Wrong size on UDuplicateLODCommand");
static_assert(offsetof(UDuplicateLODCommand, SourceLODIndex) == 0x000148, "Member 'UDuplicateLODCommand::SourceLODIndex' has a wrong offset!");
static_assert(offsetof(UDuplicateLODCommand, bInsertMode) == 0x00014C, "Member 'UDuplicateLODCommand::bInsertMode' has a wrong offset!");
static_assert(offsetof(UDuplicateLODCommand, TargetLODInsertIndices) == 0x000150, "Member 'UDuplicateLODCommand::TargetLODInsertIndices' has a wrong offset!");
static_assert(offsetof(UDuplicateLODCommand, TargetLODIndices) == 0x000160, "Member 'UDuplicateLODCommand::TargetLODIndices' has a wrong offset!");

// Class CharacterSkinSystem.MergeMeshCommand
// 0x0158 (0x02A0 - 0x0148)
class UMergeMeshCommand final : public UBaseSkinCommand
{
public:
	TArray<class USkeletalMesh*>                  AppendMeshes;                                      // 0x0148(0x0010)(Edit, BlueprintVisible, ZeroConstructor, Protected, UObjectWrapper, NativeAccessSpecifierProtected)
	class FName                                   AttachedBoneName;                                  // 0x0158(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIgnoreAttachedBoneRotation;                       // 0x0160(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_161[0xF];                                      // 0x0161(0x000F)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             RelativeTransform;                                 // 0x0170(0x0060)(Edit, BlueprintVisible, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FConvertToSkinOperationMeshParams      ConvertParams;                                     // 0x01D0(0x0050)(Edit, BlueprintVisible, Protected, NativeAccessSpecifierProtected)
	struct FMergeOperationBakedData               BakedData;                                         // 0x0220(0x0018)(Edit, EditConst, DuplicateTransient, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_238[0x8];                                      // 0x0238(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             BaseTransform;                                     // 0x0240(0x0060)(IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"MergeMeshCommand">();
	}
	static class UMergeMeshCommand* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UMergeMeshCommand>();
	}
};
static_assert(alignof(UMergeMeshCommand) == 0x000010, "Wrong alignment on UMergeMeshCommand");
static_assert(sizeof(UMergeMeshCommand) == 0x0002A0, "Wrong size on UMergeMeshCommand");
static_assert(offsetof(UMergeMeshCommand, AppendMeshes) == 0x000148, "Member 'UMergeMeshCommand::AppendMeshes' has a wrong offset!");
static_assert(offsetof(UMergeMeshCommand, AttachedBoneName) == 0x000158, "Member 'UMergeMeshCommand::AttachedBoneName' has a wrong offset!");
static_assert(offsetof(UMergeMeshCommand, bIgnoreAttachedBoneRotation) == 0x000160, "Member 'UMergeMeshCommand::bIgnoreAttachedBoneRotation' has a wrong offset!");
static_assert(offsetof(UMergeMeshCommand, RelativeTransform) == 0x000170, "Member 'UMergeMeshCommand::RelativeTransform' has a wrong offset!");
static_assert(offsetof(UMergeMeshCommand, ConvertParams) == 0x0001D0, "Member 'UMergeMeshCommand::ConvertParams' has a wrong offset!");
static_assert(offsetof(UMergeMeshCommand, BakedData) == 0x000220, "Member 'UMergeMeshCommand::BakedData' has a wrong offset!");
static_assert(offsetof(UMergeMeshCommand, BaseTransform) == 0x000240, "Member 'UMergeMeshCommand::BaseTransform' has a wrong offset!");

// Class CharacterSkinSystem.MergeWrappedClothCommand
// 0x00E8 (0x0230 - 0x0148)
class UMergeWrappedClothCommand final : public UBaseSkinCommand
{
public:
	class USkeletalMesh*                          MergeWrappedMesh;                                  // 0x0148(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USkeleton*                              Skeleton;                                          // 0x0150(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FConvertToSkinOperationMeshParams      ConvertParams;                                     // 0x0158(0x0050)(Edit, BlueprintVisible, Protected, NativeAccessSpecifierProtected)
	struct FIntVector                             Dimension;                                         // 0x01A8(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bFakeInner;                                        // 0x01B4(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bUseMinDelta;                                      // 0x01B5(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1B6[0x2];                                      // 0x01B6(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	double                                        Weight;                                            // 0x01B8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bNeedExtrudePass;                                  // 0x01C0(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1C1[0x7];                                      // 0x01C1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	double                                        AngleTolerance;                                    // 0x01C8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<struct FMergeWrappedClothWeightData>   DetailWeights;                                     // 0x01D0(0x0010)(Edit, BlueprintVisible, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	struct FLatticeWrapOperationBakedData         BakedData;                                         // 0x01E0(0x0050)(Edit, EditConst, DuplicateTransient, Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"MergeWrappedClothCommand">();
	}
	static class UMergeWrappedClothCommand* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UMergeWrappedClothCommand>();
	}
};
static_assert(alignof(UMergeWrappedClothCommand) == 0x000008, "Wrong alignment on UMergeWrappedClothCommand");
static_assert(sizeof(UMergeWrappedClothCommand) == 0x000230, "Wrong size on UMergeWrappedClothCommand");
static_assert(offsetof(UMergeWrappedClothCommand, MergeWrappedMesh) == 0x000148, "Member 'UMergeWrappedClothCommand::MergeWrappedMesh' has a wrong offset!");
static_assert(offsetof(UMergeWrappedClothCommand, Skeleton) == 0x000150, "Member 'UMergeWrappedClothCommand::Skeleton' has a wrong offset!");
static_assert(offsetof(UMergeWrappedClothCommand, ConvertParams) == 0x000158, "Member 'UMergeWrappedClothCommand::ConvertParams' has a wrong offset!");
static_assert(offsetof(UMergeWrappedClothCommand, Dimension) == 0x0001A8, "Member 'UMergeWrappedClothCommand::Dimension' has a wrong offset!");
static_assert(offsetof(UMergeWrappedClothCommand, bFakeInner) == 0x0001B4, "Member 'UMergeWrappedClothCommand::bFakeInner' has a wrong offset!");
static_assert(offsetof(UMergeWrappedClothCommand, bUseMinDelta) == 0x0001B5, "Member 'UMergeWrappedClothCommand::bUseMinDelta' has a wrong offset!");
static_assert(offsetof(UMergeWrappedClothCommand, Weight) == 0x0001B8, "Member 'UMergeWrappedClothCommand::Weight' has a wrong offset!");
static_assert(offsetof(UMergeWrappedClothCommand, bNeedExtrudePass) == 0x0001C0, "Member 'UMergeWrappedClothCommand::bNeedExtrudePass' has a wrong offset!");
static_assert(offsetof(UMergeWrappedClothCommand, AngleTolerance) == 0x0001C8, "Member 'UMergeWrappedClothCommand::AngleTolerance' has a wrong offset!");
static_assert(offsetof(UMergeWrappedClothCommand, DetailWeights) == 0x0001D0, "Member 'UMergeWrappedClothCommand::DetailWeights' has a wrong offset!");
static_assert(offsetof(UMergeWrappedClothCommand, BakedData) == 0x0001E0, "Member 'UMergeWrappedClothCommand::BakedData' has a wrong offset!");

// Class CharacterSkinSystem.SkeletalMeshToSkinMeshCommand
// 0x00A8 (0x01F0 - 0x0148)
class USkeletalMeshToSkinMeshCommand final : public UBaseSkinCommand
{
public:
	class USkeletalMesh*                          SkeletalMesh;                                      // 0x0148(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FConvertToSkinOperationMeshParams      ConvertParams;                                     // 0x0150(0x0050)(Edit, BlueprintVisible, Protected, NativeAccessSpecifierProtected)
	struct FConvertToSkinMeshOperationBakedData   BakedData;                                         // 0x01A0(0x0050)(Edit, EditConst, DuplicateTransient, Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"SkeletalMeshToSkinMeshCommand">();
	}
	static class USkeletalMeshToSkinMeshCommand* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<USkeletalMeshToSkinMeshCommand>();
	}
};
static_assert(alignof(USkeletalMeshToSkinMeshCommand) == 0x000008, "Wrong alignment on USkeletalMeshToSkinMeshCommand");
static_assert(sizeof(USkeletalMeshToSkinMeshCommand) == 0x0001F0, "Wrong size on USkeletalMeshToSkinMeshCommand");
static_assert(offsetof(USkeletalMeshToSkinMeshCommand, SkeletalMesh) == 0x000148, "Member 'USkeletalMeshToSkinMeshCommand::SkeletalMesh' has a wrong offset!");
static_assert(offsetof(USkeletalMeshToSkinMeshCommand, ConvertParams) == 0x000150, "Member 'USkeletalMeshToSkinMeshCommand::ConvertParams' has a wrong offset!");
static_assert(offsetof(USkeletalMeshToSkinMeshCommand, BakedData) == 0x0001A0, "Member 'USkeletalMeshToSkinMeshCommand::BakedData' has a wrong offset!");

// Class CharacterSkinSystem.SqueezeClothCommand
// 0x02D8 (0x0420 - 0x0148)
class USqueezeClothCommand final : public UBaseSkinCommand
{
public:
	class USkeletalMesh*                          SqueezeMesh;                                       // 0x0148(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USkeleton*                              Skeleton;                                          // 0x0150(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FConvertToSkinOperationMeshParams      ConvertParams;                                     // 0x0158(0x0050)(Edit, BlueprintVisible, Protected, NativeAccessSpecifierProtected)
	bool                                          bMirrorCommand;                                    // 0x01A8(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1A9[0x7];                                      // 0x01A9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FSkinCommandMirrorSettings             MirrorSettings;                                    // 0x01B0(0x0030)(Edit, BlueprintVisible, Protected, NativeAccessSpecifierProtected)
	struct FTransform                             LocalSqueezeTransform;                             // 0x01E0(0x0060)(Edit, BlueprintVisible, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	double                                        AngleTolerance;                                    // 0x0240(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	double                                        ModifiedDistance;                                  // 0x0248(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         SubdivLoopCount;                                   // 0x0250(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bFakeInner;                                        // 0x0254(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_255[0x3];                                      // 0x0255(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	double                                        FakeThickness;                                     // 0x0258(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	double                                        Weight_A;                                          // 0x0260(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	double                                        Weight_B;                                          // 0x0268(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bUseSkinWeight;                                    // 0x0270(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_271[0x7];                                      // 0x0271(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	double                                        SkinWeightThreshold;                               // 0x0278(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSet<class FName>                             BoneNames;                                         // 0x0280(0x0050)(Edit, BlueprintVisible, Protected, NativeAccessSpecifierProtected)
	struct FSqueezeOperationBakedData             BakedData;                                         // 0x02D0(0x00A8)(Edit, EditConst, DuplicateTransient, Protected, NativeAccessSpecifierProtected)
	struct FSqueezeOperationBakedData             MirroredBakedData;                                 // 0x0378(0x00A8)(Edit, EditConst, DuplicateTransient, Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"SqueezeClothCommand">();
	}
	static class USqueezeClothCommand* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<USqueezeClothCommand>();
	}
};
static_assert(alignof(USqueezeClothCommand) == 0x000010, "Wrong alignment on USqueezeClothCommand");
static_assert(sizeof(USqueezeClothCommand) == 0x000420, "Wrong size on USqueezeClothCommand");
static_assert(offsetof(USqueezeClothCommand, SqueezeMesh) == 0x000148, "Member 'USqueezeClothCommand::SqueezeMesh' has a wrong offset!");
static_assert(offsetof(USqueezeClothCommand, Skeleton) == 0x000150, "Member 'USqueezeClothCommand::Skeleton' has a wrong offset!");
static_assert(offsetof(USqueezeClothCommand, ConvertParams) == 0x000158, "Member 'USqueezeClothCommand::ConvertParams' has a wrong offset!");
static_assert(offsetof(USqueezeClothCommand, bMirrorCommand) == 0x0001A8, "Member 'USqueezeClothCommand::bMirrorCommand' has a wrong offset!");
static_assert(offsetof(USqueezeClothCommand, MirrorSettings) == 0x0001B0, "Member 'USqueezeClothCommand::MirrorSettings' has a wrong offset!");
static_assert(offsetof(USqueezeClothCommand, LocalSqueezeTransform) == 0x0001E0, "Member 'USqueezeClothCommand::LocalSqueezeTransform' has a wrong offset!");
static_assert(offsetof(USqueezeClothCommand, AngleTolerance) == 0x000240, "Member 'USqueezeClothCommand::AngleTolerance' has a wrong offset!");
static_assert(offsetof(USqueezeClothCommand, ModifiedDistance) == 0x000248, "Member 'USqueezeClothCommand::ModifiedDistance' has a wrong offset!");
static_assert(offsetof(USqueezeClothCommand, SubdivLoopCount) == 0x000250, "Member 'USqueezeClothCommand::SubdivLoopCount' has a wrong offset!");
static_assert(offsetof(USqueezeClothCommand, bFakeInner) == 0x000254, "Member 'USqueezeClothCommand::bFakeInner' has a wrong offset!");
static_assert(offsetof(USqueezeClothCommand, FakeThickness) == 0x000258, "Member 'USqueezeClothCommand::FakeThickness' has a wrong offset!");
static_assert(offsetof(USqueezeClothCommand, Weight_A) == 0x000260, "Member 'USqueezeClothCommand::Weight_A' has a wrong offset!");
static_assert(offsetof(USqueezeClothCommand, Weight_B) == 0x000268, "Member 'USqueezeClothCommand::Weight_B' has a wrong offset!");
static_assert(offsetof(USqueezeClothCommand, bUseSkinWeight) == 0x000270, "Member 'USqueezeClothCommand::bUseSkinWeight' has a wrong offset!");
static_assert(offsetof(USqueezeClothCommand, SkinWeightThreshold) == 0x000278, "Member 'USqueezeClothCommand::SkinWeightThreshold' has a wrong offset!");
static_assert(offsetof(USqueezeClothCommand, BoneNames) == 0x000280, "Member 'USqueezeClothCommand::BoneNames' has a wrong offset!");
static_assert(offsetof(USqueezeClothCommand, BakedData) == 0x0002D0, "Member 'USqueezeClothCommand::BakedData' has a wrong offset!");
static_assert(offsetof(USqueezeClothCommand, MirroredBakedData) == 0x000378, "Member 'USqueezeClothCommand::MirroredBakedData' has a wrong offset!");

// Class CharacterSkinSystem.StaticMeshToSkinMeshCommand
// 0x00A8 (0x01F0 - 0x0148)
class UStaticMeshToSkinMeshCommand final : public UBaseSkinCommand
{
public:
	class UStaticMesh*                            StaticMesh;                                        // 0x0148(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FConvertToSkinOperationMeshParams      ConvertParams;                                     // 0x0150(0x0050)(Edit, BlueprintVisible, Protected, NativeAccessSpecifierProtected)
	struct FConvertToSkinMeshOperationBakedData   BakedData;                                         // 0x01A0(0x0050)(Edit, EditConst, DuplicateTransient, Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"StaticMeshToSkinMeshCommand">();
	}
	static class UStaticMeshToSkinMeshCommand* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UStaticMeshToSkinMeshCommand>();
	}
};
static_assert(alignof(UStaticMeshToSkinMeshCommand) == 0x000008, "Wrong alignment on UStaticMeshToSkinMeshCommand");
static_assert(sizeof(UStaticMeshToSkinMeshCommand) == 0x0001F0, "Wrong size on UStaticMeshToSkinMeshCommand");
static_assert(offsetof(UStaticMeshToSkinMeshCommand, StaticMesh) == 0x000148, "Member 'UStaticMeshToSkinMeshCommand::StaticMesh' has a wrong offset!");
static_assert(offsetof(UStaticMeshToSkinMeshCommand, ConvertParams) == 0x000150, "Member 'UStaticMeshToSkinMeshCommand::ConvertParams' has a wrong offset!");
static_assert(offsetof(UStaticMeshToSkinMeshCommand, BakedData) == 0x0001A0, "Member 'UStaticMeshToSkinMeshCommand::BakedData' has a wrong offset!");

// Class CharacterSkinSystem.SkinOperationProvider
// 0x0000 (0x0028 - 0x0028)
class USkinOperationProvider final : public UObject
{
public:
	static struct FImmatureSkeletalMesh ConvertDynamicToSkeletalMesh(const TArray<class UDynamicMesh*>& LODMeshes, const TArray<class UMaterialInterface*>& Materials, const struct FConvertToSkeletalMeshParams& ConvertParams, const struct FCreateSkeletalMeshParams& CreateParams)	 // 0x43f6128;
	static void ConvertSkeletalToDynamicMesh(TArray<class UDynamicMesh*>* OutLODMeshes, TArray<class UMaterialInterface*>* OutMaterials, class USkeletalMesh* SkeletalMesh, const struct FConvertToSkinOperationMeshParams& Params_0)	 // 0x43f6308;
	static void ConvertStaticToDynamicMesh(TArray<class UDynamicMesh*>* OutLODMeshes, TArray<class UMaterialInterface*>* OutMaterials, class UStaticMesh* StaticMesh, const struct FConvertToSkinOperationMeshParams& Params_0)	 // 0x43f6878;
	static class USkeletalMesh* CreateEmptySkeletalMesh(class USkeletalMesh* TemplateMesh, class UObject* OuterObject)	 // 0x43f6de8;
	static class USkeletalMesh* DeferInitImmatureSkeletalMesh(struct FImmatureSkeletalMesh* ImmatureSkeletalMesh, class UWorld* InWorld)	 // 0x43f6f3c;
	static void PrepareSkeletalMesh(class USkeletalMesh* SkeletalMesh)	 // 0x43f70c8;
	static void PrepareStaticMesh(class UStaticMesh* StaticMesh)	 // 0x43f717c;

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"SkinOperationProvider">();
	}
	static class USkinOperationProvider* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<USkinOperationProvider>();
	}
};
static_assert(alignof(USkinOperationProvider) == 0x000008, "Wrong alignment on USkinOperationProvider");
static_assert(sizeof(USkinOperationProvider) == 0x000028, "Wrong size on USkinOperationProvider");

// Class CharacterSkinSystem.WearClothCommand
// 0x01A8 (0x02F0 - 0x0148)
class UWearClothCommand final : public UBaseSkinCommand
{
public:
	class USkeletalMesh*                          SkinMesh;                                          // 0x0148(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UStaticMesh*                            CageMesh;                                          // 0x0150(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	ECutMeshCommandType                           CuttingOpType;                                     // 0x0158(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_159[0x3];                                      // 0x0159(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   AttachedBoneName;                                  // 0x015C(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIgnoreAttachedBoneRotation;                       // 0x0164(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_165[0xB];                                      // 0x0165(0x000B)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             RelativeTransform;                                 // 0x0170(0x0060)(Edit, BlueprintVisible, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FConvertToSkinOperationMeshParams      SkinMeshConvertParams;                             // 0x01D0(0x0050)(Edit, BlueprintVisible, Protected, NativeAccessSpecifierProtected)
	struct FConvertToSkinOperationMeshParams      CageMeshConvertParams;                             // 0x0220(0x0050)(Edit, BlueprintVisible, Protected, NativeAccessSpecifierProtected)
	EBooleanOperationType                         OpMode;                                            // 0x0270(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bFillHole;                                         // 0x0271(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bFastIntersection;                                 // 0x0272(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bAllowSelfOcclude;                                 // 0x0273(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bDeferRemove;                                      // 0x0274(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_275[0x3];                                      // 0x0275(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FMergeOperationBakedData               MergeBakedData;                                    // 0x0278(0x0018)(Edit, EditConst, DuplicateTransient, Protected, NativeAccessSpecifierProtected)
	struct FTransform                             BaseTransform;                                     // 0x0290(0x0060)(IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"WearClothCommand">();
	}
	static class UWearClothCommand* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UWearClothCommand>();
	}
};
static_assert(alignof(UWearClothCommand) == 0x000010, "Wrong alignment on UWearClothCommand");
static_assert(sizeof(UWearClothCommand) == 0x0002F0, "Wrong size on UWearClothCommand");
static_assert(offsetof(UWearClothCommand, SkinMesh) == 0x000148, "Member 'UWearClothCommand::SkinMesh' has a wrong offset!");
static_assert(offsetof(UWearClothCommand, CageMesh) == 0x000150, "Member 'UWearClothCommand::CageMesh' has a wrong offset!");
static_assert(offsetof(UWearClothCommand, CuttingOpType) == 0x000158, "Member 'UWearClothCommand::CuttingOpType' has a wrong offset!");
static_assert(offsetof(UWearClothCommand, AttachedBoneName) == 0x00015C, "Member 'UWearClothCommand::AttachedBoneName' has a wrong offset!");
static_assert(offsetof(UWearClothCommand, bIgnoreAttachedBoneRotation) == 0x000164, "Member 'UWearClothCommand::bIgnoreAttachedBoneRotation' has a wrong offset!");
static_assert(offsetof(UWearClothCommand, RelativeTransform) == 0x000170, "Member 'UWearClothCommand::RelativeTransform' has a wrong offset!");
static_assert(offsetof(UWearClothCommand, SkinMeshConvertParams) == 0x0001D0, "Member 'UWearClothCommand::SkinMeshConvertParams' has a wrong offset!");
static_assert(offsetof(UWearClothCommand, CageMeshConvertParams) == 0x000220, "Member 'UWearClothCommand::CageMeshConvertParams' has a wrong offset!");
static_assert(offsetof(UWearClothCommand, OpMode) == 0x000270, "Member 'UWearClothCommand::OpMode' has a wrong offset!");
static_assert(offsetof(UWearClothCommand, bFillHole) == 0x000271, "Member 'UWearClothCommand::bFillHole' has a wrong offset!");
static_assert(offsetof(UWearClothCommand, bFastIntersection) == 0x000272, "Member 'UWearClothCommand::bFastIntersection' has a wrong offset!");
static_assert(offsetof(UWearClothCommand, bAllowSelfOcclude) == 0x000273, "Member 'UWearClothCommand::bAllowSelfOcclude' has a wrong offset!");
static_assert(offsetof(UWearClothCommand, bDeferRemove) == 0x000274, "Member 'UWearClothCommand::bDeferRemove' has a wrong offset!");
static_assert(offsetof(UWearClothCommand, MergeBakedData) == 0x000278, "Member 'UWearClothCommand::MergeBakedData' has a wrong offset!");
static_assert(offsetof(UWearClothCommand, BaseTransform) == 0x000290, "Member 'UWearClothCommand::BaseTransform' has a wrong offset!");

// Class CharacterSkinSystem.WrapClothCommand
// 0x01B8 (0x0300 - 0x0148)
class UWrapClothCommand final : public UBaseSkinCommand
{
public:
	class USkeletalMesh*                          WrapMesh;                                          // 0x0148(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USkeleton*                              Skeleton;                                          // 0x0150(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FConvertToSkinOperationMeshParams      ConvertParams;                                     // 0x0158(0x0050)(Edit, BlueprintVisible, Protected, NativeAccessSpecifierProtected)
	bool                                          bMirrorCommand;                                    // 0x01A8(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1A9[0x7];                                      // 0x01A9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FSkinCommandMirrorSettings             MirrorSettings;                                    // 0x01B0(0x0030)(Edit, BlueprintVisible, Protected, NativeAccessSpecifierProtected)
	struct FTransform                             LocalWrapTransform;                                // 0x01E0(0x0060)(Edit, BlueprintVisible, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EWrapOperationType                            Operation;                                         // 0x0240(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_241[0x7];                                      // 0x0241(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	double                                        ModifiedDistance;                                  // 0x0248(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         SubdivLoopCount;                                   // 0x0250(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_254[0x4];                                      // 0x0254(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	double                                        Offset;                                            // 0x0258(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bUseSkinWeight;                                    // 0x0260(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_261[0x7];                                      // 0x0261(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	double                                        SkinWeightThreshold;                               // 0x0268(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	double                                        ExtrudeDistance;                                   // 0x0270(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	double                                        ExtrudeTolerance;                                  // 0x0278(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bSimplifyHulls;                                    // 0x0280(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_281[0x3];                                      // 0x0281(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         HullTargetFaceCount;                               // 0x0284(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector                                ExpandAmount;                                      // 0x0288(0x0018)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	double                                        NormalTolerance;                                   // 0x02A0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSet<class FName>                             BoneNames;                                         // 0x02A8(0x0050)(Edit, BlueprintVisible, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_2F8[0x8];                                      // 0x02F8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"WrapClothCommand">();
	}
	static class UWrapClothCommand* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UWrapClothCommand>();
	}
};
static_assert(alignof(UWrapClothCommand) == 0x000010, "Wrong alignment on UWrapClothCommand");
static_assert(sizeof(UWrapClothCommand) == 0x000300, "Wrong size on UWrapClothCommand");
static_assert(offsetof(UWrapClothCommand, WrapMesh) == 0x000148, "Member 'UWrapClothCommand::WrapMesh' has a wrong offset!");
static_assert(offsetof(UWrapClothCommand, Skeleton) == 0x000150, "Member 'UWrapClothCommand::Skeleton' has a wrong offset!");
static_assert(offsetof(UWrapClothCommand, ConvertParams) == 0x000158, "Member 'UWrapClothCommand::ConvertParams' has a wrong offset!");
static_assert(offsetof(UWrapClothCommand, bMirrorCommand) == 0x0001A8, "Member 'UWrapClothCommand::bMirrorCommand' has a wrong offset!");
static_assert(offsetof(UWrapClothCommand, MirrorSettings) == 0x0001B0, "Member 'UWrapClothCommand::MirrorSettings' has a wrong offset!");
static_assert(offsetof(UWrapClothCommand, LocalWrapTransform) == 0x0001E0, "Member 'UWrapClothCommand::LocalWrapTransform' has a wrong offset!");
static_assert(offsetof(UWrapClothCommand, Operation) == 0x000240, "Member 'UWrapClothCommand::Operation' has a wrong offset!");
static_assert(offsetof(UWrapClothCommand, ModifiedDistance) == 0x000248, "Member 'UWrapClothCommand::ModifiedDistance' has a wrong offset!");
static_assert(offsetof(UWrapClothCommand, SubdivLoopCount) == 0x000250, "Member 'UWrapClothCommand::SubdivLoopCount' has a wrong offset!");
static_assert(offsetof(UWrapClothCommand, Offset) == 0x000258, "Member 'UWrapClothCommand::Offset' has a wrong offset!");
static_assert(offsetof(UWrapClothCommand, bUseSkinWeight) == 0x000260, "Member 'UWrapClothCommand::bUseSkinWeight' has a wrong offset!");
static_assert(offsetof(UWrapClothCommand, SkinWeightThreshold) == 0x000268, "Member 'UWrapClothCommand::SkinWeightThreshold' has a wrong offset!");
static_assert(offsetof(UWrapClothCommand, ExtrudeDistance) == 0x000270, "Member 'UWrapClothCommand::ExtrudeDistance' has a wrong offset!");
static_assert(offsetof(UWrapClothCommand, ExtrudeTolerance) == 0x000278, "Member 'UWrapClothCommand::ExtrudeTolerance' has a wrong offset!");
static_assert(offsetof(UWrapClothCommand, bSimplifyHulls) == 0x000280, "Member 'UWrapClothCommand::bSimplifyHulls' has a wrong offset!");
static_assert(offsetof(UWrapClothCommand, HullTargetFaceCount) == 0x000284, "Member 'UWrapClothCommand::HullTargetFaceCount' has a wrong offset!");
static_assert(offsetof(UWrapClothCommand, ExpandAmount) == 0x000288, "Member 'UWrapClothCommand::ExpandAmount' has a wrong offset!");
static_assert(offsetof(UWrapClothCommand, NormalTolerance) == 0x0002A0, "Member 'UWrapClothCommand::NormalTolerance' has a wrong offset!");
static_assert(offsetof(UWrapClothCommand, BoneNames) == 0x0002A8, "Member 'UWrapClothCommand::BoneNames' has a wrong offset!");

}

