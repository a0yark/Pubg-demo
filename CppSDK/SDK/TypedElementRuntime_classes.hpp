#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: TypedElementRuntime

#include "Basic.hpp"

#include "CoreUObject_classes.hpp"
#include "TypedElementRuntime_structs.hpp"


namespace SDK
{

// Class TypedElementRuntime.TypedElementSelectionSetLibrary
// 0x0000 (0x0028 - 0x0028)
class UTypedElementSelectionSetLibrary final : public UObject
{
public:
	static bool DeselectElementsFromList(class UTypedElementSelectionSet* SelectionSet, const struct FScriptTypedElementListProxy& ElementList, const struct FTypedElementSelectionOptions& SelectionOptions)	 // 0x6722a78;
	static struct FScriptTypedElementListProxy GetNormalizedElementList(class UTypedElementSelectionSet* SelectionSet, const struct FScriptTypedElementListProxy& ElementList, const struct FTypedElementSelectionNormalizationOptions& NormalizationOptions)	 // 0x672319c;
	static struct FScriptTypedElementListProxy GetNormalizedSelection(class UTypedElementSelectionSet* SelectionSet, const struct FTypedElementSelectionNormalizationOptions& NormalizationOptions)	 // 0x67233f0;
	static bool SelectElementsFromList(class UTypedElementSelectionSet* SelectionSet, const struct FScriptTypedElementListProxy& ElementList, const struct FTypedElementSelectionOptions& SelectionOptions)	 // 0x6724cd0;
	static bool SetSelectionFromList(class UTypedElementSelectionSet* SelectionSet, const struct FScriptTypedElementListProxy& ElementList, const struct FTypedElementSelectionOptions& SelectionOptions)	 // 0x67250c4;

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"TypedElementSelectionSetLibrary">();
	}
	static class UTypedElementSelectionSetLibrary* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UTypedElementSelectionSetLibrary>();
	}
};
static_assert(alignof(UTypedElementSelectionSetLibrary) == 0x000008, "Wrong alignment on UTypedElementSelectionSetLibrary");
static_assert(sizeof(UTypedElementSelectionSetLibrary) == 0x000028, "Wrong size on UTypedElementSelectionSetLibrary");

// Class TypedElementRuntime.TypedElementSelectionSet
// 0x0870 (0x0898 - 0x0028)
class UTypedElementSelectionSet final : public UObject
{
public:
	uint8                                         Pad_28[0x800];                                     // 0x0028(0x0800)(Fixing Size After Last Property [ Dumper-7 ])
	TMulticastInlineDelegate<void(const class UTypedElementSelectionSet* SelectionSet)> OnPreSelectionChange; // 0x0828(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(const class UTypedElementSelectionSet* SelectionSet)> OnSelectionChange; // 0x0838(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_848[0x50];                                     // 0x0848(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	bool ClearSelection(const struct FTypedElementSelectionOptions& InSelectionOptions)	 // 0x6722208;
	bool DeselectElement(const struct FScriptTypedElementHandle& InElementHandle, const struct FTypedElementSelectionOptions& InSelectionOptions)	 // 0x67226cc;
	bool DeselectElements(const TArray<struct FScriptTypedElementHandle>& InElementHandles, const struct FTypedElementSelectionOptions& InSelectionOptions)	 // 0x67228a4;
	void RestoreSelectionState(const struct FTypedElementSelectionSetState& InSelectionState)	 // 0x6724644;
	bool SelectElement(const struct FScriptTypedElementHandle& InElementHandle, const struct FTypedElementSelectionOptions& InSelectionOptions)	 // 0x6724924;
	bool SelectElements(const TArray<struct FScriptTypedElementHandle>& InElementHandles, const struct FTypedElementSelectionOptions& InSelectionOptions)	 // 0x6724afc;
	bool SetSelection(const TArray<struct FScriptTypedElementHandle>& InElementHandles, const struct FTypedElementSelectionOptions& InSelectionOptions)	 // 0x6724f08;

	bool AllowSelectionModifiers(const struct FScriptTypedElementHandle& InElementHandle) const	 // 0x6721bc8;
	bool CanDeselectElement(const struct FScriptTypedElementHandle& InElementHandle, const struct FTypedElementSelectionOptions& InSelectionOptions) const	 // 0x6721db0;
	bool CanSelectElement(const struct FScriptTypedElementHandle& InElementHandle, const struct FTypedElementSelectionOptions& InSelectionOptions) const	 // 0x6722060;
	int32 CountSelectedElements(const TSubclassOf<class IInterface> InBaseInterfaceType) const	 // 0x67222e8;
	int32 CountSelectedObjects(const class UClass* InRequiredClass) const	 // 0x67223b8;
	class UObject* GetBottomSelectedObject(const class UClass* InRequiredClass) const	 // 0x6722e60;
	struct FTypedElementSelectionSetState GetCurrentSelectionState() const	 // 0x6723160;
	int32 GetNumSelectedElements() const	 // 0x6723548;
	TArray<class UObject*> GetSelectedObjects(const class UClass* InRequiredClass) const	 // 0x672387c;
	struct FScriptTypedElementHandle GetSelectionElement(const struct FScriptTypedElementHandle& InElementHandle, const ETypedElementSelectionMethod InSelectionMethod) const	 // 0x6723cac;
	class UObject* GetTopSelectedObject(const class UClass* InRequiredClass) const	 // 0x6723e54;
	bool HasSelectedElements(const TSubclassOf<class IInterface> InBaseInterfaceType) const	 // 0x6723f60;
	bool HasSelectedObjects(const class UClass* InRequiredClass) const	 // 0x6724090;
	bool IsElementSelected(const struct FScriptTypedElementHandle& InElementHandle, const struct FTypedElementIsSelectedOptions& InSelectionOptions) const	 // 0x672439c;
	TArray<struct FScriptTypedElementHandle> K2_GetSelectedElementHandles(const TSubclassOf<class IInterface> InBaseInterfaceType) const	 // 0x672455c;

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"TypedElementSelectionSet">();
	}
	static class UTypedElementSelectionSet* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UTypedElementSelectionSet>();
	}
};
static_assert(alignof(UTypedElementSelectionSet) == 0x000008, "Wrong alignment on UTypedElementSelectionSet");
static_assert(sizeof(UTypedElementSelectionSet) == 0x000898, "Wrong size on UTypedElementSelectionSet");
static_assert(offsetof(UTypedElementSelectionSet, OnPreSelectionChange) == 0x000828, "Member 'UTypedElementSelectionSet::OnPreSelectionChange' has a wrong offset!");
static_assert(offsetof(UTypedElementSelectionSet, OnSelectionChange) == 0x000838, "Member 'UTypedElementSelectionSet::OnSelectionChange' has a wrong offset!");

// Class TypedElementRuntime.TypedElementAssetDataInterface
// 0x0000 (0x0000 - 0x0000)
class ITypedElementAssetDataInterface final
{
public:
	TArray<struct FAssetData> GetAllReferencedAssetDatas(const struct FScriptTypedElementHandle& InElementHandle)	 // 0x6722cb0;
	struct FAssetData GetAssetData(const struct FScriptTypedElementHandle& InElementHandle)	 // 0x6722d7c;

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"TypedElementAssetDataInterface">();
	}
	static class ITypedElementAssetDataInterface* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<ITypedElementAssetDataInterface>();
	}

	class UObject* AsUObject()	 // 0x0
	{
		return reinterpret_cast<UObject*>(this);
	}
	const class UObject* AsUObject() const	 // 0x0
	{
		return reinterpret_cast<const UObject*>(this);
	}
};
static_assert(alignof(ITypedElementAssetDataInterface) == 0x000001, "Wrong alignment on ITypedElementAssetDataInterface");
static_assert(sizeof(ITypedElementAssetDataInterface) == 0x000001, "Wrong size on ITypedElementAssetDataInterface");

// Class TypedElementRuntime.TypedElementHierarchyInterface
// 0x0000 (0x0000 - 0x0000)
class ITypedElementHierarchyInterface final
{
public:
	void GetChildElements(const struct FScriptTypedElementHandle& InElementHandle, TArray<struct FScriptTypedElementHandle>* OutElementHandles, const bool bAllowCreate)	 // 0x6722f6c;
	struct FScriptTypedElementHandle GetParentElement(const struct FScriptTypedElementHandle& InElementHandle, const bool bAllowCreate)	 // 0x67236cc;

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"TypedElementHierarchyInterface">();
	}
	static class ITypedElementHierarchyInterface* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<ITypedElementHierarchyInterface>();
	}

	class UObject* AsUObject()	 // 0x0
	{
		return reinterpret_cast<UObject*>(this);
	}
	const class UObject* AsUObject() const	 // 0x0
	{
		return reinterpret_cast<const UObject*>(this);
	}
};
static_assert(alignof(ITypedElementHierarchyInterface) == 0x000001, "Wrong alignment on ITypedElementHierarchyInterface");
static_assert(sizeof(ITypedElementHierarchyInterface) == 0x000001, "Wrong size on ITypedElementHierarchyInterface");

// Class TypedElementRuntime.TypedElementObjectInterface
// 0x0000 (0x0000 - 0x0000)
class ITypedElementObjectInterface final
{
public:
	class UObject* GetObject(const struct FScriptTypedElementHandle& InElementHandle)	 // 0x6723564;
	class UClass* GetObjectClass(const struct FScriptTypedElementHandle& InElementHandle)	 // 0x6723618;

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"TypedElementObjectInterface">();
	}
	static class ITypedElementObjectInterface* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<ITypedElementObjectInterface>();
	}

	class UObject* AsUObject()	 // 0x0
	{
		return reinterpret_cast<UObject*>(this);
	}
	const class UObject* AsUObject() const	 // 0x0
	{
		return reinterpret_cast<const UObject*>(this);
	}
};
static_assert(alignof(ITypedElementObjectInterface) == 0x000001, "Wrong alignment on ITypedElementObjectInterface");
static_assert(sizeof(ITypedElementObjectInterface) == 0x000001, "Wrong size on ITypedElementObjectInterface");

// Class TypedElementRuntime.TypedElementSelectionInterface
// 0x0000 (0x0000 - 0x0000)
class ITypedElementSelectionInterface final
{
public:
	bool AllowSelectionModifiers(const struct FScriptTypedElementHandle& InElementHandle, const struct FScriptTypedElementListProxy& InSelectionSet)	 // 0x67219a8;
	bool CanDeselectElement(const struct FScriptTypedElementHandle& InElementHandle, const struct FTypedElementSelectionOptions& InSelectionOptions)	 // 0x6721ca8;
	bool CanSelectElement(const struct FScriptTypedElementHandle& InElementHandle, const struct FTypedElementSelectionOptions& InSelectionOptions)	 // 0x6721f58;
	bool DeselectElement(const struct FScriptTypedElementHandle& InElementHandle, const struct FScriptTypedElementListProxy& InSelectionSet, const struct FTypedElementSelectionOptions& InSelectionOptions)	 // 0x6722488;
	struct FScriptTypedElementHandle GetSelectionElement(const struct FScriptTypedElementHandle& InElementHandle, const struct FScriptTypedElementListProxy& InCurrentSelection, const ETypedElementSelectionMethod InSelectionMethod)	 // 0x67239a4;
	bool IsElementSelected(const struct FScriptTypedElementHandle& InElementHandle, const struct FScriptTypedElementListProxy& InSelectionSet, const struct FTypedElementIsSelectedOptions& InSelectionOptions)	 // 0x6724160;
	bool SelectElement(const struct FScriptTypedElementHandle& InElementHandle, const struct FScriptTypedElementListProxy& InSelectionSet, const struct FTypedElementSelectionOptions& InSelectionOptions)	 // 0x67246e0;

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"TypedElementSelectionInterface">();
	}
	static class ITypedElementSelectionInterface* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<ITypedElementSelectionInterface>();
	}

	class UObject* AsUObject()	 // 0x0
	{
		return reinterpret_cast<UObject*>(this);
	}
	const class UObject* AsUObject() const	 // 0x0
	{
		return reinterpret_cast<const UObject*>(this);
	}
};
static_assert(alignof(ITypedElementSelectionInterface) == 0x000001, "Wrong alignment on ITypedElementSelectionInterface");
static_assert(sizeof(ITypedElementSelectionInterface) == 0x000001, "Wrong size on ITypedElementSelectionInterface");

}

