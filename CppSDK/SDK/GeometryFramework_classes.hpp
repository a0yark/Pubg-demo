#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: GeometryFramework

#include "Basic.hpp"

#include "GeometryFramework_structs.hpp"
#include "CoreUObject_structs.hpp"
#include "CoreUObject_classes.hpp"
#include "Engine_structs.hpp"
#include "Engine_classes.hpp"
#include "PhysicsCore_structs.hpp"


namespace SDK
{

// Class GeometryFramework.BaseDynamicMeshComponent
// 0x0070 (0x0650 - 0x05E0)
class UBaseDynamicMeshComponent : public UMeshComponent
{
public:
	uint8                                         Pad_5E0[0x20];                                     // 0x05E0(0x0020)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bExplicitShowWireframe;                            // 0x0600(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_601[0x3];                                      // 0x0601(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FLinearColor                           WireframeColor;                                    // 0x0604(0x0010)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EDynamicMeshComponentColorOverrideMode        ColorMode;                                         // 0x0614(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_615[0x3];                                      // 0x0615(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FColor                                 ConstantColor;                                     // 0x0618(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bEnableFlatShading;                                // 0x061C(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bEnableViewModeOverrides;                          // 0x061D(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_61E[0x2];                                      // 0x061E(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	class UMaterialInterface*                     OverrideRenderMaterial;                            // 0x0620(0x0008)(ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UMaterialInterface*                     SecondaryRenderMaterial;                           // 0x0628(0x0008)(ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_630[0x1];                                      // 0x0630(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bEnableRayTracing;                                 // 0x0631(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_632[0x6];                                      // 0x0632(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UMaterialInterface*>             BaseMaterials;                                     // 0x0638(0x0010)(ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
	uint8                                         Pad_648[0x8];                                      // 0x0648(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ClearOverrideRenderMaterial()	 // 0x6d10074;
	void ClearSecondaryRenderMaterial()	 // 0x719cce4;
	class UDynamicMesh* GetDynamicMesh()	 // 0x719cea4;
	void SetColorOverrideMode(EDynamicMeshComponentColorOverrideMode NewMode)	 // 0x719d4b4;
	void SetConstantOverrideColor(const struct FColor& NewColor)	 // 0x719d6c8;
	void SetEnableFlatShading(bool bEnable)	 // 0x719da70;
	void SetEnableRaytracing(bool bSetEnabled)	 // 0x719db38;
	void SetEnableWireframeRenderPass(bool bEnable)	 // 0x719dc00;
	void SetOverrideRenderMaterial(class UMaterialInterface* Material)	 // 0x719dcc8;
	void SetSecondaryBuffersVisibility(bool bSetVisible)	 // 0x719dd8c;
	void SetSecondaryRenderMaterial(class UMaterialInterface* Material)	 // 0x719de54;
	void SetShadowsEnabled(bool bEnabled)	 // 0x719df18;
	void SetViewModeOverridesEnabled(bool bEnabled)	 // 0x6d10298;

	EDynamicMeshComponentColorOverrideMode GetColorOverrideMode() const	 // 0x719ce28;
	struct FColor GetConstantOverrideColor() const	 // 0x719ce74;
	bool GetEnableRaytracing() const	 // 0x719cecc;
	bool GetEnableWireframeRenderPass() const	 // 0x16637f8;
	bool GetFlatShadingEnabled() const	 // 0x719cef4;
	class UMaterialInterface* GetOverrideRenderMaterial(int32 MaterialIndex) const	 // 0x719cf1c;
	bool GetSecondaryBuffersVisibility() const	 // 0x719cff0;
	class UMaterialInterface* GetSecondaryRenderMaterial() const	 // 0x719d018;
	bool GetShadowsEnabled() const	 // 0x719d040;
	bool GetViewModeOverridesEnabled() const	 // 0x719d0a0;
	bool HasOverrideRenderMaterial(int32 K) const	 // 0x719d0c8;

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"BaseDynamicMeshComponent">();
	}
	static class UBaseDynamicMeshComponent* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UBaseDynamicMeshComponent>();
	}
};
static_assert(alignof(UBaseDynamicMeshComponent) == 0x000010, "Wrong alignment on UBaseDynamicMeshComponent");
static_assert(sizeof(UBaseDynamicMeshComponent) == 0x000650, "Wrong size on UBaseDynamicMeshComponent");
static_assert(offsetof(UBaseDynamicMeshComponent, bExplicitShowWireframe) == 0x000600, "Member 'UBaseDynamicMeshComponent::bExplicitShowWireframe' has a wrong offset!");
static_assert(offsetof(UBaseDynamicMeshComponent, WireframeColor) == 0x000604, "Member 'UBaseDynamicMeshComponent::WireframeColor' has a wrong offset!");
static_assert(offsetof(UBaseDynamicMeshComponent, ColorMode) == 0x000614, "Member 'UBaseDynamicMeshComponent::ColorMode' has a wrong offset!");
static_assert(offsetof(UBaseDynamicMeshComponent, ConstantColor) == 0x000618, "Member 'UBaseDynamicMeshComponent::ConstantColor' has a wrong offset!");
static_assert(offsetof(UBaseDynamicMeshComponent, bEnableFlatShading) == 0x00061C, "Member 'UBaseDynamicMeshComponent::bEnableFlatShading' has a wrong offset!");
static_assert(offsetof(UBaseDynamicMeshComponent, bEnableViewModeOverrides) == 0x00061D, "Member 'UBaseDynamicMeshComponent::bEnableViewModeOverrides' has a wrong offset!");
static_assert(offsetof(UBaseDynamicMeshComponent, OverrideRenderMaterial) == 0x000620, "Member 'UBaseDynamicMeshComponent::OverrideRenderMaterial' has a wrong offset!");
static_assert(offsetof(UBaseDynamicMeshComponent, SecondaryRenderMaterial) == 0x000628, "Member 'UBaseDynamicMeshComponent::SecondaryRenderMaterial' has a wrong offset!");
static_assert(offsetof(UBaseDynamicMeshComponent, bEnableRayTracing) == 0x000631, "Member 'UBaseDynamicMeshComponent::bEnableRayTracing' has a wrong offset!");
static_assert(offsetof(UBaseDynamicMeshComponent, BaseMaterials) == 0x000638, "Member 'UBaseDynamicMeshComponent::BaseMaterials' has a wrong offset!");

// Class GeometryFramework.DynamicMeshComponent
// 0x0210 (0x0860 - 0x0650)
class UDynamicMeshComponent final : public UBaseDynamicMeshComponent
{
public:
	class UDynamicMesh*                           MeshObject;                                        // 0x0650(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, PersistentInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_658[0xF8];                                     // 0x0658(0x00F8)(Fixing Size After Last Property [ Dumper-7 ])
	EDynamicMeshComponentTangentsMode             TangentsType;                                      // 0x0750(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_751[0x3F];                                     // 0x0751(0x003F)(Fixing Size After Last Property [ Dumper-7 ])
	ECollisionTraceFlag                           CollisionType;                                     // 0x0790(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUseAsyncCooking;                                  // 0x0791(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bEnableComplexCollision;                           // 0x0792(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDeferCollisionUpdates;                            // 0x0793(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_794[0x4];                                      // 0x0794(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UBodySetup*                             MeshBodySetup;                                     // 0x0798(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, PersistentInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_7A0[0x38];                                     // 0x07A0(0x0038)(Fixing Size After Last Property [ Dumper-7 ])
	struct FKAggregateGeom                        AggGeom;                                           // 0x07D8(0x0068)(Edit, Protected, NativeAccessSpecifierProtected)
	TArray<class UBodySetup*>                     AsyncBodySetupQueue;                               // 0x0840(0x0010)(ZeroConstructor, Transient, Protected, UObjectWrapper, NativeAccessSpecifierProtected)
	uint8                                         Pad_850[0x10];                                     // 0x0850(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ConfigureMaterialSet(const TArray<class UMaterialInterface*>& NewMaterialSet)	 // 0x719ccfc;
	void EnableComplexAsSimpleCollision()	 // 0x719cdd4;
	void SetComplexAsSimpleCollisionEnabled(bool bEnabled, bool bImmediateUpdate)	 // 0x719d578;
	void SetDeferredCollisionUpdatesEnabled(bool bEnabled, bool bImmediateUpdate)	 // 0x719d788;
	void SetDynamicMesh(class UDynamicMesh* NewMesh)	 // 0x719d8f0;
	void SetTangentsType(EDynamicMeshComponentTangentsMode NewTangentsType)	 // 0x719dfe0;
	void UpdateCollision(bool bOnlyIfPending)	 // 0x719e0a0;
	bool ValidateMaterialSlots(bool bCreateIfMissing, bool bDeleteExtraSlots)	 // 0x719e168;

	EDynamicMeshComponentTangentsMode GetTangentsType() const	 // 0x719d068;

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"DynamicMeshComponent">();
	}
	static class UDynamicMeshComponent* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UDynamicMeshComponent>();
	}
};
static_assert(alignof(UDynamicMeshComponent) == 0x000010, "Wrong alignment on UDynamicMeshComponent");
static_assert(sizeof(UDynamicMeshComponent) == 0x000860, "Wrong size on UDynamicMeshComponent");
static_assert(offsetof(UDynamicMeshComponent, MeshObject) == 0x000650, "Member 'UDynamicMeshComponent::MeshObject' has a wrong offset!");
static_assert(offsetof(UDynamicMeshComponent, TangentsType) == 0x000750, "Member 'UDynamicMeshComponent::TangentsType' has a wrong offset!");
static_assert(offsetof(UDynamicMeshComponent, CollisionType) == 0x000790, "Member 'UDynamicMeshComponent::CollisionType' has a wrong offset!");
static_assert(offsetof(UDynamicMeshComponent, bUseAsyncCooking) == 0x000791, "Member 'UDynamicMeshComponent::bUseAsyncCooking' has a wrong offset!");
static_assert(offsetof(UDynamicMeshComponent, bEnableComplexCollision) == 0x000792, "Member 'UDynamicMeshComponent::bEnableComplexCollision' has a wrong offset!");
static_assert(offsetof(UDynamicMeshComponent, bDeferCollisionUpdates) == 0x000793, "Member 'UDynamicMeshComponent::bDeferCollisionUpdates' has a wrong offset!");
static_assert(offsetof(UDynamicMeshComponent, MeshBodySetup) == 0x000798, "Member 'UDynamicMeshComponent::MeshBodySetup' has a wrong offset!");
static_assert(offsetof(UDynamicMeshComponent, AggGeom) == 0x0007D8, "Member 'UDynamicMeshComponent::AggGeom' has a wrong offset!");
static_assert(offsetof(UDynamicMeshComponent, AsyncBodySetupQueue) == 0x000840, "Member 'UDynamicMeshComponent::AsyncBodySetupQueue' has a wrong offset!");

// Class GeometryFramework.MeshCommandChangeTarget
// 0x0000 (0x0000 - 0x0000)
class IMeshCommandChangeTarget final
{
public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"MeshCommandChangeTarget">();
	}
	static class IMeshCommandChangeTarget* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<IMeshCommandChangeTarget>();
	}

	class UObject* AsUObject()	 // 0x0
	{
		return reinterpret_cast<UObject*>(this);
	}
	const class UObject* AsUObject() const	 // 0x0
	{
		return reinterpret_cast<const UObject*>(this);
	}
};
static_assert(alignof(IMeshCommandChangeTarget) == 0x000001, "Wrong alignment on IMeshCommandChangeTarget");
static_assert(sizeof(IMeshCommandChangeTarget) == 0x000001, "Wrong size on IMeshCommandChangeTarget");

// Class GeometryFramework.MeshReplacementCommandChangeTarget
// 0x0000 (0x0000 - 0x0000)
class IMeshReplacementCommandChangeTarget final
{
public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"MeshReplacementCommandChangeTarget">();
	}
	static class IMeshReplacementCommandChangeTarget* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<IMeshReplacementCommandChangeTarget>();
	}

	class UObject* AsUObject()	 // 0x0
	{
		return reinterpret_cast<UObject*>(this);
	}
	const class UObject* AsUObject() const	 // 0x0
	{
		return reinterpret_cast<const UObject*>(this);
	}
};
static_assert(alignof(IMeshReplacementCommandChangeTarget) == 0x000001, "Wrong alignment on IMeshReplacementCommandChangeTarget");
static_assert(sizeof(IMeshReplacementCommandChangeTarget) == 0x000001, "Wrong size on IMeshReplacementCommandChangeTarget");

// Class GeometryFramework.MeshVertexCommandChangeTarget
// 0x0000 (0x0000 - 0x0000)
class IMeshVertexCommandChangeTarget final
{
public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"MeshVertexCommandChangeTarget">();
	}
	static class IMeshVertexCommandChangeTarget* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<IMeshVertexCommandChangeTarget>();
	}

	class UObject* AsUObject()	 // 0x0
	{
		return reinterpret_cast<UObject*>(this);
	}
	const class UObject* AsUObject() const	 // 0x0
	{
		return reinterpret_cast<const UObject*>(this);
	}
};
static_assert(alignof(IMeshVertexCommandChangeTarget) == 0x000001, "Wrong alignment on IMeshVertexCommandChangeTarget");
static_assert(sizeof(IMeshVertexCommandChangeTarget) == 0x000001, "Wrong size on IMeshVertexCommandChangeTarget");

// Class GeometryFramework.DynamicMeshActor
// 0x0018 (0x02C8 - 0x02B0)
class ADynamicMeshActor final : public AActor
{
public:
	class UDynamicMeshComponent*                  DynamicMeshComponent;                              // 0x02B0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bEnableComputeMeshPool;                            // 0x02B8(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2B9[0x7];                                      // 0x02B9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UDynamicMeshPool*                       DynamicMeshPool;                                   // 0x02C0(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	class UDynamicMesh* AllocateComputeMesh()	 // 0x719cc94;
	void FreeAllComputeMeshes()	 // 0x719cdec;
	class UDynamicMeshPool* GetComputeMeshPool()	 // 0x719ce50;
	void ReleaseAllComputeMeshes()	 // 0x719d1c0;
	bool ReleaseComputeMesh(class UDynamicMesh* Mesh)	 // 0x719d1e8;

	class UDynamicMeshComponent* GetDynamicMeshComponent() const	 // 0x17d5724;

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"DynamicMeshActor">();
	}
	static class ADynamicMeshActor* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<ADynamicMeshActor>();
	}
};
static_assert(alignof(ADynamicMeshActor) == 0x000008, "Wrong alignment on ADynamicMeshActor");
static_assert(sizeof(ADynamicMeshActor) == 0x0002C8, "Wrong size on ADynamicMeshActor");
static_assert(offsetof(ADynamicMeshActor, DynamicMeshComponent) == 0x0002B0, "Member 'ADynamicMeshActor::DynamicMeshComponent' has a wrong offset!");
static_assert(offsetof(ADynamicMeshActor, bEnableComputeMeshPool) == 0x0002B8, "Member 'ADynamicMeshActor::bEnableComputeMeshPool' has a wrong offset!");
static_assert(offsetof(ADynamicMeshActor, DynamicMeshPool) == 0x0002C0, "Member 'ADynamicMeshActor::DynamicMeshPool' has a wrong offset!");

// Class GeometryFramework.DynamicMeshGenerator
// 0x0000 (0x0028 - 0x0028)
class UDynamicMeshGenerator final : public UObject
{
public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"DynamicMeshGenerator">();
	}
	static class UDynamicMeshGenerator* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UDynamicMeshGenerator>();
	}
};
static_assert(alignof(UDynamicMeshGenerator) == 0x000008, "Wrong alignment on UDynamicMeshGenerator");
static_assert(sizeof(UDynamicMeshGenerator) == 0x000028, "Wrong size on UDynamicMeshGenerator");

// Class GeometryFramework.DynamicMesh
// 0x0088 (0x00B0 - 0x0028)
class UDynamicMesh final : public UObject
{
public:
	uint8                                         Pad_28[0x48];                                      // 0x0028(0x0048)(Fixing Size After Last Property [ Dumper-7 ])
	TMulticastInlineDelegate<void(class UDynamicMesh* Mesh)> MeshModifiedBPEvent;                    // 0x0070(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_80[0x20];                                      // 0x0080(0x0020)(Fixing Size After Last Property [ Dumper-7 ])
	class UDynamicMeshGenerator*                  MeshGenerator;                                     // 0x00A0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, PersistentInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bEnableMeshGenerator;                              // 0x00A8(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A9[0x7];                                       // 0x00A9(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	class UDynamicMesh* Reset()	 // 0x719d344;
	class UDynamicMesh* ResetToCube()	 // 0x719d368;

	int32 GetTriangleCount() const	 // 0x719d080;
	bool IsEmpty() const	 // 0x719d19c;

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"DynamicMesh">();
	}
	static class UDynamicMesh* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UDynamicMesh>();
	}
};
static_assert(alignof(UDynamicMesh) == 0x000008, "Wrong alignment on UDynamicMesh");
static_assert(sizeof(UDynamicMesh) == 0x0000B0, "Wrong size on UDynamicMesh");
static_assert(offsetof(UDynamicMesh, MeshModifiedBPEvent) == 0x000070, "Member 'UDynamicMesh::MeshModifiedBPEvent' has a wrong offset!");
static_assert(offsetof(UDynamicMesh, MeshGenerator) == 0x0000A0, "Member 'UDynamicMesh::MeshGenerator' has a wrong offset!");
static_assert(offsetof(UDynamicMesh, bEnableMeshGenerator) == 0x0000A8, "Member 'UDynamicMesh::bEnableMeshGenerator' has a wrong offset!");

// Class GeometryFramework.DynamicMeshPool
// 0x0020 (0x0048 - 0x0028)
class UDynamicMeshPool final : public UObject
{
public:
	TArray<class UDynamicMesh*>                   CachedMeshes;                                      // 0x0028(0x0010)(ZeroConstructor, Protected, UObjectWrapper, NativeAccessSpecifierProtected)
	TArray<class UDynamicMesh*>                   AllCreatedMeshes;                                  // 0x0038(0x0010)(ZeroConstructor, Protected, UObjectWrapper, NativeAccessSpecifierProtected)

public:
	void FreeAllMeshes()	 // 0x719ce14;
	class UDynamicMesh* RequestMesh()	 // 0x719d320;
	void ReturnAllMeshes()	 // 0x719d38c;
	void ReturnMesh(class UDynamicMesh* Mesh)	 // 0x719d3a0;

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"DynamicMeshPool">();
	}
	static class UDynamicMeshPool* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UDynamicMeshPool>();
	}
};
static_assert(alignof(UDynamicMeshPool) == 0x000008, "Wrong alignment on UDynamicMeshPool");
static_assert(sizeof(UDynamicMeshPool) == 0x000048, "Wrong size on UDynamicMeshPool");
static_assert(offsetof(UDynamicMeshPool, CachedMeshes) == 0x000028, "Member 'UDynamicMeshPool::CachedMeshes' has a wrong offset!");
static_assert(offsetof(UDynamicMeshPool, AllCreatedMeshes) == 0x000038, "Member 'UDynamicMeshPool::AllCreatedMeshes' has a wrong offset!");

}

