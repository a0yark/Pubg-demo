#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: MotionTrajectory

#include "Basic.hpp"

#include "MotionTrajectory_structs.hpp"
#include "Engine_classes.hpp"
#include "CoreUObject_structs.hpp"


namespace SDK
{

// Class MotionTrajectory.MotionTrajectoryComponent
// 0x01B8 (0x0278 - 0x00C0)
#pragma pack(push, 0x1)
class alignas(0x08) UMotionTrajectoryComponent : public UActorComponent
{
public:
	uint8                                         Pad_C0[0x1A0];                                     // 0x00C0(0x01A0)(Fixing Size After Last Property [ Dumper-7 ])
	struct FMotionTrajectorySettings              PredictionSettings;                                // 0x0260(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
	struct FMotionTrajectorySettings              HistorySettings;                                   // 0x0264(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
	int32                                         SampleRate;                                        // 0x0268(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MaxSamples;                                        // 0x026C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bPredictionIncludesHistory;                        // 0x0270(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_271[0x7];                                      // 0x0271(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	struct FTrajectorySampleRange GetHistory() const	 // 0x71a444c;
	struct FTrajectorySampleRange GetTrajectory() const	 // 0x71a448c;
	struct FTrajectorySampleRange GetTrajectoryWithSettings(const struct FMotionTrajectorySettings& Settings, bool bIncludeHistory) const	 // 0x71a44d0;

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"MotionTrajectoryComponent">();
	}
	static class UMotionTrajectoryComponent* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UMotionTrajectoryComponent>();
	}
};
#pragma pack(pop)
static_assert(alignof(UMotionTrajectoryComponent) == 0x000008, "Wrong alignment on UMotionTrajectoryComponent");
static_assert(sizeof(UMotionTrajectoryComponent) == 0x000278, "Wrong size on UMotionTrajectoryComponent");
static_assert(offsetof(UMotionTrajectoryComponent, PredictionSettings) == 0x000260, "Member 'UMotionTrajectoryComponent::PredictionSettings' has a wrong offset!");
static_assert(offsetof(UMotionTrajectoryComponent, HistorySettings) == 0x000264, "Member 'UMotionTrajectoryComponent::HistorySettings' has a wrong offset!");
static_assert(offsetof(UMotionTrajectoryComponent, SampleRate) == 0x000268, "Member 'UMotionTrajectoryComponent::SampleRate' has a wrong offset!");
static_assert(offsetof(UMotionTrajectoryComponent, MaxSamples) == 0x00026C, "Member 'UMotionTrajectoryComponent::MaxSamples' has a wrong offset!");
static_assert(offsetof(UMotionTrajectoryComponent, bPredictionIncludesHistory) == 0x000270, "Member 'UMotionTrajectoryComponent::bPredictionIncludesHistory' has a wrong offset!");

// Class MotionTrajectory.CharacterMovementTrajectoryComponent
// 0x0038 (0x02B0 - 0x0278)
class alignas(0x10) UCharacterMovementTrajectoryComponent final : public UMotionTrajectoryComponent
{
public:
	struct FRotator                               LastDesiredControlRotation;                        // 0x0278(0x0018)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)
	struct FRotator                               DesiredControlRotationVelocity;                    // 0x0290(0x0018)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_2A8[0x8];                                      // 0x02A8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnMovementUpdated(float DeltaSeconds, const struct FVector& OldLocation, const struct FVector& OldVelocity)	 // 0x71a4f64;

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"CharacterMovementTrajectoryComponent">();
	}
	static class UCharacterMovementTrajectoryComponent* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UCharacterMovementTrajectoryComponent>();
	}
};
static_assert(alignof(UCharacterMovementTrajectoryComponent) == 0x000010, "Wrong alignment on UCharacterMovementTrajectoryComponent");
static_assert(sizeof(UCharacterMovementTrajectoryComponent) == 0x0002B0, "Wrong size on UCharacterMovementTrajectoryComponent");
static_assert(offsetof(UCharacterMovementTrajectoryComponent, LastDesiredControlRotation) == 0x000278, "Member 'UCharacterMovementTrajectoryComponent::LastDesiredControlRotation' has a wrong offset!");
static_assert(offsetof(UCharacterMovementTrajectoryComponent, DesiredControlRotationVelocity) == 0x000290, "Member 'UCharacterMovementTrajectoryComponent::DesiredControlRotationVelocity' has a wrong offset!");

// Class MotionTrajectory.MotionTrajectoryBlueprintLibrary
// 0x0000 (0x0028 - 0x0028)
class UMotionTrajectoryBlueprintLibrary final : public UBlueprintFunctionLibrary
{
public:
	static void DebugDrawTrajectory(const class AActor* Actor, const struct FTransform& WorldTransform, const struct FTrajectorySampleRange& Trajectory, const struct FLinearColor& PredictionColor, const struct FLinearColor& HistoryColor, float TransformScale, float TransformThickness, float ArrowScale, float ArrowSize, float ArrowThickness)	 // 0x71a3ad8;
	static struct FTrajectorySampleRange FlattenTrajectory2D(const struct FTrajectorySampleRange& Trajectory)	 // 0x71a4350;
	static bool IsConstantSpeedTrajectory(const struct FTrajectorySampleRange& Trajectory, float Speed, float Tolerance)	 // 0x71a467c;
	static bool IsStartingTrajectory(const struct FTrajectorySampleRange& Trajectory, float MoveMinSpeed, float IdleMaxSpeed)	 // 0x71a48f0;
	static bool IsStoppingTrajectory(const struct FTrajectorySampleRange& Trajectory, float MoveMinSpeed, float IdleMaxSpeed)	 // 0x71a4b64;
	static struct FTrajectorySampleRange MakeTrajectoryRelativeToComponent(const struct FTrajectorySampleRange& ActorTrajectory, const class USceneComponent* Component)	 // 0x71a4dd8;
	static struct FTrajectorySampleRange RotateTrajectory(const struct FTrajectorySampleRange& Trajectory, const struct FQuat& Rotation)	 // 0x71a5120;

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"MotionTrajectoryBlueprintLibrary">();
	}
	static class UMotionTrajectoryBlueprintLibrary* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UMotionTrajectoryBlueprintLibrary>();
	}
};
static_assert(alignof(UMotionTrajectoryBlueprintLibrary) == 0x000008, "Wrong alignment on UMotionTrajectoryBlueprintLibrary");
static_assert(sizeof(UMotionTrajectoryBlueprintLibrary) == 0x000028, "Wrong size on UMotionTrajectoryBlueprintLibrary");

}

