#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: MultiWorld

#include "Basic.hpp"

#include "CoreUObject_classes.hpp"
#include "Engine_structs.hpp"
#include "Engine_classes.hpp"
#include "UMG_classes.hpp"
#include "MultiWorld_structs.hpp"


namespace SDK
{

// Class MultiWorld.MultiWorldActorInterface
// 0x0000 (0x0000 - 0x0000)
class IMultiWorldActorInterface final
{
public:
	void OnEnteringWorld()	 // 0x30cfd60;
	void OnExitingWorld()	 // 0x30cfd80;

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"MultiWorldActorInterface">();
	}
	static class IMultiWorldActorInterface* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<IMultiWorldActorInterface>();
	}

	class UObject* AsUObject()	 // 0x0
	{
		return reinterpret_cast<UObject*>(this);
	}
	const class UObject* AsUObject() const	 // 0x0
	{
		return reinterpret_cast<const UObject*>(this);
	}
};
static_assert(alignof(IMultiWorldActorInterface) == 0x000001, "Wrong alignment on IMultiWorldActorInterface");
static_assert(sizeof(IMultiWorldActorInterface) == 0x000001, "Wrong size on IMultiWorldActorInterface");

// Class MultiWorld.MultiWorldSceneCapture2D
// 0x0000 (0x02C8 - 0x02C8)
class AMultiWorldSceneCapture2D final : public ASceneCapture2D
{
public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"MultiWorldSceneCapture2D">();
	}
	static class AMultiWorldSceneCapture2D* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<AMultiWorldSceneCapture2D>();
	}
};
static_assert(alignof(AMultiWorldSceneCapture2D) == 0x000008, "Wrong alignment on AMultiWorldSceneCapture2D");
static_assert(sizeof(AMultiWorldSceneCapture2D) == 0x0002C8, "Wrong size on AMultiWorldSceneCapture2D");

// Class MultiWorld.MultiWorldGameInstance
// 0x0000 (0x01C0 - 0x01C0)
class UMultiWorldGameInstance final : public UGameInstance
{
public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"MultiWorldGameInstance">();
	}
	static class UMultiWorldGameInstance* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UMultiWorldGameInstance>();
	}
};
static_assert(alignof(UMultiWorldGameInstance) == 0x000008, "Wrong alignment on UMultiWorldGameInstance");
static_assert(sizeof(UMultiWorldGameInstance) == 0x0001C0, "Wrong size on UMultiWorldGameInstance");

// Class MultiWorld.MultiWorldSeamTransition
// 0x0078 (0x00A8 - 0x0030)
class UMultiWorldSeamTransition final : public UGameInstanceSubsystem
{
public:
	uint8                                         Pad_30[0x8];                                       // 0x0030(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class UUserWidget>                UMGEffetLayerClass;                                // 0x0038(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UMultiWorldSeamTransitionFXLayer*       FXLayer;                                           // 0x0040(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TDelegate<void()>                             OnTransitionEnd;                                   // 0x0048(0x0010)(ZeroConstructor, Transient, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UTextureRenderTarget2D*                 SrcWorldRT;                                        // 0x0058(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UTextureRenderTarget2D*                 DstWorldRT;                                        // 0x0060(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UMaterialInstanceDynamic*               MatInstance;                                       // 0x0068(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class ASceneCapture2D*                        SrcWorldSceneCapture;                              // 0x0070(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class ASceneCapture2D*                        DstWorldSceneCapture;                              // 0x0078(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_80[0x18];                                      // 0x0080(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	struct FMultiWorldHandle                      DestinationWorldHandle;                            // 0x0098(0x0008)(Transient, NoDestructor, NativeAccessSpecifierPrivate)
	struct FMultiWorldHandle                      SourceWorldHandle;                                 // 0x00A0(0x0008)(Transient, NoDestructor, NativeAccessSpecifierPrivate)

public:
	void OnPreWorldEnded(const struct FMultiWorldHandle& InWorldToEnd)	 // 0x30cfda0;
	void SetDefaultFXLayerZOrder(int32 ZOrder)	 // 0x30d0a30;
	bool StartTransition(class UObject* WorldContextObject, const struct FMultiWorldHandle& InDestinationWorldHandle, class UMaterialInterface* TransitionMaterial, const TDelegate<void()>& OnTransitionEnd_0, float DurationInSeconds, float WorldSwitchNormalizedTime, bool bForceWorldsTickingDuringTransition, bool bAutoHandleAudioFade)	 // 0x30d20e0;

	bool IsInTransition() const	 // 0x30cd050;

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"MultiWorldSeamTransition">();
	}
	static class UMultiWorldSeamTransition* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UMultiWorldSeamTransition>();
	}
};
static_assert(alignof(UMultiWorldSeamTransition) == 0x000008, "Wrong alignment on UMultiWorldSeamTransition");
static_assert(sizeof(UMultiWorldSeamTransition) == 0x0000A8, "Wrong size on UMultiWorldSeamTransition");
static_assert(offsetof(UMultiWorldSeamTransition, UMGEffetLayerClass) == 0x000038, "Member 'UMultiWorldSeamTransition::UMGEffetLayerClass' has a wrong offset!");
static_assert(offsetof(UMultiWorldSeamTransition, FXLayer) == 0x000040, "Member 'UMultiWorldSeamTransition::FXLayer' has a wrong offset!");
static_assert(offsetof(UMultiWorldSeamTransition, OnTransitionEnd) == 0x000048, "Member 'UMultiWorldSeamTransition::OnTransitionEnd' has a wrong offset!");
static_assert(offsetof(UMultiWorldSeamTransition, SrcWorldRT) == 0x000058, "Member 'UMultiWorldSeamTransition::SrcWorldRT' has a wrong offset!");
static_assert(offsetof(UMultiWorldSeamTransition, DstWorldRT) == 0x000060, "Member 'UMultiWorldSeamTransition::DstWorldRT' has a wrong offset!");
static_assert(offsetof(UMultiWorldSeamTransition, MatInstance) == 0x000068, "Member 'UMultiWorldSeamTransition::MatInstance' has a wrong offset!");
static_assert(offsetof(UMultiWorldSeamTransition, SrcWorldSceneCapture) == 0x000070, "Member 'UMultiWorldSeamTransition::SrcWorldSceneCapture' has a wrong offset!");
static_assert(offsetof(UMultiWorldSeamTransition, DstWorldSceneCapture) == 0x000078, "Member 'UMultiWorldSeamTransition::DstWorldSceneCapture' has a wrong offset!");
static_assert(offsetof(UMultiWorldSeamTransition, DestinationWorldHandle) == 0x000098, "Member 'UMultiWorldSeamTransition::DestinationWorldHandle' has a wrong offset!");
static_assert(offsetof(UMultiWorldSeamTransition, SourceWorldHandle) == 0x0000A0, "Member 'UMultiWorldSeamTransition::SourceWorldHandle' has a wrong offset!");

// Class MultiWorld.MultiWorldGameViewportClient
// 0x0000 (0x03B8 - 0x03B8)
class UMultiWorldGameViewportClient final : public UGameViewportClient
{
public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"MultiWorldGameViewportClient">();
	}
	static class UMultiWorldGameViewportClient* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UMultiWorldGameViewportClient>();
	}
};
static_assert(alignof(UMultiWorldGameViewportClient) == 0x000008, "Wrong alignment on UMultiWorldGameViewportClient");
static_assert(sizeof(UMultiWorldGameViewportClient) == 0x0003B8, "Wrong size on UMultiWorldGameViewportClient");

// Class MultiWorld.MultiWorldSeamTransitionFXLayer
// 0x0000 (0x0280 - 0x0280)
class UMultiWorldSeamTransitionFXLayer : public UUserWidget
{
public:
	void SetEffect(class UMaterialInstance* InMaterial)	 // 0xae1e64;

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"MultiWorldSeamTransitionFXLayer">();
	}
	static class UMultiWorldSeamTransitionFXLayer* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UMultiWorldSeamTransitionFXLayer>();
	}
};
static_assert(alignof(UMultiWorldSeamTransitionFXLayer) == 0x000008, "Wrong alignment on UMultiWorldSeamTransitionFXLayer");
static_assert(sizeof(UMultiWorldSeamTransitionFXLayer) == 0x000280, "Wrong size on UMultiWorldSeamTransitionFXLayer");

// Class MultiWorld.MultiWorldManager
// 0x0130 (0x0160 - 0x0030)
class UMultiWorldManager final : public UGameInstanceSubsystem
{
public:
	uint8                                         Pad_30[0x8];                                       // 0x0030(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TMulticastInlineDelegate<void(bool Success, const struct FMultiWorldHandle& WorldHandle, const struct FMultiWorldLoadParameters& LoadParams)> OnLoadWorldCompleted; // 0x0038(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(const struct FMultiWorldHandle& PreviousWorld, const struct FMultiWorldHandle& CurrentWorld)> OnWorldSwitched; // 0x0048(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(const struct FMultiWorldHandle& WorldToEnd)> OnPreWorldEnded;      // 0x0058(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	class UWorld*                                 MainWorld;                                         // 0x0068(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UWorld*                                 ActiveWorld;                                       // 0x0070(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_78[0x18];                                      // 0x0078(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UWorld*>                         PendingEndWorlds;                                  // 0x0090(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	uint8                                         Pad_A0[0xC0];                                      // 0x00A0(0x00C0)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"MultiWorldManager">();
	}
	static class UMultiWorldManager* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UMultiWorldManager>();
	}
};
static_assert(alignof(UMultiWorldManager) == 0x000008, "Wrong alignment on UMultiWorldManager");
static_assert(sizeof(UMultiWorldManager) == 0x000160, "Wrong size on UMultiWorldManager");
static_assert(offsetof(UMultiWorldManager, OnLoadWorldCompleted) == 0x000038, "Member 'UMultiWorldManager::OnLoadWorldCompleted' has a wrong offset!");
static_assert(offsetof(UMultiWorldManager, OnWorldSwitched) == 0x000048, "Member 'UMultiWorldManager::OnWorldSwitched' has a wrong offset!");
static_assert(offsetof(UMultiWorldManager, OnPreWorldEnded) == 0x000058, "Member 'UMultiWorldManager::OnPreWorldEnded' has a wrong offset!");
static_assert(offsetof(UMultiWorldManager, MainWorld) == 0x000068, "Member 'UMultiWorldManager::MainWorld' has a wrong offset!");
static_assert(offsetof(UMultiWorldManager, ActiveWorld) == 0x000070, "Member 'UMultiWorldManager::ActiveWorld' has a wrong offset!");
static_assert(offsetof(UMultiWorldManager, PendingEndWorlds) == 0x000090, "Member 'UMultiWorldManager::PendingEndWorlds' has a wrong offset!");

// Class MultiWorld.MultiWorldSceneCaptureComponent2D
// 0x0010 (0x0C00 - 0x0BF0)
class UMultiWorldSceneCaptureComponent2D final : public USceneCaptureComponent2D
{
public:
	uint8                                         Pad_BF0[0x10];                                     // 0x0BF0(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"MultiWorldSceneCaptureComponent2D">();
	}
	static class UMultiWorldSceneCaptureComponent2D* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UMultiWorldSceneCaptureComponent2D>();
	}
};
static_assert(alignof(UMultiWorldSceneCaptureComponent2D) == 0x000010, "Wrong alignment on UMultiWorldSceneCaptureComponent2D");
static_assert(sizeof(UMultiWorldSceneCaptureComponent2D) == 0x000C00, "Wrong size on UMultiWorldSceneCaptureComponent2D");

// Class MultiWorld.MultiWorldStatics
// 0x0000 (0x0028 - 0x0028)
class UMultiWorldStatics final : public UBlueprintFunctionLibrary
{
public:
	static bool AreWorldsEquals(const struct FMultiWorldHandle& InWorldHandleA, const struct FMultiWorldHandle& InWorldHandleB)	 // 0x30c84d0;
	static void EndWorld(const class UObject* WorldContextObject, const struct FMultiWorldHandle& InWorldHandle, bool bCallImmediately)	 // 0x30c8670;
	static void ExecuteConsoleCommandInWorld(const struct FMultiWorldHandle& InWorldHandle, const class FString& Command)	 // 0x30c8b50;
	static struct FMultiWorldHandle GetActiveWorldHandle(const class UObject* WorldContextObject)	 // 0x30c8e90;
	static class AActor* GetActorOfClass(const struct FMultiWorldHandle& InWorldHandle, TSubclassOf<class AActor> ActorClass)	 // 0x30c90e0;
	static void GetAllActorsOfClass(const struct FMultiWorldHandle& InWorldHandle, TSubclassOf<class AActor> ActorClass, TArray<class AActor*>* OutActors)	 // 0x30c9750;
	static void GetAllActorsOfClassWithTag(const struct FMultiWorldHandle& InWorldHandle, TSubclassOf<class AActor> ActorClass, class FName Tag, TArray<class AActor*>* OutActors)	 // 0x30ca0e0;
	static void GetAllActorsWithInterface(const struct FMultiWorldHandle& InWorldHandle, TSubclassOf<class IInterface> Interface, TArray<class AActor*>* OutActors)	 // 0x30ca670;
	static void GetAllActorsWithTag(const struct FMultiWorldHandle& InWorldHandle, class FName Tag, TArray<class AActor*>* OutActors)	 // 0x30cb250;
	static void GetAllObjectsWithInterface(const struct FMultiWorldHandle& InWorldHandle, TSubclassOf<class IInterface> Interface, TArray<class UObject*>* OutObjects)	 // 0x30cbbe0;
	static struct FMultiWorldHandle GetMainWorldHandle(const class UObject* WorldContextObject)	 // 0x30cbfa0;
	static class APlayerController* GetPlayerController(const class UObject* WorldContextObject, int32 PlayerIndex)	 // 0x30cc210;
	static struct FMultiWorldHandle GetThisWorldHandle(const class UObject* WorldContextObject)	 // 0x30cc6c0;
	static struct FMultiWorldHandle GetWorldHandleByName(const class UObject* WorldContextObject, class FName WorldName)	 // 0x30cc920;
	static void InitializeWorld(const class UObject* WorldContextObject, const struct FMultiWorldHandle& InWorldHandle)	 // 0x30ccd60;
	static bool IsValidHandle(const class UObject* WorldContextObject, const struct FMultiWorldHandle& InWorldHandle)	 // 0x30cd080;
	static void LoadWorldAsyncWithDelegate(const class UObject* WorldContextObject, TSoftObjectPtr<class UWorld> InMapAsset, const struct FMultiWorldLoadParameters& InParams, TDelegate<void(bool Success, const struct FMultiWorldHandle& WorldHandle, const struct FMultiWorldLoadParameters& LoadParams)> OnComplete)	 // 0x30ce400;
	static void LoadWorldWithDelegate(const class UObject* WorldContextObject, TSoftObjectPtr<class UWorld> InMapAsset, const struct FMultiWorldLoadParameters& InParams, TDelegate<void(bool Success, const struct FMultiWorldHandle& WorldHandle, const struct FMultiWorldLoadParameters& LoadParams)> OnComplete)	 // 0x30ced80;
	static void RequestSwitchWorld(const class UObject* WorldContextObject, const struct FMultiWorldHandle& InWorldHandle)	 // 0x30d0010;
	static bool ReturnToMainWorld(const class UObject* WorldContextObject)	 // 0x30d0340;
	static void SetAutoHandleWidgetsForMainWorld(const class UObject* WorldContextObject, bool bAutoHandleWidgets)	 // 0x30d05d0;
	static void SetPhysicsActorTransform(class AActor* Actor, const struct FTransform& NewTransform, ETeleportType Teleport)	 // 0x30d0cf0;
	static void SetShouldTickWhenInBackground(const class UObject* WorldContextObject, const struct FMultiWorldHandle& InWorldHandle, bool bShouldTick)	 // 0x30d1240;
	static class AActor* SpawnActorInWorld(const class UObject* WorldContextObject, TSubclassOf<class AActor> ActorClass, const struct FMultiWorldHandle& InWorldHandle, const struct FTransform& SpawnTransform, ESpawnActorCollisionHandlingMethod CollisionHandlingOverride, class AActor* Owner)	 // 0x30d1720;
	static bool SwitchWorld(const class UObject* WorldContextObject, const struct FMultiWorldHandle& InWorldHandle)	 // 0x30d30a0;
	static void TransferActorToWorld(const class UObject* WorldContextObject, class AActor* InActor, const struct FMultiWorldHandle& InWorldHandle, const struct FMultiWorldTransferActorParameters& OPTIONS)	 // 0x30d3390;

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"MultiWorldStatics">();
	}
	static class UMultiWorldStatics* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UMultiWorldStatics>();
	}
};
static_assert(alignof(UMultiWorldStatics) == 0x000008, "Wrong alignment on UMultiWorldStatics");
static_assert(sizeof(UMultiWorldStatics) == 0x000028, "Wrong size on UMultiWorldStatics");

// Class MultiWorld.LoadWorldAction
// 0x0060 (0x0090 - 0x0030)
class ULoadWorldAction final : public UBlueprintAsyncActionBase
{
public:
	TMulticastInlineDelegate<void(bool Success, const struct FMultiWorldHandle& WorldHandle, const struct FMultiWorldLoadParameters& LoadParams)> Completed; // 0x0030(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_40[0x50];                                      // 0x0040(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class ULoadWorldAction* LoadWorld(class UObject* WorldContextObject, TSoftObjectPtr<class UWorld> InMapAsset, const struct FMultiWorldLoadParameters& InParams)	 // 0x30cd360;

	void OnCompleted(bool Success, const struct FMultiWorldHandle& WorldHandle, const struct FMultiWorldLoadParameters& LoadParams)	 // 0x30cf700;

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"LoadWorldAction">();
	}
	static class ULoadWorldAction* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<ULoadWorldAction>();
	}
};
static_assert(alignof(ULoadWorldAction) == 0x000008, "Wrong alignment on ULoadWorldAction");
static_assert(sizeof(ULoadWorldAction) == 0x000090, "Wrong size on ULoadWorldAction");
static_assert(offsetof(ULoadWorldAction, Completed) == 0x000030, "Member 'ULoadWorldAction::Completed' has a wrong offset!");

// Class MultiWorld.LoadWorldAsyncAction
// 0x0060 (0x0090 - 0x0030)
class ULoadWorldAsyncAction final : public UBlueprintAsyncActionBase
{
public:
	TMulticastInlineDelegate<void(bool Success, const struct FMultiWorldHandle& WorldHandle, const struct FMultiWorldLoadParameters& LoadParams)> Completed; // 0x0030(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_40[0x50];                                      // 0x0040(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class ULoadWorldAsyncAction* LoadWorldAsync(class UObject* WorldContextObject, TSoftObjectPtr<class UWorld> InMapAsset, const struct FMultiWorldLoadParameters& InParams)	 // 0x30cdbb0;

	void OnCompleted(bool Success, const struct FMultiWorldHandle& WorldHandle, const struct FMultiWorldLoadParameters& LoadParams)	 // 0x30cf700;

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"LoadWorldAsyncAction">();
	}
	static class ULoadWorldAsyncAction* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<ULoadWorldAsyncAction>();
	}
};
static_assert(alignof(ULoadWorldAsyncAction) == 0x000008, "Wrong alignment on ULoadWorldAsyncAction");
static_assert(sizeof(ULoadWorldAsyncAction) == 0x000090, "Wrong size on ULoadWorldAsyncAction");
static_assert(offsetof(ULoadWorldAsyncAction, Completed) == 0x000030, "Member 'ULoadWorldAsyncAction::Completed' has a wrong offset!");

}

