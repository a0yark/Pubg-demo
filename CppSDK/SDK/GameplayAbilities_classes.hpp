#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: GameplayAbilities

#include "Basic.hpp"

#include "GameplayTasks_classes.hpp"
#include "GameplayTags_structs.hpp"
#include "Engine_structs.hpp"
#include "Engine_classes.hpp"
#include "CoreUObject_structs.hpp"
#include "CoreUObject_classes.hpp"
#include "GameplayAbilities_structs.hpp"
#include "MovieScene_classes.hpp"


namespace SDK
{

// Class GameplayAbilities.AbilityAsync
// 0x0008 (0x0038 - 0x0030)
class UAbilityAsync : public UCancellableAsyncAction
{
public:
	uint8                                         Pad_30[0x8];                                       // 0x0030(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void EndAction()	 // 0x3d9afa4;

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"AbilityAsync">();
	}
	static class UAbilityAsync* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UAbilityAsync>();
	}
};
static_assert(alignof(UAbilityAsync) == 0x000008, "Wrong alignment on UAbilityAsync");
static_assert(sizeof(UAbilityAsync) == 0x000038, "Wrong size on UAbilityAsync");

// Class GameplayAbilities.GameplayAbility
// 0x0390 (0x03B8 - 0x0028)
class UGameplayAbility : public UObject
{
public:
	uint8                                         Pad_28[0x80];                                      // 0x0028(0x0080)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTagContainer                  AbilityTags;                                       // 0x00A8(0x0020)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	bool                                          bReplicateInputDirectly;                           // 0x00C8(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          RemoteInstanceEnded;                               // 0x00C9(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_CA[0x4];                                       // 0x00CA(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	EGameplayAbilityReplicationPolicy             ReplicationPolicy;                                 // 0x00CE(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EGameplayAbilityInstancingPolicy              InstancingPolicy;                                  // 0x00CF(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bServerRespectsRemoteAbilityCancellation;          // 0x00D0(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bRetriggerInstancedAbility;                        // 0x00D1(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_D2[0x6];                                       // 0x00D2(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayAbilityActivationInfo         CurrentActivationInfo;                             // 0x00D8(0x0020)(BlueprintVisible, BlueprintReadOnly, NoDestructor, Protected, NativeAccessSpecifierProtected)
	struct FGameplayEventData                     CurrentEventData;                                  // 0x00F8(0x00B0)(BlueprintVisible, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)
	EGameplayAbilityNetExecutionPolicy            NetExecutionPolicy;                                // 0x01A8(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EGameplayAbilityNetSecurityPolicy             NetSecurityPolicy;                                 // 0x01A9(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1AA[0x6];                                      // 0x01AA(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class UGameplayEffect>            CostGameplayEffectClass;                           // 0x01B0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<struct FAbilityTriggerData>            AbilityTriggers;                                   // 0x01B8(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	TSubclassOf<class UGameplayEffect>            CooldownGameplayEffectClass;                       // 0x01C8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FGameplayTagContainer                  CancelAbilitiesWithTag;                            // 0x01D0(0x0020)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FGameplayTagContainer                  BlockAbilitiesWithTag;                             // 0x01F0(0x0020)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FGameplayTagContainer                  ActivationOwnedTags;                               // 0x0210(0x0020)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FGameplayTagContainer                  ActivationRequiredTags;                            // 0x0230(0x0020)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FGameplayTagContainer                  ActivationBlockedTags;                             // 0x0250(0x0020)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FGameplayTagContainer                  SourceRequiredTags;                                // 0x0270(0x0020)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FGameplayTagContainer                  SourceBlockedTags;                                 // 0x0290(0x0020)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FGameplayTagContainer                  TargetRequiredTags;                                // 0x02B0(0x0020)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FGameplayTagContainer                  TargetBlockedTags;                                 // 0x02D0(0x0020)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_2F0[0x20];                                     // 0x02F0(0x0020)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UGameplayTask*>                  ActiveTasks;                                       // 0x0310(0x0010)(ZeroConstructor, Protected, UObjectWrapper, NativeAccessSpecifierProtected)
	uint8                                         Pad_320[0x10];                                     // 0x0320(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class UAnimMontage*                           CurrentMontage;                                    // 0x0330(0x0008)(ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_338[0x60];                                     // 0x0338(0x0060)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bIsActive;                                         // 0x0398(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIsAbilityEnding;                                  // 0x0399(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIsCancelable;                                     // 0x039A(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIsBlockingOtherAbilities;                         // 0x039B(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_39C[0x14];                                     // 0x039C(0x0014)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bMarkPendingKillOnAbilityEnd;                      // 0x03B0(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3B1[0x7];                                      // 0x03B1(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	struct FActiveGameplayEffectHandle BP_ApplyGameplayEffectToOwner(TSubclassOf<class UGameplayEffect> GameplayEffectClass, int32 GameplayEffectLevel, int32 Stacks)	 // 0xa2dae4;
	TArray<struct FActiveGameplayEffectHandle> BP_ApplyGameplayEffectToTarget(const struct FGameplayAbilityTargetDataHandle& TargetData, TSubclassOf<class UGameplayEffect> GameplayEffectClass, int32 GameplayEffectLevel, int32 Stacks)	 // 0x3d980a8;
	void BP_RemoveGameplayEffectFromOwnerWithAssetTags(const struct FGameplayTagContainer& WithAssetTags, int32 StacksToRemove)	 // 0x3d983a0;
	void BP_RemoveGameplayEffectFromOwnerWithGrantedTags(const struct FGameplayTagContainer& WithGrantedTags, int32 StacksToRemove)	 // 0x3d9858c;
	void BP_RemoveGameplayEffectFromOwnerWithHandle(const struct FActiveGameplayEffectHandle& Handle, int32 StacksToRemove)	 // 0x175e578;
	void CancelTaskByInstanceName(class FName InstanceName)	 // 0x3d98cf8;
	void ConfirmTaskByInstanceName(class FName InstanceName, bool bEndTask)	 // 0x3d99018;
	void EndAbilityState(class FName OptionalStateNameToEnd)	 // 0x3d9aedc;
	void EndTaskByInstanceName(class FName InstanceName)	 // 0x3d9afbc;
	void K2_ActivateAbility()	 // 0xae1e64;
	void K2_ActivateAbilityFromEvent(const struct FGameplayEventData& EventData)	 // 0xae1e64;
	void K2_AddGameplayCue(const struct FGameplayTag& GameplayCueTag, const struct FGameplayEffectContextHandle& Context, bool bRemoveOnAbilityEnd)	 // 0x1760dd0;
	void K2_AddGameplayCueWithParams(const struct FGameplayTag& GameplayCueTag, const struct FGameplayCueParameters& GameplayCueParameter, bool bRemoveOnAbilityEnd)	 // 0x3da002c;
	struct FActiveGameplayEffectHandle K2_ApplyGameplayEffectSpecToOwner(const struct FGameplayEffectSpecHandle& EffectSpecHandle)	 // 0x3da0220;
	TArray<struct FActiveGameplayEffectHandle> K2_ApplyGameplayEffectSpecToTarget(const struct FGameplayEffectSpecHandle& EffectSpecHandle, const struct FGameplayAbilityTargetDataHandle& TargetData)	 // 0x3da03d0;
	void K2_CancelAbility()	 // 0x3da084c;
	bool K2_CheckAbilityCooldown()	 // 0x3da0860;
	bool K2_CheckAbilityCost()	 // 0x3da0888;
	bool K2_CommitAbility()	 // 0x1768c8c;
	bool K2_CommitAbilityCooldown(bool BroadcastCommitEvent, bool ForceCooldown)	 // 0x1331008;
	bool K2_CommitAbilityCost(bool BroadcastCommitEvent)	 // 0x3da08b0;
	void K2_CommitExecute()	 // 0xae1e64;
	void K2_EndAbility()	 // 0x13308a8;
	void K2_EndAbilityLocally()	 // 0x3da0988;
	void K2_ExecuteGameplayCue(const struct FGameplayTag& GameplayCueTag, const struct FGameplayEffectContextHandle& Context)	 // 0x3da09a0;
	void K2_ExecuteGameplayCueWithParams(const struct FGameplayTag& GameplayCueTag, const struct FGameplayCueParameters& GameplayCueParameters)	 // 0x1723ac4;
	void K2_OnEndAbility(bool bWasCancelled)	 // 0xae1e64;
	void K2_RemoveGameplayCue(const struct FGameplayTag& GameplayCueTag)	 // 0x17e2530;
	struct FGameplayAbilityTargetingLocationInfo MakeTargetLocationInfoFromOwnerActor()	 // 0x3da11ac;
	struct FGameplayAbilityTargetingLocationInfo MakeTargetLocationInfoFromOwnerSkeletalMeshComponent(class FName SocketName)	 // 0x3da1244;
	void MontageJumpToSection(class FName SectionName)	 // 0x3da1364;
	void MontageSetNextSectionName(class FName FromSectionName, class FName ToSectionName)	 // 0x3da1424;
	void MontageStop(float OverrideBlendOutTime)	 // 0x3da1594;
	void RemoveGrantedByEffect()	 // 0x3da331c;
	void SendGameplayEvent(const struct FGameplayTag& EventTag, const struct FGameplayEventData& Payload)	 // 0x1364820;
	void SetCanBeCanceled(bool bCanBeCanceled)	 // 0x3da36e0;
	void SetShouldBlockOtherAbilities(bool bShouldBlockAbilities)	 // 0x3da39a8;

	int32 GetAbilityLevel() const	 // 0x3d9c978;
	int32 GetAbilityLevel_BP(const struct FGameplayAbilitySpecHandle& Handle, const struct FGameplayAbilityActorInfo& ActorInfo) const	 // 0x3d9c99c;
	class UAbilitySystemComponent* GetAbilitySystemComponentFromActorInfo() const	 // 0x3d9cac4;
	struct FGameplayAbilityActorInfo GetActorInfo() const	 // 0xd91350;
	class AActor* GetAvatarActorFromActorInfo() const	 // 0x3d9d8ac;
	struct FGameplayEffectContextHandle GetContextFromOwner(const struct FGameplayAbilityTargetDataHandle& OptionalTargetData) const	 // 0x3d9d8d0;
	float GetCooldownTimeRemaining() const	 // 0x3d9da04;
	class UAnimMontage* GetCurrentMontage() const	 // 0x3d9da2c;
	class UObject* GetCurrentSourceObject() const	 // 0x3d9da44;
	struct FGameplayEffectContextHandle GetGrantedByEffectContext() const	 // 0x3d9e9a0;
	class AActor* GetOwningActorFromActorInfo() const	 // 0x3d9f42c;
	class USkeletalMeshComponent* GetOwningComponentFromActorInfo() const	 // 0x3d9f450;
	class UObject* GetSourceObject_BP(const struct FGameplayAbilitySpecHandle& Handle, const struct FGameplayAbilityActorInfo& ActorInfo) const	 // 0x3d9f488;
	void InvalidateClientPredictionKey() const	 // 0x3d9fcac;
	bool IsLocallyControlled() const	 // 0x17f9208;
	bool K2_CanActivateAbility(const struct FGameplayAbilityActorInfo& ActorInfo, const struct FGameplayAbilitySpecHandle& Handle, struct FGameplayTagContainer* RelevantTags) const	 // 0xae1e64;
	bool K2_HasAuthority() const	 // 0x180c644;
	bool K2_ShouldAbilityRespondToEvent(const struct FGameplayAbilityActorInfo& ActorInfo, const struct FGameplayEventData& Payload) const	 // 0xae1e64;
	struct FGameplayEffectSpecHandle MakeOutgoingGameplayEffectSpec(TSubclassOf<class UGameplayEffect> GameplayEffectClass, float Level) const	 // 0x3da0d14;

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"GameplayAbility">();
	}
	static class UGameplayAbility* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UGameplayAbility>();
	}
};
static_assert(alignof(UGameplayAbility) == 0x000008, "Wrong alignment on UGameplayAbility");
static_assert(sizeof(UGameplayAbility) == 0x0003B8, "Wrong size on UGameplayAbility");
static_assert(offsetof(UGameplayAbility, AbilityTags) == 0x0000A8, "Member 'UGameplayAbility::AbilityTags' has a wrong offset!");
static_assert(offsetof(UGameplayAbility, bReplicateInputDirectly) == 0x0000C8, "Member 'UGameplayAbility::bReplicateInputDirectly' has a wrong offset!");
static_assert(offsetof(UGameplayAbility, RemoteInstanceEnded) == 0x0000C9, "Member 'UGameplayAbility::RemoteInstanceEnded' has a wrong offset!");
static_assert(offsetof(UGameplayAbility, ReplicationPolicy) == 0x0000CE, "Member 'UGameplayAbility::ReplicationPolicy' has a wrong offset!");
static_assert(offsetof(UGameplayAbility, InstancingPolicy) == 0x0000CF, "Member 'UGameplayAbility::InstancingPolicy' has a wrong offset!");
static_assert(offsetof(UGameplayAbility, bServerRespectsRemoteAbilityCancellation) == 0x0000D0, "Member 'UGameplayAbility::bServerRespectsRemoteAbilityCancellation' has a wrong offset!");
static_assert(offsetof(UGameplayAbility, bRetriggerInstancedAbility) == 0x0000D1, "Member 'UGameplayAbility::bRetriggerInstancedAbility' has a wrong offset!");
static_assert(offsetof(UGameplayAbility, CurrentActivationInfo) == 0x0000D8, "Member 'UGameplayAbility::CurrentActivationInfo' has a wrong offset!");
static_assert(offsetof(UGameplayAbility, CurrentEventData) == 0x0000F8, "Member 'UGameplayAbility::CurrentEventData' has a wrong offset!");
static_assert(offsetof(UGameplayAbility, NetExecutionPolicy) == 0x0001A8, "Member 'UGameplayAbility::NetExecutionPolicy' has a wrong offset!");
static_assert(offsetof(UGameplayAbility, NetSecurityPolicy) == 0x0001A9, "Member 'UGameplayAbility::NetSecurityPolicy' has a wrong offset!");
static_assert(offsetof(UGameplayAbility, CostGameplayEffectClass) == 0x0001B0, "Member 'UGameplayAbility::CostGameplayEffectClass' has a wrong offset!");
static_assert(offsetof(UGameplayAbility, AbilityTriggers) == 0x0001B8, "Member 'UGameplayAbility::AbilityTriggers' has a wrong offset!");
static_assert(offsetof(UGameplayAbility, CooldownGameplayEffectClass) == 0x0001C8, "Member 'UGameplayAbility::CooldownGameplayEffectClass' has a wrong offset!");
static_assert(offsetof(UGameplayAbility, CancelAbilitiesWithTag) == 0x0001D0, "Member 'UGameplayAbility::CancelAbilitiesWithTag' has a wrong offset!");
static_assert(offsetof(UGameplayAbility, BlockAbilitiesWithTag) == 0x0001F0, "Member 'UGameplayAbility::BlockAbilitiesWithTag' has a wrong offset!");
static_assert(offsetof(UGameplayAbility, ActivationOwnedTags) == 0x000210, "Member 'UGameplayAbility::ActivationOwnedTags' has a wrong offset!");
static_assert(offsetof(UGameplayAbility, ActivationRequiredTags) == 0x000230, "Member 'UGameplayAbility::ActivationRequiredTags' has a wrong offset!");
static_assert(offsetof(UGameplayAbility, ActivationBlockedTags) == 0x000250, "Member 'UGameplayAbility::ActivationBlockedTags' has a wrong offset!");
static_assert(offsetof(UGameplayAbility, SourceRequiredTags) == 0x000270, "Member 'UGameplayAbility::SourceRequiredTags' has a wrong offset!");
static_assert(offsetof(UGameplayAbility, SourceBlockedTags) == 0x000290, "Member 'UGameplayAbility::SourceBlockedTags' has a wrong offset!");
static_assert(offsetof(UGameplayAbility, TargetRequiredTags) == 0x0002B0, "Member 'UGameplayAbility::TargetRequiredTags' has a wrong offset!");
static_assert(offsetof(UGameplayAbility, TargetBlockedTags) == 0x0002D0, "Member 'UGameplayAbility::TargetBlockedTags' has a wrong offset!");
static_assert(offsetof(UGameplayAbility, ActiveTasks) == 0x000310, "Member 'UGameplayAbility::ActiveTasks' has a wrong offset!");
static_assert(offsetof(UGameplayAbility, CurrentMontage) == 0x000330, "Member 'UGameplayAbility::CurrentMontage' has a wrong offset!");
static_assert(offsetof(UGameplayAbility, bIsActive) == 0x000398, "Member 'UGameplayAbility::bIsActive' has a wrong offset!");
static_assert(offsetof(UGameplayAbility, bIsAbilityEnding) == 0x000399, "Member 'UGameplayAbility::bIsAbilityEnding' has a wrong offset!");
static_assert(offsetof(UGameplayAbility, bIsCancelable) == 0x00039A, "Member 'UGameplayAbility::bIsCancelable' has a wrong offset!");
static_assert(offsetof(UGameplayAbility, bIsBlockingOtherAbilities) == 0x00039B, "Member 'UGameplayAbility::bIsBlockingOtherAbilities' has a wrong offset!");
static_assert(offsetof(UGameplayAbility, bMarkPendingKillOnAbilityEnd) == 0x0003B0, "Member 'UGameplayAbility::bMarkPendingKillOnAbilityEnd' has a wrong offset!");

// Class GameplayAbilities.AbilitySystemDebugHUD
// 0x0000 (0x03A0 - 0x03A0)
class AAbilitySystemDebugHUD final : public AHUD
{
public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"AbilitySystemDebugHUD">();
	}
	static class AAbilitySystemDebugHUD* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<AAbilitySystemDebugHUD>();
	}
};
static_assert(alignof(AAbilitySystemDebugHUD) == 0x000008, "Wrong alignment on AAbilitySystemDebugHUD");
static_assert(sizeof(AAbilitySystemDebugHUD) == 0x0003A0, "Wrong size on AAbilitySystemDebugHUD");

// Class GameplayAbilities.AbilityAsync_WaitGameplayTag
// 0x0018 (0x0050 - 0x0038)
class UAbilityAsync_WaitGameplayTag : public UAbilityAsync
{
public:
	uint8                                         Pad_38[0x18];                                      // 0x0038(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"AbilityAsync_WaitGameplayTag">();
	}
	static class UAbilityAsync_WaitGameplayTag* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UAbilityAsync_WaitGameplayTag>();
	}
};
static_assert(alignof(UAbilityAsync_WaitGameplayTag) == 0x000008, "Wrong alignment on UAbilityAsync_WaitGameplayTag");
static_assert(sizeof(UAbilityAsync_WaitGameplayTag) == 0x000050, "Wrong size on UAbilityAsync_WaitGameplayTag");

// Class GameplayAbilities.AbilityTask
// 0x0018 (0x0080 - 0x0068)
class UAbilityTask : public UGameplayTask
{
public:
	class UGameplayAbility*                       Ability;                                           // 0x0068(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TWeakObjectPtr<class UAbilitySystemComponent> AbilitySystemComponent;                            // 0x0070(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_78[0x8];                                       // 0x0078(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"AbilityTask">();
	}
	static class UAbilityTask* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UAbilityTask>();
	}
};
static_assert(alignof(UAbilityTask) == 0x000008, "Wrong alignment on UAbilityTask");
static_assert(sizeof(UAbilityTask) == 0x000080, "Wrong size on UAbilityTask");
static_assert(offsetof(UAbilityTask, Ability) == 0x000068, "Member 'UAbilityTask::Ability' has a wrong offset!");
static_assert(offsetof(UAbilityTask, AbilitySystemComponent) == 0x000070, "Member 'UAbilityTask::AbilitySystemComponent' has a wrong offset!");

// Class GameplayAbilities.AbilityTask_WaitTargetData
// 0x0040 (0x00C0 - 0x0080)
class UAbilityTask_WaitTargetData final : public UAbilityTask
{
public:
	TMulticastInlineDelegate<void(const struct FGameplayAbilityTargetDataHandle& Data)> ValidData;   // 0x0080(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(const struct FGameplayAbilityTargetDataHandle& Data)> Cancelled;   // 0x0090(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TSubclassOf<class AGameplayAbilityTargetActor> TargetClass;                                      // 0x00A0(0x0008)(ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class AGameplayAbilityTargetActor*            TargetActor;                                       // 0x00A8(0x0008)(ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_B0[0x10];                                      // 0x00B0(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UAbilityTask_WaitTargetData* WaitTargetData(class UGameplayAbility* OwningAbility, class FName TaskInstanceName, EGameplayTargetingConfirmation ConfirmationType, TSubclassOf<class AGameplayAbilityTargetActor> Class_0)	 // 0x3daa4dc;
	static class UAbilityTask_WaitTargetData* WaitTargetDataUsingActor(class UGameplayAbility* OwningAbility, class FName TaskInstanceName, EGameplayTargetingConfirmation ConfirmationType, class AGameplayAbilityTargetActor* TargetActor_0)	 // 0x3daa728;

	bool BeginSpawningActor(class UGameplayAbility* OwningAbility, TSubclassOf<class AGameplayAbilityTargetActor> Class_0, class AGameplayAbilityTargetActor** SpawnedActor)	 // 0x3d98b54;
	void FinishSpawningActor(class UGameplayAbility* OwningAbility, class AGameplayAbilityTargetActor* SpawnedActor)	 // 0x3d9c4dc;
	void OnTargetDataCancelledCallback(const struct FGameplayAbilityTargetDataHandle& Data)	 // 0x3da2fd0;
	void OnTargetDataReadyCallback(const struct FGameplayAbilityTargetDataHandle& Data)	 // 0x3da3094;
	void OnTargetDataReplicatedCallback(const struct FGameplayAbilityTargetDataHandle& Data, const struct FGameplayTag& ActivationTag)	 // 0x3da3158;
	void OnTargetDataReplicatedCancelledCallback()	 // 0x3da3308;

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"AbilityTask_WaitTargetData">();
	}
	static class UAbilityTask_WaitTargetData* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UAbilityTask_WaitTargetData>();
	}
};
static_assert(alignof(UAbilityTask_WaitTargetData) == 0x000008, "Wrong alignment on UAbilityTask_WaitTargetData");
static_assert(sizeof(UAbilityTask_WaitTargetData) == 0x0000C0, "Wrong size on UAbilityTask_WaitTargetData");
static_assert(offsetof(UAbilityTask_WaitTargetData, ValidData) == 0x000080, "Member 'UAbilityTask_WaitTargetData::ValidData' has a wrong offset!");
static_assert(offsetof(UAbilityTask_WaitTargetData, Cancelled) == 0x000090, "Member 'UAbilityTask_WaitTargetData::Cancelled' has a wrong offset!");
static_assert(offsetof(UAbilityTask_WaitTargetData, TargetClass) == 0x0000A0, "Member 'UAbilityTask_WaitTargetData::TargetClass' has a wrong offset!");
static_assert(offsetof(UAbilityTask_WaitTargetData, TargetActor) == 0x0000A8, "Member 'UAbilityTask_WaitTargetData::TargetActor' has a wrong offset!");

// Class GameplayAbilities.GameplayEffectUIData
// 0x0000 (0x0028 - 0x0028)
class UGameplayEffectUIData : public UObject
{
public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"GameplayEffectUIData">();
	}
	static class UGameplayEffectUIData* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UGameplayEffectUIData>();
	}
};
static_assert(alignof(UGameplayEffectUIData) == 0x000008, "Wrong alignment on UGameplayEffectUIData");
static_assert(sizeof(UGameplayEffectUIData) == 0x000028, "Wrong size on UGameplayEffectUIData");

// Class GameplayAbilities.AbilityTask_WaitVelocityChange
// 0x0038 (0x00B8 - 0x0080)
class UAbilityTask_WaitVelocityChange final : public UAbilityTask
{
public:
	TMulticastInlineDelegate<void()>              OnVelocityChage;                                   // 0x0080(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	class UMovementComponent*                     CachedMovementComponent;                           // 0x0090(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_98[0x20];                                      // 0x0098(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UAbilityTask_WaitVelocityChange* CreateWaitVelocityChange(class UGameplayAbility* OwningAbility, const struct FVector& Direction, float MinimumMagnitude)	 // 0x3d99704;

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"AbilityTask_WaitVelocityChange">();
	}
	static class UAbilityTask_WaitVelocityChange* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UAbilityTask_WaitVelocityChange>();
	}
};
static_assert(alignof(UAbilityTask_WaitVelocityChange) == 0x000008, "Wrong alignment on UAbilityTask_WaitVelocityChange");
static_assert(sizeof(UAbilityTask_WaitVelocityChange) == 0x0000B8, "Wrong size on UAbilityTask_WaitVelocityChange");
static_assert(offsetof(UAbilityTask_WaitVelocityChange, OnVelocityChage) == 0x000080, "Member 'UAbilityTask_WaitVelocityChange::OnVelocityChage' has a wrong offset!");
static_assert(offsetof(UAbilityTask_WaitVelocityChange, CachedMovementComponent) == 0x000090, "Member 'UAbilityTask_WaitVelocityChange::CachedMovementComponent' has a wrong offset!");

// Class GameplayAbilities.GameplayEffectUIData_TextOnly
// 0x0018 (0x0040 - 0x0028)
class UGameplayEffectUIData_TextOnly final : public UGameplayEffectUIData
{
public:
	class FText                                   Description;                                       // 0x0028(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"GameplayEffectUIData_TextOnly">();
	}
	static class UGameplayEffectUIData_TextOnly* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UGameplayEffectUIData_TextOnly>();
	}
};
static_assert(alignof(UGameplayEffectUIData_TextOnly) == 0x000008, "Wrong alignment on UGameplayEffectUIData_TextOnly");
static_assert(sizeof(UGameplayEffectUIData_TextOnly) == 0x000040, "Wrong size on UGameplayEffectUIData_TextOnly");
static_assert(offsetof(UGameplayEffectUIData_TextOnly, Description) == 0x000028, "Member 'UGameplayEffectUIData_TextOnly::Description' has a wrong offset!");

// Class GameplayAbilities.AbilityAsync_WaitAttributeChanged
// 0x0058 (0x0090 - 0x0038)
class UAbilityAsync_WaitAttributeChanged final : public UAbilityAsync
{
public:
	TMulticastInlineDelegate<void(const struct FGameplayAttribute& Attribute, float NewValue, float OldValue)> Changed; // 0x0038(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_48[0x48];                                      // 0x0048(0x0048)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UAbilityAsync_WaitAttributeChanged* WaitForAttributeChanged(class AActor* TargetActor, const struct FGameplayAttribute& Attribute, bool OnlyTriggerOnce)	 // 0x3da7078;

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"AbilityAsync_WaitAttributeChanged">();
	}
	static class UAbilityAsync_WaitAttributeChanged* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UAbilityAsync_WaitAttributeChanged>();
	}
};
static_assert(alignof(UAbilityAsync_WaitAttributeChanged) == 0x000008, "Wrong alignment on UAbilityAsync_WaitAttributeChanged");
static_assert(sizeof(UAbilityAsync_WaitAttributeChanged) == 0x000090, "Wrong size on UAbilityAsync_WaitAttributeChanged");
static_assert(offsetof(UAbilityAsync_WaitAttributeChanged, Changed) == 0x000038, "Member 'UAbilityAsync_WaitAttributeChanged::Changed' has a wrong offset!");

// Class GameplayAbilities.AbilityAsync_WaitGameplayEffectApplied
// 0x00C0 (0x00F8 - 0x0038)
class UAbilityAsync_WaitGameplayEffectApplied final : public UAbilityAsync
{
public:
	TMulticastInlineDelegate<void(class AActor* Source, const struct FGameplayEffectSpecHandle& SpecHandle, const struct FActiveGameplayEffectHandle& ActiveHandle)> OnApplied; // 0x0038(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_48[0xB0];                                      // 0x0048(0x00B0)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UAbilityAsync_WaitGameplayEffectApplied* WaitGameplayEffectAppliedToActor(class AActor* TargetActor, const struct FGameplayTargetDataFilterHandle& SourceFilter, const struct FGameplayTagRequirements& SourceTagRequirements, const struct FGameplayTagRequirements& TargetTagRequirements, bool TriggerOnce, bool ListenForPeriodicEffect)	 // 0x3da7694;

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"AbilityAsync_WaitGameplayEffectApplied">();
	}
	static class UAbilityAsync_WaitGameplayEffectApplied* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UAbilityAsync_WaitGameplayEffectApplied>();
	}
};
static_assert(alignof(UAbilityAsync_WaitGameplayEffectApplied) == 0x000008, "Wrong alignment on UAbilityAsync_WaitGameplayEffectApplied");
static_assert(sizeof(UAbilityAsync_WaitGameplayEffectApplied) == 0x0000F8, "Wrong size on UAbilityAsync_WaitGameplayEffectApplied");
static_assert(offsetof(UAbilityAsync_WaitGameplayEffectApplied, OnApplied) == 0x000038, "Member 'UAbilityAsync_WaitGameplayEffectApplied::OnApplied' has a wrong offset!");

// Class GameplayAbilities.AbilityAsync_WaitGameplayEvent
// 0x0028 (0x0060 - 0x0038)
class UAbilityAsync_WaitGameplayEvent final : public UAbilityAsync
{
public:
	TMulticastInlineDelegate<void(const struct FGameplayEventData& Payload)> EventReceived;          // 0x0038(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_48[0x18];                                      // 0x0048(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UAbilityAsync_WaitGameplayEvent* WaitGameplayEventToActor(class AActor* TargetActor, const struct FGameplayTag& EventTag, bool OnlyTriggerOnce, bool OnlyMatchExact)	 // 0x162e0f4;

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"AbilityAsync_WaitGameplayEvent">();
	}
	static class UAbilityAsync_WaitGameplayEvent* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UAbilityAsync_WaitGameplayEvent>();
	}
};
static_assert(alignof(UAbilityAsync_WaitGameplayEvent) == 0x000008, "Wrong alignment on UAbilityAsync_WaitGameplayEvent");
static_assert(sizeof(UAbilityAsync_WaitGameplayEvent) == 0x000060, "Wrong size on UAbilityAsync_WaitGameplayEvent");
static_assert(offsetof(UAbilityAsync_WaitGameplayEvent, EventReceived) == 0x000038, "Member 'UAbilityAsync_WaitGameplayEvent::EventReceived' has a wrong offset!");

// Class GameplayAbilities.AbilityAsync_WaitGameplayTagAdded
// 0x0010 (0x0060 - 0x0050)
class UAbilityAsync_WaitGameplayTagAdded final : public UAbilityAsync_WaitGameplayTag
{
public:
	TMulticastInlineDelegate<void()>              Added;                                             // 0x0050(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)

public:
	static class UAbilityAsync_WaitGameplayTagAdded* WaitGameplayTagAddToActor(class AActor* TargetActor, const struct FGameplayTag& Tag, bool OnlyTriggerOnce)	 // 0x3da96f4;

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"AbilityAsync_WaitGameplayTagAdded">();
	}
	static class UAbilityAsync_WaitGameplayTagAdded* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UAbilityAsync_WaitGameplayTagAdded>();
	}
};
static_assert(alignof(UAbilityAsync_WaitGameplayTagAdded) == 0x000008, "Wrong alignment on UAbilityAsync_WaitGameplayTagAdded");
static_assert(sizeof(UAbilityAsync_WaitGameplayTagAdded) == 0x000060, "Wrong size on UAbilityAsync_WaitGameplayTagAdded");
static_assert(offsetof(UAbilityAsync_WaitGameplayTagAdded, Added) == 0x000050, "Member 'UAbilityAsync_WaitGameplayTagAdded::Added' has a wrong offset!");

// Class GameplayAbilities.AbilityAsync_WaitGameplayTagRemoved
// 0x0010 (0x0060 - 0x0050)
class UAbilityAsync_WaitGameplayTagRemoved final : public UAbilityAsync_WaitGameplayTag
{
public:
	TMulticastInlineDelegate<void()>              Removed;                                           // 0x0050(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)

public:
	static class UAbilityAsync_WaitGameplayTagRemoved* WaitGameplayTagRemoveFromActor(class AActor* TargetActor, const struct FGameplayTag& Tag, bool OnlyTriggerOnce)	 // 0x3da9ef4;

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"AbilityAsync_WaitGameplayTagRemoved">();
	}
	static class UAbilityAsync_WaitGameplayTagRemoved* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UAbilityAsync_WaitGameplayTagRemoved>();
	}
};
static_assert(alignof(UAbilityAsync_WaitGameplayTagRemoved) == 0x000008, "Wrong alignment on UAbilityAsync_WaitGameplayTagRemoved");
static_assert(sizeof(UAbilityAsync_WaitGameplayTagRemoved) == 0x000060, "Wrong size on UAbilityAsync_WaitGameplayTagRemoved");
static_assert(offsetof(UAbilityAsync_WaitGameplayTagRemoved, Removed) == 0x000050, "Member 'UAbilityAsync_WaitGameplayTagRemoved::Removed' has a wrong offset!");

// Class GameplayAbilities.AbilityAsync_WaitGameplayTagQuery
// 0x00D0 (0x0108 - 0x0038)
class UAbilityAsync_WaitGameplayTagQuery final : public UAbilityAsync
{
public:
	uint8                                         Pad_38[0xC0];                                      // 0x0038(0x00C0)(Fixing Size After Last Property [ Dumper-7 ])
	TMulticastInlineDelegate<void()>              Triggered;                                         // 0x00F8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, Protected, NativeAccessSpecifierProtected)

public:
	static class UAbilityAsync_WaitGameplayTagQuery* WaitGameplayTagQueryOnActor(class AActor* TargetActor, const struct FGameplayTagQuery& TagQuery, const EWaitGameplayTagQueryTriggerCondition TriggerCondition, const bool bOnlyTriggerOnce)	 // 0x3da9c04;

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"AbilityAsync_WaitGameplayTagQuery">();
	}
	static class UAbilityAsync_WaitGameplayTagQuery* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UAbilityAsync_WaitGameplayTagQuery>();
	}
};
static_assert(alignof(UAbilityAsync_WaitGameplayTagQuery) == 0x000008, "Wrong alignment on UAbilityAsync_WaitGameplayTagQuery");
static_assert(sizeof(UAbilityAsync_WaitGameplayTagQuery) == 0x000108, "Wrong size on UAbilityAsync_WaitGameplayTagQuery");
static_assert(offsetof(UAbilityAsync_WaitGameplayTagQuery, Triggered) == 0x0000F8, "Member 'UAbilityAsync_WaitGameplayTagQuery::Triggered' has a wrong offset!");

// Class GameplayAbilities.GameplayAbilitySet
// 0x0010 (0x0040 - 0x0030)
class UGameplayAbilitySet final : public UDataAsset
{
public:
	TArray<struct FGameplayAbilityBindInfo>       Abilities;                                         // 0x0030(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"GameplayAbilitySet">();
	}
	static class UGameplayAbilitySet* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UGameplayAbilitySet>();
	}
};
static_assert(alignof(UGameplayAbilitySet) == 0x000008, "Wrong alignment on UGameplayAbilitySet");
static_assert(sizeof(UGameplayAbilitySet) == 0x000040, "Wrong size on UGameplayAbilitySet");
static_assert(offsetof(UGameplayAbilitySet, Abilities) == 0x000030, "Member 'UGameplayAbilitySet::Abilities' has a wrong offset!");

// Class GameplayAbilities.GameplayAbilityTargetActor
// 0x0150 (0x0400 - 0x02B0)
class AGameplayAbilityTargetActor : public AActor
{
public:
	bool                                          ShouldProduceTargetDataOnServer;                   // 0x02B0(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2B1[0xF];                                      // 0x02B1(0x000F)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayAbilityTargetingLocationInfo  StartLocation;                                     // 0x02C0(0x00A0)(BlueprintVisible, BlueprintReadOnly, Net, ContainsInstancedReference, ExposeOnSpawn, NativeAccessSpecifierPublic)
	uint8                                         Pad_360[0x30];                                     // 0x0360(0x0030)(Fixing Size After Last Property [ Dumper-7 ])
	class APlayerController*                      PrimaryPC;                                         // 0x0390(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UGameplayAbility*                       OwningAbility;                                     // 0x0398(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDestroyOnConfirmation;                            // 0x03A0(0x0001)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3A1[0x7];                                      // 0x03A1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class AActor*                                 SourceActor;                                       // 0x03A8(0x0008)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FWorldReticleParameters                ReticleParams;                                     // 0x03B0(0x0018)(BlueprintVisible, NoDestructor, ExposeOnSpawn, NativeAccessSpecifierPublic)
	TSubclassOf<class AGameplayAbilityWorldReticle> ReticleClass;                                    // 0x03C8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, ExposeOnSpawn, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTargetDataFilterHandle        Filter;                                            // 0x03D0(0x0010)(BlueprintVisible, Net, ExposeOnSpawn, NativeAccessSpecifierPublic)
	bool                                          bDebug;                                            // 0x03E0(0x0001)(Edit, BlueprintVisible, Net, ZeroConstructor, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3E1[0x17];                                     // 0x03E1(0x0017)(Fixing Size After Last Property [ Dumper-7 ])
	class UAbilitySystemComponent*                GenericDelegateBoundASC;                           // 0x03F8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	void CancelTargeting()	 // 0x3d98ce0;
	void ConfirmTargeting()	 // 0x3d99000;

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"GameplayAbilityTargetActor">();
	}
	static class AGameplayAbilityTargetActor* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<AGameplayAbilityTargetActor>();
	}
};
static_assert(alignof(AGameplayAbilityTargetActor) == 0x000010, "Wrong alignment on AGameplayAbilityTargetActor");
static_assert(sizeof(AGameplayAbilityTargetActor) == 0x000400, "Wrong size on AGameplayAbilityTargetActor");
static_assert(offsetof(AGameplayAbilityTargetActor, ShouldProduceTargetDataOnServer) == 0x0002B0, "Member 'AGameplayAbilityTargetActor::ShouldProduceTargetDataOnServer' has a wrong offset!");
static_assert(offsetof(AGameplayAbilityTargetActor, StartLocation) == 0x0002C0, "Member 'AGameplayAbilityTargetActor::StartLocation' has a wrong offset!");
static_assert(offsetof(AGameplayAbilityTargetActor, PrimaryPC) == 0x000390, "Member 'AGameplayAbilityTargetActor::PrimaryPC' has a wrong offset!");
static_assert(offsetof(AGameplayAbilityTargetActor, OwningAbility) == 0x000398, "Member 'AGameplayAbilityTargetActor::OwningAbility' has a wrong offset!");
static_assert(offsetof(AGameplayAbilityTargetActor, bDestroyOnConfirmation) == 0x0003A0, "Member 'AGameplayAbilityTargetActor::bDestroyOnConfirmation' has a wrong offset!");
static_assert(offsetof(AGameplayAbilityTargetActor, SourceActor) == 0x0003A8, "Member 'AGameplayAbilityTargetActor::SourceActor' has a wrong offset!");
static_assert(offsetof(AGameplayAbilityTargetActor, ReticleParams) == 0x0003B0, "Member 'AGameplayAbilityTargetActor::ReticleParams' has a wrong offset!");
static_assert(offsetof(AGameplayAbilityTargetActor, ReticleClass) == 0x0003C8, "Member 'AGameplayAbilityTargetActor::ReticleClass' has a wrong offset!");
static_assert(offsetof(AGameplayAbilityTargetActor, Filter) == 0x0003D0, "Member 'AGameplayAbilityTargetActor::Filter' has a wrong offset!");
static_assert(offsetof(AGameplayAbilityTargetActor, bDebug) == 0x0003E0, "Member 'AGameplayAbilityTargetActor::bDebug' has a wrong offset!");
static_assert(offsetof(AGameplayAbilityTargetActor, GenericDelegateBoundASC) == 0x0003F8, "Member 'AGameplayAbilityTargetActor::GenericDelegateBoundASC' has a wrong offset!");

// Class GameplayAbilities.GameplayAbilityTargetActor_Trace
// 0x0020 (0x0420 - 0x0400)
#pragma pack(push, 0x1)
class alignas(0x10) AGameplayAbilityTargetActor_Trace : public AGameplayAbilityTargetActor
{
public:
	float                                         MaxRange;                                          // 0x0400(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FCollisionProfileName                  TraceProfile;                                      // 0x0404(0x0008)(Edit, BlueprintVisible, Config, NoDestructor, ExposeOnSpawn, NativeAccessSpecifierPublic)
	bool                                          bTraceAffectsAimPitch;                             // 0x040C(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_40D[0xB];                                      // 0x040D(0x000B)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"GameplayAbilityTargetActor_Trace">();
	}
	static class AGameplayAbilityTargetActor_Trace* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<AGameplayAbilityTargetActor_Trace>();
	}
};
#pragma pack(pop)
static_assert(alignof(AGameplayAbilityTargetActor_Trace) == 0x000010, "Wrong alignment on AGameplayAbilityTargetActor_Trace");
static_assert(sizeof(AGameplayAbilityTargetActor_Trace) == 0x000420, "Wrong size on AGameplayAbilityTargetActor_Trace");
static_assert(offsetof(AGameplayAbilityTargetActor_Trace, MaxRange) == 0x000400, "Member 'AGameplayAbilityTargetActor_Trace::MaxRange' has a wrong offset!");
static_assert(offsetof(AGameplayAbilityTargetActor_Trace, TraceProfile) == 0x000404, "Member 'AGameplayAbilityTargetActor_Trace::TraceProfile' has a wrong offset!");
static_assert(offsetof(AGameplayAbilityTargetActor_Trace, bTraceAffectsAimPitch) == 0x00040C, "Member 'AGameplayAbilityTargetActor_Trace::bTraceAffectsAimPitch' has a wrong offset!");

// Class GameplayAbilities.GameplayAbilityTargetActor_GroundTrace
// 0x0020 (0x0440 - 0x0420)
#pragma pack(push, 0x1)
class alignas(0x10) AGameplayAbilityTargetActor_GroundTrace : public AGameplayAbilityTargetActor_Trace
{
public:
	float                                         CollisionRadius;                                   // 0x0418(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CollisionHeight;                                   // 0x041C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_420[0x18];                                     // 0x0420(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"GameplayAbilityTargetActor_GroundTrace">();
	}
	static class AGameplayAbilityTargetActor_GroundTrace* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<AGameplayAbilityTargetActor_GroundTrace>();
	}
};
#pragma pack(pop)
static_assert(alignof(AGameplayAbilityTargetActor_GroundTrace) == 0x000010, "Wrong alignment on AGameplayAbilityTargetActor_GroundTrace");
static_assert(sizeof(AGameplayAbilityTargetActor_GroundTrace) == 0x000440, "Wrong size on AGameplayAbilityTargetActor_GroundTrace");
static_assert(offsetof(AGameplayAbilityTargetActor_GroundTrace, CollisionRadius) == 0x000418, "Member 'AGameplayAbilityTargetActor_GroundTrace::CollisionRadius' has a wrong offset!");
static_assert(offsetof(AGameplayAbilityTargetActor_GroundTrace, CollisionHeight) == 0x00041C, "Member 'AGameplayAbilityTargetActor_GroundTrace::CollisionHeight' has a wrong offset!");

// Class GameplayAbilities.GameplayAbilityTargetActor_ActorPlacement
// 0x0010 (0x0450 - 0x0440)
class AGameplayAbilityTargetActor_ActorPlacement final : public AGameplayAbilityTargetActor_GroundTrace
{
public:
	TSubclassOf<class UObject>                    PlacedActorClass;                                  // 0x0438(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, ExposeOnSpawn, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMaterialInterface*                     PlacedActorMaterial;                               // 0x0440(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, ExposeOnSpawn, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_448[0x8];                                      // 0x0448(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"GameplayAbilityTargetActor_ActorPlacement">();
	}
	static class AGameplayAbilityTargetActor_ActorPlacement* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<AGameplayAbilityTargetActor_ActorPlacement>();
	}
};
static_assert(alignof(AGameplayAbilityTargetActor_ActorPlacement) == 0x000010, "Wrong alignment on AGameplayAbilityTargetActor_ActorPlacement");
static_assert(sizeof(AGameplayAbilityTargetActor_ActorPlacement) == 0x000450, "Wrong size on AGameplayAbilityTargetActor_ActorPlacement");
static_assert(offsetof(AGameplayAbilityTargetActor_ActorPlacement, PlacedActorClass) == 0x000438, "Member 'AGameplayAbilityTargetActor_ActorPlacement::PlacedActorClass' has a wrong offset!");
static_assert(offsetof(AGameplayAbilityTargetActor_ActorPlacement, PlacedActorMaterial) == 0x000440, "Member 'AGameplayAbilityTargetActor_ActorPlacement::PlacedActorMaterial' has a wrong offset!");

// Class GameplayAbilities.GameplayAbilityTargetActor_Radius
// 0x0010 (0x0410 - 0x0400)
class AGameplayAbilityTargetActor_Radius final : public AGameplayAbilityTargetActor
{
public:
	float                                         Radius;                                            // 0x0400(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_404[0xC];                                      // 0x0404(0x000C)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"GameplayAbilityTargetActor_Radius">();
	}
	static class AGameplayAbilityTargetActor_Radius* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<AGameplayAbilityTargetActor_Radius>();
	}
};
static_assert(alignof(AGameplayAbilityTargetActor_Radius) == 0x000010, "Wrong alignment on AGameplayAbilityTargetActor_Radius");
static_assert(sizeof(AGameplayAbilityTargetActor_Radius) == 0x000410, "Wrong size on AGameplayAbilityTargetActor_Radius");
static_assert(offsetof(AGameplayAbilityTargetActor_Radius, Radius) == 0x000400, "Member 'AGameplayAbilityTargetActor_Radius::Radius' has a wrong offset!");

// Class GameplayAbilities.GameplayAbilityTargetActor_SingleLineTrace
// 0x0000 (0x0420 - 0x0420)
class AGameplayAbilityTargetActor_SingleLineTrace final : public AGameplayAbilityTargetActor_Trace
{
public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"GameplayAbilityTargetActor_SingleLineTrace">();
	}
	static class AGameplayAbilityTargetActor_SingleLineTrace* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<AGameplayAbilityTargetActor_SingleLineTrace>();
	}
};
static_assert(alignof(AGameplayAbilityTargetActor_SingleLineTrace) == 0x000010, "Wrong alignment on AGameplayAbilityTargetActor_SingleLineTrace");
static_assert(sizeof(AGameplayAbilityTargetActor_SingleLineTrace) == 0x000420, "Wrong size on AGameplayAbilityTargetActor_SingleLineTrace");

// Class GameplayAbilities.GameplayAbilityWorldReticle
// 0x0030 (0x02E0 - 0x02B0)
class AGameplayAbilityWorldReticle : public AActor
{
public:
	struct FWorldReticleParameters                Parameters;                                        // 0x02B0(0x0018)(Edit, BlueprintVisible, DisableEditOnTemplate, NoDestructor, ExposeOnSpawn, NativeAccessSpecifierPublic)
	bool                                          bFaceOwnerFlat;                                    // 0x02C8(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bSnapToTargetedActor;                              // 0x02C9(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsTargetValid;                                    // 0x02CA(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIsTargetAnActor;                                  // 0x02CB(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2CC[0x4];                                      // 0x02CC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class APlayerController*                      PrimaryPC;                                         // 0x02D0(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class AActor*                                 TargetingActor;                                    // 0x02D8(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void FaceTowardSource(bool bFaceIn2D)	 // 0x3d9bcc8;
	void OnParametersInitialized()	 // 0xae1e64;
	void OnTargetingAnActor(bool bNewValue)	 // 0xae1e64;
	void OnValidTargetChanged(bool bNewValue)	 // 0xae1e64;
	void SetReticleMaterialParamFloat(class FName ParamName, float Value)	 // 0xae1e64;
	void SetReticleMaterialParamVector(class FName ParamName, const struct FVector& Value)	 // 0xae1e64;

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"GameplayAbilityWorldReticle">();
	}
	static class AGameplayAbilityWorldReticle* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<AGameplayAbilityWorldReticle>();
	}
};
static_assert(alignof(AGameplayAbilityWorldReticle) == 0x000008, "Wrong alignment on AGameplayAbilityWorldReticle");
static_assert(sizeof(AGameplayAbilityWorldReticle) == 0x0002E0, "Wrong size on AGameplayAbilityWorldReticle");
static_assert(offsetof(AGameplayAbilityWorldReticle, Parameters) == 0x0002B0, "Member 'AGameplayAbilityWorldReticle::Parameters' has a wrong offset!");
static_assert(offsetof(AGameplayAbilityWorldReticle, bFaceOwnerFlat) == 0x0002C8, "Member 'AGameplayAbilityWorldReticle::bFaceOwnerFlat' has a wrong offset!");
static_assert(offsetof(AGameplayAbilityWorldReticle, bSnapToTargetedActor) == 0x0002C9, "Member 'AGameplayAbilityWorldReticle::bSnapToTargetedActor' has a wrong offset!");
static_assert(offsetof(AGameplayAbilityWorldReticle, bIsTargetValid) == 0x0002CA, "Member 'AGameplayAbilityWorldReticle::bIsTargetValid' has a wrong offset!");
static_assert(offsetof(AGameplayAbilityWorldReticle, bIsTargetAnActor) == 0x0002CB, "Member 'AGameplayAbilityWorldReticle::bIsTargetAnActor' has a wrong offset!");
static_assert(offsetof(AGameplayAbilityWorldReticle, PrimaryPC) == 0x0002D0, "Member 'AGameplayAbilityWorldReticle::PrimaryPC' has a wrong offset!");
static_assert(offsetof(AGameplayAbilityWorldReticle, TargetingActor) == 0x0002D8, "Member 'AGameplayAbilityWorldReticle::TargetingActor' has a wrong offset!");

// Class GameplayAbilities.GameplayAbilityWorldReticle_ActorVisualization
// 0x0018 (0x02F8 - 0x02E0)
class AGameplayAbilityWorldReticle_ActorVisualization final : public AGameplayAbilityWorldReticle
{
public:
	class UCapsuleComponent*                      CollisionComponent;                                // 0x02E0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<class UActorComponent*>                VisualizationComponents;                           // 0x02E8(0x0010)(ExportObject, ZeroConstructor, ContainsInstancedReference, UObjectWrapper, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"GameplayAbilityWorldReticle_ActorVisualization">();
	}
	static class AGameplayAbilityWorldReticle_ActorVisualization* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<AGameplayAbilityWorldReticle_ActorVisualization>();
	}
};
static_assert(alignof(AGameplayAbilityWorldReticle_ActorVisualization) == 0x000008, "Wrong alignment on AGameplayAbilityWorldReticle_ActorVisualization");
static_assert(sizeof(AGameplayAbilityWorldReticle_ActorVisualization) == 0x0002F8, "Wrong size on AGameplayAbilityWorldReticle_ActorVisualization");
static_assert(offsetof(AGameplayAbilityWorldReticle_ActorVisualization, CollisionComponent) == 0x0002E0, "Member 'AGameplayAbilityWorldReticle_ActorVisualization::CollisionComponent' has a wrong offset!");
static_assert(offsetof(AGameplayAbilityWorldReticle_ActorVisualization, VisualizationComponents) == 0x0002E8, "Member 'AGameplayAbilityWorldReticle_ActorVisualization::VisualizationComponents' has a wrong offset!");

// Class GameplayAbilities.GameplayAbility_CharacterJump
// 0x0000 (0x03B8 - 0x03B8)
class UGameplayAbility_CharacterJump final : public UGameplayAbility
{
public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"GameplayAbility_CharacterJump">();
	}
	static class UGameplayAbility_CharacterJump* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UGameplayAbility_CharacterJump>();
	}
};
static_assert(alignof(UGameplayAbility_CharacterJump) == 0x000008, "Wrong alignment on UGameplayAbility_CharacterJump");
static_assert(sizeof(UGameplayAbility_CharacterJump) == 0x0003B8, "Wrong size on UGameplayAbility_CharacterJump");

// Class GameplayAbilities.GameplayAbility_Montage
// 0x0038 (0x03F0 - 0x03B8)
class UGameplayAbility_Montage final : public UGameplayAbility
{
public:
	class UAnimMontage*                           MontageToPlay;                                     // 0x03B8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PlayRate;                                          // 0x03C0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   SectionName;                                       // 0x03C4(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3CC[0x4];                                      // 0x03CC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<TSubclassOf<class UGameplayEffect>>    GameplayEffectClassesWhileAnimating;               // 0x03D0(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, UObjectWrapper, NativeAccessSpecifierPublic)
	TArray<class UGameplayEffect*>                GameplayEffectsWhileAnimating;                     // 0x03E0(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, EditConst, UObjectWrapper, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"GameplayAbility_Montage">();
	}
	static class UGameplayAbility_Montage* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UGameplayAbility_Montage>();
	}
};
static_assert(alignof(UGameplayAbility_Montage) == 0x000008, "Wrong alignment on UGameplayAbility_Montage");
static_assert(sizeof(UGameplayAbility_Montage) == 0x0003F0, "Wrong size on UGameplayAbility_Montage");
static_assert(offsetof(UGameplayAbility_Montage, MontageToPlay) == 0x0003B8, "Member 'UGameplayAbility_Montage::MontageToPlay' has a wrong offset!");
static_assert(offsetof(UGameplayAbility_Montage, PlayRate) == 0x0003C0, "Member 'UGameplayAbility_Montage::PlayRate' has a wrong offset!");
static_assert(offsetof(UGameplayAbility_Montage, SectionName) == 0x0003C4, "Member 'UGameplayAbility_Montage::SectionName' has a wrong offset!");
static_assert(offsetof(UGameplayAbility_Montage, GameplayEffectClassesWhileAnimating) == 0x0003D0, "Member 'UGameplayAbility_Montage::GameplayEffectClassesWhileAnimating' has a wrong offset!");
static_assert(offsetof(UGameplayAbility_Montage, GameplayEffectsWhileAnimating) == 0x0003E0, "Member 'UGameplayAbility_Montage::GameplayEffectsWhileAnimating' has a wrong offset!");

// Class GameplayAbilities.AbilityTask_ApplyRootMotion_Base
// 0x0048 (0x00C8 - 0x0080)
class UAbilityTask_ApplyRootMotion_Base : public UAbilityTask
{
public:
	class FName                                   ForceName;                                         // 0x0080(0x0008)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	ERootMotionFinishVelocityMode                 FinishVelocityMode;                                // 0x0088(0x0001)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_89[0x7];                                       // 0x0089(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                FinishSetVelocity;                                 // 0x0090(0x0018)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         FinishClampVelocity;                               // 0x00A8(0x0004)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_AC[0x4];                                       // 0x00AC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UCharacterMovementComponent*            MovementComponent;                                 // 0x00B0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_B8[0x10];                                      // 0x00B8(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"AbilityTask_ApplyRootMotion_Base">();
	}
	static class UAbilityTask_ApplyRootMotion_Base* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UAbilityTask_ApplyRootMotion_Base>();
	}
};
static_assert(alignof(UAbilityTask_ApplyRootMotion_Base) == 0x000008, "Wrong alignment on UAbilityTask_ApplyRootMotion_Base");
static_assert(sizeof(UAbilityTask_ApplyRootMotion_Base) == 0x0000C8, "Wrong size on UAbilityTask_ApplyRootMotion_Base");
static_assert(offsetof(UAbilityTask_ApplyRootMotion_Base, ForceName) == 0x000080, "Member 'UAbilityTask_ApplyRootMotion_Base::ForceName' has a wrong offset!");
static_assert(offsetof(UAbilityTask_ApplyRootMotion_Base, FinishVelocityMode) == 0x000088, "Member 'UAbilityTask_ApplyRootMotion_Base::FinishVelocityMode' has a wrong offset!");
static_assert(offsetof(UAbilityTask_ApplyRootMotion_Base, FinishSetVelocity) == 0x000090, "Member 'UAbilityTask_ApplyRootMotion_Base::FinishSetVelocity' has a wrong offset!");
static_assert(offsetof(UAbilityTask_ApplyRootMotion_Base, FinishClampVelocity) == 0x0000A8, "Member 'UAbilityTask_ApplyRootMotion_Base::FinishClampVelocity' has a wrong offset!");
static_assert(offsetof(UAbilityTask_ApplyRootMotion_Base, MovementComponent) == 0x0000B0, "Member 'UAbilityTask_ApplyRootMotion_Base::MovementComponent' has a wrong offset!");

// Class GameplayAbilities.AbilityTask_ApplyRootMotionConstantForce
// 0x0048 (0x0110 - 0x00C8)
class UAbilityTask_ApplyRootMotionConstantForce final : public UAbilityTask_ApplyRootMotion_Base
{
public:
	TMulticastInlineDelegate<void()>              OnFinish;                                          // 0x00C8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	struct FVector                                WorldDirection;                                    // 0x00D8(0x0018)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         Strength;                                          // 0x00F0(0x0004)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         Duration;                                          // 0x00F4(0x0004)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIsAdditive;                                       // 0x00F8(0x0001)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_F9[0x7];                                       // 0x00F9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UCurveFloat*                            StrengthOverTime;                                  // 0x0100(0x0008)(Net, ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bEnableGravity;                                    // 0x0108(0x0001)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_109[0x7];                                      // 0x0109(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UAbilityTask_ApplyRootMotionConstantForce* ApplyRootMotionConstantForce(class UGameplayAbility* OwningAbility, class FName TaskInstanceName, const struct FVector& WorldDirection_0, float Strength_0, float Duration_0, bool bIsAdditive_0, class UCurveFloat* StrengthOverTime_0, ERootMotionFinishVelocityMode VelocityOnFinishMode, const struct FVector& SetVelocityOnFinish, float ClampVelocityOnFinish, bool bEnableGravity_0)	 // 0x3d94cb0;

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"AbilityTask_ApplyRootMotionConstantForce">();
	}
	static class UAbilityTask_ApplyRootMotionConstantForce* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UAbilityTask_ApplyRootMotionConstantForce>();
	}
};
static_assert(alignof(UAbilityTask_ApplyRootMotionConstantForce) == 0x000008, "Wrong alignment on UAbilityTask_ApplyRootMotionConstantForce");
static_assert(sizeof(UAbilityTask_ApplyRootMotionConstantForce) == 0x000110, "Wrong size on UAbilityTask_ApplyRootMotionConstantForce");
static_assert(offsetof(UAbilityTask_ApplyRootMotionConstantForce, OnFinish) == 0x0000C8, "Member 'UAbilityTask_ApplyRootMotionConstantForce::OnFinish' has a wrong offset!");
static_assert(offsetof(UAbilityTask_ApplyRootMotionConstantForce, WorldDirection) == 0x0000D8, "Member 'UAbilityTask_ApplyRootMotionConstantForce::WorldDirection' has a wrong offset!");
static_assert(offsetof(UAbilityTask_ApplyRootMotionConstantForce, Strength) == 0x0000F0, "Member 'UAbilityTask_ApplyRootMotionConstantForce::Strength' has a wrong offset!");
static_assert(offsetof(UAbilityTask_ApplyRootMotionConstantForce, Duration) == 0x0000F4, "Member 'UAbilityTask_ApplyRootMotionConstantForce::Duration' has a wrong offset!");
static_assert(offsetof(UAbilityTask_ApplyRootMotionConstantForce, bIsAdditive) == 0x0000F8, "Member 'UAbilityTask_ApplyRootMotionConstantForce::bIsAdditive' has a wrong offset!");
static_assert(offsetof(UAbilityTask_ApplyRootMotionConstantForce, StrengthOverTime) == 0x000100, "Member 'UAbilityTask_ApplyRootMotionConstantForce::StrengthOverTime' has a wrong offset!");
static_assert(offsetof(UAbilityTask_ApplyRootMotionConstantForce, bEnableGravity) == 0x000108, "Member 'UAbilityTask_ApplyRootMotionConstantForce::bEnableGravity' has a wrong offset!");

// Class GameplayAbilities.AbilityTask_ApplyRootMotionJumpForce
// 0x0068 (0x0130 - 0x00C8)
class UAbilityTask_ApplyRootMotionJumpForce final : public UAbilityTask_ApplyRootMotion_Base
{
public:
	TMulticastInlineDelegate<void()>              OnFinish;                                          // 0x00C8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void()>              OnLanded;                                          // 0x00D8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	struct FRotator                               Rotation;                                          // 0x00E8(0x0018)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)
	float                                         Distance;                                          // 0x0100(0x0004)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         Height;                                            // 0x0104(0x0004)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         Duration;                                          // 0x0108(0x0004)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MinimumLandedTriggerTime;                          // 0x010C(0x0004)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bFinishOnLanded;                                   // 0x0110(0x0001)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_111[0x7];                                      // 0x0111(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UCurveVector*                           PathOffsetCurve;                                   // 0x0118(0x0008)(Net, ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCurveFloat*                            TimeMappingCurve;                                  // 0x0120(0x0008)(Net, ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_128[0x8];                                      // 0x0128(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UAbilityTask_ApplyRootMotionJumpForce* ApplyRootMotionJumpForce(class UGameplayAbility* OwningAbility, class FName TaskInstanceName, const struct FRotator& Rotation_0, float Distance_0, float Height_0, float Duration_0, float MinimumLandedTriggerTime_0, bool bFinishOnLanded_0, ERootMotionFinishVelocityMode VelocityOnFinishMode, const struct FVector& SetVelocityOnFinish, float ClampVelocityOnFinish, class UCurveVector* PathOffsetCurve_0, class UCurveFloat* TimeMappingCurve_0)	 // 0x3d95278;

	void Finish()	 // 0x3d9bfc4;
	void OnLandedCallback(const struct FHitResult& Hit)	 // 0x3da28a4;

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"AbilityTask_ApplyRootMotionJumpForce">();
	}
	static class UAbilityTask_ApplyRootMotionJumpForce* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UAbilityTask_ApplyRootMotionJumpForce>();
	}
};
static_assert(alignof(UAbilityTask_ApplyRootMotionJumpForce) == 0x000008, "Wrong alignment on UAbilityTask_ApplyRootMotionJumpForce");
static_assert(sizeof(UAbilityTask_ApplyRootMotionJumpForce) == 0x000130, "Wrong size on UAbilityTask_ApplyRootMotionJumpForce");
static_assert(offsetof(UAbilityTask_ApplyRootMotionJumpForce, OnFinish) == 0x0000C8, "Member 'UAbilityTask_ApplyRootMotionJumpForce::OnFinish' has a wrong offset!");
static_assert(offsetof(UAbilityTask_ApplyRootMotionJumpForce, OnLanded) == 0x0000D8, "Member 'UAbilityTask_ApplyRootMotionJumpForce::OnLanded' has a wrong offset!");
static_assert(offsetof(UAbilityTask_ApplyRootMotionJumpForce, Rotation) == 0x0000E8, "Member 'UAbilityTask_ApplyRootMotionJumpForce::Rotation' has a wrong offset!");
static_assert(offsetof(UAbilityTask_ApplyRootMotionJumpForce, Distance) == 0x000100, "Member 'UAbilityTask_ApplyRootMotionJumpForce::Distance' has a wrong offset!");
static_assert(offsetof(UAbilityTask_ApplyRootMotionJumpForce, Height) == 0x000104, "Member 'UAbilityTask_ApplyRootMotionJumpForce::Height' has a wrong offset!");
static_assert(offsetof(UAbilityTask_ApplyRootMotionJumpForce, Duration) == 0x000108, "Member 'UAbilityTask_ApplyRootMotionJumpForce::Duration' has a wrong offset!");
static_assert(offsetof(UAbilityTask_ApplyRootMotionJumpForce, MinimumLandedTriggerTime) == 0x00010C, "Member 'UAbilityTask_ApplyRootMotionJumpForce::MinimumLandedTriggerTime' has a wrong offset!");
static_assert(offsetof(UAbilityTask_ApplyRootMotionJumpForce, bFinishOnLanded) == 0x000110, "Member 'UAbilityTask_ApplyRootMotionJumpForce::bFinishOnLanded' has a wrong offset!");
static_assert(offsetof(UAbilityTask_ApplyRootMotionJumpForce, PathOffsetCurve) == 0x000118, "Member 'UAbilityTask_ApplyRootMotionJumpForce::PathOffsetCurve' has a wrong offset!");
static_assert(offsetof(UAbilityTask_ApplyRootMotionJumpForce, TimeMappingCurve) == 0x000120, "Member 'UAbilityTask_ApplyRootMotionJumpForce::TimeMappingCurve' has a wrong offset!");

// Class GameplayAbilities.AbilityTask_ApplyRootMotionMoveToActorForce
// 0x00A0 (0x0168 - 0x00C8)
class UAbilityTask_ApplyRootMotionMoveToActorForce final : public UAbilityTask_ApplyRootMotion_Base
{
public:
	TMulticastInlineDelegate<void(bool DestinationReached, bool TimedOut, const struct FVector& FinalTargetLocation)> OnFinished; // 0x00C8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_D8[0x8];                                       // 0x00D8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                StartLocation;                                     // 0x00E0(0x0018)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector                                TargetLocation;                                    // 0x00F8(0x0018)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class AActor*                                 TargetActor;                                       // 0x0110(0x0008)(Net, ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector                                TargetLocationOffset;                              // 0x0118(0x0018)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	ERootMotionMoveToActorTargetOffsetType        OffsetAlignment;                                   // 0x0130(0x0001)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_131[0x3];                                      // 0x0131(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Duration;                                          // 0x0134(0x0004)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bDisableDestinationReachedInterrupt;               // 0x0138(0x0001)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bSetNewMovementMode;                               // 0x0139(0x0001)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EMovementMode                                 NewMovementMode;                                   // 0x013A(0x0001)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bRestrictSpeedToExpected;                          // 0x013B(0x0001)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_13C[0x4];                                      // 0x013C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UCurveVector*                           PathOffsetCurve;                                   // 0x0140(0x0008)(Net, ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCurveFloat*                            TimeMappingCurve;                                  // 0x0148(0x0008)(Net, ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCurveFloat*                            TargetLerpSpeedHorizontalCurve;                    // 0x0150(0x0008)(Net, ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCurveFloat*                            TargetLerpSpeedVerticalCurve;                      // 0x0158(0x0008)(Net, ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_160[0x8];                                      // 0x0160(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UAbilityTask_ApplyRootMotionMoveToActorForce* ApplyRootMotionMoveToActorForce(class UGameplayAbility* OwningAbility, class FName TaskInstanceName, class AActor* TargetActor_0, const struct FVector& TargetLocationOffset_0, ERootMotionMoveToActorTargetOffsetType OffsetAlignment_0, float Duration_0, class UCurveFloat* TargetLerpSpeedHorizontal, class UCurveFloat* TargetLerpSpeedVertical, bool bSetNewMovementMode_0, EMovementMode MovementMode, bool bRestrictSpeedToExpected_0, class UCurveVector* PathOffsetCurve_0, class UCurveFloat* TimeMappingCurve_0, ERootMotionFinishVelocityMode VelocityOnFinishMode, const struct FVector& SetVelocityOnFinish, float ClampVelocityOnFinish, bool bDisableDestinationReachedInterrupt_0)	 // 0x3d95950;
	static class UAbilityTask_ApplyRootMotionMoveToActorForce* ApplyRootMotionMoveToTargetDataActorForce(class UGameplayAbility* OwningAbility, class FName TaskInstanceName, const struct FGameplayAbilityTargetDataHandle& TargetDataHandle, int32 TargetDataIndex, int32 TargetActorIndex, const struct FVector& TargetLocationOffset_0, ERootMotionMoveToActorTargetOffsetType OffsetAlignment_0, float Duration_0, class UCurveFloat* TargetLerpSpeedHorizontal, class UCurveFloat* TargetLerpSpeedVertical, bool bSetNewMovementMode_0, EMovementMode MovementMode, bool bRestrictSpeedToExpected_0, class UCurveVector* PathOffsetCurve_0, class UCurveFloat* TimeMappingCurve_0, ERootMotionFinishVelocityMode VelocityOnFinishMode, const struct FVector& SetVelocityOnFinish, float ClampVelocityOnFinish, bool bDisableDestinationReachedInterrupt_0)	 // 0x3d96818;

	void OnRep_TargetLocation()	 // 0x3da2e48;
	void OnTargetActorSwapped(class AActor* OriginalTarget, class AActor* NewTarget)	 // 0x3da2e80;

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"AbilityTask_ApplyRootMotionMoveToActorForce">();
	}
	static class UAbilityTask_ApplyRootMotionMoveToActorForce* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UAbilityTask_ApplyRootMotionMoveToActorForce>();
	}
};
static_assert(alignof(UAbilityTask_ApplyRootMotionMoveToActorForce) == 0x000008, "Wrong alignment on UAbilityTask_ApplyRootMotionMoveToActorForce");
static_assert(sizeof(UAbilityTask_ApplyRootMotionMoveToActorForce) == 0x000168, "Wrong size on UAbilityTask_ApplyRootMotionMoveToActorForce");
static_assert(offsetof(UAbilityTask_ApplyRootMotionMoveToActorForce, OnFinished) == 0x0000C8, "Member 'UAbilityTask_ApplyRootMotionMoveToActorForce::OnFinished' has a wrong offset!");
static_assert(offsetof(UAbilityTask_ApplyRootMotionMoveToActorForce, StartLocation) == 0x0000E0, "Member 'UAbilityTask_ApplyRootMotionMoveToActorForce::StartLocation' has a wrong offset!");
static_assert(offsetof(UAbilityTask_ApplyRootMotionMoveToActorForce, TargetLocation) == 0x0000F8, "Member 'UAbilityTask_ApplyRootMotionMoveToActorForce::TargetLocation' has a wrong offset!");
static_assert(offsetof(UAbilityTask_ApplyRootMotionMoveToActorForce, TargetActor) == 0x000110, "Member 'UAbilityTask_ApplyRootMotionMoveToActorForce::TargetActor' has a wrong offset!");
static_assert(offsetof(UAbilityTask_ApplyRootMotionMoveToActorForce, TargetLocationOffset) == 0x000118, "Member 'UAbilityTask_ApplyRootMotionMoveToActorForce::TargetLocationOffset' has a wrong offset!");
static_assert(offsetof(UAbilityTask_ApplyRootMotionMoveToActorForce, OffsetAlignment) == 0x000130, "Member 'UAbilityTask_ApplyRootMotionMoveToActorForce::OffsetAlignment' has a wrong offset!");
static_assert(offsetof(UAbilityTask_ApplyRootMotionMoveToActorForce, Duration) == 0x000134, "Member 'UAbilityTask_ApplyRootMotionMoveToActorForce::Duration' has a wrong offset!");
static_assert(offsetof(UAbilityTask_ApplyRootMotionMoveToActorForce, bDisableDestinationReachedInterrupt) == 0x000138, "Member 'UAbilityTask_ApplyRootMotionMoveToActorForce::bDisableDestinationReachedInterrupt' has a wrong offset!");
static_assert(offsetof(UAbilityTask_ApplyRootMotionMoveToActorForce, bSetNewMovementMode) == 0x000139, "Member 'UAbilityTask_ApplyRootMotionMoveToActorForce::bSetNewMovementMode' has a wrong offset!");
static_assert(offsetof(UAbilityTask_ApplyRootMotionMoveToActorForce, NewMovementMode) == 0x00013A, "Member 'UAbilityTask_ApplyRootMotionMoveToActorForce::NewMovementMode' has a wrong offset!");
static_assert(offsetof(UAbilityTask_ApplyRootMotionMoveToActorForce, bRestrictSpeedToExpected) == 0x00013B, "Member 'UAbilityTask_ApplyRootMotionMoveToActorForce::bRestrictSpeedToExpected' has a wrong offset!");
static_assert(offsetof(UAbilityTask_ApplyRootMotionMoveToActorForce, PathOffsetCurve) == 0x000140, "Member 'UAbilityTask_ApplyRootMotionMoveToActorForce::PathOffsetCurve' has a wrong offset!");
static_assert(offsetof(UAbilityTask_ApplyRootMotionMoveToActorForce, TimeMappingCurve) == 0x000148, "Member 'UAbilityTask_ApplyRootMotionMoveToActorForce::TimeMappingCurve' has a wrong offset!");
static_assert(offsetof(UAbilityTask_ApplyRootMotionMoveToActorForce, TargetLerpSpeedHorizontalCurve) == 0x000150, "Member 'UAbilityTask_ApplyRootMotionMoveToActorForce::TargetLerpSpeedHorizontalCurve' has a wrong offset!");
static_assert(offsetof(UAbilityTask_ApplyRootMotionMoveToActorForce, TargetLerpSpeedVerticalCurve) == 0x000158, "Member 'UAbilityTask_ApplyRootMotionMoveToActorForce::TargetLerpSpeedVerticalCurve' has a wrong offset!");

// Class GameplayAbilities.AbilityTask_ApplyRootMotionMoveToForce
// 0x0068 (0x0130 - 0x00C8)
class UAbilityTask_ApplyRootMotionMoveToForce final : public UAbilityTask_ApplyRootMotion_Base
{
public:
	TMulticastInlineDelegate<void()>              OnTimedOut;                                        // 0x00C8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void()>              OnTimedOutAndDestinationReached;                   // 0x00D8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	struct FVector                                StartLocation;                                     // 0x00E8(0x0018)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector                                TargetLocation;                                    // 0x0100(0x0018)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         Duration;                                          // 0x0118(0x0004)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bSetNewMovementMode;                               // 0x011C(0x0001)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EMovementMode                                 NewMovementMode;                                   // 0x011D(0x0001)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bRestrictSpeedToExpected;                          // 0x011E(0x0001)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_11F[0x1];                                      // 0x011F(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	class UCurveVector*                           PathOffsetCurve;                                   // 0x0120(0x0008)(Net, ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_128[0x8];                                      // 0x0128(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UAbilityTask_ApplyRootMotionMoveToForce* ApplyRootMotionMoveToForce(class UGameplayAbility* OwningAbility, class FName TaskInstanceName, const struct FVector& TargetLocation_0, float Duration_0, bool bSetNewMovementMode_0, EMovementMode MovementMode, bool bRestrictSpeedToExpected_0, class UCurveVector* PathOffsetCurve_0, ERootMotionFinishVelocityMode VelocityOnFinishMode, const struct FVector& SetVelocityOnFinish, float ClampVelocityOnFinish)	 // 0x3d96240;

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"AbilityTask_ApplyRootMotionMoveToForce">();
	}
	static class UAbilityTask_ApplyRootMotionMoveToForce* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UAbilityTask_ApplyRootMotionMoveToForce>();
	}
};
static_assert(alignof(UAbilityTask_ApplyRootMotionMoveToForce) == 0x000008, "Wrong alignment on UAbilityTask_ApplyRootMotionMoveToForce");
static_assert(sizeof(UAbilityTask_ApplyRootMotionMoveToForce) == 0x000130, "Wrong size on UAbilityTask_ApplyRootMotionMoveToForce");
static_assert(offsetof(UAbilityTask_ApplyRootMotionMoveToForce, OnTimedOut) == 0x0000C8, "Member 'UAbilityTask_ApplyRootMotionMoveToForce::OnTimedOut' has a wrong offset!");
static_assert(offsetof(UAbilityTask_ApplyRootMotionMoveToForce, OnTimedOutAndDestinationReached) == 0x0000D8, "Member 'UAbilityTask_ApplyRootMotionMoveToForce::OnTimedOutAndDestinationReached' has a wrong offset!");
static_assert(offsetof(UAbilityTask_ApplyRootMotionMoveToForce, StartLocation) == 0x0000E8, "Member 'UAbilityTask_ApplyRootMotionMoveToForce::StartLocation' has a wrong offset!");
static_assert(offsetof(UAbilityTask_ApplyRootMotionMoveToForce, TargetLocation) == 0x000100, "Member 'UAbilityTask_ApplyRootMotionMoveToForce::TargetLocation' has a wrong offset!");
static_assert(offsetof(UAbilityTask_ApplyRootMotionMoveToForce, Duration) == 0x000118, "Member 'UAbilityTask_ApplyRootMotionMoveToForce::Duration' has a wrong offset!");
static_assert(offsetof(UAbilityTask_ApplyRootMotionMoveToForce, bSetNewMovementMode) == 0x00011C, "Member 'UAbilityTask_ApplyRootMotionMoveToForce::bSetNewMovementMode' has a wrong offset!");
static_assert(offsetof(UAbilityTask_ApplyRootMotionMoveToForce, NewMovementMode) == 0x00011D, "Member 'UAbilityTask_ApplyRootMotionMoveToForce::NewMovementMode' has a wrong offset!");
static_assert(offsetof(UAbilityTask_ApplyRootMotionMoveToForce, bRestrictSpeedToExpected) == 0x00011E, "Member 'UAbilityTask_ApplyRootMotionMoveToForce::bRestrictSpeedToExpected' has a wrong offset!");
static_assert(offsetof(UAbilityTask_ApplyRootMotionMoveToForce, PathOffsetCurve) == 0x000120, "Member 'UAbilityTask_ApplyRootMotionMoveToForce::PathOffsetCurve' has a wrong offset!");

// Class GameplayAbilities.AbilityTask_ApplyRootMotionRadialForce
// 0x0070 (0x0138 - 0x00C8)
class UAbilityTask_ApplyRootMotionRadialForce final : public UAbilityTask_ApplyRootMotion_Base
{
public:
	TMulticastInlineDelegate<void()>              OnFinish;                                          // 0x00C8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	struct FVector                                Location;                                          // 0x00D8(0x0018)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class AActor*                                 LocationActor;                                     // 0x00F0(0x0008)(Net, ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         Strength;                                          // 0x00F8(0x0004)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         Duration;                                          // 0x00FC(0x0004)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         Radius;                                            // 0x0100(0x0004)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIsPush;                                           // 0x0104(0x0001)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIsAdditive;                                       // 0x0105(0x0001)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bNoZForce;                                         // 0x0106(0x0001)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_107[0x1];                                      // 0x0107(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	class UCurveFloat*                            StrengthDistanceFalloff;                           // 0x0108(0x0008)(Net, ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCurveFloat*                            StrengthOverTime;                                  // 0x0110(0x0008)(Net, ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bUseFixedWorldDirection;                           // 0x0118(0x0001)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_119[0x7];                                      // 0x0119(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRotator                               FixedWorldDirection;                               // 0x0120(0x0018)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)

public:
	static class UAbilityTask_ApplyRootMotionRadialForce* ApplyRootMotionRadialForce(class UGameplayAbility* OwningAbility, class FName TaskInstanceName, const struct FVector& Location_0, class AActor* LocationActor_0, float Strength_0, float Duration_0, float Radius_0, bool bIsPush_0, bool bIsAdditive_0, bool bNoZForce_0, class UCurveFloat* StrengthDistanceFalloff_0, class UCurveFloat* StrengthOverTime_0, bool bUseFixedWorldDirection_0, const struct FRotator& FixedWorldDirection_0, ERootMotionFinishVelocityMode VelocityOnFinishMode, const struct FVector& SetVelocityOnFinish, float ClampVelocityOnFinish)	 // 0x3d972ac;

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"AbilityTask_ApplyRootMotionRadialForce">();
	}
	static class UAbilityTask_ApplyRootMotionRadialForce* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UAbilityTask_ApplyRootMotionRadialForce>();
	}
};
static_assert(alignof(UAbilityTask_ApplyRootMotionRadialForce) == 0x000008, "Wrong alignment on UAbilityTask_ApplyRootMotionRadialForce");
static_assert(sizeof(UAbilityTask_ApplyRootMotionRadialForce) == 0x000138, "Wrong size on UAbilityTask_ApplyRootMotionRadialForce");
static_assert(offsetof(UAbilityTask_ApplyRootMotionRadialForce, OnFinish) == 0x0000C8, "Member 'UAbilityTask_ApplyRootMotionRadialForce::OnFinish' has a wrong offset!");
static_assert(offsetof(UAbilityTask_ApplyRootMotionRadialForce, Location) == 0x0000D8, "Member 'UAbilityTask_ApplyRootMotionRadialForce::Location' has a wrong offset!");
static_assert(offsetof(UAbilityTask_ApplyRootMotionRadialForce, LocationActor) == 0x0000F0, "Member 'UAbilityTask_ApplyRootMotionRadialForce::LocationActor' has a wrong offset!");
static_assert(offsetof(UAbilityTask_ApplyRootMotionRadialForce, Strength) == 0x0000F8, "Member 'UAbilityTask_ApplyRootMotionRadialForce::Strength' has a wrong offset!");
static_assert(offsetof(UAbilityTask_ApplyRootMotionRadialForce, Duration) == 0x0000FC, "Member 'UAbilityTask_ApplyRootMotionRadialForce::Duration' has a wrong offset!");
static_assert(offsetof(UAbilityTask_ApplyRootMotionRadialForce, Radius) == 0x000100, "Member 'UAbilityTask_ApplyRootMotionRadialForce::Radius' has a wrong offset!");
static_assert(offsetof(UAbilityTask_ApplyRootMotionRadialForce, bIsPush) == 0x000104, "Member 'UAbilityTask_ApplyRootMotionRadialForce::bIsPush' has a wrong offset!");
static_assert(offsetof(UAbilityTask_ApplyRootMotionRadialForce, bIsAdditive) == 0x000105, "Member 'UAbilityTask_ApplyRootMotionRadialForce::bIsAdditive' has a wrong offset!");
static_assert(offsetof(UAbilityTask_ApplyRootMotionRadialForce, bNoZForce) == 0x000106, "Member 'UAbilityTask_ApplyRootMotionRadialForce::bNoZForce' has a wrong offset!");
static_assert(offsetof(UAbilityTask_ApplyRootMotionRadialForce, StrengthDistanceFalloff) == 0x000108, "Member 'UAbilityTask_ApplyRootMotionRadialForce::StrengthDistanceFalloff' has a wrong offset!");
static_assert(offsetof(UAbilityTask_ApplyRootMotionRadialForce, StrengthOverTime) == 0x000110, "Member 'UAbilityTask_ApplyRootMotionRadialForce::StrengthOverTime' has a wrong offset!");
static_assert(offsetof(UAbilityTask_ApplyRootMotionRadialForce, bUseFixedWorldDirection) == 0x000118, "Member 'UAbilityTask_ApplyRootMotionRadialForce::bUseFixedWorldDirection' has a wrong offset!");
static_assert(offsetof(UAbilityTask_ApplyRootMotionRadialForce, FixedWorldDirection) == 0x000120, "Member 'UAbilityTask_ApplyRootMotionRadialForce::FixedWorldDirection' has a wrong offset!");

// Class GameplayAbilities.AbilityTask_MoveToLocation
// 0x0068 (0x00E8 - 0x0080)
class UAbilityTask_MoveToLocation final : public UAbilityTask
{
public:
	TMulticastInlineDelegate<void()>              OnTargetLocationReached;                           // 0x0080(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_90[0x8];                                       // 0x0090(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                StartLocation;                                     // 0x0098(0x0018)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector                                TargetLocation;                                    // 0x00B0(0x0018)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         DurationOfMovement;                                // 0x00C8(0x0004)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_CC[0xC];                                       // 0x00CC(0x000C)(Fixing Size After Last Property [ Dumper-7 ])
	class UCurveFloat*                            LerpCurve;                                         // 0x00D8(0x0008)(Net, ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCurveVector*                           LerpCurveVector;                                   // 0x00E0(0x0008)(Net, ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UAbilityTask_MoveToLocation* MoveToLocation(class UGameplayAbility* OwningAbility, class FName TaskInstanceName, const struct FVector& Location, float Duration, class UCurveFloat* OptionalInterpolationCurve, class UCurveVector* OptionalVectorInterpolationCurve)	 // 0x3da1658;

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"AbilityTask_MoveToLocation">();
	}
	static class UAbilityTask_MoveToLocation* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UAbilityTask_MoveToLocation>();
	}
};
static_assert(alignof(UAbilityTask_MoveToLocation) == 0x000008, "Wrong alignment on UAbilityTask_MoveToLocation");
static_assert(sizeof(UAbilityTask_MoveToLocation) == 0x0000E8, "Wrong size on UAbilityTask_MoveToLocation");
static_assert(offsetof(UAbilityTask_MoveToLocation, OnTargetLocationReached) == 0x000080, "Member 'UAbilityTask_MoveToLocation::OnTargetLocationReached' has a wrong offset!");
static_assert(offsetof(UAbilityTask_MoveToLocation, StartLocation) == 0x000098, "Member 'UAbilityTask_MoveToLocation::StartLocation' has a wrong offset!");
static_assert(offsetof(UAbilityTask_MoveToLocation, TargetLocation) == 0x0000B0, "Member 'UAbilityTask_MoveToLocation::TargetLocation' has a wrong offset!");
static_assert(offsetof(UAbilityTask_MoveToLocation, DurationOfMovement) == 0x0000C8, "Member 'UAbilityTask_MoveToLocation::DurationOfMovement' has a wrong offset!");
static_assert(offsetof(UAbilityTask_MoveToLocation, LerpCurve) == 0x0000D8, "Member 'UAbilityTask_MoveToLocation::LerpCurve' has a wrong offset!");
static_assert(offsetof(UAbilityTask_MoveToLocation, LerpCurveVector) == 0x0000E0, "Member 'UAbilityTask_MoveToLocation::LerpCurveVector' has a wrong offset!");

// Class GameplayAbilities.AbilityTask_NetworkSyncPoint
// 0x0018 (0x0098 - 0x0080)
class UAbilityTask_NetworkSyncPoint final : public UAbilityTask
{
public:
	TMulticastInlineDelegate<void()>              OnSync;                                            // 0x0080(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_90[0x8];                                       // 0x0090(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UAbilityTask_NetworkSyncPoint* WaitNetSync(class UGameplayAbility* OwningAbility, EAbilityTaskNetSyncType SyncType)	 // 0x3daa39c;

	void OnSignalCallback()	 // 0x3da2e6c;

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"AbilityTask_NetworkSyncPoint">();
	}
	static class UAbilityTask_NetworkSyncPoint* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UAbilityTask_NetworkSyncPoint>();
	}
};
static_assert(alignof(UAbilityTask_NetworkSyncPoint) == 0x000008, "Wrong alignment on UAbilityTask_NetworkSyncPoint");
static_assert(sizeof(UAbilityTask_NetworkSyncPoint) == 0x000098, "Wrong size on UAbilityTask_NetworkSyncPoint");
static_assert(offsetof(UAbilityTask_NetworkSyncPoint, OnSync) == 0x000080, "Member 'UAbilityTask_NetworkSyncPoint::OnSync' has a wrong offset!");

// Class GameplayAbilities.AbilityTask_PlayMontageAndWait
// 0x0088 (0x0108 - 0x0080)
class UAbilityTask_PlayMontageAndWait : public UAbilityTask
{
public:
	TMulticastInlineDelegate<void()>              OnCompleted;                                       // 0x0080(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void()>              OnBlendOut;                                        // 0x0090(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void()>              OnInterrupted;                                     // 0x00A0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void()>              OnCancelled;                                       // 0x00B0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_C0[0x28];                                      // 0x00C0(0x0028)(Fixing Size After Last Property [ Dumper-7 ])
	class UAnimMontage*                           MontageToPlay;                                     // 0x00E8(0x0008)(ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         Rate;                                              // 0x00F0(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   StartSection;                                      // 0x00F4(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         AnimRootMotionTranslationScale;                    // 0x00FC(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         StartTimeSeconds;                                  // 0x0100(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bStopWhenAbilityEnds;                              // 0x0104(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_105[0x3];                                      // 0x0105(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UAbilityTask_PlayMontageAndWait* CreatePlayMontageAndWaitProxy(class UGameplayAbility* OwningAbility, class FName TaskInstanceName, class UAnimMontage* MontageToPlay_0, float Rate_0, class FName StartSection_0, bool bStopWhenAbilityEnds_0, float AnimRootMotionTranslationScale_0, float StartTimeSeconds_0)	 // 0x3d99158;

	void OnMontageBlendingOut(class UAnimMontage* Montage, bool bInterrupted)	 // 0x3da2978;
	void OnMontageEnded(class UAnimMontage* Montage, bool bInterrupted)	 // 0x3da2ab8;
	void OnMontageInterrupted()	 // 0x3da2bf8;

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"AbilityTask_PlayMontageAndWait">();
	}
	static class UAbilityTask_PlayMontageAndWait* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UAbilityTask_PlayMontageAndWait>();
	}
};
static_assert(alignof(UAbilityTask_PlayMontageAndWait) == 0x000008, "Wrong alignment on UAbilityTask_PlayMontageAndWait");
static_assert(sizeof(UAbilityTask_PlayMontageAndWait) == 0x000108, "Wrong size on UAbilityTask_PlayMontageAndWait");
static_assert(offsetof(UAbilityTask_PlayMontageAndWait, OnCompleted) == 0x000080, "Member 'UAbilityTask_PlayMontageAndWait::OnCompleted' has a wrong offset!");
static_assert(offsetof(UAbilityTask_PlayMontageAndWait, OnBlendOut) == 0x000090, "Member 'UAbilityTask_PlayMontageAndWait::OnBlendOut' has a wrong offset!");
static_assert(offsetof(UAbilityTask_PlayMontageAndWait, OnInterrupted) == 0x0000A0, "Member 'UAbilityTask_PlayMontageAndWait::OnInterrupted' has a wrong offset!");
static_assert(offsetof(UAbilityTask_PlayMontageAndWait, OnCancelled) == 0x0000B0, "Member 'UAbilityTask_PlayMontageAndWait::OnCancelled' has a wrong offset!");
static_assert(offsetof(UAbilityTask_PlayMontageAndWait, MontageToPlay) == 0x0000E8, "Member 'UAbilityTask_PlayMontageAndWait::MontageToPlay' has a wrong offset!");
static_assert(offsetof(UAbilityTask_PlayMontageAndWait, Rate) == 0x0000F0, "Member 'UAbilityTask_PlayMontageAndWait::Rate' has a wrong offset!");
static_assert(offsetof(UAbilityTask_PlayMontageAndWait, StartSection) == 0x0000F4, "Member 'UAbilityTask_PlayMontageAndWait::StartSection' has a wrong offset!");
static_assert(offsetof(UAbilityTask_PlayMontageAndWait, AnimRootMotionTranslationScale) == 0x0000FC, "Member 'UAbilityTask_PlayMontageAndWait::AnimRootMotionTranslationScale' has a wrong offset!");
static_assert(offsetof(UAbilityTask_PlayMontageAndWait, StartTimeSeconds) == 0x000100, "Member 'UAbilityTask_PlayMontageAndWait::StartTimeSeconds' has a wrong offset!");
static_assert(offsetof(UAbilityTask_PlayMontageAndWait, bStopWhenAbilityEnds) == 0x000104, "Member 'UAbilityTask_PlayMontageAndWait::bStopWhenAbilityEnds' has a wrong offset!");

// Class GameplayAbilities.AbilityTask_Repeat
// 0x0038 (0x00B8 - 0x0080)
class UAbilityTask_Repeat final : public UAbilityTask
{
public:
	TMulticastInlineDelegate<void(int32 ActionNumber)> OnPerformAction;                              // 0x0080(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(int32 ActionNumber)> OnFinished;                                   // 0x0090(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_A0[0x18];                                      // 0x00A0(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UAbilityTask_Repeat* RepeatAction(class UGameplayAbility* OwningAbility, float TimeBetweenActions, int32 TotalActionCount)	 // 0x3da3528;

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"AbilityTask_Repeat">();
	}
	static class UAbilityTask_Repeat* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UAbilityTask_Repeat>();
	}
};
static_assert(alignof(UAbilityTask_Repeat) == 0x000008, "Wrong alignment on UAbilityTask_Repeat");
static_assert(sizeof(UAbilityTask_Repeat) == 0x0000B8, "Wrong size on UAbilityTask_Repeat");
static_assert(offsetof(UAbilityTask_Repeat, OnPerformAction) == 0x000080, "Member 'UAbilityTask_Repeat::OnPerformAction' has a wrong offset!");
static_assert(offsetof(UAbilityTask_Repeat, OnFinished) == 0x000090, "Member 'UAbilityTask_Repeat::OnFinished' has a wrong offset!");

// Class GameplayAbilities.AbilityTask_SpawnActor
// 0x0048 (0x00C8 - 0x0080)
class UAbilityTask_SpawnActor final : public UAbilityTask
{
public:
	TMulticastInlineDelegate<void(class AActor* SpawnedActor)> Success;                              // 0x0080(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(class AActor* SpawnedActor)> DidNotSpawn;                          // 0x0090(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_A0[0x28];                                      // 0x00A0(0x0028)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UAbilityTask_SpawnActor* SpawnActor(class UGameplayAbility* OwningAbility, const struct FGameplayAbilityTargetDataHandle& TargetData, TSubclassOf<class AActor> Class_0)	 // 0x3da3de0;

	bool BeginSpawningActor(class UGameplayAbility* OwningAbility, const struct FGameplayAbilityTargetDataHandle& TargetData, TSubclassOf<class AActor> Class_0, class AActor** SpawnedActor)	 // 0x3d98778;
	void FinishSpawningActor(class UGameplayAbility* OwningAbility, const struct FGameplayAbilityTargetDataHandle& TargetData, class AActor* SpawnedActor)	 // 0x3d9bfd8;

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"AbilityTask_SpawnActor">();
	}
	static class UAbilityTask_SpawnActor* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UAbilityTask_SpawnActor>();
	}
};
static_assert(alignof(UAbilityTask_SpawnActor) == 0x000008, "Wrong alignment on UAbilityTask_SpawnActor");
static_assert(sizeof(UAbilityTask_SpawnActor) == 0x0000C8, "Wrong size on UAbilityTask_SpawnActor");
static_assert(offsetof(UAbilityTask_SpawnActor, Success) == 0x000080, "Member 'UAbilityTask_SpawnActor::Success' has a wrong offset!");
static_assert(offsetof(UAbilityTask_SpawnActor, DidNotSpawn) == 0x000090, "Member 'UAbilityTask_SpawnActor::DidNotSpawn' has a wrong offset!");

// Class GameplayAbilities.AbilityTask_StartAbilityState
// 0x0038 (0x00B8 - 0x0080)
class UAbilityTask_StartAbilityState final : public UAbilityTask
{
public:
	TMulticastInlineDelegate<void()>              OnStateEnded;                                      // 0x0080(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void()>              OnStateInterrupted;                                // 0x0090(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_A0[0x18];                                      // 0x00A0(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UAbilityTask_StartAbilityState* StartAbilityState(class UGameplayAbility* OwningAbility, class FName StateName, bool bEndCurrentState)	 // 0x3da3fe0;

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"AbilityTask_StartAbilityState">();
	}
	static class UAbilityTask_StartAbilityState* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UAbilityTask_StartAbilityState>();
	}
};
static_assert(alignof(UAbilityTask_StartAbilityState) == 0x000008, "Wrong alignment on UAbilityTask_StartAbilityState");
static_assert(sizeof(UAbilityTask_StartAbilityState) == 0x0000B8, "Wrong size on UAbilityTask_StartAbilityState");
static_assert(offsetof(UAbilityTask_StartAbilityState, OnStateEnded) == 0x000080, "Member 'UAbilityTask_StartAbilityState::OnStateEnded' has a wrong offset!");
static_assert(offsetof(UAbilityTask_StartAbilityState, OnStateInterrupted) == 0x000090, "Member 'UAbilityTask_StartAbilityState::OnStateInterrupted' has a wrong offset!");

// Class GameplayAbilities.AbilityTask_VisualizeTargeting
// 0x0028 (0x00A8 - 0x0080)
class UAbilityTask_VisualizeTargeting final : public UAbilityTask
{
public:
	TMulticastInlineDelegate<void()>              TimeElapsed;                                       // 0x0080(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_90[0x18];                                      // 0x0090(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UAbilityTask_VisualizeTargeting* VisualizeTargeting(class UGameplayAbility* OwningAbility, TSubclassOf<class AGameplayAbilityTargetActor> Class_0, class FName TaskInstanceName, float Duration)	 // 0x3da4ab0;
	static class UAbilityTask_VisualizeTargeting* VisualizeTargetingUsingActor(class UGameplayAbility* OwningAbility, class AGameplayAbilityTargetActor* TargetActor, class FName TaskInstanceName, float Duration)	 // 0x3da4ce4;

	bool BeginSpawningActor(class UGameplayAbility* OwningAbility, TSubclassOf<class AGameplayAbilityTargetActor> Class_0, class AGameplayAbilityTargetActor** SpawnedActor)	 // 0x3d989c8;
	void FinishSpawningActor(class UGameplayAbility* OwningAbility, class AGameplayAbilityTargetActor* SpawnedActor)	 // 0x3d9c314;

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"AbilityTask_VisualizeTargeting">();
	}
	static class UAbilityTask_VisualizeTargeting* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UAbilityTask_VisualizeTargeting>();
	}
};
static_assert(alignof(UAbilityTask_VisualizeTargeting) == 0x000008, "Wrong alignment on UAbilityTask_VisualizeTargeting");
static_assert(sizeof(UAbilityTask_VisualizeTargeting) == 0x0000A8, "Wrong size on UAbilityTask_VisualizeTargeting");
static_assert(offsetof(UAbilityTask_VisualizeTargeting, TimeElapsed) == 0x000080, "Member 'UAbilityTask_VisualizeTargeting::TimeElapsed' has a wrong offset!");

// Class GameplayAbilities.AbilityTask_WaitAbilityActivate
// 0x00B8 (0x0138 - 0x0080)
class UAbilityTask_WaitAbilityActivate final : public UAbilityTask
{
public:
	TMulticastInlineDelegate<void(class UGameplayAbility* ActivatedAbility)> OnActivate;             // 0x0080(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_90[0xA8];                                      // 0x0090(0x00A8)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UAbilityTask_WaitAbilityActivate* WaitForAbilityActivate(class UGameplayAbility* OwningAbility, const struct FGameplayTag& WithTag, const struct FGameplayTag& WithoutTag, bool IncludeTriggeredAbilities, bool TriggerOnce)	 // 0x3da520c;
	static class UAbilityTask_WaitAbilityActivate* WaitForAbilityActivate_Query(class UGameplayAbility* OwningAbility, const struct FGameplayTagQuery& Query, bool IncludeTriggeredAbilities, bool TriggerOnce)	 // 0x3da5788;
	static class UAbilityTask_WaitAbilityActivate* WaitForAbilityActivateWithTagRequirements(class UGameplayAbility* OwningAbility, const struct FGameplayTagRequirements& TagRequirements, bool IncludeTriggeredAbilities, bool TriggerOnce)	 // 0x3da54e4;

	void OnAbilityActivate(class UGameplayAbility* ActivatedAbility)	 // 0x3da1d8c;

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"AbilityTask_WaitAbilityActivate">();
	}
	static class UAbilityTask_WaitAbilityActivate* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UAbilityTask_WaitAbilityActivate>();
	}
};
static_assert(alignof(UAbilityTask_WaitAbilityActivate) == 0x000008, "Wrong alignment on UAbilityTask_WaitAbilityActivate");
static_assert(sizeof(UAbilityTask_WaitAbilityActivate) == 0x000138, "Wrong size on UAbilityTask_WaitAbilityActivate");
static_assert(offsetof(UAbilityTask_WaitAbilityActivate, OnActivate) == 0x000080, "Member 'UAbilityTask_WaitAbilityActivate::OnActivate' has a wrong offset!");

// Class GameplayAbilities.AbilityTask_WaitAbilityCommit
// 0x0078 (0x00F8 - 0x0080)
class UAbilityTask_WaitAbilityCommit final : public UAbilityTask
{
public:
	TMulticastInlineDelegate<void(class UGameplayAbility* ActivatedAbility)> OnCommit;               // 0x0080(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_90[0x68];                                      // 0x0090(0x0068)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UAbilityTask_WaitAbilityCommit* WaitForAbilityCommit(class UGameplayAbility* OwningAbility, const struct FGameplayTag& WithTag, const struct FGameplayTag& WithoutTage, bool TriggerOnce)	 // 0x3da5a60;
	static class UAbilityTask_WaitAbilityCommit* WaitForAbilityCommit_Query(class UGameplayAbility* OwningAbility, const struct FGameplayTagQuery& Query, bool TriggerOnce)	 // 0x3da5cb8;

	void OnAbilityCommit(class UGameplayAbility* ActivatedAbility)	 // 0x3da1e4c;

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"AbilityTask_WaitAbilityCommit">();
	}
	static class UAbilityTask_WaitAbilityCommit* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UAbilityTask_WaitAbilityCommit>();
	}
};
static_assert(alignof(UAbilityTask_WaitAbilityCommit) == 0x000008, "Wrong alignment on UAbilityTask_WaitAbilityCommit");
static_assert(sizeof(UAbilityTask_WaitAbilityCommit) == 0x0000F8, "Wrong size on UAbilityTask_WaitAbilityCommit");
static_assert(offsetof(UAbilityTask_WaitAbilityCommit, OnCommit) == 0x000080, "Member 'UAbilityTask_WaitAbilityCommit::OnCommit' has a wrong offset!");

// Class GameplayAbilities.AbilityTask_WaitAttributeChange
// 0x0078 (0x00F8 - 0x0080)
class UAbilityTask_WaitAttributeChange final : public UAbilityTask
{
public:
	TMulticastInlineDelegate<void()>              OnChange;                                          // 0x0080(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_90[0x60];                                      // 0x0090(0x0060)(Fixing Size After Last Property [ Dumper-7 ])
	class UAbilitySystemComponent*                ExternalOwner;                                     // 0x00F0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UAbilityTask_WaitAttributeChange* WaitForAttributeChange(class UGameplayAbility* OwningAbility, const struct FGameplayAttribute& Attribute, const struct FGameplayTag& WithSrcTag, const struct FGameplayTag& WithoutSrcTag, bool TriggerOnce, class AActor* OptionalExternalOwner)	 // 0x3da5f10;
	static class UAbilityTask_WaitAttributeChange* WaitForAttributeChangeWithComparison(class UGameplayAbility* OwningAbility, const struct FGameplayAttribute& InAttribute, const struct FGameplayTag& InWithTag, const struct FGameplayTag& InWithoutTag, EWaitAttributeChangeComparison InComparisonType, float InComparisonValue, bool TriggerOnce, class AActor* OptionalExternalOwner)	 // 0x3da6bd8;

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"AbilityTask_WaitAttributeChange">();
	}
	static class UAbilityTask_WaitAttributeChange* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UAbilityTask_WaitAttributeChange>();
	}
};
static_assert(alignof(UAbilityTask_WaitAttributeChange) == 0x000008, "Wrong alignment on UAbilityTask_WaitAttributeChange");
static_assert(sizeof(UAbilityTask_WaitAttributeChange) == 0x0000F8, "Wrong size on UAbilityTask_WaitAttributeChange");
static_assert(offsetof(UAbilityTask_WaitAttributeChange, OnChange) == 0x000080, "Member 'UAbilityTask_WaitAttributeChange::OnChange' has a wrong offset!");
static_assert(offsetof(UAbilityTask_WaitAttributeChange, ExternalOwner) == 0x0000F0, "Member 'UAbilityTask_WaitAttributeChange::ExternalOwner' has a wrong offset!");

// Class GameplayAbilities.AbilityTask_WaitAttributeChangeRatioThreshold
// 0x00C0 (0x0140 - 0x0080)
class UAbilityTask_WaitAttributeChangeRatioThreshold final : public UAbilityTask
{
public:
	TMulticastInlineDelegate<void(bool bMatchesComparison, float CurrentRatio)> OnChange;            // 0x0080(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_90[0xA8];                                      // 0x0090(0x00A8)(Fixing Size After Last Property [ Dumper-7 ])
	class UAbilitySystemComponent*                ExternalOwner;                                     // 0x0138(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UAbilityTask_WaitAttributeChangeRatioThreshold* WaitForAttributeChangeRatioThreshold(class UGameplayAbility* OwningAbility, const struct FGameplayAttribute& AttributeNumerator, const struct FGameplayAttribute& AttributeDenominator, EWaitAttributeChangeComparison ComparisonType, float ComparisonValue, bool bTriggerOnce, class AActor* OptionalExternalOwner)	 // 0x3da63a4;

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"AbilityTask_WaitAttributeChangeRatioThreshold">();
	}
	static class UAbilityTask_WaitAttributeChangeRatioThreshold* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UAbilityTask_WaitAttributeChangeRatioThreshold>();
	}
};
static_assert(alignof(UAbilityTask_WaitAttributeChangeRatioThreshold) == 0x000008, "Wrong alignment on UAbilityTask_WaitAttributeChangeRatioThreshold");
static_assert(sizeof(UAbilityTask_WaitAttributeChangeRatioThreshold) == 0x000140, "Wrong size on UAbilityTask_WaitAttributeChangeRatioThreshold");
static_assert(offsetof(UAbilityTask_WaitAttributeChangeRatioThreshold, OnChange) == 0x000080, "Member 'UAbilityTask_WaitAttributeChangeRatioThreshold::OnChange' has a wrong offset!");
static_assert(offsetof(UAbilityTask_WaitAttributeChangeRatioThreshold, ExternalOwner) == 0x000138, "Member 'UAbilityTask_WaitAttributeChangeRatioThreshold::ExternalOwner' has a wrong offset!");

// Class GameplayAbilities.AbilityTask_WaitAttributeChangeThreshold
// 0x0070 (0x00F0 - 0x0080)
class UAbilityTask_WaitAttributeChangeThreshold final : public UAbilityTask
{
public:
	TMulticastInlineDelegate<void(bool bMatchesComparison, float CurrentValue)> OnChange;            // 0x0080(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_90[0x58];                                      // 0x0090(0x0058)(Fixing Size After Last Property [ Dumper-7 ])
	class UAbilitySystemComponent*                ExternalOwner;                                     // 0x00E8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UAbilityTask_WaitAttributeChangeThreshold* WaitForAttributeChangeThreshold(class UGameplayAbility* OwningAbility, const struct FGameplayAttribute& Attribute, EWaitAttributeChangeComparison ComparisonType, float ComparisonValue, bool bTriggerOnce, class AActor* OptionalExternalOwner)	 // 0x3da6840;

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"AbilityTask_WaitAttributeChangeThreshold">();
	}
	static class UAbilityTask_WaitAttributeChangeThreshold* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UAbilityTask_WaitAttributeChangeThreshold>();
	}
};
static_assert(alignof(UAbilityTask_WaitAttributeChangeThreshold) == 0x000008, "Wrong alignment on UAbilityTask_WaitAttributeChangeThreshold");
static_assert(sizeof(UAbilityTask_WaitAttributeChangeThreshold) == 0x0000F0, "Wrong size on UAbilityTask_WaitAttributeChangeThreshold");
static_assert(offsetof(UAbilityTask_WaitAttributeChangeThreshold, OnChange) == 0x000080, "Member 'UAbilityTask_WaitAttributeChangeThreshold::OnChange' has a wrong offset!");
static_assert(offsetof(UAbilityTask_WaitAttributeChangeThreshold, ExternalOwner) == 0x0000E8, "Member 'UAbilityTask_WaitAttributeChangeThreshold::ExternalOwner' has a wrong offset!");

// Class GameplayAbilities.AbilityTask_WaitCancel
// 0x0018 (0x0098 - 0x0080)
class UAbilityTask_WaitCancel final : public UAbilityTask
{
public:
	TMulticastInlineDelegate<void()>              OnCancel;                                          // 0x0080(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_90[0x8];                                       // 0x0090(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UAbilityTask_WaitCancel* WaitCancel(class UGameplayAbility* OwningAbility)	 // 0x3da4f18;

	void OnCancelCallback()	 // 0x3da2140;
	void OnLocalCancelCallback()	 // 0x3da293c;

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"AbilityTask_WaitCancel">();
	}
	static class UAbilityTask_WaitCancel* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UAbilityTask_WaitCancel>();
	}
};
static_assert(alignof(UAbilityTask_WaitCancel) == 0x000008, "Wrong alignment on UAbilityTask_WaitCancel");
static_assert(sizeof(UAbilityTask_WaitCancel) == 0x000098, "Wrong size on UAbilityTask_WaitCancel");
static_assert(offsetof(UAbilityTask_WaitCancel, OnCancel) == 0x000080, "Member 'UAbilityTask_WaitCancel::OnCancel' has a wrong offset!");

// Class GameplayAbilities.AbilityTask_WaitConfirm
// 0x0020 (0x00A0 - 0x0080)
class UAbilityTask_WaitConfirm final : public UAbilityTask
{
public:
	TMulticastInlineDelegate<void()>              OnConfirm;                                         // 0x0080(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_90[0x10];                                      // 0x0090(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UAbilityTask_WaitConfirm* WaitConfirm(class UGameplayAbility* OwningAbility)	 // 0x3da5014;

	void OnConfirmCallback(class UGameplayAbility* InAbility)	 // 0x3da2168;

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"AbilityTask_WaitConfirm">();
	}
	static class UAbilityTask_WaitConfirm* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UAbilityTask_WaitConfirm>();
	}
};
static_assert(alignof(UAbilityTask_WaitConfirm) == 0x000008, "Wrong alignment on UAbilityTask_WaitConfirm");
static_assert(sizeof(UAbilityTask_WaitConfirm) == 0x0000A0, "Wrong size on UAbilityTask_WaitConfirm");
static_assert(offsetof(UAbilityTask_WaitConfirm, OnConfirm) == 0x000080, "Member 'UAbilityTask_WaitConfirm::OnConfirm' has a wrong offset!");

// Class GameplayAbilities.AbilityTask_WaitConfirmCancel
// 0x0028 (0x00A8 - 0x0080)
class UAbilityTask_WaitConfirmCancel final : public UAbilityTask
{
public:
	TMulticastInlineDelegate<void()>              OnConfirm;                                         // 0x0080(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void()>              OnCancel;                                          // 0x0090(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_A0[0x8];                                       // 0x00A0(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UAbilityTask_WaitConfirmCancel* WaitConfirmCancel(class UGameplayAbility* OwningAbility)	 // 0x3da5110;

	void OnCancelCallback()	 // 0x3da2154;
	void OnConfirmCallback()	 // 0x3da2228;
	void OnLocalCancelCallback()	 // 0x3da2950;
	void OnLocalConfirmCallback()	 // 0x3da2964;

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"AbilityTask_WaitConfirmCancel">();
	}
	static class UAbilityTask_WaitConfirmCancel* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UAbilityTask_WaitConfirmCancel>();
	}
};
static_assert(alignof(UAbilityTask_WaitConfirmCancel) == 0x000008, "Wrong alignment on UAbilityTask_WaitConfirmCancel");
static_assert(sizeof(UAbilityTask_WaitConfirmCancel) == 0x0000A8, "Wrong size on UAbilityTask_WaitConfirmCancel");
static_assert(offsetof(UAbilityTask_WaitConfirmCancel, OnConfirm) == 0x000080, "Member 'UAbilityTask_WaitConfirmCancel::OnConfirm' has a wrong offset!");
static_assert(offsetof(UAbilityTask_WaitConfirmCancel, OnCancel) == 0x000090, "Member 'UAbilityTask_WaitConfirmCancel::OnCancel' has a wrong offset!");

// Class GameplayAbilities.AbilityTask_WaitDelay
// 0x0018 (0x0098 - 0x0080)
class UAbilityTask_WaitDelay final : public UAbilityTask
{
public:
	TMulticastInlineDelegate<void()>              OnFinish;                                          // 0x0080(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_90[0x8];                                       // 0x0090(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UAbilityTask_WaitDelay* WaitDelay(class UGameplayAbility* OwningAbility, float Time)	 // 0x133035c;

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"AbilityTask_WaitDelay">();
	}
	static class UAbilityTask_WaitDelay* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UAbilityTask_WaitDelay>();
	}
};
static_assert(alignof(UAbilityTask_WaitDelay) == 0x000008, "Wrong alignment on UAbilityTask_WaitDelay");
static_assert(sizeof(UAbilityTask_WaitDelay) == 0x000098, "Wrong size on UAbilityTask_WaitDelay");
static_assert(offsetof(UAbilityTask_WaitDelay, OnFinish) == 0x000080, "Member 'UAbilityTask_WaitDelay::OnFinish' has a wrong offset!");

// Class GameplayAbilities.AbilityTask_WaitGameplayEffectApplied
// 0x0138 (0x01B8 - 0x0080)
class UAbilityTask_WaitGameplayEffectApplied : public UAbilityTask
{
public:
	uint8                                         Pad_80[0x128];                                     // 0x0080(0x0128)(Fixing Size After Last Property [ Dumper-7 ])
	class UAbilitySystemComponent*                ExternalOwner;                                     // 0x01A8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1B0[0x8];                                      // 0x01B0(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnApplyGameplayEffectCallback(class UAbilitySystemComponent* Target, const struct FGameplayEffectSpec& SpecApplied, const struct FActiveGameplayEffectHandle& ActiveHandle)	 // 0x3da1f0c;

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"AbilityTask_WaitGameplayEffectApplied">();
	}
	static class UAbilityTask_WaitGameplayEffectApplied* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UAbilityTask_WaitGameplayEffectApplied>();
	}
};
static_assert(alignof(UAbilityTask_WaitGameplayEffectApplied) == 0x000008, "Wrong alignment on UAbilityTask_WaitGameplayEffectApplied");
static_assert(sizeof(UAbilityTask_WaitGameplayEffectApplied) == 0x0001B8, "Wrong size on UAbilityTask_WaitGameplayEffectApplied");
static_assert(offsetof(UAbilityTask_WaitGameplayEffectApplied, ExternalOwner) == 0x0001A8, "Member 'UAbilityTask_WaitGameplayEffectApplied::ExternalOwner' has a wrong offset!");

// Class GameplayAbilities.AbilityTask_WaitGameplayEffectApplied_Self
// 0x0020 (0x01D8 - 0x01B8)
class UAbilityTask_WaitGameplayEffectApplied_Self final : public UAbilityTask_WaitGameplayEffectApplied
{
public:
	TMulticastInlineDelegate<void(class AActor* Source, const struct FGameplayEffectSpecHandle& SpecHandle, const struct FActiveGameplayEffectHandle& ActiveHandle)> OnApplied; // 0x01B8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C8[0x10];                                     // 0x01C8(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UAbilityTask_WaitGameplayEffectApplied_Self* WaitGameplayEffectAppliedToSelf(class UGameplayAbility* OwningAbility, const struct FGameplayTargetDataFilterHandle& SourceFilter, const struct FGameplayTagRequirements& SourceTagRequirements, const struct FGameplayTagRequirements& TargetTagRequirements, bool TriggerOnce, class AActor* OptionalExternalOwner, bool ListenForPeriodicEffect)	 // 0x3da7ae4;
	static class UAbilityTask_WaitGameplayEffectApplied_Self* WaitGameplayEffectAppliedToSelf_Query(class UGameplayAbility* OwningAbility, const struct FGameplayTargetDataFilterHandle& SourceFilter, const struct FGameplayTagQuery& SourceTagQuery, const struct FGameplayTagQuery& TargetTagQuery, bool TriggerOnce, class AActor* OptionalExternalOwner, bool ListenForPeriodicEffect)	 // 0x3da7fac;

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"AbilityTask_WaitGameplayEffectApplied_Self">();
	}
	static class UAbilityTask_WaitGameplayEffectApplied_Self* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UAbilityTask_WaitGameplayEffectApplied_Self>();
	}
};
static_assert(alignof(UAbilityTask_WaitGameplayEffectApplied_Self) == 0x000008, "Wrong alignment on UAbilityTask_WaitGameplayEffectApplied_Self");
static_assert(sizeof(UAbilityTask_WaitGameplayEffectApplied_Self) == 0x0001D8, "Wrong size on UAbilityTask_WaitGameplayEffectApplied_Self");
static_assert(offsetof(UAbilityTask_WaitGameplayEffectApplied_Self, OnApplied) == 0x0001B8, "Member 'UAbilityTask_WaitGameplayEffectApplied_Self::OnApplied' has a wrong offset!");

// Class GameplayAbilities.AbilityTask_WaitGameplayEffectApplied_Target
// 0x0020 (0x01D8 - 0x01B8)
class UAbilityTask_WaitGameplayEffectApplied_Target final : public UAbilityTask_WaitGameplayEffectApplied
{
public:
	TMulticastInlineDelegate<void(class AActor* Target, const struct FGameplayEffectSpecHandle& SpecHandle, const struct FActiveGameplayEffectHandle& ActiveHandle)> OnApplied; // 0x01B8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C8[0x10];                                     // 0x01C8(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UAbilityTask_WaitGameplayEffectApplied_Target* WaitGameplayEffectAppliedToTarget(class UGameplayAbility* OwningAbility, const struct FGameplayTargetDataFilterHandle& TargetFilter, const struct FGameplayTagRequirements& SourceTagRequirements, const struct FGameplayTagRequirements& TargetTagRequirements, bool TriggerOnce, class AActor* OptionalExternalOwner, bool ListenForPeriodicEffects)	 // 0x3da84dc;
	static class UAbilityTask_WaitGameplayEffectApplied_Target* WaitGameplayEffectAppliedToTarget_Query(class UGameplayAbility* OwningAbility, const struct FGameplayTargetDataFilterHandle& SourceFilter, const struct FGameplayTagQuery& SourceTagQuery, const struct FGameplayTagQuery& TargetTagQuery, bool TriggerOnce, class AActor* OptionalExternalOwner, bool ListenForPeriodicEffect)	 // 0x3da89a4;

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"AbilityTask_WaitGameplayEffectApplied_Target">();
	}
	static class UAbilityTask_WaitGameplayEffectApplied_Target* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UAbilityTask_WaitGameplayEffectApplied_Target>();
	}
};
static_assert(alignof(UAbilityTask_WaitGameplayEffectApplied_Target) == 0x000008, "Wrong alignment on UAbilityTask_WaitGameplayEffectApplied_Target");
static_assert(sizeof(UAbilityTask_WaitGameplayEffectApplied_Target) == 0x0001D8, "Wrong size on UAbilityTask_WaitGameplayEffectApplied_Target");
static_assert(offsetof(UAbilityTask_WaitGameplayEffectApplied_Target, OnApplied) == 0x0001B8, "Member 'UAbilityTask_WaitGameplayEffectApplied_Target::OnApplied' has a wrong offset!");

// Class GameplayAbilities.AbilityTask_WaitGameplayEffectBlockedImmunity
// 0x00A8 (0x0128 - 0x0080)
class UAbilityTask_WaitGameplayEffectBlockedImmunity final : public UAbilityTask
{
public:
	TMulticastInlineDelegate<void(const struct FGameplayEffectSpecHandle& BlockedSpec, const struct FActiveGameplayEffectHandle& ImmunityGameplayEffectHandle)> bLocked; // 0x0080(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_90[0x88];                                      // 0x0090(0x0088)(Fixing Size After Last Property [ Dumper-7 ])
	class UAbilitySystemComponent*                ExternalOwner;                                     // 0x0118(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_120[0x8];                                      // 0x0120(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UAbilityTask_WaitGameplayEffectBlockedImmunity* WaitGameplayEffectBlockedByImmunity(class UGameplayAbility* OwningAbility, const struct FGameplayTagRequirements& SourceTagRequirements, const struct FGameplayTagRequirements& TargetTagRequirements, class AActor* OptionalExternalTarget, bool OnlyTriggerOnce)	 // 0x3da8ed4;

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"AbilityTask_WaitGameplayEffectBlockedImmunity">();
	}
	static class UAbilityTask_WaitGameplayEffectBlockedImmunity* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UAbilityTask_WaitGameplayEffectBlockedImmunity>();
	}
};
static_assert(alignof(UAbilityTask_WaitGameplayEffectBlockedImmunity) == 0x000008, "Wrong alignment on UAbilityTask_WaitGameplayEffectBlockedImmunity");
static_assert(sizeof(UAbilityTask_WaitGameplayEffectBlockedImmunity) == 0x000128, "Wrong size on UAbilityTask_WaitGameplayEffectBlockedImmunity");
static_assert(offsetof(UAbilityTask_WaitGameplayEffectBlockedImmunity, bLocked) == 0x000080, "Member 'UAbilityTask_WaitGameplayEffectBlockedImmunity::bLocked' has a wrong offset!");
static_assert(offsetof(UAbilityTask_WaitGameplayEffectBlockedImmunity, ExternalOwner) == 0x000118, "Member 'UAbilityTask_WaitGameplayEffectBlockedImmunity::ExternalOwner' has a wrong offset!");

// Class GameplayAbilities.AbilityTask_WaitGameplayEffectRemoved
// 0x0040 (0x00C0 - 0x0080)
class UAbilityTask_WaitGameplayEffectRemoved final : public UAbilityTask
{
public:
	TMulticastInlineDelegate<void(const struct FGameplayEffectRemovalInfo& GameplayEffectRemovalInfo)> OnRemoved; // 0x0080(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(const struct FGameplayEffectRemovalInfo& GameplayEffectRemovalInfo)> InvalidHandle; // 0x0090(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_A0[0x20];                                      // 0x00A0(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UAbilityTask_WaitGameplayEffectRemoved* WaitForGameplayEffectRemoved(class UGameplayAbility* OwningAbility, const struct FActiveGameplayEffectHandle& Handle)	 // 0x3da72d0;

	void OnGameplayEffectRemoved(const struct FGameplayEffectRemovalInfo& InGameplayEffectRemovalInfo)	 // 0x3da223c;

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"AbilityTask_WaitGameplayEffectRemoved">();
	}
	static class UAbilityTask_WaitGameplayEffectRemoved* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UAbilityTask_WaitGameplayEffectRemoved>();
	}
};
static_assert(alignof(UAbilityTask_WaitGameplayEffectRemoved) == 0x000008, "Wrong alignment on UAbilityTask_WaitGameplayEffectRemoved");
static_assert(sizeof(UAbilityTask_WaitGameplayEffectRemoved) == 0x0000C0, "Wrong size on UAbilityTask_WaitGameplayEffectRemoved");
static_assert(offsetof(UAbilityTask_WaitGameplayEffectRemoved, OnRemoved) == 0x000080, "Member 'UAbilityTask_WaitGameplayEffectRemoved::OnRemoved' has a wrong offset!");
static_assert(offsetof(UAbilityTask_WaitGameplayEffectRemoved, InvalidHandle) == 0x000090, "Member 'UAbilityTask_WaitGameplayEffectRemoved::InvalidHandle' has a wrong offset!");

// Class GameplayAbilities.AbilityTask_WaitGameplayEffectStackChange
// 0x0038 (0x00B8 - 0x0080)
class UAbilityTask_WaitGameplayEffectStackChange final : public UAbilityTask
{
public:
	TMulticastInlineDelegate<void(const struct FActiveGameplayEffectHandle& Handle, int32 NewCount, int32 OldCount)> OnChange; // 0x0080(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(const struct FActiveGameplayEffectHandle& Handle, int32 NewCount, int32 OldCount)> InvalidHandle; // 0x0090(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_A0[0x18];                                      // 0x00A0(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UAbilityTask_WaitGameplayEffectStackChange* WaitForGameplayEffectStackChange(class UGameplayAbility* OwningAbility, const struct FActiveGameplayEffectHandle& Handle)	 // 0x3da7414;

	void OnGameplayEffectStackChange(const struct FActiveGameplayEffectHandle& Handle, int32 NewCount, int32 OldCount)	 // 0x3da2330;

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"AbilityTask_WaitGameplayEffectStackChange">();
	}
	static class UAbilityTask_WaitGameplayEffectStackChange* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UAbilityTask_WaitGameplayEffectStackChange>();
	}
};
static_assert(alignof(UAbilityTask_WaitGameplayEffectStackChange) == 0x000008, "Wrong alignment on UAbilityTask_WaitGameplayEffectStackChange");
static_assert(sizeof(UAbilityTask_WaitGameplayEffectStackChange) == 0x0000B8, "Wrong size on UAbilityTask_WaitGameplayEffectStackChange");
static_assert(offsetof(UAbilityTask_WaitGameplayEffectStackChange, OnChange) == 0x000080, "Member 'UAbilityTask_WaitGameplayEffectStackChange::OnChange' has a wrong offset!");
static_assert(offsetof(UAbilityTask_WaitGameplayEffectStackChange, InvalidHandle) == 0x000090, "Member 'UAbilityTask_WaitGameplayEffectStackChange::InvalidHandle' has a wrong offset!");

// Class GameplayAbilities.AbilityTask_WaitGameplayEvent
// 0x0030 (0x00B0 - 0x0080)
class UAbilityTask_WaitGameplayEvent final : public UAbilityTask
{
public:
	TMulticastInlineDelegate<void(const struct FGameplayEventData& Payload)> EventReceived;          // 0x0080(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_90[0x8];                                       // 0x0090(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UAbilitySystemComponent*                OptionalExternalTarget;                            // 0x0098(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A0[0x10];                                      // 0x00A0(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UAbilityTask_WaitGameplayEvent* WaitGameplayEvent(class UGameplayAbility* OwningAbility, const struct FGameplayTag& EventTag, class AActor* OptionalExternalTarget_0, bool OnlyTriggerOnce, bool OnlyMatchExact)	 // 0x3da920c;

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"AbilityTask_WaitGameplayEvent">();
	}
	static class UAbilityTask_WaitGameplayEvent* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UAbilityTask_WaitGameplayEvent>();
	}
};
static_assert(alignof(UAbilityTask_WaitGameplayEvent) == 0x000008, "Wrong alignment on UAbilityTask_WaitGameplayEvent");
static_assert(sizeof(UAbilityTask_WaitGameplayEvent) == 0x0000B0, "Wrong size on UAbilityTask_WaitGameplayEvent");
static_assert(offsetof(UAbilityTask_WaitGameplayEvent, EventReceived) == 0x000080, "Member 'UAbilityTask_WaitGameplayEvent::EventReceived' has a wrong offset!");
static_assert(offsetof(UAbilityTask_WaitGameplayEvent, OptionalExternalTarget) == 0x000098, "Member 'UAbilityTask_WaitGameplayEvent::OptionalExternalTarget' has a wrong offset!");

// Class GameplayAbilities.AbilityTask_WaitGameplayTag
// 0x0028 (0x00A8 - 0x0080)
class UAbilityTask_WaitGameplayTag : public UAbilityTask
{
public:
	uint8                                         Pad_80[0x10];                                      // 0x0080(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class UAbilitySystemComponent*                OptionalExternalTarget;                            // 0x0090(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_98[0x10];                                      // 0x0098(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void GameplayTagCallback(const struct FGameplayTag& Tag, int32 NewCount)	 // 0x3d9c834;

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"AbilityTask_WaitGameplayTag">();
	}
	static class UAbilityTask_WaitGameplayTag* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UAbilityTask_WaitGameplayTag>();
	}
};
static_assert(alignof(UAbilityTask_WaitGameplayTag) == 0x000008, "Wrong alignment on UAbilityTask_WaitGameplayTag");
static_assert(sizeof(UAbilityTask_WaitGameplayTag) == 0x0000A8, "Wrong size on UAbilityTask_WaitGameplayTag");
static_assert(offsetof(UAbilityTask_WaitGameplayTag, OptionalExternalTarget) == 0x000090, "Member 'UAbilityTask_WaitGameplayTag::OptionalExternalTarget' has a wrong offset!");

// Class GameplayAbilities.AbilityTask_WaitGameplayTagAdded
// 0x0010 (0x00B8 - 0x00A8)
class UAbilityTask_WaitGameplayTagAdded final : public UAbilityTask_WaitGameplayTag
{
public:
	TMulticastInlineDelegate<void()>              Added;                                             // 0x00A8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)

public:
	static class UAbilityTask_WaitGameplayTagAdded* WaitGameplayTagAdd(class UGameplayAbility* OwningAbility, const struct FGameplayTag& Tag, class AActor* InOptionalExternalTarget, bool OnlyTriggerOnce)	 // 0x3da94c0;

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"AbilityTask_WaitGameplayTagAdded">();
	}
	static class UAbilityTask_WaitGameplayTagAdded* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UAbilityTask_WaitGameplayTagAdded>();
	}
};
static_assert(alignof(UAbilityTask_WaitGameplayTagAdded) == 0x000008, "Wrong alignment on UAbilityTask_WaitGameplayTagAdded");
static_assert(sizeof(UAbilityTask_WaitGameplayTagAdded) == 0x0000B8, "Wrong size on UAbilityTask_WaitGameplayTagAdded");
static_assert(offsetof(UAbilityTask_WaitGameplayTagAdded, Added) == 0x0000A8, "Member 'UAbilityTask_WaitGameplayTagAdded::Added' has a wrong offset!");

// Class GameplayAbilities.AbilityTask_WaitGameplayTagRemoved
// 0x0010 (0x00B8 - 0x00A8)
class UAbilityTask_WaitGameplayTagRemoved final : public UAbilityTask_WaitGameplayTag
{
public:
	TMulticastInlineDelegate<void()>              Removed;                                           // 0x00A8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)

public:
	static class UAbilityTask_WaitGameplayTagRemoved* WaitGameplayTagRemove(class UGameplayAbility* OwningAbility, const struct FGameplayTag& Tag, class AActor* InOptionalExternalTarget, bool OnlyTriggerOnce)	 // 0x1368034;

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"AbilityTask_WaitGameplayTagRemoved">();
	}
	static class UAbilityTask_WaitGameplayTagRemoved* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UAbilityTask_WaitGameplayTagRemoved>();
	}
};
static_assert(alignof(UAbilityTask_WaitGameplayTagRemoved) == 0x000008, "Wrong alignment on UAbilityTask_WaitGameplayTagRemoved");
static_assert(sizeof(UAbilityTask_WaitGameplayTagRemoved) == 0x0000B8, "Wrong size on UAbilityTask_WaitGameplayTagRemoved");
static_assert(offsetof(UAbilityTask_WaitGameplayTagRemoved, Removed) == 0x0000A8, "Member 'UAbilityTask_WaitGameplayTagRemoved::Removed' has a wrong offset!");

// Class GameplayAbilities.AbilityTask_WaitGameplayTagQuery
// 0x00E0 (0x0160 - 0x0080)
class UAbilityTask_WaitGameplayTagQuery final : public UAbilityTask
{
public:
	uint8                                         Pad_80[0xC0];                                      // 0x0080(0x00C0)(Fixing Size After Last Property [ Dumper-7 ])
	TMulticastInlineDelegate<void()>              Triggered;                                         // 0x0140(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, Protected, NativeAccessSpecifierProtected)
	class UAbilitySystemComponent*                OptionalExternalTarget;                            // 0x0150(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_158[0x8];                                      // 0x0158(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UAbilityTask_WaitGameplayTagQuery* WaitGameplayTagQuery(class UGameplayAbility* OwningAbility, const struct FGameplayTagQuery& TagQuery, const class AActor* InOptionalExternalTarget, const EWaitGameplayTagQueryTriggerCondition TriggerCondition, const bool bOnlyTriggerOnce)	 // 0x3da98d8;

	void UpdateTargetTags(const struct FGameplayTag& Tag, int32 NewCount)	 // 0x3da4974;

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"AbilityTask_WaitGameplayTagQuery">();
	}
	static class UAbilityTask_WaitGameplayTagQuery* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UAbilityTask_WaitGameplayTagQuery>();
	}
};
static_assert(alignof(UAbilityTask_WaitGameplayTagQuery) == 0x000008, "Wrong alignment on UAbilityTask_WaitGameplayTagQuery");
static_assert(sizeof(UAbilityTask_WaitGameplayTagQuery) == 0x000160, "Wrong size on UAbilityTask_WaitGameplayTagQuery");
static_assert(offsetof(UAbilityTask_WaitGameplayTagQuery, Triggered) == 0x000140, "Member 'UAbilityTask_WaitGameplayTagQuery::Triggered' has a wrong offset!");
static_assert(offsetof(UAbilityTask_WaitGameplayTagQuery, OptionalExternalTarget) == 0x000150, "Member 'UAbilityTask_WaitGameplayTagQuery::OptionalExternalTarget' has a wrong offset!");

// Class GameplayAbilities.AbilityTask_WaitInputPress
// 0x0020 (0x00A0 - 0x0080)
class UAbilityTask_WaitInputPress final : public UAbilityTask
{
public:
	TMulticastInlineDelegate<void(float TimeWaited)> OnPress;                                        // 0x0080(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_90[0x10];                                      // 0x0090(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UAbilityTask_WaitInputPress* WaitInputPress(class UGameplayAbility* OwningAbility, bool bTestAlreadyPressed)	 // 0x3daa0d8;

	void OnPressCallback()	 // 0x3da2e20;

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"AbilityTask_WaitInputPress">();
	}
	static class UAbilityTask_WaitInputPress* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UAbilityTask_WaitInputPress>();
	}
};
static_assert(alignof(UAbilityTask_WaitInputPress) == 0x000008, "Wrong alignment on UAbilityTask_WaitInputPress");
static_assert(sizeof(UAbilityTask_WaitInputPress) == 0x0000A0, "Wrong size on UAbilityTask_WaitInputPress");
static_assert(offsetof(UAbilityTask_WaitInputPress, OnPress) == 0x000080, "Member 'UAbilityTask_WaitInputPress::OnPress' has a wrong offset!");

// Class GameplayAbilities.AbilityTask_WaitInputRelease
// 0x0020 (0x00A0 - 0x0080)
class UAbilityTask_WaitInputRelease final : public UAbilityTask
{
public:
	TMulticastInlineDelegate<void(float TimeHeld)> OnRelease;                                        // 0x0080(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_90[0x10];                                      // 0x0090(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UAbilityTask_WaitInputRelease* WaitInputRelease(class UGameplayAbility* OwningAbility, bool bTestAlreadyReleased)	 // 0x3daa25c;

	void OnReleaseCallback()	 // 0x3da2e34;

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"AbilityTask_WaitInputRelease">();
	}
	static class UAbilityTask_WaitInputRelease* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UAbilityTask_WaitInputRelease>();
	}
};
static_assert(alignof(UAbilityTask_WaitInputRelease) == 0x000008, "Wrong alignment on UAbilityTask_WaitInputRelease");
static_assert(sizeof(UAbilityTask_WaitInputRelease) == 0x0000A0, "Wrong size on UAbilityTask_WaitInputRelease");
static_assert(offsetof(UAbilityTask_WaitInputRelease, OnRelease) == 0x000080, "Member 'UAbilityTask_WaitInputRelease::OnRelease' has a wrong offset!");

// Class GameplayAbilities.AbilityTask_WaitMovementModeChange
// 0x0020 (0x00A0 - 0x0080)
class UAbilityTask_WaitMovementModeChange final : public UAbilityTask
{
public:
	TMulticastInlineDelegate<void(EMovementMode NewMovementMode)> OnChange;                          // 0x0080(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_90[0x10];                                      // 0x0090(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UAbilityTask_WaitMovementModeChange* CreateWaitMovementModeChange(class UGameplayAbility* OwningAbility, EMovementMode NewMode)	 // 0x3d99584;

	void OnMovementModeChange(class ACharacter* Character, EMovementMode PrevMovementMode, uint8 PreviousCustomMode)	 // 0x3da2c0c;

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"AbilityTask_WaitMovementModeChange">();
	}
	static class UAbilityTask_WaitMovementModeChange* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UAbilityTask_WaitMovementModeChange>();
	}
};
static_assert(alignof(UAbilityTask_WaitMovementModeChange) == 0x000008, "Wrong alignment on UAbilityTask_WaitMovementModeChange");
static_assert(sizeof(UAbilityTask_WaitMovementModeChange) == 0x0000A0, "Wrong size on UAbilityTask_WaitMovementModeChange");
static_assert(offsetof(UAbilityTask_WaitMovementModeChange, OnChange) == 0x000080, "Member 'UAbilityTask_WaitMovementModeChange::OnChange' has a wrong offset!");

// Class GameplayAbilities.AbilityTask_WaitOverlap
// 0x0010 (0x0090 - 0x0080)
class UAbilityTask_WaitOverlap final : public UAbilityTask
{
public:
	TMulticastInlineDelegate<void(const struct FGameplayAbilityTargetDataHandle& TargetData)> OnOverlap; // 0x0080(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)

public:
	static class UAbilityTask_WaitOverlap* WaitForOverlap(class UGameplayAbility* OwningAbility)	 // 0x3da7598;

	void OnHitCallback(class UPrimitiveComponent* HitComp, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, const struct FVector& NormalImpulse, const struct FHitResult& Hit)	 // 0x3da24ec;

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"AbilityTask_WaitOverlap">();
	}
	static class UAbilityTask_WaitOverlap* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UAbilityTask_WaitOverlap>();
	}
};
static_assert(alignof(UAbilityTask_WaitOverlap) == 0x000008, "Wrong alignment on UAbilityTask_WaitOverlap");
static_assert(sizeof(UAbilityTask_WaitOverlap) == 0x000090, "Wrong size on UAbilityTask_WaitOverlap");
static_assert(offsetof(UAbilityTask_WaitOverlap, OnOverlap) == 0x000080, "Member 'UAbilityTask_WaitOverlap::OnOverlap' has a wrong offset!");

// Class GameplayAbilities.AbilitySystemBlueprintLibrary
// 0x0000 (0x0028 - 0x0028)
class UAbilitySystemBlueprintLibrary final : public UBlueprintFunctionLibrary
{
public:
	static struct FGameplayAbilityTargetDataHandle AbilityTargetDataFromActor(class AActor* Actor)	 // 0x3d93478;
	static struct FGameplayAbilityTargetDataHandle AbilityTargetDataFromActorArray(const TArray<class AActor*>& ActorArray, bool OneTargetPerHandle)	 // 0x3d93570;
	static struct FGameplayAbilityTargetDataHandle AbilityTargetDataFromHitResult(const struct FHitResult& HitResult)	 // 0x3d936d0;
	static struct FGameplayAbilityTargetDataHandle AbilityTargetDataFromLocations(const struct FGameplayAbilityTargetingLocationInfo& SourceLocation, const struct FGameplayAbilityTargetingLocationInfo& TargetLocation)	 // 0x3d937a8;
	static struct FGameplayEffectSpecHandle AddAssetTag(const struct FGameplayEffectSpecHandle& SpecHandle, const struct FGameplayTag& NewGameplayTag)	 // 0x3d938d8;
	static struct FGameplayEffectSpecHandle AddAssetTags(const struct FGameplayEffectSpecHandle& SpecHandle, const struct FGameplayTagContainer& NewGameplayTags)	 // 0x3d93ae0;
	static struct FGameplayEffectSpecHandle AddGrantedTag(const struct FGameplayEffectSpecHandle& SpecHandle, const struct FGameplayTag& NewGameplayTag)	 // 0x3d93dec;
	static struct FGameplayEffectSpecHandle AddGrantedTags(const struct FGameplayEffectSpecHandle& SpecHandle, const struct FGameplayTagContainer& NewGameplayTags)	 // 0x3d93ff8;
	static struct FGameplayEffectSpecHandle AddLinkedGameplayEffect(const struct FGameplayEffectSpecHandle& SpecHandle, TSubclassOf<class UGameplayEffect> LinkedGameplayEffect)	 // 0x3d94308;
	static struct FGameplayEffectSpecHandle AddLinkedGameplayEffectSpec(const struct FGameplayEffectSpecHandle& SpecHandle, const struct FGameplayEffectSpecHandle& LinkedGameplayEffectSpec)	 // 0x3d946ac;
	static bool AddLooseGameplayTags(class AActor* Actor, const struct FGameplayTagContainer& GameplayTags, bool bShouldReplicate)	 // 0x3d9495c;
	static struct FGameplayAbilityTargetDataHandle AppendTargetDataHandle(const struct FGameplayAbilityTargetDataHandle& TargetHandle, const struct FGameplayAbilityTargetDataHandle& HandleToAdd)	 // 0x3d94b14;
	static struct FGameplayEffectSpecHandle AssignSetByCallerMagnitude(const struct FGameplayEffectSpecHandle& SpecHandle, class FName DataName, float Magnitude)	 // 0x3d97bb0;
	static struct FGameplayEffectSpecHandle AssignTagSetByCallerMagnitude(const struct FGameplayEffectSpecHandle& SpecHandle, const struct FGameplayTag& DataTag, float Magnitude)	 // 0x3d97e2c;
	static void BreakGameplayCueParameters(const struct FGameplayCueParameters& Parameters, float* NormalizedMagnitude, float* RawMagnitude, struct FGameplayEffectContextHandle* EffectContext, struct FGameplayTag* MatchedTagName, struct FGameplayTag* OriginalTag, struct FGameplayTagContainer* AggregatedSourceTags, struct FGameplayTagContainer* AggregatedTargetTags, struct FVector* Location, struct FVector* Normal, class AActor** Instigator, class AActor** EffectCauser, class UObject** SourceObject, class UPhysicalMaterial** PhysicalMaterial, int32* GameplayEffectLevel, int32* AbilityLevel, class USceneComponent** TargetAttachComponent, bool* bReplicateLocationWhenUsingMinimalRepProxy)	 // 0xb152ec;
	static struct FGameplayEffectSpecHandle CloneSpecHandle(class AActor* InNewInstigator, class AActor* InEffectCauser, const struct FGameplayEffectSpecHandle& GameplayEffectSpecHandle_Clone)	 // 0x3d98db8;
	static bool DoesGameplayCueMeetTagRequirements(const struct FGameplayCueParameters& Parameters, const struct FGameplayTagRequirements& SourceTagReqs, const struct FGameplayTagRequirements& TargetTagReqs)	 // 0x3d998d0;
	static bool DoesTargetDataContainActor(const struct FGameplayAbilityTargetDataHandle& TargetData, int32 Index_0, class AActor* Actor)	 // 0x3d99ae8;
	static void EffectContextAddHitResult(const struct FGameplayEffectContextHandle& EffectContext, const struct FHitResult& HitResult, bool bReset)	 // 0x3d99d6c;
	static class AActor* EffectContextGetEffectCauser(const struct FGameplayEffectContextHandle& EffectContext)	 // 0x3d9a010;
	static struct FHitResult EffectContextGetHitResult(const struct FGameplayEffectContextHandle& EffectContext)	 // 0x120154c;
	static class AActor* EffectContextGetInstigatorActor(const struct FGameplayEffectContextHandle& EffectContext)	 // 0x3d9a1a0;
	static struct FVector EffectContextGetOrigin(const struct FGameplayEffectContextHandle& EffectContext)	 // 0x3d9a330;
	static class AActor* EffectContextGetOriginalInstigatorActor(const struct FGameplayEffectContextHandle& EffectContext)	 // 0x3d9a500;
	static class UObject* EffectContextGetSourceObject(const struct FGameplayEffectContextHandle& EffectContext)	 // 0x3d9a690;
	static bool EffectContextHasHitResult(const struct FGameplayEffectContextHandle& EffectContext)	 // 0x3d9a820;
	static bool EffectContextIsInstigatorLocallyControlled(const struct FGameplayEffectContextHandle& EffectContext)	 // 0x3d9a9b4;
	static bool EffectContextIsValid(const struct FGameplayEffectContextHandle& EffectContext)	 // 0x3d9ab48;
	static void EffectContextSetOrigin(const struct FGameplayEffectContextHandle& EffectContext, const struct FVector& Origin)	 // 0x3d9accc;
	static bool EqualEqual_ActiveGameplayEffectHandle(const struct FActiveGameplayEffectHandle& A, const struct FActiveGameplayEffectHandle& B)	 // 0x3d9b07c;
	static bool EqualEqual_GameplayAbilitySpecHandle(const struct FGameplayAbilitySpecHandle& A, const struct FGameplayAbilitySpecHandle& B)	 // 0x3d9b16c;
	static bool EqualEqual_GameplayAttributeGameplayAttribute(const struct FGameplayAttribute& AttributeA, const struct FGameplayAttribute& AttributeB)	 // 0x3d9b254;
	static float EvaluateAttributeValueWithTags(class UAbilitySystemComponent* AbilitySystem, const struct FGameplayAttribute& Attribute, const struct FGameplayTagContainer& SourceTags, const struct FGameplayTagContainer& TargetTags, bool* bSuccess)	 // 0x3d9b468;
	static float EvaluateAttributeValueWithTagsAndBase(class UAbilitySystemComponent* AbilitySystem, const struct FGameplayAttribute& Attribute, const struct FGameplayTagContainer& SourceTags, const struct FGameplayTagContainer& TargetTags, float BaseValue, bool* bSuccess)	 // 0x3d9b850;
	static struct FGameplayAbilityTargetDataHandle FilterTargetData(const struct FGameplayAbilityTargetDataHandle& TargetDataHandle, const struct FGameplayTargetDataFilterHandle& ActorFilterClass)	 // 0x3d9bd8c;
	static void ForwardGameplayCueToTarget(TScriptInterface<class IGameplayCueInterface> TargetCueInterface, EGameplayCueEvent EventType, const struct FGameplayCueParameters& Parameters)	 // 0x3d9c614;
	static class UAbilitySystemComponent* GetAbilitySystemComponent(class AActor* Actor)	 // 0xd2746c;
	static class FString GetActiveGameplayEffectDebugString(const struct FActiveGameplayEffectHandle& ActiveHandle)	 // 0x3d9cae8;
	static float GetActiveGameplayEffectExpectedEndTime(const struct FActiveGameplayEffectHandle& ActiveHandle)	 // 0x3d9cc08;
	static float GetActiveGameplayEffectRemainingDuration(class UObject* WorldContextObject, const struct FActiveGameplayEffectHandle& ActiveHandle)	 // 0x3d9ccd0;
	static int32 GetActiveGameplayEffectStackCount(const struct FActiveGameplayEffectHandle& ActiveHandle)	 // 0x3d9ce14;
	static int32 GetActiveGameplayEffectStackLimitCount(const struct FActiveGameplayEffectHandle& ActiveHandle)	 // 0x3d9cef8;
	static float GetActiveGameplayEffectStartTime(const struct FActiveGameplayEffectHandle& ActiveHandle)	 // 0x3d9cff0;
	static float GetActiveGameplayEffectTotalDuration(const struct FActiveGameplayEffectHandle& ActiveHandle)	 // 0x3d9d0b8;
	static class AActor* GetActorByIndex(const struct FGameplayCueParameters& Parameters, int32 Index_0)	 // 0x3d9d180;
	static int32 GetActorCount(const struct FGameplayCueParameters& Parameters)	 // 0x3d9d348;
	static TArray<class AActor*> GetActorsFromTargetData(const struct FGameplayAbilityTargetDataHandle& TargetData, int32 Index_0)	 // 0x3d9d454;
	static TArray<class AActor*> GetAllActorsFromTargetData(const struct FGameplayAbilityTargetDataHandle& TargetData)	 // 0x3d9d618;
	static TArray<struct FGameplayEffectSpecHandle> GetAllLinkedGameplayEffectSpecHandles(const struct FGameplayEffectSpecHandle& SpecHandle)	 // 0x3d9d6f4;
	static int32 GetDataCountFromTargetData(const struct FGameplayAbilityTargetDataHandle& TargetData)	 // 0x3d9da84;
	static class FString GetDebugStringFromGameplayAttribute(const struct FGameplayAttribute& Attribute)	 // 0x3d9db44;
	static struct FGameplayEffectContextHandle GetEffectContext(const struct FGameplayEffectSpecHandle& SpecHandle)	 // 0x3d9dc34;
	static float GetFloatAttribute(const class AActor* Actor, const struct FGameplayAttribute& Attribute, bool* bSuccessfullyFoundAttribute)	 // 0x15e953c;
	static float GetFloatAttributeBase(const class AActor* Actor, const struct FGameplayAttribute& Attribute, bool* bSuccessfullyFoundAttribute)	 // 0x3d9de3c;
	static float GetFloatAttributeBaseFromAbilitySystemComponent(const class UAbilitySystemComponent* AbilitySystemComponent, const struct FGameplayAttribute& Attribute, bool* bSuccessfullyFoundAttribute)	 // 0x3d9e020;
	static float GetFloatAttributeFromAbilitySystemComponent(const class UAbilitySystemComponent* AbilitySystem, const struct FGameplayAttribute& Attribute, bool* bSuccessfullyFoundAttribute)	 // 0x15e97a4;
	static const class UGameplayAbility* GetGameplayAbilityFromSpecHandle(class UAbilitySystemComponent* AbilitySystem, const struct FGameplayAbilitySpecHandle& AbilitySpecHandle, bool* bIsInstance)	 // 0x3d9e204;
	static bool GetGameplayCueDirection(class AActor* TargetActor, const struct FGameplayCueParameters& Parameters, struct FVector* Direction)	 // 0x3d9e3e0;
	static bool GetGameplayCueEndLocationAndNormal(class AActor* TargetActor, const struct FGameplayCueParameters& Parameters, struct FVector* Location, struct FVector* Normal)	 // 0x3d9e5a4;
	static const class UGameplayEffect* GetGameplayEffectFromActiveEffectHandle(const struct FActiveGameplayEffectHandle& ActiveHandle)	 // 0x3d9e7b8;
	static const class UGameplayEffectUIData* GetGameplayEffectUIData(TSubclassOf<class UGameplayEffect> EffectClass, TSubclassOf<class UGameplayEffectUIData> DataType)	 // 0x3d9e860;
	static struct FHitResult GetHitResult(const struct FGameplayCueParameters& Parameters)	 // 0x3d9e9dc;
	static struct FHitResult GetHitResultFromTargetData(const struct FGameplayAbilityTargetDataHandle& HitResult, int32 Index_0)	 // 0x3d9eb94;
	static class AActor* GetInstigatorActor(const struct FGameplayCueParameters& Parameters)	 // 0x3d9ee20;
	static struct FTransform GetInstigatorTransform(const struct FGameplayCueParameters& Parameters)	 // 0x3d9ef08;
	static float GetModifiedAttributeMagnitude(const struct FGameplayEffectSpecHandle& SpecHandle, const struct FGameplayAttribute& Attribute)	 // 0x3d9f024;
	static struct FVector GetOrigin(const struct FGameplayCueParameters& Parameters)	 // 0x3d9f2ec;
	static struct FVector GetTargetDataEndPoint(const struct FGameplayAbilityTargetDataHandle& TargetData, int32 Index_0)	 // 0x3d9f5b0;
	static struct FTransform GetTargetDataEndPointTransform(const struct FGameplayAbilityTargetDataHandle& TargetData, int32 Index_0)	 // 0x3d9f774;
	static struct FTransform GetTargetDataOrigin(const struct FGameplayAbilityTargetDataHandle& TargetData, int32 Index_0)	 // 0x3d9f9b0;
	static bool HasHitResult(const struct FGameplayCueParameters& Parameters)	 // 0x3d9fba4;
	static bool IsInstigatorLocallyControlled(const struct FGameplayCueParameters& Parameters)	 // 0x3d9fd10;
	static bool IsInstigatorLocallyControlledPlayer(const struct FGameplayCueParameters& Parameters)	 // 0x3d9fe04;
	static bool IsValid(const struct FGameplayAttribute& Attribute)	 // 0x3d9fef8;
	static struct FGameplayTargetDataFilterHandle MakeFilterHandle(const struct FGameplayTargetDataFilter& Filter, class AActor* FilterActor)	 // 0x3da0b70;
	static struct FGameplayCueParameters MakeGameplayCueParameters(float NormalizedMagnitude, float RawMagnitude, const struct FGameplayEffectContextHandle& EffectContext, const struct FGameplayTag& MatchedTagName, const struct FGameplayTag& OriginalTag, const struct FGameplayTagContainer& AggregatedSourceTags, const struct FGameplayTagContainer& AggregatedTargetTags, const struct FVector& Location, const struct FVector& Normal, class AActor* Instigator, class AActor* EffectCauser, class UObject* SourceObject, class UPhysicalMaterial* PhysicalMaterial, int32 GameplayEffectLevel, int32 AbilityLevel, class USceneComponent* TargetAttachComponent, bool bReplicateLocationWhenUsingMinimalRepProxy)	 // 0xa2b734;
	static struct FGameplayEffectSpecHandle MakeSpecHandle(class UGameplayEffect* InGameplayEffect, class AActor* InInstigator, class AActor* InEffectCauser, float InLevel)	 // 0x3da0e7c;
	static bool NotEqual_ActiveGameplayEffectHandle(const struct FActiveGameplayEffectHandle& A, const struct FActiveGameplayEffectHandle& B)	 // 0x3da19a0;
	static bool NotEqual_GameplayAbilitySpecHandle(const struct FGameplayAbilitySpecHandle& A, const struct FGameplayAbilitySpecHandle& B)	 // 0x3da1a90;
	static bool NotEqual_GameplayAttributeGameplayAttribute(const struct FGameplayAttribute& AttributeA, const struct FGameplayAttribute& AttributeB)	 // 0x3da1b78;
	static bool RemoveLooseGameplayTags(class AActor* Actor, const struct FGameplayTagContainer& GameplayTags, bool bShouldReplicate)	 // 0x3da3334;
	static void SendGameplayEventToActor(class AActor* Actor, const struct FGameplayTag& EventTag, const struct FGameplayEventData& Payload)	 // 0x170ebe4;
	static struct FGameplayEffectSpecHandle SetDuration(const struct FGameplayEffectSpecHandle& SpecHandle, float Duration)	 // 0x3da37a8;
	static struct FGameplayEffectSpecHandle SetStackCount(const struct FGameplayEffectSpecHandle& SpecHandle, int32 StackCount)	 // 0x3da3a70;
	static struct FGameplayEffectSpecHandle SetStackCountToMax(const struct FGameplayEffectSpecHandle& SpecHandle)	 // 0x3da3c68;
	static bool TargetDataHasActor(const struct FGameplayAbilityTargetDataHandle& TargetData, int32 Index_0)	 // 0x3da41d4;
	static bool TargetDataHasEndPoint(const struct FGameplayAbilityTargetDataHandle& TargetData, int32 Index_0)	 // 0x3da43c0;
	static bool TargetDataHasHitResult(const struct FGameplayAbilityTargetDataHandle& HitResult, int32 Index_0)	 // 0x3da45ac;
	static bool TargetDataHasOrigin(const struct FGameplayAbilityTargetDataHandle& TargetData, int32 Index_0)	 // 0x3da4788;

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"AbilitySystemBlueprintLibrary">();
	}
	static class UAbilitySystemBlueprintLibrary* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UAbilitySystemBlueprintLibrary>();
	}
};
static_assert(alignof(UAbilitySystemBlueprintLibrary) == 0x000008, "Wrong alignment on UAbilitySystemBlueprintLibrary");
static_assert(sizeof(UAbilitySystemBlueprintLibrary) == 0x000028, "Wrong size on UAbilitySystemBlueprintLibrary");

// Class GameplayAbilities.AbilitySystemComponent
// 0x13B0 (0x14E8 - 0x0138)
class UAbilitySystemComponent : public UGameplayTasksComponent
{
public:
	uint8                                         Pad_138[0x10];                                     // 0x0138(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FAttributeDefaults>             DefaultStartingData;                               // 0x0148(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	class FName                                   AffectedAnimInstanceTag;                           // 0x0158(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_160[0x1A0];                                    // 0x0160(0x01A0)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         OutgoingDuration;                                  // 0x0300(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         IncomingDuration;                                  // 0x0304(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_308[0x20];                                     // 0x0308(0x0020)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class FString>                         ClientDebugStrings;                                // 0x0328(0x0010)(Net, ZeroConstructor, RepNotify, NativeAccessSpecifierPublic)
	TArray<class FString>                         ServerDebugStrings;                                // 0x0338(0x0010)(Net, ZeroConstructor, RepNotify, NativeAccessSpecifierPublic)
	uint8                                         Pad_348[0x60];                                     // 0x0348(0x0060)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          UserAbilityActivationInhibited;                    // 0x03A8(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReplicationProxyEnabled;                           // 0x03A9(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bSuppressGrantAbility;                             // 0x03AA(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bSuppressGameplayCues;                             // 0x03AB(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3AC[0x4];                                      // 0x03AC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class AGameplayAbilityTargetActor*>    SpawnedTargetActors;                               // 0x03B0(0x0010)(ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
	uint8                                         Pad_3C0[0x28];                                     // 0x03C0(0x0028)(Fixing Size After Last Property [ Dumper-7 ])
	class AActor*                                 OwnerActor;                                        // 0x03E8(0x0008)(Net, ZeroConstructor, RepNotify, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class AActor*                                 AvatarActor;                                       // 0x03F0(0x0008)(Net, ZeroConstructor, RepNotify, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_3F8[0x10];                                     // 0x03F8(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayAbilitySpecContainer          ActivatableAbilities;                              // 0x0408(0x0120)(BlueprintVisible, BlueprintReadOnly, Net, RepNotify, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_528[0x30];                                     // 0x0528(0x0030)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UGameplayAbility*>               AllReplicatedInstancedAbilities;                   // 0x0558(0x0010)(ZeroConstructor, Protected, UObjectWrapper, NativeAccessSpecifierProtected)
	uint8                                         Pad_568[0x210];                                    // 0x0568(0x0210)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayAbilityRepAnimMontage         RepAnimMontageInfo;                                // 0x0778(0x0038)(Net, RepNotify, NoDestructor, Protected, NativeAccessSpecifierProtected)
	bool                                          bCachedIsNetSimulated;                             // 0x07B0(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bPendingMontageRep;                                // 0x07B1(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_7B2[0x6];                                      // 0x07B2(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayAbilityLocalAnimMontage       LocalAnimMontageInfo;                              // 0x07B8(0x0030)(NoDestructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_7E8[0xA0];                                     // 0x07E8(0x00A0)(Fixing Size After Last Property [ Dumper-7 ])
	struct FActiveGameplayEffectsContainer        ActiveGameplayEffects;                             // 0x0888(0x0478)(Net, Protected, NativeAccessSpecifierProtected)
	struct FActiveGameplayCueContainer            ActiveGameplayCues;                                // 0x0D00(0x0128)(Net, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	struct FActiveGameplayCueContainer            MinimalReplicationGameplayCues;                    // 0x0E28(0x0128)(Net, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	struct FActiveGameplayCueContainer            ProxiedGameplayCues;                               // 0x0F50(0x0128)(Net, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_1078[0x128];                                   // 0x1078(0x0128)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<uint8>                                 BlockedAbilityBindings;                            // 0x11A0(0x0010)(Net, ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_11B0[0x128];                                   // 0x11B0(0x0128)(Fixing Size After Last Property [ Dumper-7 ])
	struct FMinimalReplicationTagCountMap         MinimalReplicationTags;                            // 0x12D8(0x0060)(Net, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	TArray<class UAttributeSet*>                  SpawnedAttributes;                                 // 0x1338(0x0010)(ExportObject, Net, ZeroConstructor, RepNotify, ContainsInstancedReference, UObjectWrapper, NativeAccessSpecifierPrivate)
	uint8                                         Pad_1348[0x10];                                    // 0x1348(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	struct FMinimalReplicationTagCountMap         ReplicatedLooseTags;                               // 0x1358(0x0060)(Net, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	uint8                                         Pad_13B8[0x8];                                     // 0x13B8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FReplicatedPredictionKeyMap            ReplicatedPredictionKeyMap;                        // 0x13C0(0x0118)(Net, NativeAccessSpecifierPublic)
	uint8                                         Pad_14D8[0x10];                                    // 0x14D8(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	struct FActiveGameplayEffectHandle BP_ApplyGameplayEffectSpecToSelf(const struct FGameplayEffectSpecHandle& SpecHandle)	 // 0x3dca55c;
	struct FActiveGameplayEffectHandle BP_ApplyGameplayEffectSpecToTarget(const struct FGameplayEffectSpecHandle& SpecHandle, class UAbilitySystemComponent* Target)	 // 0x3dca690;
	struct FActiveGameplayEffectHandle BP_ApplyGameplayEffectToSelf(TSubclassOf<class UGameplayEffect> GameplayEffectClass, float Level, const struct FGameplayEffectContextHandle& EffectContext)	 // 0x171cb88;
	struct FActiveGameplayEffectHandle BP_ApplyGameplayEffectToTarget(TSubclassOf<class UGameplayEffect> GameplayEffectClass, class UAbilitySystemComponent* Target, float Level, const struct FGameplayEffectContextHandle& Context)	 // 0x3dca8b8;
	void ClearAbility(const struct FGameplayAbilitySpecHandle& Handle)	 // 0x3dcadec;
	void ClearAllAbilities()	 // 0x3dcae78;
	void ClearAllAbilitiesWithInputID(int32 InputID)	 // 0x3dcae8c;
	void ClientActivateAbilityFailed(const struct FGameplayAbilitySpecHandle& AbilityToActivate, int16 PredictionKey)	 // 0x13308c0;
	void ClientActivateAbilitySucceed(const struct FGameplayAbilitySpecHandle& AbilityToActivate, const struct FPredictionKey& PredictionKey)	 // 0x16d3cf0;
	void ClientActivateAbilitySucceedWithEventData(const struct FGameplayAbilitySpecHandle& AbilityToActivate, const struct FPredictionKey& PredictionKey, const struct FGameplayEventData& TriggerEventData)	 // 0x11d7734;
	void ClientCancelAbility(const struct FGameplayAbilitySpecHandle& AbilityToCancel, const struct FGameplayAbilityActivationInfo& ActivationInfo)	 // 0x17dc2f0;
	void ClientEndAbility(const struct FGameplayAbilitySpecHandle& AbilityToEnd, const struct FGameplayAbilityActivationInfo& ActivationInfo)	 // 0x1009ffc;
	void ClientPrintDebug_Response(const TArray<class FString>& Strings, int32 GameFlags)	 // 0x3dcafa4;
	void ClientSetReplicatedEvent(EAbilityGenericReplicatedEvent EventType, const struct FGameplayAbilitySpecHandle& AbilityHandle, const struct FPredictionKey& AbilityOriginalPredictionKey)	 // 0x17618a4;
	void ClientTryActivateAbility(const struct FGameplayAbilitySpecHandle& AbilityToActivate)	 // 0x3dcb130;
	void GetAllAttributes(TArray<struct FGameplayAttribute>* OutAttributes)	 // 0x3dcbaf0;
	void InputCancel()	 // 0x3dcc484;
	void InputConfirm()	 // 0x3dcc49c;
	struct FGameplayAbilitySpecHandle K2_GiveAbility(TSubclassOf<class UGameplayAbility> AbilityClass, int32 Level, int32 InputID)	 // 0x3dcc588;
	struct FGameplayAbilitySpecHandle K2_GiveAbilityAndActivateOnce(TSubclassOf<class UGameplayAbility> AbilityClass, int32 Level, int32 InputID)	 // 0x3dcc74c;
	void K2_InitStats(TSubclassOf<class UAttributeSet> Attributes, const class UDataTable* DataTable)	 // 0x3dcc910;
	void NetMulticast_InvokeGameplayCueAdded(const struct FGameplayTag& GameplayCueTag, const struct FPredictionKey& PredictionKey, const struct FGameplayEffectContextHandle& EffectContext)	 // 0x3dccd00;
	void NetMulticast_InvokeGameplayCueAdded_WithParams(const struct FGameplayTag& GameplayCueTag, const struct FPredictionKey& PredictionKey, const struct FGameplayCueParameters& Parameters)	 // 0xf77d2c;
	void NetMulticast_InvokeGameplayCueAddedAndWhileActive_FromSpec(const struct FGameplayEffectSpecForRPC& Spec, const struct FPredictionKey& PredictionKey)	 // 0xf7810c;
	void NetMulticast_InvokeGameplayCueAddedAndWhileActive_WithParams(const struct FGameplayTag& GameplayCueTag, const struct FPredictionKey& PredictionKey, const struct FGameplayCueParameters& GameplayCueParameters)	 // 0x3dccf74;
	void NetMulticast_InvokeGameplayCueExecuted(const struct FGameplayTag& GameplayCueTag, const struct FPredictionKey& PredictionKey, const struct FGameplayEffectContextHandle& EffectContext)	 // 0x3dcd1a4;
	void NetMulticast_InvokeGameplayCueExecuted_FromSpec(const struct FGameplayEffectSpecForRPC& Spec, const struct FPredictionKey& PredictionKey)	 // 0x16ce2dc;
	void NetMulticast_InvokeGameplayCueExecuted_WithParams(const struct FGameplayTag& GameplayCueTag, const struct FPredictionKey& PredictionKey, const struct FGameplayCueParameters& GameplayCueParameters)	 // 0xf789fc;
	void NetMulticast_InvokeGameplayCueRemoved_WithParams(const struct FGameplayTag& GameplayCueTag, const struct FPredictionKey& PredictionKey, const struct FGameplayCueParameters& Parameters)	 // 0xf77ad8;
	void NetMulticast_InvokeGameplayCuesAddedAndWhileActive_WithParams(const struct FGameplayTagContainer& GameplayCueTags, const struct FPredictionKey& PredictionKey, const struct FGameplayCueParameters& GameplayCueParameters)	 // 0x3dcd418;
	void NetMulticast_InvokeGameplayCuesExecuted(const struct FGameplayTagContainer& GameplayCueTags, const struct FPredictionKey& PredictionKey, const struct FGameplayEffectContextHandle& EffectContext)	 // 0x3dcd698;
	void NetMulticast_InvokeGameplayCuesExecuted_WithParams(const struct FGameplayTagContainer& GameplayCueTags, const struct FPredictionKey& PredictionKey, const struct FGameplayCueParameters& GameplayCueParameters)	 // 0x3dcd960;
	void OnAvatarActorDestroyed(class AActor* InActor)	 // 0x14bab84;
	void OnOwnerActorDestroyed(class AActor* InActor)	 // 0x14baac0;
	void OnRep_ActivateAbilities()	 // 0x15cbadc;
	void OnRep_ClientDebugString()	 // 0x180cc6c;
	void OnRep_OwningActor()	 // 0x3dcdbe0;
	void OnRep_ReplicatedAnimMontage()	 // 0x15e338c;
	void OnRep_ServerDebugString()	 // 0x3dcdbf4;
	void OnRep_SpawnedAttributes(const TArray<class UAttributeSet*>& PreviousSpawnedAttributes)	 // 0x3dcdc0c;
	void OnSpawnedAttributesEndPlayed(class AActor* InActor, EEndPlayReason EndPlayReason)	 // 0x3dcdca8;
	void PressInputID(int32 InputID)	 // 0x3dcdde8;
	void ReleaseInputID(int32 InputID)	 // 0x3dcdeac;
	int32 RemoveActiveEffectsWithAppliedTags(const struct FGameplayTagContainer& Tags)	 // 0x3dcdf70;
	int32 RemoveActiveEffectsWithGrantedTags(const struct FGameplayTagContainer& Tags)	 // 0x3dcdf70;
	int32 RemoveActiveEffectsWithSourceTags(const struct FGameplayTagContainer& Tags)	 // 0x3dce0e8;
	int32 RemoveActiveEffectsWithTags(const struct FGameplayTagContainer& Tags)	 // 0x3dce1f8;
	bool RemoveActiveGameplayEffect(const struct FActiveGameplayEffectHandle& Handle, int32 StacksToRemove)	 // 0x3dce308;
	void RemoveActiveGameplayEffectBySourceEffect(TSubclassOf<class UGameplayEffect> GameplayEffect, class UAbilitySystemComponent* InstigatorAbilitySystemComponent, int32 StacksToRemove)	 // 0x3dce460;
	void ServerAbilityRPCBatch(const struct GameplayAbilities::FServerAbilityRPCBatch& BatchInfo)	 // 0x3dce61c;
	void ServerCancelAbility(const struct FGameplayAbilitySpecHandle& AbilityToCancel, const struct FGameplayAbilityActivationInfo& ActivationInfo)	 // 0x3dce848;
	void ServerCurrentMontageJumpToSectionName(class UAnimMontage* ClientAnimMontage, class FName SectionName)	 // 0x3dce9e4;
	void ServerCurrentMontageSetNextSectionName(class UAnimMontage* ClientAnimMontage, float ClientPosition, class FName SectionName, class FName NextSectionName)	 // 0x3dceb60;
	void ServerCurrentMontageSetPlayRate(class UAnimMontage* ClientAnimMontage, float InPlayRate)	 // 0x3dcede0;
	void ServerEndAbility(const struct FGameplayAbilitySpecHandle& AbilityToEnd, const struct FGameplayAbilityActivationInfo& ActivationInfo, const struct FPredictionKey& PredictionKey)	 // 0x3dcef58;
	void ServerPrintDebug_Request()	 // 0x3dcf1b0;
	void ServerPrintDebug_RequestWithStrings(const TArray<class FString>& Strings)	 // 0x3dcf1fc;
	void ServerSetInputPressed(const struct FGameplayAbilitySpecHandle& AbilityHandle)	 // 0x3dcf31c;
	void ServerSetInputReleased(const struct FGameplayAbilitySpecHandle& AbilityHandle)	 // 0x3dcf3fc;
	void ServerSetReplicatedEvent(EAbilityGenericReplicatedEvent EventType, const struct FGameplayAbilitySpecHandle& AbilityHandle, const struct FPredictionKey& AbilityOriginalPredictionKey, const struct FPredictionKey& CurrentPredictionKey)	 // 0x3dcf4dc;
	void ServerSetReplicatedEventWithPayload(EAbilityGenericReplicatedEvent EventType, const struct FGameplayAbilitySpecHandle& AbilityHandle, const struct FPredictionKey& AbilityOriginalPredictionKey, const struct FPredictionKey& CurrentPredictionKey, const struct FVector_NetQuantize100& VectorPayload)	 // 0x3dcf7bc;
	void ServerSetReplicatedTargetData(const struct FGameplayAbilitySpecHandle& AbilityHandle, const struct FPredictionKey& AbilityOriginalPredictionKey, const struct FGameplayAbilityTargetDataHandle& ReplicatedTargetDataHandle, const struct FGameplayTag& ApplicationTag, const struct FPredictionKey& CurrentPredictionKey)	 // 0x3dcfb44;
	void ServerSetReplicatedTargetDataCancelled(const struct FGameplayAbilitySpecHandle& AbilityHandle, const struct FPredictionKey& AbilityOriginalPredictionKey, const struct FPredictionKey& CurrentPredictionKey)	 // 0x3dcfee0;
	void ServerTryActivateAbility(const struct FGameplayAbilitySpecHandle& AbilityToActivate, bool InputPressed, const struct FPredictionKey& PredictionKey)	 // 0x3dd0144;
	void ServerTryActivateAbilityWithEventData(const struct FGameplayAbilitySpecHandle& AbilityToActivate, bool InputPressed, const struct FPredictionKey& PredictionKey, const struct FGameplayEventData& TriggerEventData)	 // 0x3dd0374;
	void SetActiveGameplayEffectLevel(const struct FActiveGameplayEffectHandle& ActiveHandle, int32 NewLevel)	 // 0x3dd0698;
	void SetActiveGameplayEffectLevelUsingQuery(const struct FGameplayEffectQuery& Query, int32 NewLevel)	 // 0x3dd07e0;
	void SetUserAbilityActivationInhibited(bool NewInhibit)	 // 0x3dd096c;
	void TargetCancel()	 // 0x3dd0a34;
	void TargetConfirm()	 // 0x3dd0a4c;
	bool TryActivateAbilitiesByTag(const struct FGameplayTagContainer& GameplayTagContainer, bool bAllowRemoteActivation)	 // 0x3dd0a94;
	bool TryActivateAbility(const struct FGameplayAbilitySpecHandle& AbilityToActivate, bool bAllowRemoteActivation)	 // 0x3dd0be8;
	bool TryActivateAbilityByClass(TSubclassOf<class UGameplayAbility> InAbilityToActivate, bool bAllowRemoteActivation)	 // 0x3dd0d38;
	void UpdateActiveGameplayEffectSetByCallerMagnitude(const struct FActiveGameplayEffectHandle& ActiveHandle, const struct FGameplayTag& SetByCallerTag, float NewValue)	 // 0x3dd0e8c;
	void UpdateActiveGameplayEffectSetByCallerMagnitudes(const struct FActiveGameplayEffectHandle& ActiveHandle, const TMap<struct FGameplayTag, float>& NewSetByCallerValues)	 // 0x3dd1050;

	void FindAllAbilitiesMatchingQuery(TArray<struct FGameplayAbilitySpecHandle>* OutAbilityHandles, const struct FGameplayTagQuery& Query) const	 // 0x3dcb1f4;
	void FindAllAbilitiesWithInputID(TArray<struct FGameplayAbilitySpecHandle>* OutAbilityHandles, int32 InputID) const	 // 0x3dcb400;
	void FindAllAbilitiesWithTags(TArray<struct FGameplayAbilitySpecHandle>* OutAbilityHandles, const struct FGameplayTagContainer& Tags, bool bExactMatch) const	 // 0x3dcb59c;
	TArray<struct FActiveGameplayEffectHandle> GetActiveEffects(const struct FGameplayEffectQuery& Query) const	 // 0x3dcb860;
	TArray<struct FActiveGameplayEffectHandle> GetActiveEffectsWithAllTags(const struct FGameplayTagContainer& Tags) const	 // 0x3dcb928;
	void GetAllAbilities(TArray<struct FGameplayAbilitySpecHandle>* OutAbilityHandles) const	 // 0x3dcba54;
	const class UAttributeSet* GetAttributeSet(TSubclassOf<class UAttributeSet> AttributeSetClass) const	 // 0x3dcbbb0;
	float GetGameplayAttributeValue(const struct FGameplayAttribute& Attribute, bool* bFound) const	 // 0x3dcbc80;
	int32 GetGameplayEffectCount(TSubclassOf<class UGameplayEffect> SourceGameplayEffect, class UAbilitySystemComponent* OptionalInstigatorFilterComponent, bool bEnforceOnGoingCheck) const	 // 0x3dcbdfc;
	int32 GetGameplayEffectCount_IfLoaded(TSoftClassPtr<class UClass> SoftSourceGameplayEffect, class UAbilitySystemComponent* OptionalInstigatorFilterComponent, bool bEnforceOnGoingCheck) const	 // 0x3dcbfbc;
	float GetGameplayEffectMagnitude(const struct FActiveGameplayEffectHandle& Handle, const struct FGameplayAttribute& Attribute) const	 // 0x3dcc1e8;
	int32 GetGameplayTagCount(const struct FGameplayTag& GameplayTag) const	 // 0x3dcc39c;
	bool GetUserAbilityActivationInhibited() const	 // 0x3dcc46c;
	bool IsGameplayCueActive(const struct FGameplayTag& GameplayCueTag) const	 // 0x3dcc4b4;
	struct FGameplayEffectContextHandle MakeEffectContext() const	 // 0x3dcca50;
	struct FGameplayEffectSpecHandle MakeOutgoingSpec(TSubclassOf<class UGameplayEffect> GameplayEffectClass, float Level, const struct FGameplayEffectContextHandle& Context) const	 // 0x3dcca90;

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"AbilitySystemComponent">();
	}
	static class UAbilitySystemComponent* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UAbilitySystemComponent>();
	}
};
static_assert(alignof(UAbilitySystemComponent) == 0x000008, "Wrong alignment on UAbilitySystemComponent");
static_assert(sizeof(UAbilitySystemComponent) == 0x0014E8, "Wrong size on UAbilitySystemComponent");
static_assert(offsetof(UAbilitySystemComponent, DefaultStartingData) == 0x000148, "Member 'UAbilitySystemComponent::DefaultStartingData' has a wrong offset!");
static_assert(offsetof(UAbilitySystemComponent, AffectedAnimInstanceTag) == 0x000158, "Member 'UAbilitySystemComponent::AffectedAnimInstanceTag' has a wrong offset!");
static_assert(offsetof(UAbilitySystemComponent, OutgoingDuration) == 0x000300, "Member 'UAbilitySystemComponent::OutgoingDuration' has a wrong offset!");
static_assert(offsetof(UAbilitySystemComponent, IncomingDuration) == 0x000304, "Member 'UAbilitySystemComponent::IncomingDuration' has a wrong offset!");
static_assert(offsetof(UAbilitySystemComponent, ClientDebugStrings) == 0x000328, "Member 'UAbilitySystemComponent::ClientDebugStrings' has a wrong offset!");
static_assert(offsetof(UAbilitySystemComponent, ServerDebugStrings) == 0x000338, "Member 'UAbilitySystemComponent::ServerDebugStrings' has a wrong offset!");
static_assert(offsetof(UAbilitySystemComponent, UserAbilityActivationInhibited) == 0x0003A8, "Member 'UAbilitySystemComponent::UserAbilityActivationInhibited' has a wrong offset!");
static_assert(offsetof(UAbilitySystemComponent, ReplicationProxyEnabled) == 0x0003A9, "Member 'UAbilitySystemComponent::ReplicationProxyEnabled' has a wrong offset!");
static_assert(offsetof(UAbilitySystemComponent, bSuppressGrantAbility) == 0x0003AA, "Member 'UAbilitySystemComponent::bSuppressGrantAbility' has a wrong offset!");
static_assert(offsetof(UAbilitySystemComponent, bSuppressGameplayCues) == 0x0003AB, "Member 'UAbilitySystemComponent::bSuppressGameplayCues' has a wrong offset!");
static_assert(offsetof(UAbilitySystemComponent, SpawnedTargetActors) == 0x0003B0, "Member 'UAbilitySystemComponent::SpawnedTargetActors' has a wrong offset!");
static_assert(offsetof(UAbilitySystemComponent, OwnerActor) == 0x0003E8, "Member 'UAbilitySystemComponent::OwnerActor' has a wrong offset!");
static_assert(offsetof(UAbilitySystemComponent, AvatarActor) == 0x0003F0, "Member 'UAbilitySystemComponent::AvatarActor' has a wrong offset!");
static_assert(offsetof(UAbilitySystemComponent, ActivatableAbilities) == 0x000408, "Member 'UAbilitySystemComponent::ActivatableAbilities' has a wrong offset!");
static_assert(offsetof(UAbilitySystemComponent, AllReplicatedInstancedAbilities) == 0x000558, "Member 'UAbilitySystemComponent::AllReplicatedInstancedAbilities' has a wrong offset!");
static_assert(offsetof(UAbilitySystemComponent, RepAnimMontageInfo) == 0x000778, "Member 'UAbilitySystemComponent::RepAnimMontageInfo' has a wrong offset!");
static_assert(offsetof(UAbilitySystemComponent, bCachedIsNetSimulated) == 0x0007B0, "Member 'UAbilitySystemComponent::bCachedIsNetSimulated' has a wrong offset!");
static_assert(offsetof(UAbilitySystemComponent, bPendingMontageRep) == 0x0007B1, "Member 'UAbilitySystemComponent::bPendingMontageRep' has a wrong offset!");
static_assert(offsetof(UAbilitySystemComponent, LocalAnimMontageInfo) == 0x0007B8, "Member 'UAbilitySystemComponent::LocalAnimMontageInfo' has a wrong offset!");
static_assert(offsetof(UAbilitySystemComponent, ActiveGameplayEffects) == 0x000888, "Member 'UAbilitySystemComponent::ActiveGameplayEffects' has a wrong offset!");
static_assert(offsetof(UAbilitySystemComponent, ActiveGameplayCues) == 0x000D00, "Member 'UAbilitySystemComponent::ActiveGameplayCues' has a wrong offset!");
static_assert(offsetof(UAbilitySystemComponent, MinimalReplicationGameplayCues) == 0x000E28, "Member 'UAbilitySystemComponent::MinimalReplicationGameplayCues' has a wrong offset!");
static_assert(offsetof(UAbilitySystemComponent, ProxiedGameplayCues) == 0x000F50, "Member 'UAbilitySystemComponent::ProxiedGameplayCues' has a wrong offset!");
static_assert(offsetof(UAbilitySystemComponent, BlockedAbilityBindings) == 0x0011A0, "Member 'UAbilitySystemComponent::BlockedAbilityBindings' has a wrong offset!");
static_assert(offsetof(UAbilitySystemComponent, MinimalReplicationTags) == 0x0012D8, "Member 'UAbilitySystemComponent::MinimalReplicationTags' has a wrong offset!");
static_assert(offsetof(UAbilitySystemComponent, SpawnedAttributes) == 0x001338, "Member 'UAbilitySystemComponent::SpawnedAttributes' has a wrong offset!");
static_assert(offsetof(UAbilitySystemComponent, ReplicatedLooseTags) == 0x001358, "Member 'UAbilitySystemComponent::ReplicatedLooseTags' has a wrong offset!");
static_assert(offsetof(UAbilitySystemComponent, ReplicatedPredictionKeyMap) == 0x0013C0, "Member 'UAbilitySystemComponent::ReplicatedPredictionKeyMap' has a wrong offset!");

// Class GameplayAbilities.AbilitySystemDebugHUDExtension
// 0x0000 (0x0028 - 0x0028)
class UAbilitySystemDebugHUDExtension : public UObject
{
public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"AbilitySystemDebugHUDExtension">();
	}
	static class UAbilitySystemDebugHUDExtension* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UAbilitySystemDebugHUDExtension>();
	}
};
static_assert(alignof(UAbilitySystemDebugHUDExtension) == 0x000008, "Wrong alignment on UAbilitySystemDebugHUDExtension");
static_assert(sizeof(UAbilitySystemDebugHUDExtension) == 0x000028, "Wrong size on UAbilitySystemDebugHUDExtension");

// Class GameplayAbilities.AbilitySystemDebugHUDExtension_Tags
// 0x0058 (0x0080 - 0x0028)
class UAbilitySystemDebugHUDExtension_Tags final : public UAbilitySystemDebugHUDExtension
{
public:
	uint8                                         Pad_28[0x58];                                      // 0x0028(0x0058)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"AbilitySystemDebugHUDExtension_Tags">();
	}
	static class UAbilitySystemDebugHUDExtension_Tags* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UAbilitySystemDebugHUDExtension_Tags>();
	}
};
static_assert(alignof(UAbilitySystemDebugHUDExtension_Tags) == 0x000008, "Wrong alignment on UAbilitySystemDebugHUDExtension_Tags");
static_assert(sizeof(UAbilitySystemDebugHUDExtension_Tags) == 0x000080, "Wrong size on UAbilitySystemDebugHUDExtension_Tags");

// Class GameplayAbilities.AbilitySystemDebugHUDExtension_Attributes
// 0x0058 (0x0080 - 0x0028)
class UAbilitySystemDebugHUDExtension_Attributes final : public UAbilitySystemDebugHUDExtension
{
public:
	uint8                                         Pad_28[0x58];                                      // 0x0028(0x0058)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"AbilitySystemDebugHUDExtension_Attributes">();
	}
	static class UAbilitySystemDebugHUDExtension_Attributes* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UAbilitySystemDebugHUDExtension_Attributes>();
	}
};
static_assert(alignof(UAbilitySystemDebugHUDExtension_Attributes) == 0x000008, "Wrong alignment on UAbilitySystemDebugHUDExtension_Attributes");
static_assert(sizeof(UAbilitySystemDebugHUDExtension_Attributes) == 0x000080, "Wrong size on UAbilitySystemDebugHUDExtension_Attributes");

// Class GameplayAbilities.AbilitySystemDebugHUDExtension_BlockedAbilityTags
// 0x0058 (0x0080 - 0x0028)
class UAbilitySystemDebugHUDExtension_BlockedAbilityTags final : public UAbilitySystemDebugHUDExtension
{
public:
	uint8                                         Pad_28[0x58];                                      // 0x0028(0x0058)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"AbilitySystemDebugHUDExtension_BlockedAbilityTags">();
	}
	static class UAbilitySystemDebugHUDExtension_BlockedAbilityTags* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UAbilitySystemDebugHUDExtension_BlockedAbilityTags>();
	}
};
static_assert(alignof(UAbilitySystemDebugHUDExtension_BlockedAbilityTags) == 0x000008, "Wrong alignment on UAbilitySystemDebugHUDExtension_BlockedAbilityTags");
static_assert(sizeof(UAbilitySystemDebugHUDExtension_BlockedAbilityTags) == 0x000080, "Wrong size on UAbilitySystemDebugHUDExtension_BlockedAbilityTags");

// Class GameplayAbilities.AbilitySystemGlobals
// 0x0270 (0x0298 - 0x0028)
class UAbilitySystemGlobals : public UObject
{
public:
	struct FSoftClassPath                         AbilitySystemGlobalsClassName;                     // 0x0028(0x0020)(ZeroConstructor, Config, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_48[0x28];                                      // 0x0048(0x0028)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bUseDebugTargetFromHud;                            // 0x0070(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_71[0x3];                                       // 0x0071(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTag                           ActivateFailIsDeadTag;                             // 0x0074(0x0008)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   ActivateFailIsDeadName;                            // 0x007C(0x0008)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           ActivateFailCooldownTag;                           // 0x0084(0x0008)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   ActivateFailCooldownName;                          // 0x008C(0x0008)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           ActivateFailCostTag;                               // 0x0094(0x0008)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   ActivateFailCostName;                              // 0x009C(0x0008)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           ActivateFailTagsBlockedTag;                        // 0x00A4(0x0008)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   ActivateFailTagsBlockedName;                       // 0x00AC(0x0008)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           ActivateFailTagsMissingTag;                        // 0x00B4(0x0008)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   ActivateFailTagsMissingName;                       // 0x00BC(0x0008)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           ActivateFailNetworkingTag;                         // 0x00C4(0x0008)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   ActivateFailNetworkingName;                        // 0x00CC(0x0008)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MinimalReplicationTagCountBits;                    // 0x00D4(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FNetSerializeScriptStructCache         TargetDataStructCache;                             // 0x00D8(0x0010)(NativeAccessSpecifierPublic)
	bool                                          bAllowGameplayModEvaluationChannels;               // 0x00E8(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EGameplayModEvaluationChannel                 DefaultGameplayModEvaluationChannel;               // 0x00E9(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_EA[0x2];                                       // 0x00EA(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   GameplayModEvaluationChannelAliases[0xA];          // 0x00EC(0x0008)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_13C[0x4];                                      // 0x013C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FSoftObjectPath                        GlobalCurveTableName;                              // 0x0140(0x0020)(ZeroConstructor, Config, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCurveTable*                            GlobalCurveTable;                                  // 0x0160(0x0008)(ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FSoftObjectPath                        GlobalAttributeMetaDataTableName;                  // 0x0168(0x0020)(ZeroConstructor, Config, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UDataTable*                             GlobalAttributeMetaDataTable;                      // 0x0188(0x0008)(ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FSoftObjectPath                        GlobalAttributeSetDefaultsTableName;               // 0x0190(0x0020)(ZeroConstructor, Config, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<struct FSoftObjectPath>                GlobalAttributeSetDefaultsTableNames;              // 0x01B0(0x0010)(ZeroConstructor, Config, Protected, NativeAccessSpecifierProtected)
	TArray<class UCurveTable*>                    GlobalAttributeDefaultsTables;                     // 0x01C0(0x0010)(ZeroConstructor, Protected, UObjectWrapper, NativeAccessSpecifierProtected)
	struct FSoftObjectPath                        GlobalGameplayCueManagerClass;                     // 0x01D0(0x0020)(ZeroConstructor, Config, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FSoftObjectPath                        GlobalGameplayCueManagerName;                      // 0x01F0(0x0020)(ZeroConstructor, Config, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class FString>                         GameplayCueNotifyPaths;                            // 0x0210(0x0010)(ZeroConstructor, Config, Protected, NativeAccessSpecifierProtected)
	struct FSoftObjectPath                        GameplayTagResponseTableName;                      // 0x0220(0x0020)(ZeroConstructor, Config, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UGameplayTagReponseTable*               GameplayTagResponseTable;                          // 0x0240(0x0008)(ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          PredictTargetGameplayEffects;                      // 0x0248(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          ReplicateActivationOwnedTags;                      // 0x0249(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_24A[0x6];                                      // 0x024A(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	class UGameplayCueManager*                    GlobalGameplayCueManager;                          // 0x0250(0x0008)(ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_258[0x40];                                     // 0x0258(0x0040)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ListPlayerAbilities()	 // 0x17c7f2c;
	void ServerActivatePlayerAbility(const class FString& AbilityNameMatch)	 // 0x3dce774;
	void ServerCancelPlayerAbility(const class FString& AbilityNameMatch)	 // 0x3dce774;
	void ServerEndPlayerAbility(const class FString& AbilityNameMatch)	 // 0x3dce774;
	void ToggleIgnoreAbilitySystemCooldowns()	 // 0x3dd0a64;
	void ToggleIgnoreAbilitySystemCosts()	 // 0x3dd0a7c;

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"AbilitySystemGlobals">();
	}
	static class UAbilitySystemGlobals* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UAbilitySystemGlobals>();
	}
};
static_assert(alignof(UAbilitySystemGlobals) == 0x000008, "Wrong alignment on UAbilitySystemGlobals");
static_assert(sizeof(UAbilitySystemGlobals) == 0x000298, "Wrong size on UAbilitySystemGlobals");
static_assert(offsetof(UAbilitySystemGlobals, AbilitySystemGlobalsClassName) == 0x000028, "Member 'UAbilitySystemGlobals::AbilitySystemGlobalsClassName' has a wrong offset!");
static_assert(offsetof(UAbilitySystemGlobals, bUseDebugTargetFromHud) == 0x000070, "Member 'UAbilitySystemGlobals::bUseDebugTargetFromHud' has a wrong offset!");
static_assert(offsetof(UAbilitySystemGlobals, ActivateFailIsDeadTag) == 0x000074, "Member 'UAbilitySystemGlobals::ActivateFailIsDeadTag' has a wrong offset!");
static_assert(offsetof(UAbilitySystemGlobals, ActivateFailIsDeadName) == 0x00007C, "Member 'UAbilitySystemGlobals::ActivateFailIsDeadName' has a wrong offset!");
static_assert(offsetof(UAbilitySystemGlobals, ActivateFailCooldownTag) == 0x000084, "Member 'UAbilitySystemGlobals::ActivateFailCooldownTag' has a wrong offset!");
static_assert(offsetof(UAbilitySystemGlobals, ActivateFailCooldownName) == 0x00008C, "Member 'UAbilitySystemGlobals::ActivateFailCooldownName' has a wrong offset!");
static_assert(offsetof(UAbilitySystemGlobals, ActivateFailCostTag) == 0x000094, "Member 'UAbilitySystemGlobals::ActivateFailCostTag' has a wrong offset!");
static_assert(offsetof(UAbilitySystemGlobals, ActivateFailCostName) == 0x00009C, "Member 'UAbilitySystemGlobals::ActivateFailCostName' has a wrong offset!");
static_assert(offsetof(UAbilitySystemGlobals, ActivateFailTagsBlockedTag) == 0x0000A4, "Member 'UAbilitySystemGlobals::ActivateFailTagsBlockedTag' has a wrong offset!");
static_assert(offsetof(UAbilitySystemGlobals, ActivateFailTagsBlockedName) == 0x0000AC, "Member 'UAbilitySystemGlobals::ActivateFailTagsBlockedName' has a wrong offset!");
static_assert(offsetof(UAbilitySystemGlobals, ActivateFailTagsMissingTag) == 0x0000B4, "Member 'UAbilitySystemGlobals::ActivateFailTagsMissingTag' has a wrong offset!");
static_assert(offsetof(UAbilitySystemGlobals, ActivateFailTagsMissingName) == 0x0000BC, "Member 'UAbilitySystemGlobals::ActivateFailTagsMissingName' has a wrong offset!");
static_assert(offsetof(UAbilitySystemGlobals, ActivateFailNetworkingTag) == 0x0000C4, "Member 'UAbilitySystemGlobals::ActivateFailNetworkingTag' has a wrong offset!");
static_assert(offsetof(UAbilitySystemGlobals, ActivateFailNetworkingName) == 0x0000CC, "Member 'UAbilitySystemGlobals::ActivateFailNetworkingName' has a wrong offset!");
static_assert(offsetof(UAbilitySystemGlobals, MinimalReplicationTagCountBits) == 0x0000D4, "Member 'UAbilitySystemGlobals::MinimalReplicationTagCountBits' has a wrong offset!");
static_assert(offsetof(UAbilitySystemGlobals, TargetDataStructCache) == 0x0000D8, "Member 'UAbilitySystemGlobals::TargetDataStructCache' has a wrong offset!");
static_assert(offsetof(UAbilitySystemGlobals, bAllowGameplayModEvaluationChannels) == 0x0000E8, "Member 'UAbilitySystemGlobals::bAllowGameplayModEvaluationChannels' has a wrong offset!");
static_assert(offsetof(UAbilitySystemGlobals, DefaultGameplayModEvaluationChannel) == 0x0000E9, "Member 'UAbilitySystemGlobals::DefaultGameplayModEvaluationChannel' has a wrong offset!");
static_assert(offsetof(UAbilitySystemGlobals, GameplayModEvaluationChannelAliases) == 0x0000EC, "Member 'UAbilitySystemGlobals::GameplayModEvaluationChannelAliases' has a wrong offset!");
static_assert(offsetof(UAbilitySystemGlobals, GlobalCurveTableName) == 0x000140, "Member 'UAbilitySystemGlobals::GlobalCurveTableName' has a wrong offset!");
static_assert(offsetof(UAbilitySystemGlobals, GlobalCurveTable) == 0x000160, "Member 'UAbilitySystemGlobals::GlobalCurveTable' has a wrong offset!");
static_assert(offsetof(UAbilitySystemGlobals, GlobalAttributeMetaDataTableName) == 0x000168, "Member 'UAbilitySystemGlobals::GlobalAttributeMetaDataTableName' has a wrong offset!");
static_assert(offsetof(UAbilitySystemGlobals, GlobalAttributeMetaDataTable) == 0x000188, "Member 'UAbilitySystemGlobals::GlobalAttributeMetaDataTable' has a wrong offset!");
static_assert(offsetof(UAbilitySystemGlobals, GlobalAttributeSetDefaultsTableName) == 0x000190, "Member 'UAbilitySystemGlobals::GlobalAttributeSetDefaultsTableName' has a wrong offset!");
static_assert(offsetof(UAbilitySystemGlobals, GlobalAttributeSetDefaultsTableNames) == 0x0001B0, "Member 'UAbilitySystemGlobals::GlobalAttributeSetDefaultsTableNames' has a wrong offset!");
static_assert(offsetof(UAbilitySystemGlobals, GlobalAttributeDefaultsTables) == 0x0001C0, "Member 'UAbilitySystemGlobals::GlobalAttributeDefaultsTables' has a wrong offset!");
static_assert(offsetof(UAbilitySystemGlobals, GlobalGameplayCueManagerClass) == 0x0001D0, "Member 'UAbilitySystemGlobals::GlobalGameplayCueManagerClass' has a wrong offset!");
static_assert(offsetof(UAbilitySystemGlobals, GlobalGameplayCueManagerName) == 0x0001F0, "Member 'UAbilitySystemGlobals::GlobalGameplayCueManagerName' has a wrong offset!");
static_assert(offsetof(UAbilitySystemGlobals, GameplayCueNotifyPaths) == 0x000210, "Member 'UAbilitySystemGlobals::GameplayCueNotifyPaths' has a wrong offset!");
static_assert(offsetof(UAbilitySystemGlobals, GameplayTagResponseTableName) == 0x000220, "Member 'UAbilitySystemGlobals::GameplayTagResponseTableName' has a wrong offset!");
static_assert(offsetof(UAbilitySystemGlobals, GameplayTagResponseTable) == 0x000240, "Member 'UAbilitySystemGlobals::GameplayTagResponseTable' has a wrong offset!");
static_assert(offsetof(UAbilitySystemGlobals, PredictTargetGameplayEffects) == 0x000248, "Member 'UAbilitySystemGlobals::PredictTargetGameplayEffects' has a wrong offset!");
static_assert(offsetof(UAbilitySystemGlobals, ReplicateActivationOwnedTags) == 0x000249, "Member 'UAbilitySystemGlobals::ReplicateActivationOwnedTags' has a wrong offset!");
static_assert(offsetof(UAbilitySystemGlobals, GlobalGameplayCueManager) == 0x000250, "Member 'UAbilitySystemGlobals::GlobalGameplayCueManager' has a wrong offset!");

// Class GameplayAbilities.AbilitySystemInterface
// 0x0000 (0x0000 - 0x0000)
class IAbilitySystemInterface final
{
public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"AbilitySystemInterface">();
	}
	static class IAbilitySystemInterface* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<IAbilitySystemInterface>();
	}

	class UObject* AsUObject()	 // 0x0
	{
		return reinterpret_cast<UObject*>(this);
	}
	const class UObject* AsUObject() const	 // 0x0
	{
		return reinterpret_cast<const UObject*>(this);
	}
};
static_assert(alignof(IAbilitySystemInterface) == 0x000001, "Wrong alignment on IAbilitySystemInterface");
static_assert(sizeof(IAbilitySystemInterface) == 0x000001, "Wrong size on IAbilitySystemInterface");

// Class GameplayAbilities.AbilitySystemReplicationProxyInterface
// 0x0000 (0x0000 - 0x0000)
class IAbilitySystemReplicationProxyInterface final
{
public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"AbilitySystemReplicationProxyInterface">();
	}
	static class IAbilitySystemReplicationProxyInterface* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<IAbilitySystemReplicationProxyInterface>();
	}

	class UObject* AsUObject()	 // 0x0
	{
		return reinterpret_cast<UObject*>(this);
	}
	const class UObject* AsUObject() const	 // 0x0
	{
		return reinterpret_cast<const UObject*>(this);
	}
};
static_assert(alignof(IAbilitySystemReplicationProxyInterface) == 0x000001, "Wrong alignment on IAbilitySystemReplicationProxyInterface");
static_assert(sizeof(IAbilitySystemReplicationProxyInterface) == 0x000001, "Wrong size on IAbilitySystemReplicationProxyInterface");

// Class GameplayAbilities.AttributeSet
// 0x0008 (0x0030 - 0x0028)
class UAttributeSet : public UObject
{
public:
	uint8                                         Pad_28[0x8];                                       // 0x0028(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"AttributeSet">();
	}
	static class UAttributeSet* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UAttributeSet>();
	}
};
static_assert(alignof(UAttributeSet) == 0x000008, "Wrong alignment on UAttributeSet");
static_assert(sizeof(UAttributeSet) == 0x000030, "Wrong size on UAttributeSet");

// Class GameplayAbilities.AbilitySystemTestAttributeSet
// 0x0040 (0x0070 - 0x0030)
class UAbilitySystemTestAttributeSet final : public UAttributeSet
{
public:
	float                                         MaxHealth;                                         // 0x0030(0x0004)(Edit, BlueprintVisible, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Health;                                            // 0x0034(0x0004)(Edit, BlueprintVisible, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Mana;                                              // 0x0038(0x0004)(Edit, BlueprintVisible, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxMana;                                           // 0x003C(0x0004)(Edit, BlueprintVisible, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Damage;                                            // 0x0040(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SpellDamage;                                       // 0x0044(0x0004)(Edit, BlueprintVisible, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PhysicalDamage;                                    // 0x0048(0x0004)(Edit, BlueprintVisible, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CritChance;                                        // 0x004C(0x0004)(Edit, BlueprintVisible, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CritMultiplier;                                    // 0x0050(0x0004)(Edit, BlueprintVisible, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ArmorDamageReduction;                              // 0x0054(0x0004)(Edit, BlueprintVisible, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DodgeChance;                                       // 0x0058(0x0004)(Edit, BlueprintVisible, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LifeSteal;                                         // 0x005C(0x0004)(Edit, BlueprintVisible, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Strength;                                          // 0x0060(0x0004)(Edit, BlueprintVisible, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         StackingAttribute1;                                // 0x0064(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         StackingAttribute2;                                // 0x0068(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         NoStackAttribute;                                  // 0x006C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"AbilitySystemTestAttributeSet">();
	}
	static class UAbilitySystemTestAttributeSet* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UAbilitySystemTestAttributeSet>();
	}
};
static_assert(alignof(UAbilitySystemTestAttributeSet) == 0x000008, "Wrong alignment on UAbilitySystemTestAttributeSet");
static_assert(sizeof(UAbilitySystemTestAttributeSet) == 0x000070, "Wrong size on UAbilitySystemTestAttributeSet");
static_assert(offsetof(UAbilitySystemTestAttributeSet, MaxHealth) == 0x000030, "Member 'UAbilitySystemTestAttributeSet::MaxHealth' has a wrong offset!");
static_assert(offsetof(UAbilitySystemTestAttributeSet, Health) == 0x000034, "Member 'UAbilitySystemTestAttributeSet::Health' has a wrong offset!");
static_assert(offsetof(UAbilitySystemTestAttributeSet, Mana) == 0x000038, "Member 'UAbilitySystemTestAttributeSet::Mana' has a wrong offset!");
static_assert(offsetof(UAbilitySystemTestAttributeSet, MaxMana) == 0x00003C, "Member 'UAbilitySystemTestAttributeSet::MaxMana' has a wrong offset!");
static_assert(offsetof(UAbilitySystemTestAttributeSet, Damage) == 0x000040, "Member 'UAbilitySystemTestAttributeSet::Damage' has a wrong offset!");
static_assert(offsetof(UAbilitySystemTestAttributeSet, SpellDamage) == 0x000044, "Member 'UAbilitySystemTestAttributeSet::SpellDamage' has a wrong offset!");
static_assert(offsetof(UAbilitySystemTestAttributeSet, PhysicalDamage) == 0x000048, "Member 'UAbilitySystemTestAttributeSet::PhysicalDamage' has a wrong offset!");
static_assert(offsetof(UAbilitySystemTestAttributeSet, CritChance) == 0x00004C, "Member 'UAbilitySystemTestAttributeSet::CritChance' has a wrong offset!");
static_assert(offsetof(UAbilitySystemTestAttributeSet, CritMultiplier) == 0x000050, "Member 'UAbilitySystemTestAttributeSet::CritMultiplier' has a wrong offset!");
static_assert(offsetof(UAbilitySystemTestAttributeSet, ArmorDamageReduction) == 0x000054, "Member 'UAbilitySystemTestAttributeSet::ArmorDamageReduction' has a wrong offset!");
static_assert(offsetof(UAbilitySystemTestAttributeSet, DodgeChance) == 0x000058, "Member 'UAbilitySystemTestAttributeSet::DodgeChance' has a wrong offset!");
static_assert(offsetof(UAbilitySystemTestAttributeSet, LifeSteal) == 0x00005C, "Member 'UAbilitySystemTestAttributeSet::LifeSteal' has a wrong offset!");
static_assert(offsetof(UAbilitySystemTestAttributeSet, Strength) == 0x000060, "Member 'UAbilitySystemTestAttributeSet::Strength' has a wrong offset!");
static_assert(offsetof(UAbilitySystemTestAttributeSet, StackingAttribute1) == 0x000064, "Member 'UAbilitySystemTestAttributeSet::StackingAttribute1' has a wrong offset!");
static_assert(offsetof(UAbilitySystemTestAttributeSet, StackingAttribute2) == 0x000068, "Member 'UAbilitySystemTestAttributeSet::StackingAttribute2' has a wrong offset!");
static_assert(offsetof(UAbilitySystemTestAttributeSet, NoStackAttribute) == 0x00006C, "Member 'UAbilitySystemTestAttributeSet::NoStackAttribute' has a wrong offset!");

// Class GameplayAbilities.AbilitySystemTestPawn
// 0x0020 (0x0380 - 0x0360)
class AAbilitySystemTestPawn final : public ADefaultPawn
{
public:
	uint8                                         Pad_360[0x18];                                     // 0x0360(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	class UAbilitySystemComponent*                AbilitySystemComponent;                            // 0x0378(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"AbilitySystemTestPawn">();
	}
	static class AAbilitySystemTestPawn* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<AAbilitySystemTestPawn>();
	}
};
static_assert(alignof(AAbilitySystemTestPawn) == 0x000008, "Wrong alignment on AAbilitySystemTestPawn");
static_assert(sizeof(AAbilitySystemTestPawn) == 0x000380, "Wrong size on AAbilitySystemTestPawn");
static_assert(offsetof(AAbilitySystemTestPawn, AbilitySystemComponent) == 0x000378, "Member 'AAbilitySystemTestPawn::AbilitySystemComponent' has a wrong offset!");

// Class GameplayAbilities.AnimNotify_GameplayCue
// 0x0008 (0x0040 - 0x0038)
class UAnimNotify_GameplayCue final : public UAnimNotify
{
public:
	struct FGameplayCueTag                        GameplayCue;                                       // 0x0038(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"AnimNotify_GameplayCue">();
	}
	static class UAnimNotify_GameplayCue* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UAnimNotify_GameplayCue>();
	}
};
static_assert(alignof(UAnimNotify_GameplayCue) == 0x000008, "Wrong alignment on UAnimNotify_GameplayCue");
static_assert(sizeof(UAnimNotify_GameplayCue) == 0x000040, "Wrong size on UAnimNotify_GameplayCue");
static_assert(offsetof(UAnimNotify_GameplayCue, GameplayCue) == 0x000038, "Member 'UAnimNotify_GameplayCue::GameplayCue' has a wrong offset!");

// Class GameplayAbilities.AnimNotify_GameplayCueState
// 0x0008 (0x0038 - 0x0030)
class UAnimNotify_GameplayCueState final : public UAnimNotifyState
{
public:
	struct FGameplayCueTag                        GameplayCue;                                       // 0x0030(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"AnimNotify_GameplayCueState">();
	}
	static class UAnimNotify_GameplayCueState* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UAnimNotify_GameplayCueState>();
	}
};
static_assert(alignof(UAnimNotify_GameplayCueState) == 0x000008, "Wrong alignment on UAnimNotify_GameplayCueState");
static_assert(sizeof(UAnimNotify_GameplayCueState) == 0x000038, "Wrong size on UAnimNotify_GameplayCueState");
static_assert(offsetof(UAnimNotify_GameplayCueState, GameplayCue) == 0x000030, "Member 'UAnimNotify_GameplayCueState::GameplayCue' has a wrong offset!");

// Class GameplayAbilities.GameplayAbilityBlueprint
// 0x0000 (0x00A8 - 0x00A8)
class UGameplayAbilityBlueprint final : public UBlueprint
{
public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"GameplayAbilityBlueprint">();
	}
	static class UGameplayAbilityBlueprint* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UGameplayAbilityBlueprint>();
	}
};
static_assert(alignof(UGameplayAbilityBlueprint) == 0x000008, "Wrong alignment on UGameplayAbilityBlueprint");
static_assert(sizeof(UGameplayAbilityBlueprint) == 0x0000A8, "Wrong size on UGameplayAbilityBlueprint");

// Class GameplayAbilities.GameplayCueFunctionLibrary
// 0x0000 (0x0028 - 0x0028)
class UGameplayCueFunctionLibrary final : public UBlueprintFunctionLibrary
{
public:
	static void AddGameplayCueOnActor(class AActor* Target, const struct FGameplayTag& GameplayCueTag, const struct FGameplayCueParameters& Parameters)	 // 0x3dca288;
	static void ExecuteGameplayCueOnActor(class AActor* Target, const struct FGameplayTag& GameplayCueTag, const struct FGameplayCueParameters& Parameters)	 // 0x15a5b68;
	static void RemoveGameplayCueOnActor(class AActor* Target, const struct FGameplayTag& GameplayCueTag, const struct FGameplayCueParameters& Parameters)	 // 0x136a8f0;

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"GameplayCueFunctionLibrary">();
	}
	static class UGameplayCueFunctionLibrary* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UGameplayCueFunctionLibrary>();
	}
};
static_assert(alignof(UGameplayCueFunctionLibrary) == 0x000008, "Wrong alignment on UGameplayCueFunctionLibrary");
static_assert(sizeof(UGameplayCueFunctionLibrary) == 0x000028, "Wrong size on UGameplayCueFunctionLibrary");

// Class GameplayAbilities.GameplayCueInterface
// 0x0000 (0x0000 - 0x0000)
class IGameplayCueInterface final
{
public:
	void BlueprintCustomHandler(EGameplayCueEvent EventType, const struct FGameplayCueParameters& Parameters)	 // 0xae1e64;
	void ForwardGameplayCueToParent()	 // 0x3dcb84c;

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"GameplayCueInterface">();
	}
	static class IGameplayCueInterface* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<IGameplayCueInterface>();
	}

	class UObject* AsUObject()	 // 0x0
	{
		return reinterpret_cast<UObject*>(this);
	}
	const class UObject* AsUObject() const	 // 0x0
	{
		return reinterpret_cast<const UObject*>(this);
	}
};
static_assert(alignof(IGameplayCueInterface) == 0x000001, "Wrong alignment on IGameplayCueInterface");
static_assert(sizeof(IGameplayCueInterface) == 0x000001, "Wrong size on IGameplayCueInterface");

// Class GameplayAbilities.GameplayCueManager
// 0x02E0 (0x0310 - 0x0030)
class UGameplayCueManager : public UDataAsset
{
public:
	uint8                                         Pad_30[0x18];                                      // 0x0030(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayCueObjectLibrary              RuntimeGameplayCueObjectLibrary;                   // 0x0048(0x0050)(Transient, Protected, NativeAccessSpecifierProtected)
	struct FGameplayCueObjectLibrary              EditorGameplayCueObjectLibrary;                    // 0x0098(0x0050)(Transient, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_E8[0x1C8];                                     // 0x00E8(0x01C8)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<TSubclassOf<class UObject>>            LoadedGameplayCueNotifyClasses;                    // 0x02B0(0x0010)(ZeroConstructor, Transient, Protected, UObjectWrapper, NativeAccessSpecifierProtected)
	TArray<TSubclassOf<class AGameplayCueNotify_Actor>> GameplayCueClassesForPreallocation;          // 0x02C0(0x0010)(ZeroConstructor, Transient, Protected, UObjectWrapper, NativeAccessSpecifierProtected)
	TArray<struct FGameplayCuePendingExecute>     PendingExecuteCues;                                // 0x02D0(0x0010)(ZeroConstructor, Transient, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	int32                                         GameplayCueSendContextCount;                       // 0x02E0(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2E4[0x4];                                      // 0x02E4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FPreallocationInfo>             PreallocationInfoList_Internal;                    // 0x02E8(0x0010)(ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_2F8[0x18];                                     // 0x02F8(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"GameplayCueManager">();
	}
	static class UGameplayCueManager* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UGameplayCueManager>();
	}
};
static_assert(alignof(UGameplayCueManager) == 0x000008, "Wrong alignment on UGameplayCueManager");
static_assert(sizeof(UGameplayCueManager) == 0x000310, "Wrong size on UGameplayCueManager");
static_assert(offsetof(UGameplayCueManager, RuntimeGameplayCueObjectLibrary) == 0x000048, "Member 'UGameplayCueManager::RuntimeGameplayCueObjectLibrary' has a wrong offset!");
static_assert(offsetof(UGameplayCueManager, EditorGameplayCueObjectLibrary) == 0x000098, "Member 'UGameplayCueManager::EditorGameplayCueObjectLibrary' has a wrong offset!");
static_assert(offsetof(UGameplayCueManager, LoadedGameplayCueNotifyClasses) == 0x0002B0, "Member 'UGameplayCueManager::LoadedGameplayCueNotifyClasses' has a wrong offset!");
static_assert(offsetof(UGameplayCueManager, GameplayCueClassesForPreallocation) == 0x0002C0, "Member 'UGameplayCueManager::GameplayCueClassesForPreallocation' has a wrong offset!");
static_assert(offsetof(UGameplayCueManager, PendingExecuteCues) == 0x0002D0, "Member 'UGameplayCueManager::PendingExecuteCues' has a wrong offset!");
static_assert(offsetof(UGameplayCueManager, GameplayCueSendContextCount) == 0x0002E0, "Member 'UGameplayCueManager::GameplayCueSendContextCount' has a wrong offset!");
static_assert(offsetof(UGameplayCueManager, PreallocationInfoList_Internal) == 0x0002E8, "Member 'UGameplayCueManager::PreallocationInfoList_Internal' has a wrong offset!");

// Class GameplayAbilities.GameplayCueNotify_Actor
// 0x0050 (0x0300 - 0x02B0)
class AGameplayCueNotify_Actor : public AActor
{
public:
	bool                                          bAutoDestroyOnRemove;                              // 0x02B0(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2B1[0x3];                                      // 0x02B1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         AutoDestroyDelay;                                  // 0x02B4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          WarnIfTimelineIsStillRunning;                      // 0x02B8(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          WarnIfLatentActionIsStillRunning;                  // 0x02B9(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2BA[0x2];                                      // 0x02BA(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTag                           GameplayCueTag;                                    // 0x02BC(0x0008)(Edit, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   GameplayCueName;                                   // 0x02C4(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, AssetRegistrySearchable, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAutoAttachToOwner;                                // 0x02CC(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsOverride;                                        // 0x02CD(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUniqueInstancePerInstigator;                      // 0x02CE(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUniqueInstancePerSourceObject;                    // 0x02CF(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAllowMultipleOnActiveEvents;                      // 0x02D0(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAllowMultipleWhileActiveEvents;                   // 0x02D1(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2D2[0x2];                                      // 0x02D2(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         NumPreallocatedInstances;                          // 0x02D4(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2D8[0x28];                                     // 0x02D8(0x0028)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void K2_EndGameplayCue()	 // 0x3deb1fc;
	void K2_HandleGameplayCue(class AActor* MyTarget, EGameplayCueEvent EventType, const struct FGameplayCueParameters& Parameters)	 // 0xae1e64;
	bool OnActive(class AActor* MyTarget, const struct FGameplayCueParameters& Parameters)	 // 0x13dec30;
	bool OnExecute(class AActor* MyTarget, const struct FGameplayCueParameters& Parameters)	 // 0x13de8fc;
	void OnOwnerDestroyed(class AActor* DestroyedActor)	 // 0x172d518;
	bool OnRemove(class AActor* MyTarget, const struct FGameplayCueParameters& Parameters)	 // 0x13def64;
	bool WhileActive(class AActor* MyTarget, const struct FGameplayCueParameters& Parameters)	 // 0x13ddf04;

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"GameplayCueNotify_Actor">();
	}
	static class AGameplayCueNotify_Actor* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<AGameplayCueNotify_Actor>();
	}
};
static_assert(alignof(AGameplayCueNotify_Actor) == 0x000008, "Wrong alignment on AGameplayCueNotify_Actor");
static_assert(sizeof(AGameplayCueNotify_Actor) == 0x000300, "Wrong size on AGameplayCueNotify_Actor");
static_assert(offsetof(AGameplayCueNotify_Actor, bAutoDestroyOnRemove) == 0x0002B0, "Member 'AGameplayCueNotify_Actor::bAutoDestroyOnRemove' has a wrong offset!");
static_assert(offsetof(AGameplayCueNotify_Actor, AutoDestroyDelay) == 0x0002B4, "Member 'AGameplayCueNotify_Actor::AutoDestroyDelay' has a wrong offset!");
static_assert(offsetof(AGameplayCueNotify_Actor, WarnIfTimelineIsStillRunning) == 0x0002B8, "Member 'AGameplayCueNotify_Actor::WarnIfTimelineIsStillRunning' has a wrong offset!");
static_assert(offsetof(AGameplayCueNotify_Actor, WarnIfLatentActionIsStillRunning) == 0x0002B9, "Member 'AGameplayCueNotify_Actor::WarnIfLatentActionIsStillRunning' has a wrong offset!");
static_assert(offsetof(AGameplayCueNotify_Actor, GameplayCueTag) == 0x0002BC, "Member 'AGameplayCueNotify_Actor::GameplayCueTag' has a wrong offset!");
static_assert(offsetof(AGameplayCueNotify_Actor, GameplayCueName) == 0x0002C4, "Member 'AGameplayCueNotify_Actor::GameplayCueName' has a wrong offset!");
static_assert(offsetof(AGameplayCueNotify_Actor, bAutoAttachToOwner) == 0x0002CC, "Member 'AGameplayCueNotify_Actor::bAutoAttachToOwner' has a wrong offset!");
static_assert(offsetof(AGameplayCueNotify_Actor, IsOverride) == 0x0002CD, "Member 'AGameplayCueNotify_Actor::IsOverride' has a wrong offset!");
static_assert(offsetof(AGameplayCueNotify_Actor, bUniqueInstancePerInstigator) == 0x0002CE, "Member 'AGameplayCueNotify_Actor::bUniqueInstancePerInstigator' has a wrong offset!");
static_assert(offsetof(AGameplayCueNotify_Actor, bUniqueInstancePerSourceObject) == 0x0002CF, "Member 'AGameplayCueNotify_Actor::bUniqueInstancePerSourceObject' has a wrong offset!");
static_assert(offsetof(AGameplayCueNotify_Actor, bAllowMultipleOnActiveEvents) == 0x0002D0, "Member 'AGameplayCueNotify_Actor::bAllowMultipleOnActiveEvents' has a wrong offset!");
static_assert(offsetof(AGameplayCueNotify_Actor, bAllowMultipleWhileActiveEvents) == 0x0002D1, "Member 'AGameplayCueNotify_Actor::bAllowMultipleWhileActiveEvents' has a wrong offset!");
static_assert(offsetof(AGameplayCueNotify_Actor, NumPreallocatedInstances) == 0x0002D4, "Member 'AGameplayCueNotify_Actor::NumPreallocatedInstances' has a wrong offset!");

// Class GameplayAbilities.GameplayCueNotify_Static
// 0x0018 (0x0040 - 0x0028)
class UGameplayCueNotify_Static : public UObject
{
public:
	struct FGameplayTag                           GameplayCueTag;                                    // 0x0028(0x0008)(Edit, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   GameplayCueName;                                   // 0x0030(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, AssetRegistrySearchable, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsOverride;                                        // 0x0038(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_39[0x7];                                       // 0x0039(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void K2_HandleGameplayCue(class AActor* MyTarget, EGameplayCueEvent EventType, const struct FGameplayCueParameters& Parameters) const	 // 0xae1e64;
	bool OnActive(class AActor* MyTarget, const struct FGameplayCueParameters& Parameters) const	 // 0x16a0c40;
	bool OnExecute(class AActor* MyTarget, const struct FGameplayCueParameters& Parameters) const	 // 0x11752c4;
	bool OnRemove(class AActor* MyTarget, const struct FGameplayCueParameters& Parameters) const	 // 0x16a5f20;
	bool WhileActive(class AActor* MyTarget, const struct FGameplayCueParameters& Parameters) const	 // 0x1662f10;

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"GameplayCueNotify_Static">();
	}
	static class UGameplayCueNotify_Static* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UGameplayCueNotify_Static>();
	}
};
static_assert(alignof(UGameplayCueNotify_Static) == 0x000008, "Wrong alignment on UGameplayCueNotify_Static");
static_assert(sizeof(UGameplayCueNotify_Static) == 0x000040, "Wrong size on UGameplayCueNotify_Static");
static_assert(offsetof(UGameplayCueNotify_Static, GameplayCueTag) == 0x000028, "Member 'UGameplayCueNotify_Static::GameplayCueTag' has a wrong offset!");
static_assert(offsetof(UGameplayCueNotify_Static, GameplayCueName) == 0x000030, "Member 'UGameplayCueNotify_Static::GameplayCueName' has a wrong offset!");
static_assert(offsetof(UGameplayCueNotify_Static, IsOverride) == 0x000038, "Member 'UGameplayCueNotify_Static::IsOverride' has a wrong offset!");

// Class GameplayAbilities.GameplayCueNotify_Burst
// 0x0310 (0x0350 - 0x0040)
class UGameplayCueNotify_Burst final : public UGameplayCueNotify_Static
{
public:
	struct FGameplayCueNotify_SpawnCondition      DefaultSpawnCondition;                             // 0x0040(0x0038)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FGameplayCueNotify_PlacementInfo       DefaultPlacementInfo;                              // 0x0078(0x0040)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, Protected, NativeAccessSpecifierProtected)
	struct FGameplayCueNotify_BurstEffects        BurstEffects;                                      // 0x00B8(0x0298)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)

public:
	void OnBurst(class AActor* Target, const struct FGameplayCueParameters& Parameters, const struct FGameplayCueNotify_SpawnResult& SpawnResults) const	 // 0xae1e64;

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"GameplayCueNotify_Burst">();
	}
	static class UGameplayCueNotify_Burst* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UGameplayCueNotify_Burst>();
	}
};
static_assert(alignof(UGameplayCueNotify_Burst) == 0x000008, "Wrong alignment on UGameplayCueNotify_Burst");
static_assert(sizeof(UGameplayCueNotify_Burst) == 0x000350, "Wrong size on UGameplayCueNotify_Burst");
static_assert(offsetof(UGameplayCueNotify_Burst, DefaultSpawnCondition) == 0x000040, "Member 'UGameplayCueNotify_Burst::DefaultSpawnCondition' has a wrong offset!");
static_assert(offsetof(UGameplayCueNotify_Burst, DefaultPlacementInfo) == 0x000078, "Member 'UGameplayCueNotify_Burst::DefaultPlacementInfo' has a wrong offset!");
static_assert(offsetof(UGameplayCueNotify_Burst, BurstEffects) == 0x0000B8, "Member 'UGameplayCueNotify_Burst::BurstEffects' has a wrong offset!");

// Class GameplayAbilities.GameplayCueNotify_BurstLatent
// 0x0368 (0x0668 - 0x0300)
class AGameplayCueNotify_BurstLatent final : public AGameplayCueNotify_Actor
{
public:
	struct FGameplayCueNotify_SpawnCondition      DefaultSpawnCondition;                             // 0x0300(0x0038)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FGameplayCueNotify_PlacementInfo       DefaultPlacementInfo;                              // 0x0338(0x0040)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, Protected, NativeAccessSpecifierProtected)
	struct FGameplayCueNotify_BurstEffects        BurstEffects;                                      // 0x0378(0x0298)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FGameplayCueNotify_SpawnResult         BurstSpawnResults;                                 // 0x0610(0x0058)(BlueprintVisible, BlueprintReadOnly, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)

public:
	void OnBurst(class AActor* Target, const struct FGameplayCueParameters& Parameters, const struct FGameplayCueNotify_SpawnResult& SpawnResults)	 // 0xae1e64;

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"GameplayCueNotify_BurstLatent">();
	}
	static class AGameplayCueNotify_BurstLatent* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<AGameplayCueNotify_BurstLatent>();
	}
};
static_assert(alignof(AGameplayCueNotify_BurstLatent) == 0x000008, "Wrong alignment on AGameplayCueNotify_BurstLatent");
static_assert(sizeof(AGameplayCueNotify_BurstLatent) == 0x000668, "Wrong size on AGameplayCueNotify_BurstLatent");
static_assert(offsetof(AGameplayCueNotify_BurstLatent, DefaultSpawnCondition) == 0x000300, "Member 'AGameplayCueNotify_BurstLatent::DefaultSpawnCondition' has a wrong offset!");
static_assert(offsetof(AGameplayCueNotify_BurstLatent, DefaultPlacementInfo) == 0x000338, "Member 'AGameplayCueNotify_BurstLatent::DefaultPlacementInfo' has a wrong offset!");
static_assert(offsetof(AGameplayCueNotify_BurstLatent, BurstEffects) == 0x000378, "Member 'AGameplayCueNotify_BurstLatent::BurstEffects' has a wrong offset!");
static_assert(offsetof(AGameplayCueNotify_BurstLatent, BurstSpawnResults) == 0x000610, "Member 'AGameplayCueNotify_BurstLatent::BurstSpawnResults' has a wrong offset!");

// Class GameplayAbilities.GameplayCueNotify_HitImpact
// 0x0018 (0x0058 - 0x0040)
class UGameplayCueNotify_HitImpact final : public UGameplayCueNotify_Static
{
public:
	class USoundBase*                             Sound;                                             // 0x0040(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UParticleSystem*                        ParticleSystem;                                    // 0x0048(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UNiagaraSystem*                         NiagaraSystem;                                     // 0x0050(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"GameplayCueNotify_HitImpact">();
	}
	static class UGameplayCueNotify_HitImpact* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UGameplayCueNotify_HitImpact>();
	}
};
static_assert(alignof(UGameplayCueNotify_HitImpact) == 0x000008, "Wrong alignment on UGameplayCueNotify_HitImpact");
static_assert(sizeof(UGameplayCueNotify_HitImpact) == 0x000058, "Wrong size on UGameplayCueNotify_HitImpact");
static_assert(offsetof(UGameplayCueNotify_HitImpact, Sound) == 0x000040, "Member 'UGameplayCueNotify_HitImpact::Sound' has a wrong offset!");
static_assert(offsetof(UGameplayCueNotify_HitImpact, ParticleSystem) == 0x000048, "Member 'UGameplayCueNotify_HitImpact::ParticleSystem' has a wrong offset!");
static_assert(offsetof(UGameplayCueNotify_HitImpact, NiagaraSystem) == 0x000050, "Member 'UGameplayCueNotify_HitImpact::NiagaraSystem' has a wrong offset!");

// Class GameplayAbilities.GameplayCueNotify_Looping
// 0x0B98 (0x0E98 - 0x0300)
class AGameplayCueNotify_Looping final : public AGameplayCueNotify_Actor
{
public:
	struct FGameplayCueNotify_SpawnCondition      DefaultSpawnCondition;                             // 0x0300(0x0038)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FGameplayCueNotify_PlacementInfo       DefaultPlacementInfo;                              // 0x0338(0x0040)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, Protected, NativeAccessSpecifierProtected)
	struct FGameplayCueNotify_BurstEffects        ApplicationEffects;                                // 0x0378(0x0298)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FGameplayCueNotify_SpawnResult         ApplicationSpawnResults;                           // 0x0610(0x0058)(BlueprintVisible, BlueprintReadOnly, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	struct FGameplayCueNotify_LoopingEffects      LoopingEffects;                                    // 0x0668(0x01F0)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FGameplayCueNotify_SpawnResult         LoopingSpawnResults;                               // 0x0858(0x0058)(BlueprintVisible, BlueprintReadOnly, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	struct FGameplayCueNotify_BurstEffects        RecurringEffects;                                  // 0x08B0(0x0298)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FGameplayCueNotify_SpawnResult         RecurringSpawnResults;                             // 0x0B48(0x0058)(BlueprintVisible, BlueprintReadOnly, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	struct FGameplayCueNotify_BurstEffects        RemovalEffects;                                    // 0x0BA0(0x0298)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FGameplayCueNotify_SpawnResult         RemovalSpawnResults;                               // 0x0E38(0x0058)(BlueprintVisible, BlueprintReadOnly, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_E90[0x8];                                      // 0x0E90(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnApplication(class AActor* Target, const struct FGameplayCueParameters& Parameters, const struct FGameplayCueNotify_SpawnResult& SpawnResults)	 // 0xae1e64;
	void OnLoopingStart(class AActor* Target, const struct FGameplayCueParameters& Parameters, const struct FGameplayCueNotify_SpawnResult& SpawnResults)	 // 0xae1e64;
	void OnRecurring(class AActor* Target, const struct FGameplayCueParameters& Parameters, const struct FGameplayCueNotify_SpawnResult& SpawnResults)	 // 0xae1e64;
	void OnRemoval(class AActor* Target, const struct FGameplayCueParameters& Parameters, const struct FGameplayCueNotify_SpawnResult& SpawnResults)	 // 0xae1e64;

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"GameplayCueNotify_Looping">();
	}
	static class AGameplayCueNotify_Looping* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<AGameplayCueNotify_Looping>();
	}
};
static_assert(alignof(AGameplayCueNotify_Looping) == 0x000008, "Wrong alignment on AGameplayCueNotify_Looping");
static_assert(sizeof(AGameplayCueNotify_Looping) == 0x000E98, "Wrong size on AGameplayCueNotify_Looping");
static_assert(offsetof(AGameplayCueNotify_Looping, DefaultSpawnCondition) == 0x000300, "Member 'AGameplayCueNotify_Looping::DefaultSpawnCondition' has a wrong offset!");
static_assert(offsetof(AGameplayCueNotify_Looping, DefaultPlacementInfo) == 0x000338, "Member 'AGameplayCueNotify_Looping::DefaultPlacementInfo' has a wrong offset!");
static_assert(offsetof(AGameplayCueNotify_Looping, ApplicationEffects) == 0x000378, "Member 'AGameplayCueNotify_Looping::ApplicationEffects' has a wrong offset!");
static_assert(offsetof(AGameplayCueNotify_Looping, ApplicationSpawnResults) == 0x000610, "Member 'AGameplayCueNotify_Looping::ApplicationSpawnResults' has a wrong offset!");
static_assert(offsetof(AGameplayCueNotify_Looping, LoopingEffects) == 0x000668, "Member 'AGameplayCueNotify_Looping::LoopingEffects' has a wrong offset!");
static_assert(offsetof(AGameplayCueNotify_Looping, LoopingSpawnResults) == 0x000858, "Member 'AGameplayCueNotify_Looping::LoopingSpawnResults' has a wrong offset!");
static_assert(offsetof(AGameplayCueNotify_Looping, RecurringEffects) == 0x0008B0, "Member 'AGameplayCueNotify_Looping::RecurringEffects' has a wrong offset!");
static_assert(offsetof(AGameplayCueNotify_Looping, RecurringSpawnResults) == 0x000B48, "Member 'AGameplayCueNotify_Looping::RecurringSpawnResults' has a wrong offset!");
static_assert(offsetof(AGameplayCueNotify_Looping, RemovalEffects) == 0x000BA0, "Member 'AGameplayCueNotify_Looping::RemovalEffects' has a wrong offset!");
static_assert(offsetof(AGameplayCueNotify_Looping, RemovalSpawnResults) == 0x000E38, "Member 'AGameplayCueNotify_Looping::RemovalSpawnResults' has a wrong offset!");

// Class GameplayAbilities.GameplayCueSet
// 0x0060 (0x0090 - 0x0030)
class UGameplayCueSet final : public UDataAsset
{
public:
	TArray<struct FGameplayCueNotifyData>         GameplayCueData;                                   // 0x0030(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_40[0x50];                                      // 0x0040(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"GameplayCueSet">();
	}
	static class UGameplayCueSet* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UGameplayCueSet>();
	}
};
static_assert(alignof(UGameplayCueSet) == 0x000008, "Wrong alignment on UGameplayCueSet");
static_assert(sizeof(UGameplayCueSet) == 0x000090, "Wrong size on UGameplayCueSet");
static_assert(offsetof(UGameplayCueSet, GameplayCueData) == 0x000030, "Member 'UGameplayCueSet::GameplayCueData' has a wrong offset!");

// Class GameplayAbilities.GameplayCueTranslator
// 0x0000 (0x0028 - 0x0028)
class UGameplayCueTranslator : public UObject
{
public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"GameplayCueTranslator">();
	}
	static class UGameplayCueTranslator* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UGameplayCueTranslator>();
	}
};
static_assert(alignof(UGameplayCueTranslator) == 0x000008, "Wrong alignment on UGameplayCueTranslator");
static_assert(sizeof(UGameplayCueTranslator) == 0x000028, "Wrong size on UGameplayCueTranslator");

// Class GameplayAbilities.GameplayCueTranslator_Test
// 0x0000 (0x0028 - 0x0028)
class UGameplayCueTranslator_Test final : public UGameplayCueTranslator
{
public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"GameplayCueTranslator_Test">();
	}
	static class UGameplayCueTranslator_Test* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UGameplayCueTranslator_Test>();
	}
};
static_assert(alignof(UGameplayCueTranslator_Test) == 0x000008, "Wrong alignment on UGameplayCueTranslator_Test");
static_assert(sizeof(UGameplayCueTranslator_Test) == 0x000028, "Wrong size on UGameplayCueTranslator_Test");

// Class GameplayAbilities.GameplayEffect
// 0x0838 (0x0860 - 0x0028)
class UGameplayEffect : public UObject
{
public:
	uint8                                         Pad_28[0x8];                                       // 0x0028(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	EGameplayEffectDurationType                   DurationPolicy;                                    // 0x0030(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_31[0x7];                                       // 0x0031(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayEffectModifierMagnitude       DurationMagnitude;                                 // 0x0038(0x01E0)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FScalableFloat                         Period;                                            // 0x0218(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	bool                                          bExecutePeriodicEffectOnApplication;               // 0x0240(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EGameplayEffectPeriodInhibitionRemovedPolicy  PeriodicInhibitionPolicy;                          // 0x0241(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_242[0x6];                                      // 0x0242(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FGameplayModifierInfo>          Modifiers;                                         // 0x0248(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TArray<struct FGameplayEffectExecutionDefinition> Executions;                                    // 0x0258(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FScalableFloat                         ChanceToApplyToTarget;                             // 0x0268(0x0028)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TArray<TSubclassOf<class UGameplayEffectCustomApplicationRequirement>> ApplicationRequirements;  // 0x0290(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, UObjectWrapper, NativeAccessSpecifierPublic)
	TArray<TSubclassOf<class UGameplayEffect>>    TargetEffectClasses;                               // 0x02A0(0x0010)(ZeroConstructor, Deprecated, UObjectWrapper, NativeAccessSpecifierPublic)
	TArray<struct FConditionalGameplayEffect>     ConditionalGameplayEffects;                        // 0x02B0(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TArray<TSubclassOf<class UGameplayEffect>>    OverflowEffects;                                   // 0x02C0(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, UObjectWrapper, NativeAccessSpecifierPublic)
	bool                                          bDenyOverflowApplication;                          // 0x02D0(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bClearStackOnOverflow;                             // 0x02D1(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2D2[0x6];                                      // 0x02D2(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<TSubclassOf<class UGameplayEffect>>    PrematureExpirationEffectClasses;                  // 0x02D8(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, UObjectWrapper, NativeAccessSpecifierPublic)
	TArray<TSubclassOf<class UGameplayEffect>>    RoutineExpirationEffectClasses;                    // 0x02E8(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, UObjectWrapper, NativeAccessSpecifierPublic)
	bool                                          bRequireModifierSuccessToTriggerCues;              // 0x02F8(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bSuppressStackingCues;                             // 0x02F9(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2FA[0x6];                                      // 0x02FA(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FGameplayEffectCue>             GameplayCues;                                      // 0x0300(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	class UGameplayEffectUIData*                  UIData;                                            // 0x0310(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, PersistentInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FInheritedTagContainer                 InheritableGameplayEffectTags;                     // 0x0318(0x0060)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FInheritedTagContainer                 InheritableOwnedTagsContainer;                     // 0x0378(0x0060)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FInheritedTagContainer                 InheritableBlockedAbilityTagsContainer;            // 0x03D8(0x0060)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FGameplayTagRequirements               OngoingTagRequirements;                            // 0x0438(0x0040)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FGameplayTagRequirements               ApplicationTagRequirements;                        // 0x0478(0x0040)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FGameplayTagRequirements               RemovalTagRequirements;                            // 0x04B8(0x0040)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FInheritedTagContainer                 RemoveGameplayEffectsWithTags;                     // 0x04F8(0x0060)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FGameplayTagRequirements               GrantedApplicationImmunityTags;                    // 0x0558(0x0040)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FGameplayEffectQuery                   GrantedApplicationImmunityQuery;                   // 0x0598(0x0150)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, ContainsInstancedReference, NativeAccessSpecifierPublic)
	uint8                                         Pad_6E8[0x8];                                      // 0x06E8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayEffectQuery                   RemoveGameplayEffectQuery;                         // 0x06F0(0x0150)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, ContainsInstancedReference, NativeAccessSpecifierPublic)
	uint8                                         Pad_840[0x1];                                      // 0x0840(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	EGameplayEffectStackingType                   StackingType;                                      // 0x0841(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_842[0x2];                                      // 0x0842(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         StackLimitCount;                                   // 0x0844(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EGameplayEffectStackingDurationPolicy         StackDurationRefreshPolicy;                        // 0x0848(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EGameplayEffectStackingPeriodPolicy           StackPeriodResetPolicy;                            // 0x0849(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EGameplayEffectStackingExpirationPolicy       StackExpirationPolicy;                             // 0x084A(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_84B[0x5];                                      // 0x084B(0x0005)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FGameplayAbilitySpecDef>        GrantedAbilities;                                  // 0x0850(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"GameplayEffect">();
	}
	static class UGameplayEffect* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UGameplayEffect>();
	}
};
static_assert(alignof(UGameplayEffect) == 0x000008, "Wrong alignment on UGameplayEffect");
static_assert(sizeof(UGameplayEffect) == 0x000860, "Wrong size on UGameplayEffect");
static_assert(offsetof(UGameplayEffect, DurationPolicy) == 0x000030, "Member 'UGameplayEffect::DurationPolicy' has a wrong offset!");
static_assert(offsetof(UGameplayEffect, DurationMagnitude) == 0x000038, "Member 'UGameplayEffect::DurationMagnitude' has a wrong offset!");
static_assert(offsetof(UGameplayEffect, Period) == 0x000218, "Member 'UGameplayEffect::Period' has a wrong offset!");
static_assert(offsetof(UGameplayEffect, bExecutePeriodicEffectOnApplication) == 0x000240, "Member 'UGameplayEffect::bExecutePeriodicEffectOnApplication' has a wrong offset!");
static_assert(offsetof(UGameplayEffect, PeriodicInhibitionPolicy) == 0x000241, "Member 'UGameplayEffect::PeriodicInhibitionPolicy' has a wrong offset!");
static_assert(offsetof(UGameplayEffect, Modifiers) == 0x000248, "Member 'UGameplayEffect::Modifiers' has a wrong offset!");
static_assert(offsetof(UGameplayEffect, Executions) == 0x000258, "Member 'UGameplayEffect::Executions' has a wrong offset!");
static_assert(offsetof(UGameplayEffect, ChanceToApplyToTarget) == 0x000268, "Member 'UGameplayEffect::ChanceToApplyToTarget' has a wrong offset!");
static_assert(offsetof(UGameplayEffect, ApplicationRequirements) == 0x000290, "Member 'UGameplayEffect::ApplicationRequirements' has a wrong offset!");
static_assert(offsetof(UGameplayEffect, TargetEffectClasses) == 0x0002A0, "Member 'UGameplayEffect::TargetEffectClasses' has a wrong offset!");
static_assert(offsetof(UGameplayEffect, ConditionalGameplayEffects) == 0x0002B0, "Member 'UGameplayEffect::ConditionalGameplayEffects' has a wrong offset!");
static_assert(offsetof(UGameplayEffect, OverflowEffects) == 0x0002C0, "Member 'UGameplayEffect::OverflowEffects' has a wrong offset!");
static_assert(offsetof(UGameplayEffect, bDenyOverflowApplication) == 0x0002D0, "Member 'UGameplayEffect::bDenyOverflowApplication' has a wrong offset!");
static_assert(offsetof(UGameplayEffect, bClearStackOnOverflow) == 0x0002D1, "Member 'UGameplayEffect::bClearStackOnOverflow' has a wrong offset!");
static_assert(offsetof(UGameplayEffect, PrematureExpirationEffectClasses) == 0x0002D8, "Member 'UGameplayEffect::PrematureExpirationEffectClasses' has a wrong offset!");
static_assert(offsetof(UGameplayEffect, RoutineExpirationEffectClasses) == 0x0002E8, "Member 'UGameplayEffect::RoutineExpirationEffectClasses' has a wrong offset!");
static_assert(offsetof(UGameplayEffect, bRequireModifierSuccessToTriggerCues) == 0x0002F8, "Member 'UGameplayEffect::bRequireModifierSuccessToTriggerCues' has a wrong offset!");
static_assert(offsetof(UGameplayEffect, bSuppressStackingCues) == 0x0002F9, "Member 'UGameplayEffect::bSuppressStackingCues' has a wrong offset!");
static_assert(offsetof(UGameplayEffect, GameplayCues) == 0x000300, "Member 'UGameplayEffect::GameplayCues' has a wrong offset!");
static_assert(offsetof(UGameplayEffect, UIData) == 0x000310, "Member 'UGameplayEffect::UIData' has a wrong offset!");
static_assert(offsetof(UGameplayEffect, InheritableGameplayEffectTags) == 0x000318, "Member 'UGameplayEffect::InheritableGameplayEffectTags' has a wrong offset!");
static_assert(offsetof(UGameplayEffect, InheritableOwnedTagsContainer) == 0x000378, "Member 'UGameplayEffect::InheritableOwnedTagsContainer' has a wrong offset!");
static_assert(offsetof(UGameplayEffect, InheritableBlockedAbilityTagsContainer) == 0x0003D8, "Member 'UGameplayEffect::InheritableBlockedAbilityTagsContainer' has a wrong offset!");
static_assert(offsetof(UGameplayEffect, OngoingTagRequirements) == 0x000438, "Member 'UGameplayEffect::OngoingTagRequirements' has a wrong offset!");
static_assert(offsetof(UGameplayEffect, ApplicationTagRequirements) == 0x000478, "Member 'UGameplayEffect::ApplicationTagRequirements' has a wrong offset!");
static_assert(offsetof(UGameplayEffect, RemovalTagRequirements) == 0x0004B8, "Member 'UGameplayEffect::RemovalTagRequirements' has a wrong offset!");
static_assert(offsetof(UGameplayEffect, RemoveGameplayEffectsWithTags) == 0x0004F8, "Member 'UGameplayEffect::RemoveGameplayEffectsWithTags' has a wrong offset!");
static_assert(offsetof(UGameplayEffect, GrantedApplicationImmunityTags) == 0x000558, "Member 'UGameplayEffect::GrantedApplicationImmunityTags' has a wrong offset!");
static_assert(offsetof(UGameplayEffect, GrantedApplicationImmunityQuery) == 0x000598, "Member 'UGameplayEffect::GrantedApplicationImmunityQuery' has a wrong offset!");
static_assert(offsetof(UGameplayEffect, RemoveGameplayEffectQuery) == 0x0006F0, "Member 'UGameplayEffect::RemoveGameplayEffectQuery' has a wrong offset!");
static_assert(offsetof(UGameplayEffect, StackingType) == 0x000841, "Member 'UGameplayEffect::StackingType' has a wrong offset!");
static_assert(offsetof(UGameplayEffect, StackLimitCount) == 0x000844, "Member 'UGameplayEffect::StackLimitCount' has a wrong offset!");
static_assert(offsetof(UGameplayEffect, StackDurationRefreshPolicy) == 0x000848, "Member 'UGameplayEffect::StackDurationRefreshPolicy' has a wrong offset!");
static_assert(offsetof(UGameplayEffect, StackPeriodResetPolicy) == 0x000849, "Member 'UGameplayEffect::StackPeriodResetPolicy' has a wrong offset!");
static_assert(offsetof(UGameplayEffect, StackExpirationPolicy) == 0x00084A, "Member 'UGameplayEffect::StackExpirationPolicy' has a wrong offset!");
static_assert(offsetof(UGameplayEffect, GrantedAbilities) == 0x000850, "Member 'UGameplayEffect::GrantedAbilities' has a wrong offset!");

// Class GameplayAbilities.GameplayEffectCalculation
// 0x0010 (0x0038 - 0x0028)
class UGameplayEffectCalculation : public UObject
{
public:
	TArray<struct FGameplayEffectAttributeCaptureDefinition> RelevantAttributesToCapture;            // 0x0028(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"GameplayEffectCalculation">();
	}
	static class UGameplayEffectCalculation* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UGameplayEffectCalculation>();
	}
};
static_assert(alignof(UGameplayEffectCalculation) == 0x000008, "Wrong alignment on UGameplayEffectCalculation");
static_assert(sizeof(UGameplayEffectCalculation) == 0x000038, "Wrong size on UGameplayEffectCalculation");
static_assert(offsetof(UGameplayEffectCalculation, RelevantAttributesToCapture) == 0x000028, "Member 'UGameplayEffectCalculation::RelevantAttributesToCapture' has a wrong offset!");

// Class GameplayAbilities.GameplayEffectCustomApplicationRequirement
// 0x0000 (0x0028 - 0x0028)
class UGameplayEffectCustomApplicationRequirement : public UObject
{
public:
	bool CanApplyGameplayEffect(const class UGameplayEffect* GameplayEffect, const struct FGameplayEffectSpec& Spec, class UAbilitySystemComponent* ASC) const	 // 0x3dea654;

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"GameplayEffectCustomApplicationRequirement">();
	}
	static class UGameplayEffectCustomApplicationRequirement* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UGameplayEffectCustomApplicationRequirement>();
	}
};
static_assert(alignof(UGameplayEffectCustomApplicationRequirement) == 0x000008, "Wrong alignment on UGameplayEffectCustomApplicationRequirement");
static_assert(sizeof(UGameplayEffectCustomApplicationRequirement) == 0x000028, "Wrong size on UGameplayEffectCustomApplicationRequirement");

// Class GameplayAbilities.GameplayEffectExecutionCalculation
// 0x0008 (0x0040 - 0x0038)
class UGameplayEffectExecutionCalculation : public UGameplayEffectCalculation
{
public:
	bool                                          bRequiresPassedInTags;                             // 0x0038(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_39[0x7];                                       // 0x0039(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Execute(const struct FGameplayEffectCustomExecutionParameters& ExecutionParams, struct FGameplayEffectCustomExecutionOutput* OutExecutionOutput) const	 // 0x3dea888;

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"GameplayEffectExecutionCalculation">();
	}
	static class UGameplayEffectExecutionCalculation* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UGameplayEffectExecutionCalculation>();
	}
};
static_assert(alignof(UGameplayEffectExecutionCalculation) == 0x000008, "Wrong alignment on UGameplayEffectExecutionCalculation");
static_assert(sizeof(UGameplayEffectExecutionCalculation) == 0x000040, "Wrong size on UGameplayEffectExecutionCalculation");
static_assert(offsetof(UGameplayEffectExecutionCalculation, bRequiresPassedInTags) == 0x000038, "Member 'UGameplayEffectExecutionCalculation::bRequiresPassedInTags' has a wrong offset!");

// Class GameplayAbilities.GameplayModMagnitudeCalculation
// 0x0008 (0x0040 - 0x0038)
class UGameplayModMagnitudeCalculation : public UGameplayEffectCalculation
{
public:
	bool                                          bAllowNonNetAuthorityDependencyRegistration;       // 0x0038(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, AdvancedDisplay, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_39[0x7];                                       // 0x0039(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	float CalculateBaseMagnitude(const struct FGameplayEffectSpec& Spec) const	 // 0x1608368;
	float GetSetByCallerMagnitudeByName(const struct FGameplayEffectSpec& EffectSpec, const class FName& MagnitudeName) const	 // 0x3dea9bc;
	float GetSetByCallerMagnitudeByTag(const struct FGameplayEffectSpec& EffectSpec, const struct FGameplayTag& Tag) const	 // 0x3deaad8;
	const struct FGameplayTagContainer GetSourceActorTags(const struct FGameplayEffectSpec& EffectSpec) const	 // 0x3deac70;
	struct FGameplayTagContainer GetSourceAggregatedTags(const struct FGameplayEffectSpec& EffectSpec) const	 // 0x3dead38;
	const struct FGameplayTagContainer GetSourceSpecTags(const struct FGameplayEffectSpec& EffectSpec) const	 // 0x3deae68;
	const struct FGameplayTagContainer GetTargetActorTags(const struct FGameplayEffectSpec& EffectSpec) const	 // 0x3deaf34;
	struct FGameplayTagContainer GetTargetAggregatedTags(const struct FGameplayEffectSpec& EffectSpec) const	 // 0x3deb000;
	const struct FGameplayTagContainer GetTargetSpecTags(const struct FGameplayEffectSpec& EffectSpec) const	 // 0x3deb130;
	float K2_GetCapturedAttributeMagnitude(const struct FGameplayEffectSpec& EffectSpec, const struct FGameplayAttribute& Attribute, const struct FGameplayTagContainer& SourceTags, const struct FGameplayTagContainer& TargetTags) const	 // 0x3deb214;

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"GameplayModMagnitudeCalculation">();
	}
	static class UGameplayModMagnitudeCalculation* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UGameplayModMagnitudeCalculation>();
	}
};
static_assert(alignof(UGameplayModMagnitudeCalculation) == 0x000008, "Wrong alignment on UGameplayModMagnitudeCalculation");
static_assert(sizeof(UGameplayModMagnitudeCalculation) == 0x000040, "Wrong size on UGameplayModMagnitudeCalculation");
static_assert(offsetof(UGameplayModMagnitudeCalculation, bAllowNonNetAuthorityDependencyRegistration) == 0x000038, "Member 'UGameplayModMagnitudeCalculation::bAllowNonNetAuthorityDependencyRegistration' has a wrong offset!");

// Class GameplayAbilities.GameplayTagReponseTable
// 0x01B8 (0x01E8 - 0x0030)
class UGameplayTagReponseTable final : public UDataAsset
{
public:
	TArray<struct FGameplayTagResponseTableEntry> Entries;                                           // 0x0030(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_40[0x1A8];                                     // 0x0040(0x01A8)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void TagResponseEvent(const struct FGameplayTag& Tag, int32 NewCount, class UAbilitySystemComponent* ASC, int32 idx)	 // 0x3deb684;

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"GameplayTagReponseTable">();
	}
	static class UGameplayTagReponseTable* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UGameplayTagReponseTable>();
	}
};
static_assert(alignof(UGameplayTagReponseTable) == 0x000008, "Wrong alignment on UGameplayTagReponseTable");
static_assert(sizeof(UGameplayTagReponseTable) == 0x0001E8, "Wrong size on UGameplayTagReponseTable");
static_assert(offsetof(UGameplayTagReponseTable, Entries) == 0x000030, "Member 'UGameplayTagReponseTable::Entries' has a wrong offset!");

// Class GameplayAbilities.MovieSceneGameplayCueTriggerSection
// 0x00F8 (0x0200 - 0x0108)
class UMovieSceneGameplayCueTriggerSection final : public UMovieSceneHookSection
{
public:
	struct FMovieSceneGameplayCueChannel          Channel;                                           // 0x0108(0x00F8)(AssetRegistrySearchable, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"MovieSceneGameplayCueTriggerSection">();
	}
	static class UMovieSceneGameplayCueTriggerSection* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UMovieSceneGameplayCueTriggerSection>();
	}
};
static_assert(alignof(UMovieSceneGameplayCueTriggerSection) == 0x000008, "Wrong alignment on UMovieSceneGameplayCueTriggerSection");
static_assert(sizeof(UMovieSceneGameplayCueTriggerSection) == 0x000200, "Wrong size on UMovieSceneGameplayCueTriggerSection");
static_assert(offsetof(UMovieSceneGameplayCueTriggerSection, Channel) == 0x000108, "Member 'UMovieSceneGameplayCueTriggerSection::Channel' has a wrong offset!");

// Class GameplayAbilities.MovieSceneGameplayCueSection
// 0x0090 (0x0198 - 0x0108)
class UMovieSceneGameplayCueSection final : public UMovieSceneHookSection
{
public:
	struct FMovieSceneGameplayCueKey              Cue;                                               // 0x0108(0x0090)(Edit, NoDestructor, AssetRegistrySearchable, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"MovieSceneGameplayCueSection">();
	}
	static class UMovieSceneGameplayCueSection* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UMovieSceneGameplayCueSection>();
	}
};
static_assert(alignof(UMovieSceneGameplayCueSection) == 0x000008, "Wrong alignment on UMovieSceneGameplayCueSection");
static_assert(sizeof(UMovieSceneGameplayCueSection) == 0x000198, "Wrong size on UMovieSceneGameplayCueSection");
static_assert(offsetof(UMovieSceneGameplayCueSection, Cue) == 0x000108, "Member 'UMovieSceneGameplayCueSection::Cue' has a wrong offset!");

// Class GameplayAbilities.MovieSceneGameplayCueTrack
// 0x0010 (0x00A8 - 0x0098)
class UMovieSceneGameplayCueTrack final : public UMovieSceneNameableTrack
{
public:
	TArray<class UMovieSceneSection*>             Sections;                                          // 0x0098(0x0010)(ExportObject, ZeroConstructor, ContainsInstancedReference, UObjectWrapper, NativeAccessSpecifierPrivate)

public:
	static void SetSequencerTrackHandler(TDelegate<void(class AActor* Target, const struct FGameplayTag& GameplayTag, const struct FGameplayCueParameters& Parameters, EGameplayCueEvent Event)> InGameplayCueTrackHandler)	 // 0x3deb5cc;

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"MovieSceneGameplayCueTrack">();
	}
	static class UMovieSceneGameplayCueTrack* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UMovieSceneGameplayCueTrack>();
	}
};
static_assert(alignof(UMovieSceneGameplayCueTrack) == 0x000008, "Wrong alignment on UMovieSceneGameplayCueTrack");
static_assert(sizeof(UMovieSceneGameplayCueTrack) == 0x0000A8, "Wrong size on UMovieSceneGameplayCueTrack");
static_assert(offsetof(UMovieSceneGameplayCueTrack, Sections) == 0x000098, "Member 'UMovieSceneGameplayCueTrack::Sections' has a wrong offset!");

// Class GameplayAbilities.TickableAttributeSetInterface
// 0x0000 (0x0000 - 0x0000)
class ITickableAttributeSetInterface final
{
public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"TickableAttributeSetInterface">();
	}
	static class ITickableAttributeSetInterface* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<ITickableAttributeSetInterface>();
	}

	class UObject* AsUObject()	 // 0x0
	{
		return reinterpret_cast<UObject*>(this);
	}
	const class UObject* AsUObject() const	 // 0x0
	{
		return reinterpret_cast<const UObject*>(this);
	}
};
static_assert(alignof(ITickableAttributeSetInterface) == 0x000001, "Wrong alignment on ITickableAttributeSetInterface");
static_assert(sizeof(ITickableAttributeSetInterface) == 0x000001, "Wrong size on ITickableAttributeSetInterface");

}

