#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: Paper2D

#include "Basic.hpp"

#include "Engine_classes.hpp"
#include "Paper2D_structs.hpp"
#include "CoreUObject_structs.hpp"
#include "CoreUObject_classes.hpp"


namespace SDK
{

// Class Paper2D.PaperCharacter
// 0x0000 (0x0660 - 0x0660)
class APaperCharacter final : public ACharacter
{
public:
	class UPaperFlipbookComponent*                Sprite;                                            // 0x0658(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"PaperCharacter">();
	}
	static class APaperCharacter* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<APaperCharacter>();
	}
};
static_assert(alignof(APaperCharacter) == 0x000010, "Wrong alignment on APaperCharacter");
static_assert(sizeof(APaperCharacter) == 0x000660, "Wrong size on APaperCharacter");
static_assert(offsetof(APaperCharacter, Sprite) == 0x000658, "Member 'APaperCharacter::Sprite' has a wrong offset!");

// Class Paper2D.PaperFlipbook
// 0x0028 (0x0050 - 0x0028)
class UPaperFlipbook final : public UObject
{
public:
	float                                         framesPerSecond;                                   // 0x0028(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2C[0x4];                                       // 0x002C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FPaperFlipbookKeyFrame>         KeyFrames;                                         // 0x0030(0x0010)(Edit, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	class UMaterialInterface*                     DefaultMaterial;                                   // 0x0040(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EFlipbookCollisionMode                        CollisionSource;                                   // 0x0048(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_49[0x7];                                       // 0x0049(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	int32 GetKeyFrameIndexAtTime(float Time, bool bClampToEnds) const	 // 0x511cdc8;
	int32 GetNumFrames() const	 // 0x511d160;
	int32 GetNumKeyFrames() const	 // 0x46db7e8;
	class UPaperSprite* GetSpriteAtFrame(int32 FrameIndex) const	 // 0x511d1ec;
	class UPaperSprite* GetSpriteAtTime(float Time, bool bClampToEnds) const	 // 0x511d2bc;
	float GetTotalDuration() const	 // 0x511e038;
	bool IsValidKeyFrameIndex(int32 Index_0) const	 // 0x511e0b0;

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"PaperFlipbook">();
	}
	static class UPaperFlipbook* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UPaperFlipbook>();
	}
};
static_assert(alignof(UPaperFlipbook) == 0x000008, "Wrong alignment on UPaperFlipbook");
static_assert(sizeof(UPaperFlipbook) == 0x000050, "Wrong size on UPaperFlipbook");
static_assert(offsetof(UPaperFlipbook, framesPerSecond) == 0x000028, "Member 'UPaperFlipbook::framesPerSecond' has a wrong offset!");
static_assert(offsetof(UPaperFlipbook, KeyFrames) == 0x000030, "Member 'UPaperFlipbook::KeyFrames' has a wrong offset!");
static_assert(offsetof(UPaperFlipbook, DefaultMaterial) == 0x000040, "Member 'UPaperFlipbook::DefaultMaterial' has a wrong offset!");
static_assert(offsetof(UPaperFlipbook, CollisionSource) == 0x000048, "Member 'UPaperFlipbook::CollisionSource' has a wrong offset!");

// Class Paper2D.PaperFlipbookActor
// 0x0008 (0x02B8 - 0x02B0)
class APaperFlipbookActor final : public AActor
{
public:
	class UPaperFlipbookComponent*                RenderComponent;                                   // 0x02B0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"PaperFlipbookActor">();
	}
	static class APaperFlipbookActor* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<APaperFlipbookActor>();
	}
};
static_assert(alignof(APaperFlipbookActor) == 0x000008, "Wrong alignment on APaperFlipbookActor");
static_assert(sizeof(APaperFlipbookActor) == 0x0002B8, "Wrong size on APaperFlipbookActor");
static_assert(offsetof(APaperFlipbookActor, RenderComponent) == 0x0002B0, "Member 'APaperFlipbookActor::RenderComponent' has a wrong offset!");

// Class Paper2D.PaperFlipbookComponent
// 0x0050 (0x0630 - 0x05E0)
class UPaperFlipbookComponent final : public UMeshComponent
{
public:
	class UPaperFlipbook*                         SourceFlipbook;                                    // 0x05E0(0x0008)(Edit, Net, ZeroConstructor, RepNotify, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UMaterialInterface*                     Material;                                          // 0x05E8(0x0008)(ZeroConstructor, Deprecated, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         PlayRate;                                          // 0x05F0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         bLooping : 1;                                      // 0x05F4(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bReversePlayback : 1;                              // 0x05F4(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bPlaying : 1;                                      // 0x05F4(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         Pad_5F5[0x3];                                      // 0x05F5(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         AccumulatedTime;                                   // 0x05F8(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         CachedFrameIndex;                                  // 0x05FC(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FLinearColor                           SpriteColor;                                       // 0x0600(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UBodySetup*                             CachedBodySetup;                                   // 0x0610(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TMulticastInlineDelegate<void()>              OnFinishedPlaying;                                 // 0x0618(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_628[0x8];                                      // 0x0628(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	class UPaperFlipbook* GetFlipbook()	 // 0x511cb34;
	void OnRep_SourceFlipbook(class UPaperFlipbook* OldFlipbook)	 // 0x511e7b4;
	void Play()	 // 0x511e8a4;
	void PlayFromStart()	 // 0x511e8b8;
	void Reverse()	 // 0x511eb08;
	void ReverseFromEnd()	 // 0x511eb1c;
	bool SetFlipbook(class UPaperFlipbook* NewFlipbook)	 // 0x511ecb8;
	void SetLooping(bool bNewLooping)	 // 0x511f2bc;
	void SetNewTime(float NewTime)	 // 0x511f388;
	void SetPlaybackPosition(float NewPosition, bool bFireEvents)	 // 0x511f510;
	void SetPlaybackPositionInFrames(int32 NewFramePosition, bool bFireEvents)	 // 0x511f648;
	void SetPlayRate(float NewRate)	 // 0x511f44c;
	void SetSpriteColor(const struct FLinearColor& NewColor)	 // 0x511f794;
	void Stop()	 // 0x511fea0;

	float GetFlipbookFramerate() const	 // 0x511cb5c;
	float GetFlipbookLength() const	 // 0x511cb7c;
	int32 GetFlipbookLengthInFrames() const	 // 0x511cb9c;
	float GetPlaybackPosition() const	 // 0x511cbbc;
	int32 GetPlaybackPositionInFrames() const	 // 0x511d198;
	float GetPlayRate() const	 // 0x511d180;
	struct FLinearColor GetSpriteColor() const	 // 0x511d420;
	bool IsLooping() const	 // 0x511e058;
	bool IsPlaying() const	 // 0x511e074;
	bool IsReversing() const	 // 0x511e090;

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"PaperFlipbookComponent">();
	}
	static class UPaperFlipbookComponent* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UPaperFlipbookComponent>();
	}
};
static_assert(alignof(UPaperFlipbookComponent) == 0x000010, "Wrong alignment on UPaperFlipbookComponent");
static_assert(sizeof(UPaperFlipbookComponent) == 0x000630, "Wrong size on UPaperFlipbookComponent");
static_assert(offsetof(UPaperFlipbookComponent, SourceFlipbook) == 0x0005E0, "Member 'UPaperFlipbookComponent::SourceFlipbook' has a wrong offset!");
static_assert(offsetof(UPaperFlipbookComponent, Material) == 0x0005E8, "Member 'UPaperFlipbookComponent::Material' has a wrong offset!");
static_assert(offsetof(UPaperFlipbookComponent, PlayRate) == 0x0005F0, "Member 'UPaperFlipbookComponent::PlayRate' has a wrong offset!");
static_assert(offsetof(UPaperFlipbookComponent, AccumulatedTime) == 0x0005F8, "Member 'UPaperFlipbookComponent::AccumulatedTime' has a wrong offset!");
static_assert(offsetof(UPaperFlipbookComponent, CachedFrameIndex) == 0x0005FC, "Member 'UPaperFlipbookComponent::CachedFrameIndex' has a wrong offset!");
static_assert(offsetof(UPaperFlipbookComponent, SpriteColor) == 0x000600, "Member 'UPaperFlipbookComponent::SpriteColor' has a wrong offset!");
static_assert(offsetof(UPaperFlipbookComponent, CachedBodySetup) == 0x000610, "Member 'UPaperFlipbookComponent::CachedBodySetup' has a wrong offset!");
static_assert(offsetof(UPaperFlipbookComponent, OnFinishedPlaying) == 0x000618, "Member 'UPaperFlipbookComponent::OnFinishedPlaying' has a wrong offset!");

// Class Paper2D.PaperGroupedSpriteActor
// 0x0008 (0x02B8 - 0x02B0)
class APaperGroupedSpriteActor final : public AActor
{
public:
	class UPaperGroupedSpriteComponent*           RenderComponent;                                   // 0x02B0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"PaperGroupedSpriteActor">();
	}
	static class APaperGroupedSpriteActor* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<APaperGroupedSpriteActor>();
	}
};
static_assert(alignof(APaperGroupedSpriteActor) == 0x000008, "Wrong alignment on APaperGroupedSpriteActor");
static_assert(sizeof(APaperGroupedSpriteActor) == 0x0002B8, "Wrong size on APaperGroupedSpriteActor");
static_assert(offsetof(APaperGroupedSpriteActor, RenderComponent) == 0x0002B0, "Member 'APaperGroupedSpriteActor::RenderComponent' has a wrong offset!");

// Class Paper2D.PaperGroupedSpriteComponent
// 0x0030 (0x0610 - 0x05E0)
class UPaperGroupedSpriteComponent final : public UMeshComponent
{
public:
	TArray<class UMaterialInterface*>             InstanceMaterials;                                 // 0x05E0(0x0010)(ZeroConstructor, Protected, UObjectWrapper, NativeAccessSpecifierProtected)
	TArray<struct FSpriteInstanceData>            PerInstanceSpriteData;                             // 0x05F0(0x0010)(Edit, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_600[0x10];                                     // 0x0600(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	int32 AddInstance(const struct FTransform& Transform, class UPaperSprite* Sprite, bool bWorldSpace, const struct FLinearColor& Color)	 // 0x511c160;
	void ClearInstances()	 // 0x511c7ec;
	bool RemoveInstance(int32 InstanceIndex)	 // 0x511e8f8;
	void SortInstancesAlongAxis(const struct FVector& WorldSpaceSortAxis)	 // 0x511fdcc;
	bool UpdateInstanceColor(int32 InstanceIndex, const struct FLinearColor& NewInstanceColor, bool bMarkRenderStateDirty)	 // 0x511feb8;
	bool UpdateInstanceTransform(int32 InstanceIndex, const struct FTransform& NewInstanceTransform, bool bWorldSpace, bool bMarkRenderStateDirty, bool bTeleport)	 // 0x5120090;

	int32 GetInstanceCount() const	 // 0x511cbbc;
	bool GetInstanceTransform(int32 InstanceIndex, struct FTransform* OutInstanceTransform, bool bWorldSpace) const	 // 0x511cbd4;

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"PaperGroupedSpriteComponent">();
	}
	static class UPaperGroupedSpriteComponent* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UPaperGroupedSpriteComponent>();
	}
};
static_assert(alignof(UPaperGroupedSpriteComponent) == 0x000010, "Wrong alignment on UPaperGroupedSpriteComponent");
static_assert(sizeof(UPaperGroupedSpriteComponent) == 0x000610, "Wrong size on UPaperGroupedSpriteComponent");
static_assert(offsetof(UPaperGroupedSpriteComponent, InstanceMaterials) == 0x0005E0, "Member 'UPaperGroupedSpriteComponent::InstanceMaterials' has a wrong offset!");
static_assert(offsetof(UPaperGroupedSpriteComponent, PerInstanceSpriteData) == 0x0005F0, "Member 'UPaperGroupedSpriteComponent::PerInstanceSpriteData' has a wrong offset!");

// Class Paper2D.PaperRuntimeSettings
// 0x0008 (0x0030 - 0x0028)
class UPaperRuntimeSettings final : public UObject
{
public:
	bool                                          bEnableSpriteAtlasGroups;                          // 0x0028(0x0001)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bEnableTerrainSplineEditing;                       // 0x0029(0x0001)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bResizeSpriteDataToMatchTextures;                  // 0x002A(0x0001)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2B[0x5];                                       // 0x002B(0x0005)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"PaperRuntimeSettings">();
	}
	static class UPaperRuntimeSettings* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UPaperRuntimeSettings>();
	}
};
static_assert(alignof(UPaperRuntimeSettings) == 0x000008, "Wrong alignment on UPaperRuntimeSettings");
static_assert(sizeof(UPaperRuntimeSettings) == 0x000030, "Wrong size on UPaperRuntimeSettings");
static_assert(offsetof(UPaperRuntimeSettings, bEnableSpriteAtlasGroups) == 0x000028, "Member 'UPaperRuntimeSettings::bEnableSpriteAtlasGroups' has a wrong offset!");
static_assert(offsetof(UPaperRuntimeSettings, bEnableTerrainSplineEditing) == 0x000029, "Member 'UPaperRuntimeSettings::bEnableTerrainSplineEditing' has a wrong offset!");
static_assert(offsetof(UPaperRuntimeSettings, bResizeSpriteDataToMatchTextures) == 0x00002A, "Member 'UPaperRuntimeSettings::bResizeSpriteDataToMatchTextures' has a wrong offset!");

// Class Paper2D.PaperSprite
// 0x0090 (0x00B8 - 0x0028)
class UPaperSprite final : public UObject
{
public:
	uint8                                         Pad_28[0x10];                                      // 0x0028(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UTexture*>                       AdditionalSourceTextures;                          // 0x0038(0x0010)(Edit, ZeroConstructor, AssetRegistrySearchable, Protected, UObjectWrapper, NativeAccessSpecifierProtected)
	struct FVector2D                              BakedSourceUV;                                     // 0x0048(0x0010)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector2D                              BakedSourceDimension;                              // 0x0058(0x0010)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTexture2D*                             BakedSourceTexture;                                // 0x0068(0x0008)(ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UMaterialInterface*                     DefaultMaterial;                                   // 0x0070(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UMaterialInterface*                     AlternateMaterial;                                 // 0x0078(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<struct FPaperSpriteSocket>             Sockets;                                           // 0x0080(0x0010)(Edit, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	ESpriteCollisionMode                          SpriteCollisionDomain;                             // 0x0090(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_91[0x3];                                       // 0x0091(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         PixelsPerUnrealUnit;                               // 0x0094(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UBodySetup*                             BodySetup;                                         // 0x0098(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         AlternateMaterialSplitIndex;                       // 0x00A0(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A4[0x4];                                       // 0x00A4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FVector4>                       BakedRenderData;                                   // 0x00A8(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"PaperSprite">();
	}
	static class UPaperSprite* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UPaperSprite>();
	}
};
static_assert(alignof(UPaperSprite) == 0x000008, "Wrong alignment on UPaperSprite");
static_assert(sizeof(UPaperSprite) == 0x0000B8, "Wrong size on UPaperSprite");
static_assert(offsetof(UPaperSprite, AdditionalSourceTextures) == 0x000038, "Member 'UPaperSprite::AdditionalSourceTextures' has a wrong offset!");
static_assert(offsetof(UPaperSprite, BakedSourceUV) == 0x000048, "Member 'UPaperSprite::BakedSourceUV' has a wrong offset!");
static_assert(offsetof(UPaperSprite, BakedSourceDimension) == 0x000058, "Member 'UPaperSprite::BakedSourceDimension' has a wrong offset!");
static_assert(offsetof(UPaperSprite, BakedSourceTexture) == 0x000068, "Member 'UPaperSprite::BakedSourceTexture' has a wrong offset!");
static_assert(offsetof(UPaperSprite, DefaultMaterial) == 0x000070, "Member 'UPaperSprite::DefaultMaterial' has a wrong offset!");
static_assert(offsetof(UPaperSprite, AlternateMaterial) == 0x000078, "Member 'UPaperSprite::AlternateMaterial' has a wrong offset!");
static_assert(offsetof(UPaperSprite, Sockets) == 0x000080, "Member 'UPaperSprite::Sockets' has a wrong offset!");
static_assert(offsetof(UPaperSprite, SpriteCollisionDomain) == 0x000090, "Member 'UPaperSprite::SpriteCollisionDomain' has a wrong offset!");
static_assert(offsetof(UPaperSprite, PixelsPerUnrealUnit) == 0x000094, "Member 'UPaperSprite::PixelsPerUnrealUnit' has a wrong offset!");
static_assert(offsetof(UPaperSprite, BodySetup) == 0x000098, "Member 'UPaperSprite::BodySetup' has a wrong offset!");
static_assert(offsetof(UPaperSprite, AlternateMaterialSplitIndex) == 0x0000A0, "Member 'UPaperSprite::AlternateMaterialSplitIndex' has a wrong offset!");
static_assert(offsetof(UPaperSprite, BakedRenderData) == 0x0000A8, "Member 'UPaperSprite::BakedRenderData' has a wrong offset!");

// Class Paper2D.PaperSpriteActor
// 0x0008 (0x02B8 - 0x02B0)
class APaperSpriteActor final : public AActor
{
public:
	class UPaperSpriteComponent*                  RenderComponent;                                   // 0x02B0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"PaperSpriteActor">();
	}
	static class APaperSpriteActor* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<APaperSpriteActor>();
	}
};
static_assert(alignof(APaperSpriteActor) == 0x000008, "Wrong alignment on APaperSpriteActor");
static_assert(sizeof(APaperSpriteActor) == 0x0002B8, "Wrong size on APaperSpriteActor");
static_assert(offsetof(APaperSpriteActor, RenderComponent) == 0x0002B0, "Member 'APaperSpriteActor::RenderComponent' has a wrong offset!");

// Class Paper2D.PaperSpriteAtlas
// 0x0000 (0x0028 - 0x0028)
class UPaperSpriteAtlas final : public UObject
{
public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"PaperSpriteAtlas">();
	}
	static class UPaperSpriteAtlas* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UPaperSpriteAtlas>();
	}
};
static_assert(alignof(UPaperSpriteAtlas) == 0x000008, "Wrong alignment on UPaperSpriteAtlas");
static_assert(sizeof(UPaperSpriteAtlas) == 0x000028, "Wrong size on UPaperSpriteAtlas");

// Class Paper2D.PaperSpriteBlueprintLibrary
// 0x0000 (0x0028 - 0x0028)
class UPaperSpriteBlueprintLibrary final : public UBlueprintFunctionLibrary
{
public:
	static struct FSlateBrush MakeBrushFromSprite(class UPaperSprite* Sprite, int32 Width, int32 Height)	 // 0x511e184;

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"PaperSpriteBlueprintLibrary">();
	}
	static class UPaperSpriteBlueprintLibrary* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UPaperSpriteBlueprintLibrary>();
	}
};
static_assert(alignof(UPaperSpriteBlueprintLibrary) == 0x000008, "Wrong alignment on UPaperSpriteBlueprintLibrary");
static_assert(sizeof(UPaperSpriteBlueprintLibrary) == 0x000028, "Wrong size on UPaperSpriteBlueprintLibrary");

// Class Paper2D.PaperSpriteComponent
// 0x0020 (0x0600 - 0x05E0)
class UPaperSpriteComponent final : public UMeshComponent
{
public:
	class UPaperSprite*                           SourceSprite;                                      // 0x05E0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UMaterialInterface*                     MaterialOverride;                                  // 0x05E8(0x0008)(ZeroConstructor, Deprecated, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FLinearColor                           SpriteColor;                                       // 0x05F0(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	class UPaperSprite* GetSprite()	 // 0x511cb34;
	bool SetSprite(class UPaperSprite* NewSprite)	 // 0x511ecb8;
	void SetSpriteColor(const struct FLinearColor& NewColor)	 // 0x511f8a4;

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"PaperSpriteComponent">();
	}
	static class UPaperSpriteComponent* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UPaperSpriteComponent>();
	}
};
static_assert(alignof(UPaperSpriteComponent) == 0x000010, "Wrong alignment on UPaperSpriteComponent");
static_assert(sizeof(UPaperSpriteComponent) == 0x000600, "Wrong size on UPaperSpriteComponent");
static_assert(offsetof(UPaperSpriteComponent, SourceSprite) == 0x0005E0, "Member 'UPaperSpriteComponent::SourceSprite' has a wrong offset!");
static_assert(offsetof(UPaperSpriteComponent, MaterialOverride) == 0x0005E8, "Member 'UPaperSpriteComponent::MaterialOverride' has a wrong offset!");
static_assert(offsetof(UPaperSpriteComponent, SpriteColor) == 0x0005F0, "Member 'UPaperSpriteComponent::SpriteColor' has a wrong offset!");

// Class Paper2D.PaperTileLayer
// 0x0070 (0x0098 - 0x0028)
class UPaperTileLayer final : public UObject
{
public:
	class FText                                   LayerName;                                         // 0x0028(0x0018)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	int32                                         LayerWidth;                                        // 0x0040(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         LayerHeight;                                       // 0x0044(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         bHiddenInGame : 1;                                 // 0x0048(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate))
	uint8                                         bLayerCollides : 1;                                // 0x0048(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate))
	uint8                                         bOverrideCollisionThickness : 1;                   // 0x0048(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate))
	uint8                                         bOverrideCollisionOffset : 1;                      // 0x0048(0x0001)(BitIndex: 0x03, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate))
	uint8                                         Pad_49[0x3];                                       // 0x0049(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         CollisionThicknessOverride;                        // 0x004C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         CollisionOffsetOverride;                           // 0x0050(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FLinearColor                           LayerColor;                                        // 0x0054(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         AllocatedWidth;                                    // 0x0064(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         AllocatedHeight;                                   // 0x0068(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_6C[0x4];                                       // 0x006C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FPaperTileInfo>                 AllocatedCells;                                    // 0x0070(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	class UPaperTileSet*                          TileSet;                                           // 0x0080(0x0008)(ZeroConstructor, Deprecated, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<int32>                                 AllocatedGrid;                                     // 0x0088(0x0010)(ZeroConstructor, Deprecated, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"PaperTileLayer">();
	}
	static class UPaperTileLayer* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UPaperTileLayer>();
	}
};
static_assert(alignof(UPaperTileLayer) == 0x000008, "Wrong alignment on UPaperTileLayer");
static_assert(sizeof(UPaperTileLayer) == 0x000098, "Wrong size on UPaperTileLayer");
static_assert(offsetof(UPaperTileLayer, LayerName) == 0x000028, "Member 'UPaperTileLayer::LayerName' has a wrong offset!");
static_assert(offsetof(UPaperTileLayer, LayerWidth) == 0x000040, "Member 'UPaperTileLayer::LayerWidth' has a wrong offset!");
static_assert(offsetof(UPaperTileLayer, LayerHeight) == 0x000044, "Member 'UPaperTileLayer::LayerHeight' has a wrong offset!");
static_assert(offsetof(UPaperTileLayer, CollisionThicknessOverride) == 0x00004C, "Member 'UPaperTileLayer::CollisionThicknessOverride' has a wrong offset!");
static_assert(offsetof(UPaperTileLayer, CollisionOffsetOverride) == 0x000050, "Member 'UPaperTileLayer::CollisionOffsetOverride' has a wrong offset!");
static_assert(offsetof(UPaperTileLayer, LayerColor) == 0x000054, "Member 'UPaperTileLayer::LayerColor' has a wrong offset!");
static_assert(offsetof(UPaperTileLayer, AllocatedWidth) == 0x000064, "Member 'UPaperTileLayer::AllocatedWidth' has a wrong offset!");
static_assert(offsetof(UPaperTileLayer, AllocatedHeight) == 0x000068, "Member 'UPaperTileLayer::AllocatedHeight' has a wrong offset!");
static_assert(offsetof(UPaperTileLayer, AllocatedCells) == 0x000070, "Member 'UPaperTileLayer::AllocatedCells' has a wrong offset!");
static_assert(offsetof(UPaperTileLayer, TileSet) == 0x000080, "Member 'UPaperTileLayer::TileSet' has a wrong offset!");
static_assert(offsetof(UPaperTileLayer, AllocatedGrid) == 0x000088, "Member 'UPaperTileLayer::AllocatedGrid' has a wrong offset!");

// Class Paper2D.PaperTileMap
// 0x0088 (0x00B0 - 0x0028)
class UPaperTileMap final : public UObject
{
public:
	int32                                         MapWidth;                                          // 0x0028(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MapHeight;                                         // 0x002C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         TileWidth;                                         // 0x0030(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         TileHeight;                                        // 0x0034(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PixelsPerUnrealUnit;                               // 0x0038(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SeparationPerTileX;                                // 0x003C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SeparationPerTileY;                                // 0x0040(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SeparationPerLayer;                                // 0x0044(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UPaperTileSet>           SelectedTileSet;                                   // 0x0048(0x0030)(UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMaterialInterface*                     Material;                                          // 0x0078(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class UPaperTileLayer*>                TileLayers;                                        // 0x0080(0x0010)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, ContainsInstancedReference, UObjectWrapper, NativeAccessSpecifierPublic)
	float                                         CollisionThickness;                                // 0x0090(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	ESpriteCollisionMode                          SpriteCollisionDomain;                             // 0x0094(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	ETileMapProjectionMode                        ProjectionMode;                                    // 0x0095(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_96[0x2];                                       // 0x0096(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         HexSideLength;                                     // 0x0098(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9C[0x4];                                       // 0x009C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UBodySetup*                             BodySetup;                                         // 0x00A0(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         LayerNameIndex;                                    // 0x00A8(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_AC[0x4];                                       // 0x00AC(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"PaperTileMap">();
	}
	static class UPaperTileMap* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UPaperTileMap>();
	}
};
static_assert(alignof(UPaperTileMap) == 0x000008, "Wrong alignment on UPaperTileMap");
static_assert(sizeof(UPaperTileMap) == 0x0000B0, "Wrong size on UPaperTileMap");
static_assert(offsetof(UPaperTileMap, MapWidth) == 0x000028, "Member 'UPaperTileMap::MapWidth' has a wrong offset!");
static_assert(offsetof(UPaperTileMap, MapHeight) == 0x00002C, "Member 'UPaperTileMap::MapHeight' has a wrong offset!");
static_assert(offsetof(UPaperTileMap, TileWidth) == 0x000030, "Member 'UPaperTileMap::TileWidth' has a wrong offset!");
static_assert(offsetof(UPaperTileMap, TileHeight) == 0x000034, "Member 'UPaperTileMap::TileHeight' has a wrong offset!");
static_assert(offsetof(UPaperTileMap, PixelsPerUnrealUnit) == 0x000038, "Member 'UPaperTileMap::PixelsPerUnrealUnit' has a wrong offset!");
static_assert(offsetof(UPaperTileMap, SeparationPerTileX) == 0x00003C, "Member 'UPaperTileMap::SeparationPerTileX' has a wrong offset!");
static_assert(offsetof(UPaperTileMap, SeparationPerTileY) == 0x000040, "Member 'UPaperTileMap::SeparationPerTileY' has a wrong offset!");
static_assert(offsetof(UPaperTileMap, SeparationPerLayer) == 0x000044, "Member 'UPaperTileMap::SeparationPerLayer' has a wrong offset!");
static_assert(offsetof(UPaperTileMap, SelectedTileSet) == 0x000048, "Member 'UPaperTileMap::SelectedTileSet' has a wrong offset!");
static_assert(offsetof(UPaperTileMap, Material) == 0x000078, "Member 'UPaperTileMap::Material' has a wrong offset!");
static_assert(offsetof(UPaperTileMap, TileLayers) == 0x000080, "Member 'UPaperTileMap::TileLayers' has a wrong offset!");
static_assert(offsetof(UPaperTileMap, CollisionThickness) == 0x000090, "Member 'UPaperTileMap::CollisionThickness' has a wrong offset!");
static_assert(offsetof(UPaperTileMap, SpriteCollisionDomain) == 0x000094, "Member 'UPaperTileMap::SpriteCollisionDomain' has a wrong offset!");
static_assert(offsetof(UPaperTileMap, ProjectionMode) == 0x000095, "Member 'UPaperTileMap::ProjectionMode' has a wrong offset!");
static_assert(offsetof(UPaperTileMap, HexSideLength) == 0x000098, "Member 'UPaperTileMap::HexSideLength' has a wrong offset!");
static_assert(offsetof(UPaperTileMap, BodySetup) == 0x0000A0, "Member 'UPaperTileMap::BodySetup' has a wrong offset!");
static_assert(offsetof(UPaperTileMap, LayerNameIndex) == 0x0000A8, "Member 'UPaperTileMap::LayerNameIndex' has a wrong offset!");

// Class Paper2D.PaperTileMapActor
// 0x0008 (0x02B8 - 0x02B0)
class APaperTileMapActor final : public AActor
{
public:
	class UPaperTileMapComponent*                 RenderComponent;                                   // 0x02B0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"PaperTileMapActor">();
	}
	static class APaperTileMapActor* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<APaperTileMapActor>();
	}
};
static_assert(alignof(APaperTileMapActor) == 0x000008, "Wrong alignment on APaperTileMapActor");
static_assert(sizeof(APaperTileMapActor) == 0x0002B8, "Wrong size on APaperTileMapActor");
static_assert(offsetof(APaperTileMapActor, RenderComponent) == 0x0002B0, "Member 'APaperTileMapActor::RenderComponent' has a wrong offset!");

// Class Paper2D.PaperTileMapComponent
// 0x0050 (0x0630 - 0x05E0)
class UPaperTileMapComponent final : public UMeshComponent
{
public:
	int32                                         MapWidth;                                          // 0x05E0(0x0004)(ZeroConstructor, Deprecated, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         MapHeight;                                         // 0x05E4(0x0004)(ZeroConstructor, Deprecated, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         TileWidth;                                         // 0x05E8(0x0004)(ZeroConstructor, Deprecated, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         TileHeight;                                        // 0x05EC(0x0004)(ZeroConstructor, Deprecated, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UPaperTileSet*                          DefaultLayerTileSet;                               // 0x05F0(0x0008)(ZeroConstructor, Deprecated, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UMaterialInterface*                     Material;                                          // 0x05F8(0x0008)(ZeroConstructor, Deprecated, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<class UPaperTileLayer*>                TileLayers;                                        // 0x0600(0x0010)(ZeroConstructor, Deprecated, UObjectWrapper, NativeAccessSpecifierPrivate)
	struct FLinearColor                           TileMapColor;                                      // 0x0610(0x0010)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         UseSingleLayerIndex;                               // 0x0620(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bUseSingleLayer;                                   // 0x0624(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_625[0x3];                                      // 0x0625(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class UPaperTileMap*                          TileMap;                                           // 0x0628(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	class UPaperTileLayer* AddNewLayer()	 // 0x511c404;
	void CreateNewTileMap(int32 MapWidth_0, int32 MapHeight_0, int32 TileWidth_0, int32 TileHeight_0, float PixelsPerUnrealUnit, bool bCreateLayer)	 // 0x511c804;
	void GetMapSize(int32* MapWidth_0, int32* MapHeight_0, int32* NumLayers)	 // 0x511d010;
	void MakeTileMapEditable()	 // 0x511e754;
	void RebuildCollision()	 // 0x511e8e4;
	void ResizeMap(int32 NewWidthInTiles, int32 NewHeightInTiles)	 // 0x511e9cc;
	void SetDefaultCollisionThickness(float Thickness, bool bRebuildCollision)	 // 0x511eb50;
	void SetLayerCollision(int32 Layer, bool bHasCollision, bool bOverrideThickness, float CustomThickness, bool bOverrideOffset, float CustomOffset, bool bRebuildCollision)	 // 0x511ed90;
	void SetLayerColor(const struct FLinearColor& NewColor, int32 Layer)	 // 0x511f150;
	void SetTile(int32 X, int32 Y, int32 Layer, const struct FPaperTileInfo& NewValue)	 // 0x511fa7c;
	bool SetTileMap(class UPaperTileMap* NewTileMap)	 // 0x511ecb8;
	void SetTileMapColor(const struct FLinearColor& NewColor)	 // 0x511fd08;

	struct FLinearColor GetLayerColor(int32 Layer) const	 // 0x511cf1c;
	struct FPaperTileInfo GetTile(int32 X, int32 Y, int32 Layer) const	 // 0x511d43c;
	struct FVector GetTileCenterPosition(int32 TileX, int32 TileY, int32 LayerIndex, bool bWorldSpace) const	 // 0x511d634;
	struct FVector GetTileCornerPosition(int32 TileX, int32 TileY, int32 LayerIndex, bool bWorldSpace) const	 // 0x511d884;
	struct FLinearColor GetTileMapColor() const	 // 0x511dad4;
	void GetTilePolygon(int32 TileX, int32 TileY, TArray<struct FVector>* Points, int32 LayerIndex, bool bWorldSpace) const	 // 0x511daf0;
	bool OwnsTileMap() const	 // 0x511e884;

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"PaperTileMapComponent">();
	}
	static class UPaperTileMapComponent* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UPaperTileMapComponent>();
	}
};
static_assert(alignof(UPaperTileMapComponent) == 0x000010, "Wrong alignment on UPaperTileMapComponent");
static_assert(sizeof(UPaperTileMapComponent) == 0x000630, "Wrong size on UPaperTileMapComponent");
static_assert(offsetof(UPaperTileMapComponent, MapWidth) == 0x0005E0, "Member 'UPaperTileMapComponent::MapWidth' has a wrong offset!");
static_assert(offsetof(UPaperTileMapComponent, MapHeight) == 0x0005E4, "Member 'UPaperTileMapComponent::MapHeight' has a wrong offset!");
static_assert(offsetof(UPaperTileMapComponent, TileWidth) == 0x0005E8, "Member 'UPaperTileMapComponent::TileWidth' has a wrong offset!");
static_assert(offsetof(UPaperTileMapComponent, TileHeight) == 0x0005EC, "Member 'UPaperTileMapComponent::TileHeight' has a wrong offset!");
static_assert(offsetof(UPaperTileMapComponent, DefaultLayerTileSet) == 0x0005F0, "Member 'UPaperTileMapComponent::DefaultLayerTileSet' has a wrong offset!");
static_assert(offsetof(UPaperTileMapComponent, Material) == 0x0005F8, "Member 'UPaperTileMapComponent::Material' has a wrong offset!");
static_assert(offsetof(UPaperTileMapComponent, TileLayers) == 0x000600, "Member 'UPaperTileMapComponent::TileLayers' has a wrong offset!");
static_assert(offsetof(UPaperTileMapComponent, TileMapColor) == 0x000610, "Member 'UPaperTileMapComponent::TileMapColor' has a wrong offset!");
static_assert(offsetof(UPaperTileMapComponent, UseSingleLayerIndex) == 0x000620, "Member 'UPaperTileMapComponent::UseSingleLayerIndex' has a wrong offset!");
static_assert(offsetof(UPaperTileMapComponent, bUseSingleLayer) == 0x000624, "Member 'UPaperTileMapComponent::bUseSingleLayer' has a wrong offset!");
static_assert(offsetof(UPaperTileMapComponent, TileMap) == 0x000628, "Member 'UPaperTileMapComponent::TileMap' has a wrong offset!");

// Class Paper2D.PaperTileSet
// 0x0080 (0x00A8 - 0x0028)
class UPaperTileSet final : public UObject
{
public:
	struct FIntPoint                              TileSize;                                          // 0x0028(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UTexture2D*                             TileSheet;                                         // 0x0030(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<class UTexture*>                       AdditionalSourceTextures;                          // 0x0038(0x0010)(Edit, ZeroConstructor, AssetRegistrySearchable, UObjectWrapper, NativeAccessSpecifierPrivate)
	struct FIntMargin                             BorderMargin;                                      // 0x0048(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, NativeAccessSpecifierPrivate)
	struct FIntPoint                              PerTileSpacing;                                    // 0x0058(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FIntPoint                              DrawingOffset;                                     // 0x0060(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         WidthInTiles;                                      // 0x0068(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         HeightInTiles;                                     // 0x006C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         AllocatedWidth;                                    // 0x0070(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         AllocatedHeight;                                   // 0x0074(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<struct FPaperTileMetadata>             PerTileData;                                       // 0x0078(0x0010)(Edit, EditFixedSize, ZeroConstructor, NativeAccessSpecifierPrivate)
	TArray<struct FPaperTileSetTerrain>           Terrains;                                          // 0x0088(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	int32                                         TileWidth;                                         // 0x0098(0x0004)(ZeroConstructor, Deprecated, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         TileHeight;                                        // 0x009C(0x0004)(ZeroConstructor, Deprecated, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         Margin;                                            // 0x00A0(0x0004)(ZeroConstructor, Deprecated, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         Spacing;                                           // 0x00A4(0x0004)(ZeroConstructor, Deprecated, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"PaperTileSet">();
	}
	static class UPaperTileSet* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UPaperTileSet>();
	}
};
static_assert(alignof(UPaperTileSet) == 0x000008, "Wrong alignment on UPaperTileSet");
static_assert(sizeof(UPaperTileSet) == 0x0000A8, "Wrong size on UPaperTileSet");
static_assert(offsetof(UPaperTileSet, TileSize) == 0x000028, "Member 'UPaperTileSet::TileSize' has a wrong offset!");
static_assert(offsetof(UPaperTileSet, TileSheet) == 0x000030, "Member 'UPaperTileSet::TileSheet' has a wrong offset!");
static_assert(offsetof(UPaperTileSet, AdditionalSourceTextures) == 0x000038, "Member 'UPaperTileSet::AdditionalSourceTextures' has a wrong offset!");
static_assert(offsetof(UPaperTileSet, BorderMargin) == 0x000048, "Member 'UPaperTileSet::BorderMargin' has a wrong offset!");
static_assert(offsetof(UPaperTileSet, PerTileSpacing) == 0x000058, "Member 'UPaperTileSet::PerTileSpacing' has a wrong offset!");
static_assert(offsetof(UPaperTileSet, DrawingOffset) == 0x000060, "Member 'UPaperTileSet::DrawingOffset' has a wrong offset!");
static_assert(offsetof(UPaperTileSet, WidthInTiles) == 0x000068, "Member 'UPaperTileSet::WidthInTiles' has a wrong offset!");
static_assert(offsetof(UPaperTileSet, HeightInTiles) == 0x00006C, "Member 'UPaperTileSet::HeightInTiles' has a wrong offset!");
static_assert(offsetof(UPaperTileSet, AllocatedWidth) == 0x000070, "Member 'UPaperTileSet::AllocatedWidth' has a wrong offset!");
static_assert(offsetof(UPaperTileSet, AllocatedHeight) == 0x000074, "Member 'UPaperTileSet::AllocatedHeight' has a wrong offset!");
static_assert(offsetof(UPaperTileSet, PerTileData) == 0x000078, "Member 'UPaperTileSet::PerTileData' has a wrong offset!");
static_assert(offsetof(UPaperTileSet, Terrains) == 0x000088, "Member 'UPaperTileSet::Terrains' has a wrong offset!");
static_assert(offsetof(UPaperTileSet, TileWidth) == 0x000098, "Member 'UPaperTileSet::TileWidth' has a wrong offset!");
static_assert(offsetof(UPaperTileSet, TileHeight) == 0x00009C, "Member 'UPaperTileSet::TileHeight' has a wrong offset!");
static_assert(offsetof(UPaperTileSet, Margin) == 0x0000A0, "Member 'UPaperTileSet::Margin' has a wrong offset!");
static_assert(offsetof(UPaperTileSet, Spacing) == 0x0000A4, "Member 'UPaperTileSet::Spacing' has a wrong offset!");

// Class Paper2D.MaterialExpressionSpriteTextureSampler
// 0x0020 (0x0260 - 0x0240)
class UMaterialExpressionSpriteTextureSampler final : public UMaterialExpressionTextureSampleParameter2D
{
public:
	bool                                          bSampleAdditionalTextures;                         // 0x0240(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_241[0x3];                                      // 0x0241(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         AdditionalSlotIndex;                               // 0x0244(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FText                                   SlotDisplayName;                                   // 0x0248(0x0018)(Edit, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"MaterialExpressionSpriteTextureSampler">();
	}
	static class UMaterialExpressionSpriteTextureSampler* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UMaterialExpressionSpriteTextureSampler>();
	}
};
static_assert(alignof(UMaterialExpressionSpriteTextureSampler) == 0x000008, "Wrong alignment on UMaterialExpressionSpriteTextureSampler");
static_assert(sizeof(UMaterialExpressionSpriteTextureSampler) == 0x000260, "Wrong size on UMaterialExpressionSpriteTextureSampler");
static_assert(offsetof(UMaterialExpressionSpriteTextureSampler, bSampleAdditionalTextures) == 0x000240, "Member 'UMaterialExpressionSpriteTextureSampler::bSampleAdditionalTextures' has a wrong offset!");
static_assert(offsetof(UMaterialExpressionSpriteTextureSampler, AdditionalSlotIndex) == 0x000244, "Member 'UMaterialExpressionSpriteTextureSampler::AdditionalSlotIndex' has a wrong offset!");
static_assert(offsetof(UMaterialExpressionSpriteTextureSampler, SlotDisplayName) == 0x000248, "Member 'UMaterialExpressionSpriteTextureSampler::SlotDisplayName' has a wrong offset!");

// Class Paper2D.PaperTerrainActor
// 0x0018 (0x02C8 - 0x02B0)
class APaperTerrainActor final : public AActor
{
public:
	class USceneComponent*                        DummyRoot;                                         // 0x02B0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UPaperTerrainSplineComponent*           SplineComponent;                                   // 0x02B8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UPaperTerrainComponent*                 RenderComponent;                                   // 0x02C0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"PaperTerrainActor">();
	}
	static class APaperTerrainActor* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<APaperTerrainActor>();
	}
};
static_assert(alignof(APaperTerrainActor) == 0x000008, "Wrong alignment on APaperTerrainActor");
static_assert(sizeof(APaperTerrainActor) == 0x0002C8, "Wrong size on APaperTerrainActor");
static_assert(offsetof(APaperTerrainActor, DummyRoot) == 0x0002B0, "Member 'APaperTerrainActor::DummyRoot' has a wrong offset!");
static_assert(offsetof(APaperTerrainActor, SplineComponent) == 0x0002B8, "Member 'APaperTerrainActor::SplineComponent' has a wrong offset!");
static_assert(offsetof(APaperTerrainActor, RenderComponent) == 0x0002C0, "Member 'APaperTerrainActor::RenderComponent' has a wrong offset!");

// Class Paper2D.PaperTerrainComponent
// 0x0050 (0x0600 - 0x05B0)
class UPaperTerrainComponent final : public UPrimitiveComponent
{
public:
	class UPaperTerrainMaterial*                  TerrainMaterial;                                   // 0x05A8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bClosedSpline;                                     // 0x05B0(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bFilledSpline;                                     // 0x05B1(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5B2[0x6];                                      // 0x05B2(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	class UPaperTerrainSplineComponent*           AssociatedSpline;                                  // 0x05B8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         RandomSeed;                                        // 0x05C0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SegmentOverlapAmount;                              // 0x05C4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           TerrainColor;                                      // 0x05C8(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         ReparamStepsPerSegment;                            // 0x05D8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	ESpriteCollisionMode                          SpriteCollisionDomain;                             // 0x05DC(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_5DD[0x3];                                      // 0x05DD(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         CollisionThickness;                                // 0x05E0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_5E4[0x4];                                      // 0x05E4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UBodySetup*                             CachedBodySetup;                                   // 0x05E8(0x0008)(ZeroConstructor, Transient, DuplicateTransient, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_5F0[0x10];                                     // 0x05F0(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SetTerrainColor(const struct FLinearColor& NewColor)	 // 0x511f9b4;

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"PaperTerrainComponent">();
	}
	static class UPaperTerrainComponent* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UPaperTerrainComponent>();
	}
};
static_assert(alignof(UPaperTerrainComponent) == 0x000010, "Wrong alignment on UPaperTerrainComponent");
static_assert(sizeof(UPaperTerrainComponent) == 0x000600, "Wrong size on UPaperTerrainComponent");
static_assert(offsetof(UPaperTerrainComponent, TerrainMaterial) == 0x0005A8, "Member 'UPaperTerrainComponent::TerrainMaterial' has a wrong offset!");
static_assert(offsetof(UPaperTerrainComponent, bClosedSpline) == 0x0005B0, "Member 'UPaperTerrainComponent::bClosedSpline' has a wrong offset!");
static_assert(offsetof(UPaperTerrainComponent, bFilledSpline) == 0x0005B1, "Member 'UPaperTerrainComponent::bFilledSpline' has a wrong offset!");
static_assert(offsetof(UPaperTerrainComponent, AssociatedSpline) == 0x0005B8, "Member 'UPaperTerrainComponent::AssociatedSpline' has a wrong offset!");
static_assert(offsetof(UPaperTerrainComponent, RandomSeed) == 0x0005C0, "Member 'UPaperTerrainComponent::RandomSeed' has a wrong offset!");
static_assert(offsetof(UPaperTerrainComponent, SegmentOverlapAmount) == 0x0005C4, "Member 'UPaperTerrainComponent::SegmentOverlapAmount' has a wrong offset!");
static_assert(offsetof(UPaperTerrainComponent, TerrainColor) == 0x0005C8, "Member 'UPaperTerrainComponent::TerrainColor' has a wrong offset!");
static_assert(offsetof(UPaperTerrainComponent, ReparamStepsPerSegment) == 0x0005D8, "Member 'UPaperTerrainComponent::ReparamStepsPerSegment' has a wrong offset!");
static_assert(offsetof(UPaperTerrainComponent, SpriteCollisionDomain) == 0x0005DC, "Member 'UPaperTerrainComponent::SpriteCollisionDomain' has a wrong offset!");
static_assert(offsetof(UPaperTerrainComponent, CollisionThickness) == 0x0005E0, "Member 'UPaperTerrainComponent::CollisionThickness' has a wrong offset!");
static_assert(offsetof(UPaperTerrainComponent, CachedBodySetup) == 0x0005E8, "Member 'UPaperTerrainComponent::CachedBodySetup' has a wrong offset!");

// Class Paper2D.PaperTerrainMaterial
// 0x0018 (0x0048 - 0x0030)
class UPaperTerrainMaterial final : public UDataAsset
{
public:
	TArray<struct FPaperTerrainMaterialRule>      Rules;                                             // 0x0030(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	class UPaperSprite*                           InteriorFill;                                      // 0x0040(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"PaperTerrainMaterial">();
	}
	static class UPaperTerrainMaterial* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UPaperTerrainMaterial>();
	}
};
static_assert(alignof(UPaperTerrainMaterial) == 0x000008, "Wrong alignment on UPaperTerrainMaterial");
static_assert(sizeof(UPaperTerrainMaterial) == 0x000048, "Wrong size on UPaperTerrainMaterial");
static_assert(offsetof(UPaperTerrainMaterial, Rules) == 0x000030, "Member 'UPaperTerrainMaterial::Rules' has a wrong offset!");
static_assert(offsetof(UPaperTerrainMaterial, InteriorFill) == 0x000040, "Member 'UPaperTerrainMaterial::InteriorFill' has a wrong offset!");

// Class Paper2D.PaperTerrainSplineComponent
// 0x0010 (0x06C0 - 0x06B0)
class UPaperTerrainSplineComponent final : public USplineComponent
{
public:
	uint8                                         Pad_6A8[0x18];                                     // 0x06A8(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"PaperTerrainSplineComponent">();
	}
	static class UPaperTerrainSplineComponent* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UPaperTerrainSplineComponent>();
	}
};
static_assert(alignof(UPaperTerrainSplineComponent) == 0x000010, "Wrong alignment on UPaperTerrainSplineComponent");
static_assert(sizeof(UPaperTerrainSplineComponent) == 0x0006C0, "Wrong size on UPaperTerrainSplineComponent");

// Class Paper2D.TileMapBlueprintLibrary
// 0x0000 (0x0028 - 0x0028)
class UTileMapBlueprintLibrary final : public UBlueprintFunctionLibrary
{
public:
	static void BreakTile(const struct FPaperTileInfo& Tile, int32* TileIndex, class UPaperTileSet** TileSet, bool* bFlipH, bool* bFlipV, bool* bFlipD)	 // 0x511c470;
	static struct FTransform GetTileTransform(const struct FPaperTileInfo& Tile)	 // 0x511de48;
	static class FName GetTileUserData(const struct FPaperTileInfo& Tile)	 // 0x511df50;
	static struct FPaperTileInfo MakeTile(int32 TileIndex, class UPaperTileSet* TileSet, bool bFlipH, bool bFlipV, bool bFlipD)	 // 0x511e43c;

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"TileMapBlueprintLibrary">();
	}
	static class UTileMapBlueprintLibrary* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UTileMapBlueprintLibrary>();
	}
};
static_assert(alignof(UTileMapBlueprintLibrary) == 0x000008, "Wrong alignment on UTileMapBlueprintLibrary");
static_assert(sizeof(UTileMapBlueprintLibrary) == 0x000028, "Wrong size on UTileMapBlueprintLibrary");

}

