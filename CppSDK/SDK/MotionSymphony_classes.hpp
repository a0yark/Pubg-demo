#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: MotionSymphony

#include "Basic.hpp"

#include "GameplayTags_structs.hpp"
#include "Engine_structs.hpp"
#include "Engine_classes.hpp"
#include "MotionSymphony_structs.hpp"
#include "CoreUObject_structs.hpp"
#include "CoreUObject_classes.hpp"


namespace SDK
{

// Class MotionSymphony.AnimDecouplerComponent
// 0x0030 (0x00F0 - 0x00C0)
class UAnimDecouplerComponent final : public UActorComponent
{
public:
	class FName                                   YawCurveName;                                      // 0x00C0(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bNegateCurve;                                      // 0x00C8(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C9[0x27];                                      // 0x00C9(0x0027)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"AnimDecouplerComponent">();
	}
	static class UAnimDecouplerComponent* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UAnimDecouplerComponent>();
	}
};
static_assert(alignof(UAnimDecouplerComponent) == 0x000008, "Wrong alignment on UAnimDecouplerComponent");
static_assert(sizeof(UAnimDecouplerComponent) == 0x0000F0, "Wrong size on UAnimDecouplerComponent");
static_assert(offsetof(UAnimDecouplerComponent, YawCurveName) == 0x0000C0, "Member 'UAnimDecouplerComponent::YawCurveName' has a wrong offset!");
static_assert(offsetof(UAnimDecouplerComponent, bNegateCurve) == 0x0000C8, "Member 'UAnimDecouplerComponent::bNegateCurve' has a wrong offset!");

// Class MotionSymphony.AnimNotify_MSFootLockSingle
// 0x0008 (0x0040 - 0x0038)
class UAnimNotify_MSFootLockSingle final : public UAnimNotify
{
public:
	EMSFootLockId                                 FootLockId;                                        // 0x0038(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bSetLocked;                                        // 0x0039(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3A[0x6];                                       // 0x003A(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"AnimNotify_MSFootLockSingle">();
	}
	static class UAnimNotify_MSFootLockSingle* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UAnimNotify_MSFootLockSingle>();
	}
};
static_assert(alignof(UAnimNotify_MSFootLockSingle) == 0x000008, "Wrong alignment on UAnimNotify_MSFootLockSingle");
static_assert(sizeof(UAnimNotify_MSFootLockSingle) == 0x000040, "Wrong size on UAnimNotify_MSFootLockSingle");
static_assert(offsetof(UAnimNotify_MSFootLockSingle, FootLockId) == 0x000038, "Member 'UAnimNotify_MSFootLockSingle::FootLockId' has a wrong offset!");
static_assert(offsetof(UAnimNotify_MSFootLockSingle, bSetLocked) == 0x000039, "Member 'UAnimNotify_MSFootLockSingle::bSetLocked' has a wrong offset!");

// Class MotionSymphony.AnimNotify_MSFootLockTimer
// 0x0008 (0x0040 - 0x0038)
class UAnimNotify_MSFootLockTimer final : public UAnimNotify
{
public:
	EMSFootLockId                                 FootLockId;                                        // 0x0038(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_39[0x3];                                       // 0x0039(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         GroundingTime;                                     // 0x003C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"AnimNotify_MSFootLockTimer">();
	}
	static class UAnimNotify_MSFootLockTimer* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UAnimNotify_MSFootLockTimer>();
	}
};
static_assert(alignof(UAnimNotify_MSFootLockTimer) == 0x000008, "Wrong alignment on UAnimNotify_MSFootLockTimer");
static_assert(sizeof(UAnimNotify_MSFootLockTimer) == 0x000040, "Wrong size on UAnimNotify_MSFootLockTimer");
static_assert(offsetof(UAnimNotify_MSFootLockTimer, FootLockId) == 0x000038, "Member 'UAnimNotify_MSFootLockTimer::FootLockId' has a wrong offset!");
static_assert(offsetof(UAnimNotify_MSFootLockTimer, GroundingTime) == 0x00003C, "Member 'UAnimNotify_MSFootLockTimer::GroundingTime' has a wrong offset!");

// Class MotionSymphony.DistanceMatching
// 0x0078 (0x0138 - 0x00C0)
class UDistanceMatching final : public UActorComponent
{
public:
	bool                                          bAutomaticTriggers;                                // 0x00C0(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C1[0x3];                                       // 0x00C1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         DistanceTolerance;                                 // 0x00C4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MinPlantDetectionAngle;                            // 0x00C8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MinPlantSpeed;                                     // 0x00CC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MinPlantAccel;                                     // 0x00D0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D4[0x3C];                                      // 0x00D4(0x003C)(Fixing Size After Last Property [ Dumper-7 ])
	class AActor*                                 ParentActor;                                       // 0x0110(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCharacterMovementComponent*            MovementComponent;                                 // 0x0118(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_120[0x18];                                     // 0x0120(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void DetectTransitions(float DeltaTime)	 // 0x46fb180;
	EDistanceMatchTrigger GetAndConsumeTriggeredTransition()	 // 0x46fb244;
	float GetMarkerDistance()	 // 0x46fb264;
	void StopDistanceMatching()	 // 0x46fb27c;
	void TriggerJump(float DeltaTime)	 // 0x46fb290;
	void TriggerPivotFrom()	 // 0x46fb36c;
	void TriggerPivotTo()	 // 0x46fb380;
	void TriggerPlant(float DeltaTime)	 // 0x46fb394;
	void TriggerStart(float DeltaTime)	 // 0x46fb458;
	void TriggerStop(float DeltaTime)	 // 0x46fb51c;
	void TriggerTurnInPlaceFrom()	 // 0x46fb5e0;
	void TriggerTurnInPlaceTo(const struct FVector& DesiredDirection)	 // 0x46fb5f4;

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"DistanceMatching">();
	}
	static class UDistanceMatching* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UDistanceMatching>();
	}
};
static_assert(alignof(UDistanceMatching) == 0x000008, "Wrong alignment on UDistanceMatching");
static_assert(sizeof(UDistanceMatching) == 0x000138, "Wrong size on UDistanceMatching");
static_assert(offsetof(UDistanceMatching, bAutomaticTriggers) == 0x0000C0, "Member 'UDistanceMatching::bAutomaticTriggers' has a wrong offset!");
static_assert(offsetof(UDistanceMatching, DistanceTolerance) == 0x0000C4, "Member 'UDistanceMatching::DistanceTolerance' has a wrong offset!");
static_assert(offsetof(UDistanceMatching, MinPlantDetectionAngle) == 0x0000C8, "Member 'UDistanceMatching::MinPlantDetectionAngle' has a wrong offset!");
static_assert(offsetof(UDistanceMatching, MinPlantSpeed) == 0x0000CC, "Member 'UDistanceMatching::MinPlantSpeed' has a wrong offset!");
static_assert(offsetof(UDistanceMatching, MinPlantAccel) == 0x0000D0, "Member 'UDistanceMatching::MinPlantAccel' has a wrong offset!");
static_assert(offsetof(UDistanceMatching, ParentActor) == 0x000110, "Member 'UDistanceMatching::ParentActor' has a wrong offset!");
static_assert(offsetof(UDistanceMatching, MovementComponent) == 0x000118, "Member 'UDistanceMatching::MovementComponent' has a wrong offset!");

// Class MotionSymphony.MatchFeatureBase
// 0x0008 (0x0030 - 0x0028)
class UMatchFeatureBase : public UObject
{
public:
	float                                         DefaultWeight;                                     // 0x0028(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EPoseCategory                                 PoseCategory;                                      // 0x002C(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2D[0x3];                                       // 0x002D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"MatchFeatureBase">();
	}
	static class UMatchFeatureBase* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UMatchFeatureBase>();
	}
};
static_assert(alignof(UMatchFeatureBase) == 0x000008, "Wrong alignment on UMatchFeatureBase");
static_assert(sizeof(UMatchFeatureBase) == 0x000030, "Wrong size on UMatchFeatureBase");
static_assert(offsetof(UMatchFeatureBase, DefaultWeight) == 0x000028, "Member 'UMatchFeatureBase::DefaultWeight' has a wrong offset!");
static_assert(offsetof(UMatchFeatureBase, PoseCategory) == 0x00002C, "Member 'UMatchFeatureBase::PoseCategory' has a wrong offset!");

// Class MotionSymphony.MatchFeature_BodyMomentum2D
// 0x0000 (0x0030 - 0x0030)
class UMatchFeature_BodyMomentum2D final : public UMatchFeatureBase
{
public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"MatchFeature_BodyMomentum2D">();
	}
	static class UMatchFeature_BodyMomentum2D* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UMatchFeature_BodyMomentum2D>();
	}
};
static_assert(alignof(UMatchFeature_BodyMomentum2D) == 0x000008, "Wrong alignment on UMatchFeature_BodyMomentum2D");
static_assert(sizeof(UMatchFeature_BodyMomentum2D) == 0x000030, "Wrong size on UMatchFeature_BodyMomentum2D");

// Class MotionSymphony.MatchFeature_BodyMomentum3D
// 0x0000 (0x0030 - 0x0030)
class UMatchFeature_BodyMomentum3D final : public UMatchFeatureBase
{
public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"MatchFeature_BodyMomentum3D">();
	}
	static class UMatchFeature_BodyMomentum3D* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UMatchFeature_BodyMomentum3D>();
	}
};
static_assert(alignof(UMatchFeature_BodyMomentum3D) == 0x000008, "Wrong alignment on UMatchFeature_BodyMomentum3D");
static_assert(sizeof(UMatchFeature_BodyMomentum3D) == 0x000030, "Wrong size on UMatchFeature_BodyMomentum3D");

// Class MotionSymphony.MatchFeature_BodyMomentumRot
// 0x0000 (0x0030 - 0x0030)
class UMatchFeature_BodyMomentumRot final : public UMatchFeatureBase
{
public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"MatchFeature_BodyMomentumRot">();
	}
	static class UMatchFeature_BodyMomentumRot* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UMatchFeature_BodyMomentumRot>();
	}
};
static_assert(alignof(UMatchFeature_BodyMomentumRot) == 0x000008, "Wrong alignment on UMatchFeature_BodyMomentumRot");
static_assert(sizeof(UMatchFeature_BodyMomentumRot) == 0x000030, "Wrong size on UMatchFeature_BodyMomentumRot");

// Class MotionSymphony.MatchFeature_BoneAxis
// 0x0018 (0x0048 - 0x0030)
class UMatchFeature_BoneAxis final : public UMatchFeatureBase
{
public:
	EAxis                                         Axis;                                              // 0x0030(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_31[0x3];                                       // 0x0031(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FBoneReference                         BoneReference;                                     // 0x0034(0x0010)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_44[0x4];                                       // 0x0044(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"MatchFeature_BoneAxis">();
	}
	static class UMatchFeature_BoneAxis* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UMatchFeature_BoneAxis>();
	}
};
static_assert(alignof(UMatchFeature_BoneAxis) == 0x000008, "Wrong alignment on UMatchFeature_BoneAxis");
static_assert(sizeof(UMatchFeature_BoneAxis) == 0x000048, "Wrong size on UMatchFeature_BoneAxis");
static_assert(offsetof(UMatchFeature_BoneAxis, Axis) == 0x000030, "Member 'UMatchFeature_BoneAxis::Axis' has a wrong offset!");
static_assert(offsetof(UMatchFeature_BoneAxis, BoneReference) == 0x000034, "Member 'UMatchFeature_BoneAxis::BoneReference' has a wrong offset!");

// Class MotionSymphony.MatchFeature_BoneFacing
// 0x0018 (0x0048 - 0x0030)
class UMatchFeature_BoneFacing final : public UMatchFeatureBase
{
public:
	EAxis                                         FacingAxis;                                        // 0x0030(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_31[0x3];                                       // 0x0031(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FBoneReference                         BoneReference;                                     // 0x0034(0x0010)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_44[0x4];                                       // 0x0044(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"MatchFeature_BoneFacing">();
	}
	static class UMatchFeature_BoneFacing* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UMatchFeature_BoneFacing>();
	}
};
static_assert(alignof(UMatchFeature_BoneFacing) == 0x000008, "Wrong alignment on UMatchFeature_BoneFacing");
static_assert(sizeof(UMatchFeature_BoneFacing) == 0x000048, "Wrong size on UMatchFeature_BoneFacing");
static_assert(offsetof(UMatchFeature_BoneFacing, FacingAxis) == 0x000030, "Member 'UMatchFeature_BoneFacing::FacingAxis' has a wrong offset!");
static_assert(offsetof(UMatchFeature_BoneFacing, BoneReference) == 0x000034, "Member 'UMatchFeature_BoneFacing::BoneReference' has a wrong offset!");

// Class MotionSymphony.MatchFeature_BoneHeight
// 0x0010 (0x0040 - 0x0030)
class UMatchFeature_BoneHeight final : public UMatchFeatureBase
{
public:
	struct FBoneReference                         BoneReference;                                     // 0x0030(0x0010)(Edit, NoDestructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"MatchFeature_BoneHeight">();
	}
	static class UMatchFeature_BoneHeight* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UMatchFeature_BoneHeight>();
	}
};
static_assert(alignof(UMatchFeature_BoneHeight) == 0x000008, "Wrong alignment on UMatchFeature_BoneHeight");
static_assert(sizeof(UMatchFeature_BoneHeight) == 0x000040, "Wrong size on UMatchFeature_BoneHeight");
static_assert(offsetof(UMatchFeature_BoneHeight, BoneReference) == 0x000030, "Member 'UMatchFeature_BoneHeight::BoneReference' has a wrong offset!");

// Class MotionSymphony.MatchFeature_BoneLocation
// 0x0010 (0x0040 - 0x0030)
class UMatchFeature_BoneLocation final : public UMatchFeatureBase
{
public:
	struct FBoneReference                         BoneReference;                                     // 0x0030(0x0010)(Edit, NoDestructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"MatchFeature_BoneLocation">();
	}
	static class UMatchFeature_BoneLocation* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UMatchFeature_BoneLocation>();
	}
};
static_assert(alignof(UMatchFeature_BoneLocation) == 0x000008, "Wrong alignment on UMatchFeature_BoneLocation");
static_assert(sizeof(UMatchFeature_BoneLocation) == 0x000040, "Wrong size on UMatchFeature_BoneLocation");
static_assert(offsetof(UMatchFeature_BoneLocation, BoneReference) == 0x000030, "Member 'UMatchFeature_BoneLocation::BoneReference' has a wrong offset!");

// Class MotionSymphony.MatchFeature_BoneLocationAndVelocity
// 0x0018 (0x0048 - 0x0030)
class UMatchFeature_BoneLocationAndVelocity final : public UMatchFeatureBase
{
public:
	float                                         DefaultVelocityWeighting;                          // 0x0030(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FBoneReference                         BoneReference;                                     // 0x0034(0x0010)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_44[0x4];                                       // 0x0044(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"MatchFeature_BoneLocationAndVelocity">();
	}
	static class UMatchFeature_BoneLocationAndVelocity* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UMatchFeature_BoneLocationAndVelocity>();
	}
};
static_assert(alignof(UMatchFeature_BoneLocationAndVelocity) == 0x000008, "Wrong alignment on UMatchFeature_BoneLocationAndVelocity");
static_assert(sizeof(UMatchFeature_BoneLocationAndVelocity) == 0x000048, "Wrong size on UMatchFeature_BoneLocationAndVelocity");
static_assert(offsetof(UMatchFeature_BoneLocationAndVelocity, DefaultVelocityWeighting) == 0x000030, "Member 'UMatchFeature_BoneLocationAndVelocity::DefaultVelocityWeighting' has a wrong offset!");
static_assert(offsetof(UMatchFeature_BoneLocationAndVelocity, BoneReference) == 0x000034, "Member 'UMatchFeature_BoneLocationAndVelocity::BoneReference' has a wrong offset!");

// Class MotionSymphony.MatchFeature_BoneVelocity
// 0x0010 (0x0040 - 0x0030)
class UMatchFeature_BoneVelocity final : public UMatchFeatureBase
{
public:
	struct FBoneReference                         BoneReference;                                     // 0x0030(0x0010)(Edit, NoDestructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"MatchFeature_BoneVelocity">();
	}
	static class UMatchFeature_BoneVelocity* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UMatchFeature_BoneVelocity>();
	}
};
static_assert(alignof(UMatchFeature_BoneVelocity) == 0x000008, "Wrong alignment on UMatchFeature_BoneVelocity");
static_assert(sizeof(UMatchFeature_BoneVelocity) == 0x000040, "Wrong size on UMatchFeature_BoneVelocity");
static_assert(offsetof(UMatchFeature_BoneVelocity, BoneReference) == 0x000030, "Member 'UMatchFeature_BoneVelocity::BoneReference' has a wrong offset!");

// Class MotionSymphony.MatchFeature_Distance
// 0x0008 (0x0038 - 0x0030)
class UMatchFeature_Distance final : public UMatchFeatureBase
{
public:
	EDistanceMatchTrigger                         DistanceMatchTrigger;                              // 0x0030(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EDistanceMatchType                            DistanceMatchType;                                 // 0x0031(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EDistanceMatchBasis                           DistanceMatchBasis;                                // 0x0032(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_33[0x5];                                       // 0x0033(0x0005)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"MatchFeature_Distance">();
	}
	static class UMatchFeature_Distance* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UMatchFeature_Distance>();
	}
};
static_assert(alignof(UMatchFeature_Distance) == 0x000008, "Wrong alignment on UMatchFeature_Distance");
static_assert(sizeof(UMatchFeature_Distance) == 0x000038, "Wrong size on UMatchFeature_Distance");
static_assert(offsetof(UMatchFeature_Distance, DistanceMatchTrigger) == 0x000030, "Member 'UMatchFeature_Distance::DistanceMatchTrigger' has a wrong offset!");
static_assert(offsetof(UMatchFeature_Distance, DistanceMatchType) == 0x000031, "Member 'UMatchFeature_Distance::DistanceMatchType' has a wrong offset!");
static_assert(offsetof(UMatchFeature_Distance, DistanceMatchBasis) == 0x000032, "Member 'UMatchFeature_Distance::DistanceMatchBasis' has a wrong offset!");

// Class MotionSymphony.MatchFeature_Trajectory2D
// 0x0018 (0x0048 - 0x0030)
class UMatchFeature_Trajectory2D final : public UMatchFeatureBase
{
public:
	float                                         PastTrajectoryWeightMultiplier;                    // 0x0030(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DefaultDirectionWeighting;                         // 0x0034(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<float>                                 TrajectoryTiming;                                  // 0x0038(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"MatchFeature_Trajectory2D">();
	}
	static class UMatchFeature_Trajectory2D* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UMatchFeature_Trajectory2D>();
	}
};
static_assert(alignof(UMatchFeature_Trajectory2D) == 0x000008, "Wrong alignment on UMatchFeature_Trajectory2D");
static_assert(sizeof(UMatchFeature_Trajectory2D) == 0x000048, "Wrong size on UMatchFeature_Trajectory2D");
static_assert(offsetof(UMatchFeature_Trajectory2D, PastTrajectoryWeightMultiplier) == 0x000030, "Member 'UMatchFeature_Trajectory2D::PastTrajectoryWeightMultiplier' has a wrong offset!");
static_assert(offsetof(UMatchFeature_Trajectory2D, DefaultDirectionWeighting) == 0x000034, "Member 'UMatchFeature_Trajectory2D::DefaultDirectionWeighting' has a wrong offset!");
static_assert(offsetof(UMatchFeature_Trajectory2D, TrajectoryTiming) == 0x000038, "Member 'UMatchFeature_Trajectory2D::TrajectoryTiming' has a wrong offset!");

// Class MotionSymphony.MatchFeature_Trajectory3D
// 0x0018 (0x0048 - 0x0030)
class UMatchFeature_Trajectory3D final : public UMatchFeatureBase
{
public:
	float                                         PastTrajectoryWeightMultiplier;                    // 0x0030(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DefaultDirectionWeighting;                         // 0x0034(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<float>                                 TrajectoryTiming;                                  // 0x0038(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"MatchFeature_Trajectory3D">();
	}
	static class UMatchFeature_Trajectory3D* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UMatchFeature_Trajectory3D>();
	}
};
static_assert(alignof(UMatchFeature_Trajectory3D) == 0x000008, "Wrong alignment on UMatchFeature_Trajectory3D");
static_assert(sizeof(UMatchFeature_Trajectory3D) == 0x000048, "Wrong size on UMatchFeature_Trajectory3D");
static_assert(offsetof(UMatchFeature_Trajectory3D, PastTrajectoryWeightMultiplier) == 0x000030, "Member 'UMatchFeature_Trajectory3D::PastTrajectoryWeightMultiplier' has a wrong offset!");
static_assert(offsetof(UMatchFeature_Trajectory3D, DefaultDirectionWeighting) == 0x000034, "Member 'UMatchFeature_Trajectory3D::DefaultDirectionWeighting' has a wrong offset!");
static_assert(offsetof(UMatchFeature_Trajectory3D, TrajectoryTiming) == 0x000038, "Member 'UMatchFeature_Trajectory3D::TrajectoryTiming' has a wrong offset!");

// Class MotionSymphony.MMBlueprintFunctionLibrary
// 0x0000 (0x0028 - 0x0028)
class UMMBlueprintFunctionLibrary final : public UBlueprintFunctionLibrary
{
public:
	static void ConstructMotionInputFeatureArray(struct FMotionMatchingInputData& InputData, class AActor* Actor, class UMotionMatchConfig* MotionConfig)	 // 0x121a154;
	static void CreateInputDataFromTrajectory(struct FTrajectory& Trajectory, struct FMotionMatchingInputData& InputData)	 // 0x46fdc8c;
	static struct FVector GetInputVectorRelativeToCamera(const struct FVector& InputVector, class UCameraComponent* CameraComponent)	 // 0x46fdd8c;
	static struct FVector GetVectorRelativeToCamera(const float InputX, const float InputY, class UCameraComponent* CameraComponent)	 // 0x46fdf84;
	static void InitializeTrajectory(struct FTrajectory& OutTrajectory, const int32 TrajectoryCount)	 // 0x46fe1d4;
	static void SetTrajectoryPoint(struct FTrajectory& OutTrajectory, const int32 Index_0, const struct FVector& Position, const float RotationZ)	 // 0x46fe370;
	static void TransformFromUpForwardAxis(struct FTransform& OutTransform, const EAllAxis UpAxis, const EAllAxis ForwardAxis)	 // 0x46fe6b0;

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"MMBlueprintFunctionLibrary">();
	}
	static class UMMBlueprintFunctionLibrary* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UMMBlueprintFunctionLibrary>();
	}
};
static_assert(alignof(UMMBlueprintFunctionLibrary) == 0x000008, "Wrong alignment on UMMBlueprintFunctionLibrary");
static_assert(sizeof(UMMBlueprintFunctionLibrary) == 0x000028, "Wrong size on UMMBlueprintFunctionLibrary");

// Class MotionSymphony.MotionAnimObject
// 0x0078 (0x00A0 - 0x0028)
class UMotionAnimObject : public UObject
{
public:
	int32                                         AnimId;                                            // 0x0028(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EMotionAnimAssetType                          MotionAnimAssetType;                               // 0x002C(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2D[0x3];                                       // 0x002D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class UAnimationAsset*                        AnimAsset;                                         // 0x0030(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bLoop;                                             // 0x0038(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_39[0x3];                                       // 0x0039(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         PlayRate;                                          // 0x003C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bEnableMirroring;                                  // 0x0040(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bFlattenTrajectory;                                // 0x0041(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETrajectoryPreProcessMethod                   PastTrajectory;                                    // 0x0042(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_43[0x5];                                       // 0x0043(0x0005)(Fixing Size After Last Property [ Dumper-7 ])
	class UAnimSequence*                          PrecedingMotion;                                   // 0x0048(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETrajectoryPreProcessMethod                   FutureTrajectory;                                  // 0x0050(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_51[0x7];                                       // 0x0051(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UAnimSequence*                          FollowingMotion;                                   // 0x0058(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CostMultiplier;                                    // 0x0060(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_64[0x4];                                       // 0x0064(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTagContainer                  MotionTags;                                        // 0x0068(0x0020)(Edit, NativeAccessSpecifierPublic)
	TArray<struct FAnimNotifyEvent>               Tags;                                              // 0x0088(0x0010)(ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	class UMotionDataAsset*                       ParentMotionDataAsset;                             // 0x0098(0x0008)(ZeroConstructor, Transient, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"MotionAnimObject">();
	}
	static class UMotionAnimObject* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UMotionAnimObject>();
	}
};
static_assert(alignof(UMotionAnimObject) == 0x000008, "Wrong alignment on UMotionAnimObject");
static_assert(sizeof(UMotionAnimObject) == 0x0000A0, "Wrong size on UMotionAnimObject");
static_assert(offsetof(UMotionAnimObject, AnimId) == 0x000028, "Member 'UMotionAnimObject::AnimId' has a wrong offset!");
static_assert(offsetof(UMotionAnimObject, MotionAnimAssetType) == 0x00002C, "Member 'UMotionAnimObject::MotionAnimAssetType' has a wrong offset!");
static_assert(offsetof(UMotionAnimObject, AnimAsset) == 0x000030, "Member 'UMotionAnimObject::AnimAsset' has a wrong offset!");
static_assert(offsetof(UMotionAnimObject, bLoop) == 0x000038, "Member 'UMotionAnimObject::bLoop' has a wrong offset!");
static_assert(offsetof(UMotionAnimObject, PlayRate) == 0x00003C, "Member 'UMotionAnimObject::PlayRate' has a wrong offset!");
static_assert(offsetof(UMotionAnimObject, bEnableMirroring) == 0x000040, "Member 'UMotionAnimObject::bEnableMirroring' has a wrong offset!");
static_assert(offsetof(UMotionAnimObject, bFlattenTrajectory) == 0x000041, "Member 'UMotionAnimObject::bFlattenTrajectory' has a wrong offset!");
static_assert(offsetof(UMotionAnimObject, PastTrajectory) == 0x000042, "Member 'UMotionAnimObject::PastTrajectory' has a wrong offset!");
static_assert(offsetof(UMotionAnimObject, PrecedingMotion) == 0x000048, "Member 'UMotionAnimObject::PrecedingMotion' has a wrong offset!");
static_assert(offsetof(UMotionAnimObject, FutureTrajectory) == 0x000050, "Member 'UMotionAnimObject::FutureTrajectory' has a wrong offset!");
static_assert(offsetof(UMotionAnimObject, FollowingMotion) == 0x000058, "Member 'UMotionAnimObject::FollowingMotion' has a wrong offset!");
static_assert(offsetof(UMotionAnimObject, CostMultiplier) == 0x000060, "Member 'UMotionAnimObject::CostMultiplier' has a wrong offset!");
static_assert(offsetof(UMotionAnimObject, MotionTags) == 0x000068, "Member 'UMotionAnimObject::MotionTags' has a wrong offset!");
static_assert(offsetof(UMotionAnimObject, Tags) == 0x000088, "Member 'UMotionAnimObject::Tags' has a wrong offset!");
static_assert(offsetof(UMotionAnimObject, ParentMotionDataAsset) == 0x000098, "Member 'UMotionAnimObject::ParentMotionDataAsset' has a wrong offset!");

// Class MotionSymphony.MotionSequenceObject
// 0x0008 (0x00A8 - 0x00A0)
class UMotionSequenceObject final : public UMotionAnimObject
{
public:
	class UAnimSequence*                          Sequence;                                          // 0x00A0(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"MotionSequenceObject">();
	}
	static class UMotionSequenceObject* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UMotionSequenceObject>();
	}
};
static_assert(alignof(UMotionSequenceObject) == 0x000008, "Wrong alignment on UMotionSequenceObject");
static_assert(sizeof(UMotionSequenceObject) == 0x0000A8, "Wrong size on UMotionSequenceObject");
static_assert(offsetof(UMotionSequenceObject, Sequence) == 0x0000A0, "Member 'UMotionSequenceObject::Sequence' has a wrong offset!");

// Class MotionSymphony.MotionBlendSpaceObject
// 0x0018 (0x00B8 - 0x00A0)
class UMotionBlendSpaceObject final : public UMotionAnimObject
{
public:
	class UBlendSpace*                            BlendSpace;                                        // 0x00A0(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              SampleSpacing;                                     // 0x00A8(0x0010)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"MotionBlendSpaceObject">();
	}
	static class UMotionBlendSpaceObject* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UMotionBlendSpaceObject>();
	}
};
static_assert(alignof(UMotionBlendSpaceObject) == 0x000008, "Wrong alignment on UMotionBlendSpaceObject");
static_assert(sizeof(UMotionBlendSpaceObject) == 0x0000B8, "Wrong size on UMotionBlendSpaceObject");
static_assert(offsetof(UMotionBlendSpaceObject, BlendSpace) == 0x0000A0, "Member 'UMotionBlendSpaceObject::BlendSpace' has a wrong offset!");
static_assert(offsetof(UMotionBlendSpaceObject, SampleSpacing) == 0x0000A8, "Member 'UMotionBlendSpaceObject::SampleSpacing' has a wrong offset!");

// Class MotionSymphony.MotionCompositeObject
// 0x0008 (0x00A8 - 0x00A0)
class UMotionCompositeObject final : public UMotionAnimObject
{
public:
	class UAnimComposite*                         AnimComposite;                                     // 0x00A0(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"MotionCompositeObject">();
	}
	static class UMotionCompositeObject* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UMotionCompositeObject>();
	}
};
static_assert(alignof(UMotionCompositeObject) == 0x000008, "Wrong alignment on UMotionCompositeObject");
static_assert(sizeof(UMotionCompositeObject) == 0x0000A8, "Wrong size on UMotionCompositeObject");
static_assert(offsetof(UMotionCompositeObject, AnimComposite) == 0x0000A0, "Member 'UMotionCompositeObject::AnimComposite' has a wrong offset!");

// Class MotionSymphony.MotionCalibration
// 0x0030 (0x0058 - 0x0028)
class UMotionCalibration final : public UObject
{
public:
	class UMotionMatchConfig*                     MotionMatchConfig;                                 // 0x0028(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EMotionCalibrationType                        CalibrationType;                                   // 0x0030(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_31[0x3];                                       // 0x0031(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         QualityVsResponsivenessRatio;                      // 0x0034(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<float>                                 CalibrationArray;                                  // 0x0038(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<float>                                 AdjustedCalibrationArray;                          // 0x0048(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPublic)

public:
	void OnGenerateWeightings()	 // 0x46fe35c;

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"MotionCalibration">();
	}
	static class UMotionCalibration* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UMotionCalibration>();
	}
};
static_assert(alignof(UMotionCalibration) == 0x000008, "Wrong alignment on UMotionCalibration");
static_assert(sizeof(UMotionCalibration) == 0x000058, "Wrong size on UMotionCalibration");
static_assert(offsetof(UMotionCalibration, MotionMatchConfig) == 0x000028, "Member 'UMotionCalibration::MotionMatchConfig' has a wrong offset!");
static_assert(offsetof(UMotionCalibration, CalibrationType) == 0x000030, "Member 'UMotionCalibration::CalibrationType' has a wrong offset!");
static_assert(offsetof(UMotionCalibration, QualityVsResponsivenessRatio) == 0x000034, "Member 'UMotionCalibration::QualityVsResponsivenessRatio' has a wrong offset!");
static_assert(offsetof(UMotionCalibration, CalibrationArray) == 0x000038, "Member 'UMotionCalibration::CalibrationArray' has a wrong offset!");
static_assert(offsetof(UMotionCalibration, AdjustedCalibrationArray) == 0x000048, "Member 'UMotionCalibration::AdjustedCalibrationArray' has a wrong offset!");

// Class MotionSymphony.MotionDataAsset
// 0x0190 (0x0210 - 0x0080)
class UMotionDataAsset final : public UAnimationAsset
{
public:
	float                                         PoseInterval;                                      // 0x0080(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_84[0x4];                                       // 0x0084(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UMotionMatchConfig*                     MotionMatchConfig;                                 // 0x0088(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EJointVelocityCalculationMethod               JointVelocityCalculationMethod;                    // 0x0090(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ENotifyTriggerMode                            NotifyTriggerMode;                                 // 0x0091(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_92[0x6];                                       // 0x0092(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	class UMirrorDataTable*                       MirrorDataTable;                                   // 0x0098(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsProcessed;                                      // 0x00A0(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A1[0x7];                                       // 0x00A1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FMotionAnimSequence>            SourceMotionAnims;                                 // 0x00A8(0x0010)(ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	TArray<struct FMotionBlendSpace>              SourceBlendSpaces;                                 // 0x00B8(0x0010)(ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	TArray<struct FMotionComposite>               SourceComposites;                                  // 0x00C8(0x0010)(ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	TArray<class UMotionSequenceObject*>          SourceMotionSequenceObjects;                       // 0x00D8(0x0010)(ExportObject, ZeroConstructor, ContainsInstancedReference, UObjectWrapper, NativeAccessSpecifierPublic)
	TArray<class UMotionBlendSpaceObject*>        SourceBlendSpaceObjects;                           // 0x00E8(0x0010)(ExportObject, ZeroConstructor, ContainsInstancedReference, UObjectWrapper, NativeAccessSpecifierPublic)
	TArray<class UMotionCompositeObject*>         SourceCompositeObjects;                            // 0x00F8(0x0010)(ExportObject, ZeroConstructor, ContainsInstancedReference, UObjectWrapper, NativeAccessSpecifierPublic)
	TArray<int32>                                 PoseIdRemap;                                       // 0x0108(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TMap<int32, int32>                            PoseIdRemapReverse;                                // 0x0118(0x0050)(NativeAccessSpecifierPublic)
	TArray<struct FGameplayTagContainer>          MotionTagList;                                     // 0x0168(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FPoseMatrixSection>             MotionTagMatrixSections;                           // 0x0178(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FCalibrationData>               FeatureStandardDeviations;                         // 0x0188(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FPoseMotionData>                Poses;                                             // 0x0198(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	struct FPoseMatrix                            LookupPoseMatrix;                                  // 0x01A8(0x0018)(NativeAccessSpecifierPublic)
	struct FPoseAABBMatrix                        PoseAABBMatrix_Outer;                              // 0x01C0(0x0018)(Transient, NativeAccessSpecifierPublic)
	struct FPoseAABBMatrix                        PoseAABBMatrix_Inner;                              // 0x01D8(0x0018)(Transient, NativeAccessSpecifierPublic)
	struct FPoseMatrix                            SearchPoseMatrix;                                  // 0x01F0(0x0018)(Transient, NativeAccessSpecifierPublic)
	uint8                                         Pad_208[0x8];                                      // 0x0208(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"MotionDataAsset">();
	}
	static class UMotionDataAsset* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UMotionDataAsset>();
	}
};
static_assert(alignof(UMotionDataAsset) == 0x000008, "Wrong alignment on UMotionDataAsset");
static_assert(sizeof(UMotionDataAsset) == 0x000210, "Wrong size on UMotionDataAsset");
static_assert(offsetof(UMotionDataAsset, PoseInterval) == 0x000080, "Member 'UMotionDataAsset::PoseInterval' has a wrong offset!");
static_assert(offsetof(UMotionDataAsset, MotionMatchConfig) == 0x000088, "Member 'UMotionDataAsset::MotionMatchConfig' has a wrong offset!");
static_assert(offsetof(UMotionDataAsset, JointVelocityCalculationMethod) == 0x000090, "Member 'UMotionDataAsset::JointVelocityCalculationMethod' has a wrong offset!");
static_assert(offsetof(UMotionDataAsset, NotifyTriggerMode) == 0x000091, "Member 'UMotionDataAsset::NotifyTriggerMode' has a wrong offset!");
static_assert(offsetof(UMotionDataAsset, MirrorDataTable) == 0x000098, "Member 'UMotionDataAsset::MirrorDataTable' has a wrong offset!");
static_assert(offsetof(UMotionDataAsset, bIsProcessed) == 0x0000A0, "Member 'UMotionDataAsset::bIsProcessed' has a wrong offset!");
static_assert(offsetof(UMotionDataAsset, SourceMotionAnims) == 0x0000A8, "Member 'UMotionDataAsset::SourceMotionAnims' has a wrong offset!");
static_assert(offsetof(UMotionDataAsset, SourceBlendSpaces) == 0x0000B8, "Member 'UMotionDataAsset::SourceBlendSpaces' has a wrong offset!");
static_assert(offsetof(UMotionDataAsset, SourceComposites) == 0x0000C8, "Member 'UMotionDataAsset::SourceComposites' has a wrong offset!");
static_assert(offsetof(UMotionDataAsset, SourceMotionSequenceObjects) == 0x0000D8, "Member 'UMotionDataAsset::SourceMotionSequenceObjects' has a wrong offset!");
static_assert(offsetof(UMotionDataAsset, SourceBlendSpaceObjects) == 0x0000E8, "Member 'UMotionDataAsset::SourceBlendSpaceObjects' has a wrong offset!");
static_assert(offsetof(UMotionDataAsset, SourceCompositeObjects) == 0x0000F8, "Member 'UMotionDataAsset::SourceCompositeObjects' has a wrong offset!");
static_assert(offsetof(UMotionDataAsset, PoseIdRemap) == 0x000108, "Member 'UMotionDataAsset::PoseIdRemap' has a wrong offset!");
static_assert(offsetof(UMotionDataAsset, PoseIdRemapReverse) == 0x000118, "Member 'UMotionDataAsset::PoseIdRemapReverse' has a wrong offset!");
static_assert(offsetof(UMotionDataAsset, MotionTagList) == 0x000168, "Member 'UMotionDataAsset::MotionTagList' has a wrong offset!");
static_assert(offsetof(UMotionDataAsset, MotionTagMatrixSections) == 0x000178, "Member 'UMotionDataAsset::MotionTagMatrixSections' has a wrong offset!");
static_assert(offsetof(UMotionDataAsset, FeatureStandardDeviations) == 0x000188, "Member 'UMotionDataAsset::FeatureStandardDeviations' has a wrong offset!");
static_assert(offsetof(UMotionDataAsset, Poses) == 0x000198, "Member 'UMotionDataAsset::Poses' has a wrong offset!");
static_assert(offsetof(UMotionDataAsset, LookupPoseMatrix) == 0x0001A8, "Member 'UMotionDataAsset::LookupPoseMatrix' has a wrong offset!");
static_assert(offsetof(UMotionDataAsset, PoseAABBMatrix_Outer) == 0x0001C0, "Member 'UMotionDataAsset::PoseAABBMatrix_Outer' has a wrong offset!");
static_assert(offsetof(UMotionDataAsset, PoseAABBMatrix_Inner) == 0x0001D8, "Member 'UMotionDataAsset::PoseAABBMatrix_Inner' has a wrong offset!");
static_assert(offsetof(UMotionDataAsset, SearchPoseMatrix) == 0x0001F0, "Member 'UMotionDataAsset::SearchPoseMatrix' has a wrong offset!");

// Class MotionSymphony.MotionMatchConfig
// 0x0070 (0x0098 - 0x0028)
class UMotionMatchConfig final : public UObject
{
public:
	uint8                                         Pad_28[0x8];                                       // 0x0028(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class USkeleton*                              SourceSkeleton;                                    // 0x0030(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EAllAxis                                      UpAxis;                                            // 0x0038(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EAllAxis                                      ForwardAxis;                                       // 0x0039(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3A[0x2];                                       // 0x003A(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         DefaultQualityVsResponsivenessRatio;               // 0x003C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ResultantVelocityWeight;                           // 0x0040(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bNormalizeWeightsByQuantity;                       // 0x0044(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_45[0x3];                                       // 0x0045(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UMatchFeatureBase*>              InputResponseFeatures;                             // 0x0048(0x0010)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, ContainsInstancedReference, UObjectWrapper, NativeAccessSpecifierPublic)
	TArray<class UMatchFeatureBase*>              PoseQualityFeatures;                               // 0x0058(0x0010)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, ContainsInstancedReference, UObjectWrapper, NativeAccessSpecifierPublic)
	uint8                                         Pad_68[0x10];                                      // 0x0068(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         ResponseDimensionCount;                            // 0x0078(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         QualityDimensionCount;                             // 0x007C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         TotalDimensionCount;                               // 0x0080(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_84[0x4];                                       // 0x0084(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<float>                                 DefaultCalibrationArray;                           // 0x0088(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"MotionMatchConfig">();
	}
	static class UMotionMatchConfig* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UMotionMatchConfig>();
	}
};
static_assert(alignof(UMotionMatchConfig) == 0x000008, "Wrong alignment on UMotionMatchConfig");
static_assert(sizeof(UMotionMatchConfig) == 0x000098, "Wrong size on UMotionMatchConfig");
static_assert(offsetof(UMotionMatchConfig, SourceSkeleton) == 0x000030, "Member 'UMotionMatchConfig::SourceSkeleton' has a wrong offset!");
static_assert(offsetof(UMotionMatchConfig, UpAxis) == 0x000038, "Member 'UMotionMatchConfig::UpAxis' has a wrong offset!");
static_assert(offsetof(UMotionMatchConfig, ForwardAxis) == 0x000039, "Member 'UMotionMatchConfig::ForwardAxis' has a wrong offset!");
static_assert(offsetof(UMotionMatchConfig, DefaultQualityVsResponsivenessRatio) == 0x00003C, "Member 'UMotionMatchConfig::DefaultQualityVsResponsivenessRatio' has a wrong offset!");
static_assert(offsetof(UMotionMatchConfig, ResultantVelocityWeight) == 0x000040, "Member 'UMotionMatchConfig::ResultantVelocityWeight' has a wrong offset!");
static_assert(offsetof(UMotionMatchConfig, bNormalizeWeightsByQuantity) == 0x000044, "Member 'UMotionMatchConfig::bNormalizeWeightsByQuantity' has a wrong offset!");
static_assert(offsetof(UMotionMatchConfig, InputResponseFeatures) == 0x000048, "Member 'UMotionMatchConfig::InputResponseFeatures' has a wrong offset!");
static_assert(offsetof(UMotionMatchConfig, PoseQualityFeatures) == 0x000058, "Member 'UMotionMatchConfig::PoseQualityFeatures' has a wrong offset!");
static_assert(offsetof(UMotionMatchConfig, ResponseDimensionCount) == 0x000078, "Member 'UMotionMatchConfig::ResponseDimensionCount' has a wrong offset!");
static_assert(offsetof(UMotionMatchConfig, QualityDimensionCount) == 0x00007C, "Member 'UMotionMatchConfig::QualityDimensionCount' has a wrong offset!");
static_assert(offsetof(UMotionMatchConfig, TotalDimensionCount) == 0x000080, "Member 'UMotionMatchConfig::TotalDimensionCount' has a wrong offset!");
static_assert(offsetof(UMotionMatchConfig, DefaultCalibrationArray) == 0x000088, "Member 'UMotionMatchConfig::DefaultCalibrationArray' has a wrong offset!");

// Class MotionSymphony.MotionSymphonySettings
// 0x0038 (0x0060 - 0x0028)
class UMotionSymphonySettings final : public UObject
{
public:
	float                                         DebugScale_Velocity;                               // 0x0028(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DebugScale_Point;                                  // 0x002C(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FColor                                 DebugColor_Trajectory;                             // 0x0030(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FColor                                 DebugColor_TrajectoryPast;                         // 0x0034(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FColor                                 DebugColor_DesiredTrajectory;                      // 0x0038(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FColor                                 DebugColor_DesiredTrajectoryPast;                  // 0x003C(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FColor                                 DebugColor_BodyVelocity;                           // 0x0040(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FColor                                 DebugColor_BodyAngularVelocity;                    // 0x0044(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FColor                                 DebugColor_Joint;                                  // 0x0048(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FColor                                 DebugColor_JointHeight;                            // 0x004C(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FColor                                 DebugColor_JointFacing;                            // 0x0050(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FColor                                 DebugColor_Custom1;                                // 0x0054(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FColor                                 DebugColor_Custom2;                                // 0x0058(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5C[0x4];                                       // 0x005C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"MotionSymphonySettings">();
	}
	static class UMotionSymphonySettings* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UMotionSymphonySettings>();
	}
};
static_assert(alignof(UMotionSymphonySettings) == 0x000008, "Wrong alignment on UMotionSymphonySettings");
static_assert(sizeof(UMotionSymphonySettings) == 0x000060, "Wrong size on UMotionSymphonySettings");
static_assert(offsetof(UMotionSymphonySettings, DebugScale_Velocity) == 0x000028, "Member 'UMotionSymphonySettings::DebugScale_Velocity' has a wrong offset!");
static_assert(offsetof(UMotionSymphonySettings, DebugScale_Point) == 0x00002C, "Member 'UMotionSymphonySettings::DebugScale_Point' has a wrong offset!");
static_assert(offsetof(UMotionSymphonySettings, DebugColor_Trajectory) == 0x000030, "Member 'UMotionSymphonySettings::DebugColor_Trajectory' has a wrong offset!");
static_assert(offsetof(UMotionSymphonySettings, DebugColor_TrajectoryPast) == 0x000034, "Member 'UMotionSymphonySettings::DebugColor_TrajectoryPast' has a wrong offset!");
static_assert(offsetof(UMotionSymphonySettings, DebugColor_DesiredTrajectory) == 0x000038, "Member 'UMotionSymphonySettings::DebugColor_DesiredTrajectory' has a wrong offset!");
static_assert(offsetof(UMotionSymphonySettings, DebugColor_DesiredTrajectoryPast) == 0x00003C, "Member 'UMotionSymphonySettings::DebugColor_DesiredTrajectoryPast' has a wrong offset!");
static_assert(offsetof(UMotionSymphonySettings, DebugColor_BodyVelocity) == 0x000040, "Member 'UMotionSymphonySettings::DebugColor_BodyVelocity' has a wrong offset!");
static_assert(offsetof(UMotionSymphonySettings, DebugColor_BodyAngularVelocity) == 0x000044, "Member 'UMotionSymphonySettings::DebugColor_BodyAngularVelocity' has a wrong offset!");
static_assert(offsetof(UMotionSymphonySettings, DebugColor_Joint) == 0x000048, "Member 'UMotionSymphonySettings::DebugColor_Joint' has a wrong offset!");
static_assert(offsetof(UMotionSymphonySettings, DebugColor_JointHeight) == 0x00004C, "Member 'UMotionSymphonySettings::DebugColor_JointHeight' has a wrong offset!");
static_assert(offsetof(UMotionSymphonySettings, DebugColor_JointFacing) == 0x000050, "Member 'UMotionSymphonySettings::DebugColor_JointFacing' has a wrong offset!");
static_assert(offsetof(UMotionSymphonySettings, DebugColor_Custom1) == 0x000054, "Member 'UMotionSymphonySettings::DebugColor_Custom1' has a wrong offset!");
static_assert(offsetof(UMotionSymphonySettings, DebugColor_Custom2) == 0x000058, "Member 'UMotionSymphonySettings::DebugColor_Custom2' has a wrong offset!");

// Class MotionSymphony.MotionTag
// 0x0000 (0x0028 - 0x0028)
class UMotionTag final : public UObject
{
public:
	class FString GetTagName() const	 // 0x46fdf40;
	void Received_RunPreProcessForTag(float PoseInterval) const	 // 0xae1e64;

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"MotionTag">();
	}
	static class UMotionTag* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UMotionTag>();
	}
};
static_assert(alignof(UMotionTag) == 0x000008, "Wrong alignment on UMotionTag");
static_assert(sizeof(UMotionTag) == 0x000028, "Wrong size on UMotionTag");

// Class MotionSymphony.MSFootLockerMath
// 0x0000 (0x0028 - 0x0028)
class UMSFootLockerMath final : public UBlueprintFunctionLibrary
{
public:
	static float AngleBetween(const struct FVector& A, const struct FVector& B)	 // 0x47043f8;

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"MSFootLockerMath">();
	}
	static class UMSFootLockerMath* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UMSFootLockerMath>();
	}
};
static_assert(alignof(UMSFootLockerMath) == 0x000008, "Wrong alignment on UMSFootLockerMath");
static_assert(sizeof(UMSFootLockerMath) == 0x000028, "Wrong size on UMSFootLockerMath");

// Class MotionSymphony.MSFootLockManager
// 0x0050 (0x0110 - 0x00C0)
class UMSFootLockManager final : public UActorComponent
{
public:
	TMap<EMSFootLockId, struct FMSFootLockData>   FootLockMap;                                       // 0x00C0(0x0050)(Transient, NativeAccessSpecifierPublic)

public:
	void LockFoot(const EMSFootLockId FootId, const float Duration)	 // 0x47049c8;
	void ResetLockingState()	 // 0x4704b04;
	void UnlockFoot(const EMSFootLockId FootId)	 // 0x47054e4;

	bool IsFootLocked(const EMSFootLockId FootId) const	 // 0x47048a0;

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"MSFootLockManager">();
	}
	static class UMSFootLockManager* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UMSFootLockManager>();
	}
};
static_assert(alignof(UMSFootLockManager) == 0x000008, "Wrong alignment on UMSFootLockManager");
static_assert(sizeof(UMSFootLockManager) == 0x000110, "Wrong size on UMSFootLockManager");
static_assert(offsetof(UMSFootLockManager, FootLockMap) == 0x0000C0, "Member 'UMSFootLockManager::FootLockMap' has a wrong offset!");

// Class MotionSymphony.TagPoint
// 0x0000 (0x0038 - 0x0038)
class UTagPoint : public UAnimNotify
{
public:
	bool Received_PreProcessTag(const struct FPoseMotionData& PointPose, class UMotionAnimObject* OutMotionAnim, class UMotionDataAsset* OutMotionData, const float Time) const	 // 0xae1e64;

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"TagPoint">();
	}
	static class UTagPoint* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UTagPoint>();
	}
};
static_assert(alignof(UTagPoint) == 0x000008, "Wrong alignment on UTagPoint");
static_assert(sizeof(UTagPoint) == 0x000038, "Wrong size on UTagPoint");

// Class MotionSymphony.TagSection
// 0x0000 (0x0030 - 0x0030)
class UTagSection : public UAnimNotifyState
{
public:
	bool Received_PreProcessPose(struct FPoseMotionData& OutPose, class UMotionAnimObject* OutMotionAnim, class UMotionDataAsset* OutMotionData, const float StartTime, const float EndTime) const	 // 0xae1e64;
	bool Received_PreProcessTag(class UMotionAnimObject* OutMotionAnim, class UMotionDataAsset* OutMotionData, const float StartTime, const float EndTime) const	 // 0xae1e64;

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"TagSection">();
	}
	static class UTagSection* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UTagSection>();
	}
};
static_assert(alignof(UTagSection) == 0x000008, "Wrong alignment on UTagSection");
static_assert(sizeof(UTagSection) == 0x000030, "Wrong size on UTagSection");

// Class MotionSymphony.Tag_CostMultiplier
// 0x0008 (0x0038 - 0x0030)
class UTag_CostMultiplier final : public UTagSection
{
public:
	float                                         CostMultiplier;                                    // 0x0030(0x0004)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bOverride;                                         // 0x0034(0x0001)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_35[0x3];                                       // 0x0035(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"Tag_CostMultiplier">();
	}
	static class UTag_CostMultiplier* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UTag_CostMultiplier>();
	}
};
static_assert(alignof(UTag_CostMultiplier) == 0x000008, "Wrong alignment on UTag_CostMultiplier");
static_assert(sizeof(UTag_CostMultiplier) == 0x000038, "Wrong size on UTag_CostMultiplier");
static_assert(offsetof(UTag_CostMultiplier, CostMultiplier) == 0x000030, "Member 'UTag_CostMultiplier::CostMultiplier' has a wrong offset!");
static_assert(offsetof(UTag_CostMultiplier, bOverride) == 0x000034, "Member 'UTag_CostMultiplier::bOverride' has a wrong offset!");

// Class MotionSymphony.Tag_DistanceMarker
// 0x0010 (0x0048 - 0x0038)
class UTag_DistanceMarker final : public UTagPoint
{
public:
	EDistanceMatchTrigger                         DistanceMatchTrigger;                              // 0x0038(0x0001)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EDistanceMatchType                            DistanceMatchType;                                 // 0x0039(0x0001)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EDistanceMatchBasis                           DistanceMatchBasis;                                // 0x003A(0x0001)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3B[0x1];                                       // 0x003B(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Lead;                                              // 0x003C(0x0004)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Tail;                                              // 0x0040(0x0004)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_44[0x4];                                       // 0x0044(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"Tag_DistanceMarker">();
	}
	static class UTag_DistanceMarker* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UTag_DistanceMarker>();
	}
};
static_assert(alignof(UTag_DistanceMarker) == 0x000008, "Wrong alignment on UTag_DistanceMarker");
static_assert(sizeof(UTag_DistanceMarker) == 0x000048, "Wrong size on UTag_DistanceMarker");
static_assert(offsetof(UTag_DistanceMarker, DistanceMatchTrigger) == 0x000038, "Member 'UTag_DistanceMarker::DistanceMatchTrigger' has a wrong offset!");
static_assert(offsetof(UTag_DistanceMarker, DistanceMatchType) == 0x000039, "Member 'UTag_DistanceMarker::DistanceMatchType' has a wrong offset!");
static_assert(offsetof(UTag_DistanceMarker, DistanceMatchBasis) == 0x00003A, "Member 'UTag_DistanceMarker::DistanceMatchBasis' has a wrong offset!");
static_assert(offsetof(UTag_DistanceMarker, Lead) == 0x00003C, "Member 'UTag_DistanceMarker::Lead' has a wrong offset!");
static_assert(offsetof(UTag_DistanceMarker, Tail) == 0x000040, "Member 'UTag_DistanceMarker::Tail' has a wrong offset!");

// Class MotionSymphony.Tag_DoNotUse
// 0x0000 (0x0030 - 0x0030)
class UTag_DoNotUse final : public UTagSection
{
public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"Tag_DoNotUse">();
	}
	static class UTag_DoNotUse* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UTag_DoNotUse>();
	}
};
static_assert(alignof(UTag_DoNotUse) == 0x000008, "Wrong alignment on UTag_DoNotUse");
static_assert(sizeof(UTag_DoNotUse) == 0x000030, "Wrong size on UTag_DoNotUse");

// Class MotionSymphony.Tag_NextNatural
// 0x0000 (0x0030 - 0x0030)
class UTag_NextNatural final : public UTagSection
{
public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"Tag_NextNatural">();
	}
	static class UTag_NextNatural* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UTag_NextNatural>();
	}
};
static_assert(alignof(UTag_NextNatural) == 0x000008, "Wrong alignment on UTag_NextNatural");
static_assert(sizeof(UTag_NextNatural) == 0x000030, "Wrong size on UTag_NextNatural");

// Class MotionSymphony.Tag_Trait
// 0x0008 (0x0038 - 0x0030)
class UTag_Trait final : public UTagSection
{
public:
	struct FGameplayTag                           MotionTags;                                        // 0x0030(0x0008)(Edit, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"Tag_Trait">();
	}
	static class UTag_Trait* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UTag_Trait>();
	}
};
static_assert(alignof(UTag_Trait) == 0x000008, "Wrong alignment on UTag_Trait");
static_assert(sizeof(UTag_Trait) == 0x000038, "Wrong size on UTag_Trait");
static_assert(offsetof(UTag_Trait, MotionTags) == 0x000030, "Member 'UTag_Trait::MotionTags' has a wrong offset!");

// Class MotionSymphony.TrajectoryErrorWarping
// 0x0030 (0x00F0 - 0x00C0)
class UTrajectoryErrorWarping final : public UActorComponent
{
public:
	ETrajectoryErrorWarpMode                      WarpMode;                                          // 0x00C0(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C1[0x3];                                       // 0x00C1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         WarpRate;                                          // 0x00C4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MinTrajectoryLength;                               // 0x00C8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_CC[0x4];                                       // 0x00CC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector2D                              ErrorActivationRange;                              // 0x00D0(0x0010)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_E0[0x10];                                      // 0x00E0(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ApplyTrajectoryErrorWarping(const float DeltaTime, const float PlaybackSpeed)	 // 0x47044d8;
	void SetMode(const ETrajectoryErrorWarpMode InWarpMode, const float InWarpRate, const float InMinTrajectoryLength, const float MinActivation, const float MaxActivation)	 // 0x4704c74;

	float CalculateTrajectoryErrorWarping(const float DeltaTime, const float PlaybackSpeed) const	 // 0x4704618;

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"TrajectoryErrorWarping">();
	}
	static class UTrajectoryErrorWarping* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UTrajectoryErrorWarping>();
	}
};
static_assert(alignof(UTrajectoryErrorWarping) == 0x000008, "Wrong alignment on UTrajectoryErrorWarping");
static_assert(sizeof(UTrajectoryErrorWarping) == 0x0000F0, "Wrong size on UTrajectoryErrorWarping");
static_assert(offsetof(UTrajectoryErrorWarping, WarpMode) == 0x0000C0, "Member 'UTrajectoryErrorWarping::WarpMode' has a wrong offset!");
static_assert(offsetof(UTrajectoryErrorWarping, WarpRate) == 0x0000C4, "Member 'UTrajectoryErrorWarping::WarpRate' has a wrong offset!");
static_assert(offsetof(UTrajectoryErrorWarping, MinTrajectoryLength) == 0x0000C8, "Member 'UTrajectoryErrorWarping::MinTrajectoryLength' has a wrong offset!");
static_assert(offsetof(UTrajectoryErrorWarping, ErrorActivationRange) == 0x0000D0, "Member 'UTrajectoryErrorWarping::ErrorActivationRange' has a wrong offset!");

// Class MotionSymphony.TrajectoryGenerator_Base
// 0x0180 (0x0240 - 0x00C0)
#pragma pack(push, 0x1)
class alignas(0x10) UTrajectoryGenerator_Base : public UActorComponent
{
public:
	class UMotionMatchConfig*                     MotionMatchConfig;                                 // 0x00C0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RecordingFrequency;                                // 0x00C8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SampleRate;                                        // 0x00CC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bFlattenTrajectory;                                // 0x00D0(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDebugRandomInput;                                 // 0x00D1(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D2[0x6];                                       // 0x00D2(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector2D                              DebugTimeIntervalRange;                            // 0x00D8(0x0010)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FTrajectory                            Trajectory;                                        // 0x00E8(0x0010)(NativeAccessSpecifierPublic)
	struct FVector                                InputVector;                                       // 0x00F8(0x0018)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_110[0x128];                                    // 0x0110(0x0128)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ClearInputProfile()	 // 0x470476c;
	void DrawTrajectoryDebug(const struct FVector& DrawOffset)	 // 0x4704784;
	bool HasMoveInput()	 // 0x4704858;
	bool IsIdle()	 // 0x47049a4;
	void SetCharacterSkeletalMeshComponent(class USkeletalMeshComponent* InSkelMesh)	 // 0x4704b18;
	void SetInputProfile(struct FInputProfile& InInputProfile)	 // 0x4704bd8;
	void SetTrajectoryInput(float XAxisValue, float YAxisValue, float ZAxisValue)	 // 0x47050b8;
	void SetTrajectoryInputX(float XAxisValue)	 // 0x4705298;
	void SetTrajectoryInputY(float YAxisValue)	 // 0x470535c;
	void SetTrajectoryInputZ(float ZAxisValue)	 // 0x4705420;

	const struct FTrajectory GetCurrentTrajectory() const	 // 0x470483c;

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"TrajectoryGenerator_Base">();
	}
	static class UTrajectoryGenerator_Base* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UTrajectoryGenerator_Base>();
	}
};
#pragma pack(pop)
static_assert(alignof(UTrajectoryGenerator_Base) == 0x000010, "Wrong alignment on UTrajectoryGenerator_Base");
static_assert(sizeof(UTrajectoryGenerator_Base) == 0x000240, "Wrong size on UTrajectoryGenerator_Base");
static_assert(offsetof(UTrajectoryGenerator_Base, MotionMatchConfig) == 0x0000C0, "Member 'UTrajectoryGenerator_Base::MotionMatchConfig' has a wrong offset!");
static_assert(offsetof(UTrajectoryGenerator_Base, RecordingFrequency) == 0x0000C8, "Member 'UTrajectoryGenerator_Base::RecordingFrequency' has a wrong offset!");
static_assert(offsetof(UTrajectoryGenerator_Base, SampleRate) == 0x0000CC, "Member 'UTrajectoryGenerator_Base::SampleRate' has a wrong offset!");
static_assert(offsetof(UTrajectoryGenerator_Base, bFlattenTrajectory) == 0x0000D0, "Member 'UTrajectoryGenerator_Base::bFlattenTrajectory' has a wrong offset!");
static_assert(offsetof(UTrajectoryGenerator_Base, bDebugRandomInput) == 0x0000D1, "Member 'UTrajectoryGenerator_Base::bDebugRandomInput' has a wrong offset!");
static_assert(offsetof(UTrajectoryGenerator_Base, DebugTimeIntervalRange) == 0x0000D8, "Member 'UTrajectoryGenerator_Base::DebugTimeIntervalRange' has a wrong offset!");
static_assert(offsetof(UTrajectoryGenerator_Base, Trajectory) == 0x0000E8, "Member 'UTrajectoryGenerator_Base::Trajectory' has a wrong offset!");
static_assert(offsetof(UTrajectoryGenerator_Base, InputVector) == 0x0000F8, "Member 'UTrajectoryGenerator_Base::InputVector' has a wrong offset!");

// Class MotionSymphony.TrajectoryGenerator
// 0x0050 (0x0290 - 0x0240)
class UTrajectoryGenerator final : public UTrajectoryGenerator_Base
{
public:
	struct FVector                                StrafeDirection;                                   // 0x0238(0x0018)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxSpeed;                                          // 0x0250(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MoveResponse;                                      // 0x0254(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TurnResponse;                                      // 0x0258(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_25C[0x1];                                      // 0x025C(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bResetDirectionOnIdle;                             // 0x025D(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETrajectoryModel                              TrajectoryModel;                                   // 0x025E(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETrajectoryMoveMode                           TrajectoryBehaviour;                               // 0x025F(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETrajectoryControlMode                        TrajectoryControlMode;                             // 0x0260(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUsePathAsTrajectoryForAI;                         // 0x0261(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_262[0x2E];                                     // 0x0262(0x002E)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SetStrafeDirectionFromCamera(class UCameraComponent* Camera)	 // 0x4704f44;

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"TrajectoryGenerator">();
	}
	static class UTrajectoryGenerator* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UTrajectoryGenerator>();
	}
};
static_assert(alignof(UTrajectoryGenerator) == 0x000010, "Wrong alignment on UTrajectoryGenerator");
static_assert(sizeof(UTrajectoryGenerator) == 0x000290, "Wrong size on UTrajectoryGenerator");
static_assert(offsetof(UTrajectoryGenerator, StrafeDirection) == 0x000238, "Member 'UTrajectoryGenerator::StrafeDirection' has a wrong offset!");
static_assert(offsetof(UTrajectoryGenerator, MaxSpeed) == 0x000250, "Member 'UTrajectoryGenerator::MaxSpeed' has a wrong offset!");
static_assert(offsetof(UTrajectoryGenerator, MoveResponse) == 0x000254, "Member 'UTrajectoryGenerator::MoveResponse' has a wrong offset!");
static_assert(offsetof(UTrajectoryGenerator, TurnResponse) == 0x000258, "Member 'UTrajectoryGenerator::TurnResponse' has a wrong offset!");
static_assert(offsetof(UTrajectoryGenerator, bResetDirectionOnIdle) == 0x00025D, "Member 'UTrajectoryGenerator::bResetDirectionOnIdle' has a wrong offset!");
static_assert(offsetof(UTrajectoryGenerator, TrajectoryModel) == 0x00025E, "Member 'UTrajectoryGenerator::TrajectoryModel' has a wrong offset!");
static_assert(offsetof(UTrajectoryGenerator, TrajectoryBehaviour) == 0x00025F, "Member 'UTrajectoryGenerator::TrajectoryBehaviour' has a wrong offset!");
static_assert(offsetof(UTrajectoryGenerator, TrajectoryControlMode) == 0x000260, "Member 'UTrajectoryGenerator::TrajectoryControlMode' has a wrong offset!");
static_assert(offsetof(UTrajectoryGenerator, bUsePathAsTrajectoryForAI) == 0x000261, "Member 'UTrajectoryGenerator::bUsePathAsTrajectoryForAI' has a wrong offset!");

}

