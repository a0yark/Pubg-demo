#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: AICommon

#include "Basic.hpp"

#include "Game_structs.hpp"
#include "Game_classes.hpp"
#include "AICommon_structs.hpp"
#include "CoreUObject_structs.hpp"
#include "CoreUObject_classes.hpp"
#include "AIModule_structs.hpp"
#include "AIModule_classes.hpp"
#include "NavigationSystem_classes.hpp"
#include "Mercuna_structs.hpp"
#include "Mercuna_classes.hpp"
#include "GameplayAbilities_structs.hpp"
#include "GameplayAbilities_classes.hpp"
#include "Engine_structs.hpp"
#include "Engine_classes.hpp"
#include "Mercuna3DMovement_classes.hpp"
#include "GameplayTags_structs.hpp"
#include "DeveloperSettings_classes.hpp"
#include "BehaviorTreeExtension_classes.hpp"
#include "MotionSymphony_structs.hpp"
#include "MotionSymphony_classes.hpp"
#include "ModularGameplay_classes.hpp"
#include "MotionWarping_classes.hpp"
#include "GameplayStateTreeModule_classes.hpp"


namespace SDK
{

// Class AICommon.P2BTDecorator_Stance
// 0x0008 (0x0070 - 0x0068)
class UP2BTDecorator_Stance final : public UBTDecorator
{
public:
	struct FGameplayTag                           Stance;                                            // 0x0068(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"P2BTDecorator_Stance">();
	}
	static class UP2BTDecorator_Stance* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UP2BTDecorator_Stance>();
	}
};
static_assert(alignof(UP2BTDecorator_Stance) == 0x000008, "Wrong alignment on UP2BTDecorator_Stance");
static_assert(sizeof(UP2BTDecorator_Stance) == 0x000070, "Wrong size on UP2BTDecorator_Stance");
static_assert(offsetof(UP2BTDecorator_Stance, Stance) == 0x000068, "Member 'UP2BTDecorator_Stance::Stance' has a wrong offset!");

// Class AICommon.P2AIFleeConfig
// 0x0000 (0x0028 - 0x0028)
class UP2AIFleeConfig : public UObject
{
public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"P2AIFleeConfig">();
	}
	static class UP2AIFleeConfig* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UP2AIFleeConfig>();
	}
};
static_assert(alignof(UP2AIFleeConfig) == 0x000008, "Wrong alignment on UP2AIFleeConfig");
static_assert(sizeof(UP2AIFleeConfig) == 0x000028, "Wrong size on UP2AIFleeConfig");

// Class AICommon.P2AIFleeConfig_Default
// 0x0040 (0x0068 - 0x0028)
class UP2AIFleeConfig_Default : public UP2AIFleeConfig
{
public:
	float                                         InterestFleeThreshold;                             // 0x0028(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HpFleeThreshold;                                   // 0x002C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MinFriendliesToBlockFleeing;                       // 0x0030(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_34[0x4];                                       // 0x0034(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTagContainer                  ForceFleeTags;                                     // 0x0038(0x0020)(Edit, NativeAccessSpecifierPublic)
	float                                         FriendlySearchRadius;                              // 0x0058(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MinFleeingTime;                                    // 0x005C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         InterestRelaxThreshold;                            // 0x0060(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_64[0x4];                                       // 0x0064(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"P2AIFleeConfig_Default">();
	}
	static class UP2AIFleeConfig_Default* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UP2AIFleeConfig_Default>();
	}
};
static_assert(alignof(UP2AIFleeConfig_Default) == 0x000008, "Wrong alignment on UP2AIFleeConfig_Default");
static_assert(sizeof(UP2AIFleeConfig_Default) == 0x000068, "Wrong size on UP2AIFleeConfig_Default");
static_assert(offsetof(UP2AIFleeConfig_Default, InterestFleeThreshold) == 0x000028, "Member 'UP2AIFleeConfig_Default::InterestFleeThreshold' has a wrong offset!");
static_assert(offsetof(UP2AIFleeConfig_Default, HpFleeThreshold) == 0x00002C, "Member 'UP2AIFleeConfig_Default::HpFleeThreshold' has a wrong offset!");
static_assert(offsetof(UP2AIFleeConfig_Default, MinFriendliesToBlockFleeing) == 0x000030, "Member 'UP2AIFleeConfig_Default::MinFriendliesToBlockFleeing' has a wrong offset!");
static_assert(offsetof(UP2AIFleeConfig_Default, ForceFleeTags) == 0x000038, "Member 'UP2AIFleeConfig_Default::ForceFleeTags' has a wrong offset!");
static_assert(offsetof(UP2AIFleeConfig_Default, FriendlySearchRadius) == 0x000058, "Member 'UP2AIFleeConfig_Default::FriendlySearchRadius' has a wrong offset!");
static_assert(offsetof(UP2AIFleeConfig_Default, MinFleeingTime) == 0x00005C, "Member 'UP2AIFleeConfig_Default::MinFleeingTime' has a wrong offset!");
static_assert(offsetof(UP2AIFleeConfig_Default, InterestRelaxThreshold) == 0x000060, "Member 'UP2AIFleeConfig_Default::InterestRelaxThreshold' has a wrong offset!");

// Class AICommon.P2AIFleeConfig_Bombug
// 0x0010 (0x0078 - 0x0068)
class UP2AIFleeConfig_Bombug final : public UP2AIFleeConfig_Default
{
public:
	float                                         MinFriendliesToBlockFleeingGrounded;               // 0x0068(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FriendliesSearchRadiusWhenGrounded;                // 0x006C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           GroundedTag;                                       // 0x0070(0x0008)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"P2AIFleeConfig_Bombug">();
	}
	static class UP2AIFleeConfig_Bombug* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UP2AIFleeConfig_Bombug>();
	}
};
static_assert(alignof(UP2AIFleeConfig_Bombug) == 0x000008, "Wrong alignment on UP2AIFleeConfig_Bombug");
static_assert(sizeof(UP2AIFleeConfig_Bombug) == 0x000078, "Wrong size on UP2AIFleeConfig_Bombug");
static_assert(offsetof(UP2AIFleeConfig_Bombug, MinFriendliesToBlockFleeingGrounded) == 0x000068, "Member 'UP2AIFleeConfig_Bombug::MinFriendliesToBlockFleeingGrounded' has a wrong offset!");
static_assert(offsetof(UP2AIFleeConfig_Bombug, FriendliesSearchRadiusWhenGrounded) == 0x00006C, "Member 'UP2AIFleeConfig_Bombug::FriendliesSearchRadiusWhenGrounded' has a wrong offset!");
static_assert(offsetof(UP2AIFleeConfig_Bombug, GroundedTag) == 0x000070, "Member 'UP2AIFleeConfig_Bombug::GroundedTag' has a wrong offset!");

// Class AICommon.P2DisplayActorNameProvider_Npc
// 0x0000 (0x0050 - 0x0050)
class UP2DisplayActorNameProvider_Npc final : public UP2DisplayActorNameProvider_FromClass
{
public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"P2DisplayActorNameProvider_Npc">();
	}
	static class UP2DisplayActorNameProvider_Npc* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UP2DisplayActorNameProvider_Npc>();
	}
};
static_assert(alignof(UP2DisplayActorNameProvider_Npc) == 0x000008, "Wrong alignment on UP2DisplayActorNameProvider_Npc");
static_assert(sizeof(UP2DisplayActorNameProvider_Npc) == 0x000050, "Wrong size on UP2DisplayActorNameProvider_Npc");

// Class AICommon.P2AIFunctionLibrary
// 0x0000 (0x0028 - 0x0028)
class UP2AIFunctionLibrary final : public UBlueprintFunctionLibrary
{
public:
	static void GetActorsInBox(TArray<class AActor*>* OutActors, class UObject* InWorldContextObject, const TArray<class AActor*>& IgnoredActors, const struct FVector& Position, const struct FRotator& Rotation, const struct FVector3f& BoxHalfExtent, const TSubclassOf<class AActor> ActorClass, const EP2AIMobilityType MobilityType, const ECollisionChannel CollisionChannel, const bool IgnoreHiddenActors)	 // 0x4732bc8;
	static void GetActorsInBoxByChannel(TArray<class AActor*>* OutActors, class UObject* InWorldContextObject, const TArray<class AActor*>& IgnoredActors, const struct FVector& Position, const struct FRotator& Rotation, const struct FVector& BoxHalfExtent, const TSubclassOf<class AActor> ActorClass, const EP2AIMobilityType MobilityType, const ECollisionChannel CollisionChannel)	 // 0x473319c;
	static void GetActorsInSphere(TArray<class AActor*>* OutActors, class UObject* WorldContextObject, const TArray<class AActor*>& InIgnoredActors, const struct FVector& InPos, const struct FQuat& InRot, float InSphereRadius, TSubclassOf<class AActor> InActorClass, EP2AIMobilityType InMobilityType, ECollisionChannel InCollisionChannel, bool InbIgnoreHiddenActors)	 // 0x4733630;
	static void GetActorsInSphereByChannel(TArray<class AActor*>* OutActors, class UObject* WorldContextObject, const TArray<class AActor*>& InIgnoredActors, const struct FVector& InPos, const struct FQuat& InRot, float InSphereRadius, TSubclassOf<class AActor> InActorClass, EP2AIMobilityType InMobilityType, ECollisionChannel InCollisionChannel)	 // 0x4733c40;
	static void MakeGameplayAbilityDamageTarget(const TArray<class AActor*>& InActorArray, struct FGameplayAbilityTargetDataHandle* OutDataHandle)	 // 0x4734e80;
	static void MakeGameplayAbilityRadialDamageTarget(const TArray<class AActor*>& InActorArray, const struct FVector& InImpactCenter, const float InImpactAoeRadius, struct FGameplayAbilityTargetDataHandle* OutDataHandle)	 // 0x4734fa4;
	static void SendImpactAudio(const struct FGameplayAbilityTargetDataHandle& TargetDataHandle, const struct FGameplayTag& ImpactTag)	 // 0x473553c;
	static void TryDealDamage(const class UAbilitySystemComponent* InstigatorASC, const struct FGameplayAbilityTargetDataHandle& TargetDataHandle, const TSubclassOf<class UP2GameplayEffect_Damage>& EffectClass, float EffectLevel)	 // 0x47357a8;
	static void TryStun(const class UAbilitySystemComponent* InstigatorASC, const struct FGameplayAbilityTargetDataHandle& TargetDataHandle, float ChanceToApply, const struct FGameplayTag& InStunTag)	 // 0x4735a60;
	static void TryStunRadial(const class UAbilitySystemComponent* InstigatorASC, const class UCurveFloat* StunSeverityCurve, float MaxDistance, const struct FVector& ImpactCenter)	 // 0x4735ce8;
	static void TryStunTargetRadial(const class UAbilitySystemComponent* InstigatorASC, const class UCurveFloat* StunSeverityCurve, float MaxDistance, const struct FVector& ImpactCenter, class AActor* Target)	 // 0x473601c;

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"P2AIFunctionLibrary">();
	}
	static class UP2AIFunctionLibrary* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UP2AIFunctionLibrary>();
	}
};
static_assert(alignof(UP2AIFunctionLibrary) == 0x000008, "Wrong alignment on UP2AIFunctionLibrary");
static_assert(sizeof(UP2AIFunctionLibrary) == 0x000028, "Wrong size on UP2AIFunctionLibrary");

// Class AICommon.P2EnvQueryContext_Target
// 0x0000 (0x0028 - 0x0028)
class UP2EnvQueryContext_Target final : public UEnvQueryContext
{
public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"P2EnvQueryContext_Target">();
	}
	static class UP2EnvQueryContext_Target* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UP2EnvQueryContext_Target>();
	}
};
static_assert(alignof(UP2EnvQueryContext_Target) == 0x000008, "Wrong alignment on UP2EnvQueryContext_Target");
static_assert(sizeof(UP2EnvQueryContext_Target) == 0x000028, "Wrong size on UP2EnvQueryContext_Target");

// Class AICommon.P2DisplayActorNameProvider_NpcSpawningCosmeticActor
// 0x0000 (0x0050 - 0x0050)
class UP2DisplayActorNameProvider_NpcSpawningCosmeticActor final : public UP2DisplayActorNameProvider_FromClass
{
public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"P2DisplayActorNameProvider_NpcSpawningCosmeticActor">();
	}
	static class UP2DisplayActorNameProvider_NpcSpawningCosmeticActor* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UP2DisplayActorNameProvider_NpcSpawningCosmeticActor>();
	}
};
static_assert(alignof(UP2DisplayActorNameProvider_NpcSpawningCosmeticActor) == 0x000008, "Wrong alignment on UP2DisplayActorNameProvider_NpcSpawningCosmeticActor");
static_assert(sizeof(UP2DisplayActorNameProvider_NpcSpawningCosmeticActor) == 0x000050, "Wrong size on UP2DisplayActorNameProvider_NpcSpawningCosmeticActor");

// Class AICommon.AICheatExtension
// 0x00F0 (0x0168 - 0x0078)
class UAICheatExtension final : public UP2CheatManagerExtension
{
public:
	uint8                                         Pad_78[0x48];                                      // 0x0078(0x0048)(Fixing Size After Last Property [ Dumper-7 ])
	class UWorld*                                 CurrentWorld;                                      // 0x00C0(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class AP2NPCharacter*                         CurrentNPC;                                        // 0x00C8(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class AP2HeroCharacter*                       CurrentPlayer;                                     // 0x00D0(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<TSubclassOf<class AP2NpcGroupSpawner>> GroupSpawnerClasses;                               // 0x00D8(0x0010)(ZeroConstructor, Transient, UObjectWrapper, NativeAccessSpecifierPrivate)
	uint8                                         Pad_E8[0x10];                                      // 0x00E8(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UP2NpcGroupData*>                GroupDataList;                                     // 0x00F8(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	uint8                                         Pad_108[0x60];                                     // 0x0108(0x0060)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ClearPerceptionForcedAlertedLevel()	 // 0x472ab34;
	void ClientDisplayDebugMsgOnScreen(const class FString& DebugMsg)	 // 0x472ab90;
	void ClientReceiveTickDebugData(const struct FAICheatDebugData& DebugData)	 // 0x472ac64;
	void EnableSignificanceDebug(bool bEnabled)	 // 0x472ad7c;
	void RequestTickDebugData()	 // 0x1769068;
	void ServerDestroyAllNpcsOfDataType(const class UP2NpcData* NpcData)	 // 0x472b054;
	void ServerEndStateTreeDebug()	 // 0x17db788;
	void ServerKillAllNpcsOfDataType(const class UP2NpcData* NpcData)	 // 0x472b118;
	void ServerSetDynamicScale(const struct FGameplayTag& Tag, float Scale)	 // 0x472b1dc;
	void ServerSpawnNpc(const class UP2NpcData* NpcData)	 // 0x472b320;
	void ServerSpawnNpcAtDistance(const class UP2NpcData* NpcData, float SpawnDistance)	 // 0x472b3e4;
	void ServerSpawnNpcGroupSpawner(TSubclassOf<class AP2NpcGroupSpawner> InGroupSpawnerClass, const class UP2NpcGroupData* InNpcGroupData, int32 InGroupMemberNumX, int32 InGroupMemberNumY, const struct FVector& InSpawnLocation)	 // 0x472b528;
	void ServerStartStateTreeDebug(class AActor* TargetActor)	 // 0x472b7e0;
	void ServerUpdateStateTreeDebugMsg(const class FString& Msg)	 // 0x472b8a4;
	void SetDynamicScale(class FName Tag, float Scale)	 // 0x472ba38;
	void SetPerceptionForcedAlertedLevel(int32 InAlertedLevel)	 // 0x472bb78;

	void SetAllPlayersPerceptionEnabled(bool PerceptionEnabled) const	 // 0x472b974;
	void SetPlayerPerceptionEnabled(bool PerceptionEnabled) const	 // 0x472bc9c;

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"AICheatExtension">();
	}
	static class UAICheatExtension* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UAICheatExtension>();
	}
};
static_assert(alignof(UAICheatExtension) == 0x000008, "Wrong alignment on UAICheatExtension");
static_assert(sizeof(UAICheatExtension) == 0x000168, "Wrong size on UAICheatExtension");
static_assert(offsetof(UAICheatExtension, CurrentWorld) == 0x0000C0, "Member 'UAICheatExtension::CurrentWorld' has a wrong offset!");
static_assert(offsetof(UAICheatExtension, CurrentNPC) == 0x0000C8, "Member 'UAICheatExtension::CurrentNPC' has a wrong offset!");
static_assert(offsetof(UAICheatExtension, CurrentPlayer) == 0x0000D0, "Member 'UAICheatExtension::CurrentPlayer' has a wrong offset!");
static_assert(offsetof(UAICheatExtension, GroupSpawnerClasses) == 0x0000D8, "Member 'UAICheatExtension::GroupSpawnerClasses' has a wrong offset!");
static_assert(offsetof(UAICheatExtension, GroupDataList) == 0x0000F8, "Member 'UAICheatExtension::GroupDataList' has a wrong offset!");

// Class AICommon.P2AIItemStatAccessor_SentryAbility
// 0x0008 (0x0188 - 0x0180)
class UP2AIItemStatAccessor_SentryAbility : public UP2ItemStatAccessor
{
public:
	TSubclassOf<class UGameplayAbility>           AbilityClass;                                      // 0x0180(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	class UGameplayAbility* FindAbility(const class UP2ItemData* InItemData) const	 // 0x4732af8;

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"P2AIItemStatAccessor_SentryAbility">();
	}
	static class UP2AIItemStatAccessor_SentryAbility* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UP2AIItemStatAccessor_SentryAbility>();
	}
};
static_assert(alignof(UP2AIItemStatAccessor_SentryAbility) == 0x000008, "Wrong alignment on UP2AIItemStatAccessor_SentryAbility");
static_assert(sizeof(UP2AIItemStatAccessor_SentryAbility) == 0x000188, "Wrong size on UP2AIItemStatAccessor_SentryAbility");
static_assert(offsetof(UP2AIItemStatAccessor_SentryAbility, AbilityClass) == 0x000180, "Member 'UP2AIItemStatAccessor_SentryAbility::AbilityClass' has a wrong offset!");

// Class AICommon.AttackStageCondition
// 0x0000 (0x0028 - 0x0028)
class UAttackStageCondition : public UObject
{
public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"AttackStageCondition">();
	}
	static class UAttackStageCondition* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UAttackStageCondition>();
	}
};
static_assert(alignof(UAttackStageCondition) == 0x000008, "Wrong alignment on UAttackStageCondition");
static_assert(sizeof(UAttackStageCondition) == 0x000028, "Wrong size on UAttackStageCondition");

// Class AICommon.P2BTTask_ActivateAbilityBase
// 0x0028 (0x0098 - 0x0070)
class UP2BTTask_ActivateAbilityBase : public UBTTaskNode
{
public:
	bool                                          bIsBlocking;                                       // 0x0070(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bTreatCancelAsSuccess;                             // 0x0071(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUseEventToActivate;                               // 0x0072(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_73[0x5];                                       // 0x0073(0x0005)(Fixing Size After Last Property [ Dumper-7 ])
	class UBehaviorTreeComponent*                 OwnerCache;                                        // 0x0078(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UP2NpcAbilitySystemComponent*           AbilitySystemCache;                                // 0x0080(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_88[0x10];                                      // 0x0088(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"P2BTTask_ActivateAbilityBase">();
	}
	static class UP2BTTask_ActivateAbilityBase* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UP2BTTask_ActivateAbilityBase>();
	}
};
static_assert(alignof(UP2BTTask_ActivateAbilityBase) == 0x000008, "Wrong alignment on UP2BTTask_ActivateAbilityBase");
static_assert(sizeof(UP2BTTask_ActivateAbilityBase) == 0x000098, "Wrong size on UP2BTTask_ActivateAbilityBase");
static_assert(offsetof(UP2BTTask_ActivateAbilityBase, bIsBlocking) == 0x000070, "Member 'UP2BTTask_ActivateAbilityBase::bIsBlocking' has a wrong offset!");
static_assert(offsetof(UP2BTTask_ActivateAbilityBase, bTreatCancelAsSuccess) == 0x000071, "Member 'UP2BTTask_ActivateAbilityBase::bTreatCancelAsSuccess' has a wrong offset!");
static_assert(offsetof(UP2BTTask_ActivateAbilityBase, bUseEventToActivate) == 0x000072, "Member 'UP2BTTask_ActivateAbilityBase::bUseEventToActivate' has a wrong offset!");
static_assert(offsetof(UP2BTTask_ActivateAbilityBase, OwnerCache) == 0x000078, "Member 'UP2BTTask_ActivateAbilityBase::OwnerCache' has a wrong offset!");
static_assert(offsetof(UP2BTTask_ActivateAbilityBase, AbilitySystemCache) == 0x000080, "Member 'UP2BTTask_ActivateAbilityBase::AbilitySystemCache' has a wrong offset!");

// Class AICommon.P2AIItemStatAccessor_SentryAbilityCost
// 0x0000 (0x0188 - 0x0188)
class UP2AIItemStatAccessor_SentryAbilityCost final : public UP2AIItemStatAccessor_SentryAbility
{
public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"P2AIItemStatAccessor_SentryAbilityCost">();
	}
	static class UP2AIItemStatAccessor_SentryAbilityCost* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UP2AIItemStatAccessor_SentryAbilityCost>();
	}
};
static_assert(alignof(UP2AIItemStatAccessor_SentryAbilityCost) == 0x000008, "Wrong alignment on UP2AIItemStatAccessor_SentryAbilityCost");
static_assert(sizeof(UP2AIItemStatAccessor_SentryAbilityCost) == 0x000188, "Wrong size on UP2AIItemStatAccessor_SentryAbilityCost");

// Class AICommon.P2BTDecorator_TopDamageDealerWithinDistance
// 0x0010 (0x00A0 - 0x0090)
class UP2BTDecorator_TopDamageDealerWithinDistance final : public UBTDecorator_BlackboardBase
{
public:
	float                                         Radius;                                            // 0x0090(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          OnlyPlayerControlled;                              // 0x0094(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_95[0x3];                                       // 0x0095(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MaxDistance;                                       // 0x0098(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TimeWindow;                                        // 0x009C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"P2BTDecorator_TopDamageDealerWithinDistance">();
	}
	static class UP2BTDecorator_TopDamageDealerWithinDistance* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UP2BTDecorator_TopDamageDealerWithinDistance>();
	}
};
static_assert(alignof(UP2BTDecorator_TopDamageDealerWithinDistance) == 0x000008, "Wrong alignment on UP2BTDecorator_TopDamageDealerWithinDistance");
static_assert(sizeof(UP2BTDecorator_TopDamageDealerWithinDistance) == 0x0000A0, "Wrong size on UP2BTDecorator_TopDamageDealerWithinDistance");
static_assert(offsetof(UP2BTDecorator_TopDamageDealerWithinDistance, Radius) == 0x000090, "Member 'UP2BTDecorator_TopDamageDealerWithinDistance::Radius' has a wrong offset!");
static_assert(offsetof(UP2BTDecorator_TopDamageDealerWithinDistance, OnlyPlayerControlled) == 0x000094, "Member 'UP2BTDecorator_TopDamageDealerWithinDistance::OnlyPlayerControlled' has a wrong offset!");
static_assert(offsetof(UP2BTDecorator_TopDamageDealerWithinDistance, MaxDistance) == 0x000098, "Member 'UP2BTDecorator_TopDamageDealerWithinDistance::MaxDistance' has a wrong offset!");
static_assert(offsetof(UP2BTDecorator_TopDamageDealerWithinDistance, TimeWindow) == 0x00009C, "Member 'UP2BTDecorator_TopDamageDealerWithinDistance::TimeWindow' has a wrong offset!");

// Class AICommon.PredictionBasedCondition
// 0x0008 (0x0030 - 0x0028)
class UPredictionBasedCondition : public UAttackStageCondition
{
public:
	bool                                          bWithPrediction;                                   // 0x0028(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_29[0x3];                                       // 0x0029(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         PredictionTime;                                    // 0x002C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"PredictionBasedCondition">();
	}
	static class UPredictionBasedCondition* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UPredictionBasedCondition>();
	}
};
static_assert(alignof(UPredictionBasedCondition) == 0x000008, "Wrong alignment on UPredictionBasedCondition");
static_assert(sizeof(UPredictionBasedCondition) == 0x000030, "Wrong size on UPredictionBasedCondition");
static_assert(offsetof(UPredictionBasedCondition, bWithPrediction) == 0x000028, "Member 'UPredictionBasedCondition::bWithPrediction' has a wrong offset!");
static_assert(offsetof(UPredictionBasedCondition, PredictionTime) == 0x00002C, "Member 'UPredictionBasedCondition::PredictionTime' has a wrong offset!");

// Class AICommon.DistanceToTargetCondition
// 0x0008 (0x0038 - 0x0030)
class UDistanceToTargetCondition final : public UPredictionBasedCondition
{
public:
	float                                         MinDistance;                                       // 0x0030(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxDistance;                                       // 0x0034(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"DistanceToTargetCondition">();
	}
	static class UDistanceToTargetCondition* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UDistanceToTargetCondition>();
	}
};
static_assert(alignof(UDistanceToTargetCondition) == 0x000008, "Wrong alignment on UDistanceToTargetCondition");
static_assert(sizeof(UDistanceToTargetCondition) == 0x000038, "Wrong size on UDistanceToTargetCondition");
static_assert(offsetof(UDistanceToTargetCondition, MinDistance) == 0x000030, "Member 'UDistanceToTargetCondition::MinDistance' has a wrong offset!");
static_assert(offsetof(UDistanceToTargetCondition, MaxDistance) == 0x000034, "Member 'UDistanceToTargetCondition::MaxDistance' has a wrong offset!");

// Class AICommon.BTService_CheckIsLookedAt
// 0x0058 (0x00C8 - 0x0070)
class UBTService_CheckIsLookedAt final : public UBTService
{
public:
	class UP2LookedAtSenseData*                   Settings;                                          // 0x0070(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FBlackboardKeySelector                 Target;                                            // 0x0078(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FBlackboardKeySelector                 Result;                                            // 0x00A0(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"BTService_CheckIsLookedAt">();
	}
	static class UBTService_CheckIsLookedAt* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UBTService_CheckIsLookedAt>();
	}
};
static_assert(alignof(UBTService_CheckIsLookedAt) == 0x000008, "Wrong alignment on UBTService_CheckIsLookedAt");
static_assert(sizeof(UBTService_CheckIsLookedAt) == 0x0000C8, "Wrong size on UBTService_CheckIsLookedAt");
static_assert(offsetof(UBTService_CheckIsLookedAt, Settings) == 0x000070, "Member 'UBTService_CheckIsLookedAt::Settings' has a wrong offset!");
static_assert(offsetof(UBTService_CheckIsLookedAt, Target) == 0x000078, "Member 'UBTService_CheckIsLookedAt::Target' has a wrong offset!");
static_assert(offsetof(UBTService_CheckIsLookedAt, Result) == 0x0000A0, "Member 'UBTService_CheckIsLookedAt::Result' has a wrong offset!");

// Class AICommon.P2AIItemStatAccessor_PropertyProjectile
// 0x0000 (0x0198 - 0x0198)
class UP2AIItemStatAccessor_PropertyProjectile : public UP2ItemStatAccessor_Property
{
public:
	class AP2SentryProjectile* GetProjectile(const class UDataAsset* InDataAsset) const	 // 0x4734210;

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"P2AIItemStatAccessor_PropertyProjectile">();
	}
	static class UP2AIItemStatAccessor_PropertyProjectile* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UP2AIItemStatAccessor_PropertyProjectile>();
	}
};
static_assert(alignof(UP2AIItemStatAccessor_PropertyProjectile) == 0x000008, "Wrong alignment on UP2AIItemStatAccessor_PropertyProjectile");
static_assert(sizeof(UP2AIItemStatAccessor_PropertyProjectile) == 0x000198, "Wrong size on UP2AIItemStatAccessor_PropertyProjectile");

// Class AICommon.P2BruteProjectile
// 0x0130 (0x03E0 - 0x02B0)
class AP2BruteProjectile final : public AActor
{
public:
	uint8                                         Pad_2B0[0x18];                                     // 0x02B0(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	class UP2SmartObjectDefinition_BruteThrowable* Definition;                                       // 0x02C8(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FP2BrutProjectileData                  ReplicatedData;                                    // 0x02D0(0x00C0)(Net, RepNotify, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	struct FVector                                Velocity;                                          // 0x0390(0x0018)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FVector                                TargetLocation;                                    // 0x03A8(0x0018)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_3C0[0x20];                                     // 0x03C0(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	struct FAkEventSlotConfig GetImpactAudioEvent()	 // 0x473dd68;
	float GetProjectileSpeed()	 // 0x473dd9c;
	void K2_OnProjectileStop(const struct FHitResult& ImpactResult)	 // 0xae1e64;
	void OnProjectileStop(const struct FHitResult& ImpactResult)	 // 0x473ddec;
	void OnRep_ReplicatedData()	 // 0x473de84;
	void OnRep_SetVelocity()	 // 0x473de98;
	void OnVelocityChangedBP()	 // 0xae1e64;

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"P2BruteProjectile">();
	}
	static class AP2BruteProjectile* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<AP2BruteProjectile>();
	}
};
static_assert(alignof(AP2BruteProjectile) == 0x000010, "Wrong alignment on AP2BruteProjectile");
static_assert(sizeof(AP2BruteProjectile) == 0x0003E0, "Wrong size on AP2BruteProjectile");
static_assert(offsetof(AP2BruteProjectile, Definition) == 0x0002C8, "Member 'AP2BruteProjectile::Definition' has a wrong offset!");
static_assert(offsetof(AP2BruteProjectile, ReplicatedData) == 0x0002D0, "Member 'AP2BruteProjectile::ReplicatedData' has a wrong offset!");
static_assert(offsetof(AP2BruteProjectile, Velocity) == 0x000390, "Member 'AP2BruteProjectile::Velocity' has a wrong offset!");
static_assert(offsetof(AP2BruteProjectile, TargetLocation) == 0x0003A8, "Member 'AP2BruteProjectile::TargetLocation' has a wrong offset!");

// Class AICommon.InstigatorSpeedCondition
// 0x0008 (0x0030 - 0x0028)
class UInstigatorSpeedCondition final : public UAttackStageCondition
{
public:
	float                                         MinSpeed;                                          // 0x0028(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxSpeed;                                          // 0x002C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"InstigatorSpeedCondition">();
	}
	static class UInstigatorSpeedCondition* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UInstigatorSpeedCondition>();
	}
};
static_assert(alignof(UInstigatorSpeedCondition) == 0x000008, "Wrong alignment on UInstigatorSpeedCondition");
static_assert(sizeof(UInstigatorSpeedCondition) == 0x000030, "Wrong size on UInstigatorSpeedCondition");
static_assert(offsetof(UInstigatorSpeedCondition, MinSpeed) == 0x000028, "Member 'UInstigatorSpeedCondition::MinSpeed' has a wrong offset!");
static_assert(offsetof(UInstigatorSpeedCondition, MaxSpeed) == 0x00002C, "Member 'UInstigatorSpeedCondition::MaxSpeed' has a wrong offset!");

// Class AICommon.P2AIItemStatAccessor_PropertyFireData
// 0x0000 (0x0198 - 0x0198)
class UP2AIItemStatAccessor_PropertyFireData final : public UP2AIItemStatAccessor_PropertyProjectile
{
public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"P2AIItemStatAccessor_PropertyFireData">();
	}
	static class UP2AIItemStatAccessor_PropertyFireData* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UP2AIItemStatAccessor_PropertyFireData>();
	}
};
static_assert(alignof(UP2AIItemStatAccessor_PropertyFireData) == 0x000008, "Wrong alignment on UP2AIItemStatAccessor_PropertyFireData");
static_assert(sizeof(UP2AIItemStatAccessor_PropertyFireData) == 0x000198, "Wrong size on UP2AIItemStatAccessor_PropertyFireData");

// Class AICommon.P2TestKeySelector
// 0x0000 (0x0030 - 0x0030)
class UP2TestKeySelector : public UP2Object
{
public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"P2TestKeySelector">();
	}
	static class UP2TestKeySelector* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UP2TestKeySelector>();
	}
};
static_assert(alignof(UP2TestKeySelector) == 0x000008, "Wrong alignment on UP2TestKeySelector");
static_assert(sizeof(UP2TestKeySelector) == 0x000030, "Wrong size on UP2TestKeySelector");

// Class AICommon.TargetSpeedCondition
// 0x0008 (0x0030 - 0x0028)
class UTargetSpeedCondition final : public UAttackStageCondition
{
public:
	float                                         MinSpeed;                                          // 0x0028(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxSpeed;                                          // 0x002C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"TargetSpeedCondition">();
	}
	static class UTargetSpeedCondition* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UTargetSpeedCondition>();
	}
};
static_assert(alignof(UTargetSpeedCondition) == 0x000008, "Wrong alignment on UTargetSpeedCondition");
static_assert(sizeof(UTargetSpeedCondition) == 0x000030, "Wrong size on UTargetSpeedCondition");
static_assert(offsetof(UTargetSpeedCondition, MinSpeed) == 0x000028, "Member 'UTargetSpeedCondition::MinSpeed' has a wrong offset!");
static_assert(offsetof(UTargetSpeedCondition, MaxSpeed) == 0x00002C, "Member 'UTargetSpeedCondition::MaxSpeed' has a wrong offset!");

// Class AICommon.AngleToTargetCondition
// 0x0010 (0x0040 - 0x0030)
class UAngleToTargetCondition final : public UPredictionBasedCondition
{
public:
	float                                         MinAngle;                                          // 0x0030(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxAngle;                                          // 0x0034(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EAngleCalculationType                         CalculationType;                                   // 0x0038(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_39[0x7];                                       // 0x0039(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"AngleToTargetCondition">();
	}
	static class UAngleToTargetCondition* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UAngleToTargetCondition>();
	}
};
static_assert(alignof(UAngleToTargetCondition) == 0x000008, "Wrong alignment on UAngleToTargetCondition");
static_assert(sizeof(UAngleToTargetCondition) == 0x000040, "Wrong size on UAngleToTargetCondition");
static_assert(offsetof(UAngleToTargetCondition, MinAngle) == 0x000030, "Member 'UAngleToTargetCondition::MinAngle' has a wrong offset!");
static_assert(offsetof(UAngleToTargetCondition, MaxAngle) == 0x000034, "Member 'UAngleToTargetCondition::MaxAngle' has a wrong offset!");
static_assert(offsetof(UAngleToTargetCondition, CalculationType) == 0x000038, "Member 'UAngleToTargetCondition::CalculationType' has a wrong offset!");

// Class AICommon.P2AIPerceptionComponent
// 0x0318 (0x04C8 - 0x01B0)
class UP2AIPerceptionComponent final : public UAIPerceptionComponent
{
public:
	uint8                                         Pad_1B0[0x20];                                     // 0x01B0(0x0020)(Fixing Size After Last Property [ Dumper-7 ])
	TMulticastInlineDelegate<void(const class AActor* Actor, EP2PerceptionAlertedLevelType InNewAlertedLevel, EP2PerceptionAlertedLevelType InOldAlertedLevel)> OnAlertedLevelChangedDelegate; // 0x01D0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_1E0[0x18];                                     // 0x01E0(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	TMulticastInlineDelegate<void(const class AActor* Actor, class AActor* InNewTarget, class AActor* InOldTarget)> OnTargetChangedDelegate; // 0x01F8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_208[0x18];                                     // 0x0208(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FP2PerceptionAlertedLevelChangePair> AlertedLevelIncreasePairs;                    // 0x0220(0x0010)(Edit, EditFixedSize, ZeroConstructor, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	TArray<struct FP2PerceptionAlertedLevelChangePair> AlertedLevelDecreasePairs;                    // 0x0230(0x0010)(Edit, EditFixedSize, ZeroConstructor, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	TMap<EP2PerceptionAlertedLevelType, float>    AlertedLevelIncreaseRate;                          // 0x0240(0x0050)(Edit, EditFixedSize, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	TMap<EP2PerceptionAlertedLevelType, float>    AlertedLevelDecreaseRate;                          // 0x0290(0x0050)(Edit, EditFixedSize, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	class UDataTable*                             InterestLevelPerTagData;                           // 0x02E0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TMap<TSubclassOf<class UAISense>, float>      InterestLevelIncreasePerSense;                     // 0x02E8(0x0050)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	float                                         MinSpottedTime;                                    // 0x0338(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MinVisibleTime;                                    // 0x033C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSet<TSubclassOf<class UAISense>>             SpotSenses;                                        // 0x0340(0x0050)(Edit, DisableEditOnInstance, Protected, UObjectWrapper, NativeAccessSpecifierProtected)
	TSet<TSubclassOf<class UAISense>>             SensitiveSenses;                                   // 0x0390(0x0050)(Edit, DisableEditOnInstance, Protected, UObjectWrapper, NativeAccessSpecifierProtected)
	TMap<TWeakObjectPtr<class AActor>, float>     IgnoredTargets;                                    // 0x03E0(0x0050)(Protected, NativeAccessSpecifierProtected)
	struct FGameplayTagContainer                  IgnoredStimuli;                                    // 0x0430(0x0020)(Edit, BlueprintVisible, EditConst, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_450[0x78];                                     // 0x0450(0x0078)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void AssignTarget(class AActor* InTarget)	 // 0x47326b8;
	bool ClearAllThreats()	 // 0x4732778;
	bool ClearInvalidThreats()	 // 0x473279c;
	void ClearTarget()	 // 0x47327c0;
	bool ClearThreat(const class AActor* InActor)	 // 0x47327d4;
	bool ClearThreats(bool InClearNonSpotted, bool InClearNonVisible, float InMinInterestLevel, float InMaxInterestLevel)	 // 0x47328a4;
	void IgnoreTarget(const class AActor* InActor, float Time)	 // 0x4734ab8;
	void OnPostPerceptionUpdate(const TArray<class AActor*>& InUpdatedActors)	 // 0x4735168;
	void OnPostTargetPerceptionUpdated(class AActor* InActor, const struct FAIStimulus& InStimulus)	 // 0x4735204;
	void OverrideThreatInterestLevel(const class AActor* InActor, float InInterestLevel, float InInterestLevelTarget)	 // 0x4735380;
	void SetIgnoredStimuli(const struct FGameplayTagContainer& StimuliTags)	 // 0x47356c8;

	const EP2PerceptionAlertedLevelType GetAlertedLevel() const	 // 0x47341b8;
	const struct FGameplayTagContainer GetIgnoredStimuli() const	 // 0x47341d0;
	class AActor* GetPrimaryTarget() const	 // 0x47341ec;
	float GetThreatInterestLevel(const class AActor* InActor) const	 // 0x47342d0;
	float GetThreatInterestLevelTarget(const class AActor* InActor) const	 // 0x47343a0;
	struct FVector GetThreatLocation(const class AActor* InActor) const	 // 0x4734470;
	bool HasRecentStimuliByTags(const struct FGameplayTagContainer& GameplayTags, bool bCheckTargetOnly, bool bUseCustomAgeFilter, float CustomMaxAge, float MaxDistance, bool bHostileOnly) const	 // 0x4734744;
	bool IsInterestLevelDecreasingEnabled() const	 // 0x4734bf8;
	bool IsSuppressed(float InMaxTimeSince) const	 // 0x4734c10;
	bool IsThreatSpotted(const class AActor* InActor) const	 // 0x4734ce0;
	bool IsThreatVisible(const class AActor* InActor) const	 // 0x4734db0;
	bool TookDamageRecently() const	 // 0x4735784;

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"P2AIPerceptionComponent">();
	}
	static class UP2AIPerceptionComponent* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UP2AIPerceptionComponent>();
	}
};
static_assert(alignof(UP2AIPerceptionComponent) == 0x000008, "Wrong alignment on UP2AIPerceptionComponent");
static_assert(sizeof(UP2AIPerceptionComponent) == 0x0004C8, "Wrong size on UP2AIPerceptionComponent");
static_assert(offsetof(UP2AIPerceptionComponent, OnAlertedLevelChangedDelegate) == 0x0001D0, "Member 'UP2AIPerceptionComponent::OnAlertedLevelChangedDelegate' has a wrong offset!");
static_assert(offsetof(UP2AIPerceptionComponent, OnTargetChangedDelegate) == 0x0001F8, "Member 'UP2AIPerceptionComponent::OnTargetChangedDelegate' has a wrong offset!");
static_assert(offsetof(UP2AIPerceptionComponent, AlertedLevelIncreasePairs) == 0x000220, "Member 'UP2AIPerceptionComponent::AlertedLevelIncreasePairs' has a wrong offset!");
static_assert(offsetof(UP2AIPerceptionComponent, AlertedLevelDecreasePairs) == 0x000230, "Member 'UP2AIPerceptionComponent::AlertedLevelDecreasePairs' has a wrong offset!");
static_assert(offsetof(UP2AIPerceptionComponent, AlertedLevelIncreaseRate) == 0x000240, "Member 'UP2AIPerceptionComponent::AlertedLevelIncreaseRate' has a wrong offset!");
static_assert(offsetof(UP2AIPerceptionComponent, AlertedLevelDecreaseRate) == 0x000290, "Member 'UP2AIPerceptionComponent::AlertedLevelDecreaseRate' has a wrong offset!");
static_assert(offsetof(UP2AIPerceptionComponent, InterestLevelPerTagData) == 0x0002E0, "Member 'UP2AIPerceptionComponent::InterestLevelPerTagData' has a wrong offset!");
static_assert(offsetof(UP2AIPerceptionComponent, InterestLevelIncreasePerSense) == 0x0002E8, "Member 'UP2AIPerceptionComponent::InterestLevelIncreasePerSense' has a wrong offset!");
static_assert(offsetof(UP2AIPerceptionComponent, MinSpottedTime) == 0x000338, "Member 'UP2AIPerceptionComponent::MinSpottedTime' has a wrong offset!");
static_assert(offsetof(UP2AIPerceptionComponent, MinVisibleTime) == 0x00033C, "Member 'UP2AIPerceptionComponent::MinVisibleTime' has a wrong offset!");
static_assert(offsetof(UP2AIPerceptionComponent, SpotSenses) == 0x000340, "Member 'UP2AIPerceptionComponent::SpotSenses' has a wrong offset!");
static_assert(offsetof(UP2AIPerceptionComponent, SensitiveSenses) == 0x000390, "Member 'UP2AIPerceptionComponent::SensitiveSenses' has a wrong offset!");
static_assert(offsetof(UP2AIPerceptionComponent, IgnoredTargets) == 0x0003E0, "Member 'UP2AIPerceptionComponent::IgnoredTargets' has a wrong offset!");
static_assert(offsetof(UP2AIPerceptionComponent, IgnoredStimuli) == 0x000430, "Member 'UP2AIPerceptionComponent::IgnoredStimuli' has a wrong offset!");

// Class AICommon.StageCondition
// 0x0008 (0x0030 - 0x0028)
class UStageCondition final : public UAttackStageCondition
{
public:
	int8                                          PreviousStages;                                    // 0x0028(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_29[0x7];                                       // 0x0029(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"StageCondition">();
	}
	static class UStageCondition* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UStageCondition>();
	}
};
static_assert(alignof(UStageCondition) == 0x000008, "Wrong alignment on UStageCondition");
static_assert(sizeof(UStageCondition) == 0x000030, "Wrong size on UStageCondition");
static_assert(offsetof(UStageCondition, PreviousStages) == 0x000028, "Member 'UStageCondition::PreviousStages' has a wrong offset!");

// Class AICommon.MatchPreviousPoseCondition
// 0x0018 (0x0040 - 0x0028)
class UMatchPreviousPoseCondition final : public UAttackStageCondition
{
public:
	float                                         PoseMatchingTolerance;                             // 0x0028(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C[0x4];                                       // 0x002C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class FString>                         IgnoreBones;                                       // 0x0030(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"MatchPreviousPoseCondition">();
	}
	static class UMatchPreviousPoseCondition* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UMatchPreviousPoseCondition>();
	}
};
static_assert(alignof(UMatchPreviousPoseCondition) == 0x000008, "Wrong alignment on UMatchPreviousPoseCondition");
static_assert(sizeof(UMatchPreviousPoseCondition) == 0x000040, "Wrong size on UMatchPreviousPoseCondition");
static_assert(offsetof(UMatchPreviousPoseCondition, PoseMatchingTolerance) == 0x000028, "Member 'UMatchPreviousPoseCondition::PoseMatchingTolerance' has a wrong offset!");
static_assert(offsetof(UMatchPreviousPoseCondition, IgnoreBones) == 0x000030, "Member 'UMatchPreviousPoseCondition::IgnoreBones' has a wrong offset!");

// Class AICommon.EnvQueryGenerator_SentryReachable
// 0x0038 (0x0088 - 0x0050)
class UEnvQueryGenerator_SentryReachable final : public UEnvQueryGenerator
{
public:
	struct FAIDataProviderFloatValue              AngleStep;                                         // 0x0050(0x0038)(Edit, DisableEditOnInstance, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"EnvQueryGenerator_SentryReachable">();
	}
	static class UEnvQueryGenerator_SentryReachable* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UEnvQueryGenerator_SentryReachable>();
	}
};
static_assert(alignof(UEnvQueryGenerator_SentryReachable) == 0x000008, "Wrong alignment on UEnvQueryGenerator_SentryReachable");
static_assert(sizeof(UEnvQueryGenerator_SentryReachable) == 0x000088, "Wrong size on UEnvQueryGenerator_SentryReachable");
static_assert(offsetof(UEnvQueryGenerator_SentryReachable, AngleStep) == 0x000050, "Member 'UEnvQueryGenerator_SentryReachable::AngleStep' has a wrong offset!");

// Class AICommon.P2AbilityNavLinkComponent
// 0x0008 (0x01F8 - 0x01F0)
class UP2AbilityNavLinkComponent final : public UNavLinkCustomComponent
{
public:
	TSubclassOf<class UP2NpcAbility_UseNavLink>   AbilityToUse;                                      // 0x01F0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"P2AbilityNavLinkComponent">();
	}
	static class UP2AbilityNavLinkComponent* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UP2AbilityNavLinkComponent>();
	}
};
static_assert(alignof(UP2AbilityNavLinkComponent) == 0x000008, "Wrong alignment on UP2AbilityNavLinkComponent");
static_assert(sizeof(UP2AbilityNavLinkComponent) == 0x0001F8, "Wrong size on UP2AbilityNavLinkComponent");
static_assert(offsetof(UP2AbilityNavLinkComponent, AbilityToUse) == 0x0001F0, "Member 'UP2AbilityNavLinkComponent::AbilityToUse' has a wrong offset!");

// Class AICommon.P2AbilityNavLinkProxy
// 0x0000 (0x0300 - 0x0300)
class AP2AbilityNavLinkProxy final : public ANavLinkProxy
{
public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"P2AbilityNavLinkProxy">();
	}
	static class AP2AbilityNavLinkProxy* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<AP2AbilityNavLinkProxy>();
	}
};
static_assert(alignof(AP2AbilityNavLinkProxy) == 0x000008, "Wrong alignment on AP2AbilityNavLinkProxy");
static_assert(sizeof(AP2AbilityNavLinkProxy) == 0x000300, "Wrong size on AP2AbilityNavLinkProxy");

// Class AICommon.P2AbilityTask_AimCharge
// 0x0010 (0x0090 - 0x0080)
class UP2AbilityTask_AimCharge final : public UAbilityTask
{
public:
	uint8                                         Pad_80[0x10];                                      // 0x0080(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"P2AbilityTask_AimCharge">();
	}
	static class UP2AbilityTask_AimCharge* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UP2AbilityTask_AimCharge>();
	}
};
static_assert(alignof(UP2AbilityTask_AimCharge) == 0x000008, "Wrong alignment on UP2AbilityTask_AimCharge");
static_assert(sizeof(UP2AbilityTask_AimCharge) == 0x000090, "Wrong size on UP2AbilityTask_AimCharge");

// Class AICommon.P2AbilityTask_AnimLayer
// 0x0008 (0x0088 - 0x0080)
class UP2AbilityTask_AnimLayer : public UAbilityTask
{
public:
	TSubclassOf<class UAnimInstance>              AnimLayer;                                         // 0x0080(0x0008)(Net, ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"P2AbilityTask_AnimLayer">();
	}
	static class UP2AbilityTask_AnimLayer* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UP2AbilityTask_AnimLayer>();
	}
};
static_assert(alignof(UP2AbilityTask_AnimLayer) == 0x000008, "Wrong alignment on UP2AbilityTask_AnimLayer");
static_assert(sizeof(UP2AbilityTask_AnimLayer) == 0x000088, "Wrong size on UP2AbilityTask_AnimLayer");
static_assert(offsetof(UP2AbilityTask_AnimLayer, AnimLayer) == 0x000080, "Member 'UP2AbilityTask_AnimLayer::AnimLayer' has a wrong offset!");

// Class AICommon.P2StasisAnimationsData
// 0x0030 (0x0060 - 0x0030)
class UP2StasisAnimationsData final : public UPrimaryDataAsset
{
public:
	class UAnimSequenceBase*                      SleepingSequence;                                  // 0x0030(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequenceBase*                      AwakeningSequence;                                 // 0x0038(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequenceBase*                      LookingAroundSequence;                             // 0x0040(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequenceBase*                      FallingAsleepSequence;                             // 0x0048(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequenceBase*                      ExitingSequence;                                   // 0x0050(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAimOffsetBlendSpace*                   HeadAimOffset;                                     // 0x0058(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"P2StasisAnimationsData">();
	}
	static class UP2StasisAnimationsData* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UP2StasisAnimationsData>();
	}
};
static_assert(alignof(UP2StasisAnimationsData) == 0x000008, "Wrong alignment on UP2StasisAnimationsData");
static_assert(sizeof(UP2StasisAnimationsData) == 0x000060, "Wrong size on UP2StasisAnimationsData");
static_assert(offsetof(UP2StasisAnimationsData, SleepingSequence) == 0x000030, "Member 'UP2StasisAnimationsData::SleepingSequence' has a wrong offset!");
static_assert(offsetof(UP2StasisAnimationsData, AwakeningSequence) == 0x000038, "Member 'UP2StasisAnimationsData::AwakeningSequence' has a wrong offset!");
static_assert(offsetof(UP2StasisAnimationsData, LookingAroundSequence) == 0x000040, "Member 'UP2StasisAnimationsData::LookingAroundSequence' has a wrong offset!");
static_assert(offsetof(UP2StasisAnimationsData, FallingAsleepSequence) == 0x000048, "Member 'UP2StasisAnimationsData::FallingAsleepSequence' has a wrong offset!");
static_assert(offsetof(UP2StasisAnimationsData, ExitingSequence) == 0x000050, "Member 'UP2StasisAnimationsData::ExitingSequence' has a wrong offset!");
static_assert(offsetof(UP2StasisAnimationsData, HeadAimOffset) == 0x000058, "Member 'UP2StasisAnimationsData::HeadAimOffset' has a wrong offset!");

// Class AICommon.P2BTDecorator_Cooldown
// 0x0008 (0x0078 - 0x0070)
class UP2BTDecorator_Cooldown final : public UBTDecorator_Cooldown
{
public:
	float                                         RandomDeviation;                                   // 0x0070(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_74[0x4];                                       // 0x0074(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"P2BTDecorator_Cooldown">();
	}
	static class UP2BTDecorator_Cooldown* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UP2BTDecorator_Cooldown>();
	}
};
static_assert(alignof(UP2BTDecorator_Cooldown) == 0x000008, "Wrong alignment on UP2BTDecorator_Cooldown");
static_assert(sizeof(UP2BTDecorator_Cooldown) == 0x000078, "Wrong size on UP2BTDecorator_Cooldown");
static_assert(offsetof(UP2BTDecorator_Cooldown, RandomDeviation) == 0x000070, "Member 'UP2BTDecorator_Cooldown::RandomDeviation' has a wrong offset!");

// Class AICommon.P2AbilityTask_AnimLayer_Rassler
// 0x0040 (0x00C8 - 0x0088)
class UP2AbilityTask_AnimLayer_Rassler final : public UP2AbilityTask_AnimLayer
{
public:
	float                                         DetectionGaugeValue;                               // 0x0088(0x0004)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LookAroundMontageTime;                             // 0x008C(0x0004)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ExitMontageTime;                                   // 0x0090(0x0004)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EP2RasslerStasisState                         State;                                             // 0x0094(0x0001)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_95[0x3];                                       // 0x0095(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class UP2StasisAnimationsData*                AnimationSet;                                      // 0x0098(0x0008)(Net, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LookAtYaw;                                         // 0x00A0(0x0004)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LookAtPitch;                                       // 0x00A4(0x0004)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A8[0x20];                                      // 0x00A8(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"P2AbilityTask_AnimLayer_Rassler">();
	}
	static class UP2AbilityTask_AnimLayer_Rassler* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UP2AbilityTask_AnimLayer_Rassler>();
	}
};
static_assert(alignof(UP2AbilityTask_AnimLayer_Rassler) == 0x000008, "Wrong alignment on UP2AbilityTask_AnimLayer_Rassler");
static_assert(sizeof(UP2AbilityTask_AnimLayer_Rassler) == 0x0000C8, "Wrong size on UP2AbilityTask_AnimLayer_Rassler");
static_assert(offsetof(UP2AbilityTask_AnimLayer_Rassler, DetectionGaugeValue) == 0x000088, "Member 'UP2AbilityTask_AnimLayer_Rassler::DetectionGaugeValue' has a wrong offset!");
static_assert(offsetof(UP2AbilityTask_AnimLayer_Rassler, LookAroundMontageTime) == 0x00008C, "Member 'UP2AbilityTask_AnimLayer_Rassler::LookAroundMontageTime' has a wrong offset!");
static_assert(offsetof(UP2AbilityTask_AnimLayer_Rassler, ExitMontageTime) == 0x000090, "Member 'UP2AbilityTask_AnimLayer_Rassler::ExitMontageTime' has a wrong offset!");
static_assert(offsetof(UP2AbilityTask_AnimLayer_Rassler, State) == 0x000094, "Member 'UP2AbilityTask_AnimLayer_Rassler::State' has a wrong offset!");
static_assert(offsetof(UP2AbilityTask_AnimLayer_Rassler, AnimationSet) == 0x000098, "Member 'UP2AbilityTask_AnimLayer_Rassler::AnimationSet' has a wrong offset!");
static_assert(offsetof(UP2AbilityTask_AnimLayer_Rassler, LookAtYaw) == 0x0000A0, "Member 'UP2AbilityTask_AnimLayer_Rassler::LookAtYaw' has a wrong offset!");
static_assert(offsetof(UP2AbilityTask_AnimLayer_Rassler, LookAtPitch) == 0x0000A4, "Member 'UP2AbilityTask_AnimLayer_Rassler::LookAtPitch' has a wrong offset!");

// Class AICommon.P2AbilityTask_AnimLayer_Wildcat
// 0x0008 (0x0090 - 0x0088)
class UP2AbilityTask_AnimLayer_Wildcat final : public UP2AbilityTask_AnimLayer
{
public:
	EP2WildCatTreeState                           State;                                             // 0x0088(0x0001)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_89[0x7];                                       // 0x0089(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"P2AbilityTask_AnimLayer_Wildcat">();
	}
	static class UP2AbilityTask_AnimLayer_Wildcat* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UP2AbilityTask_AnimLayer_Wildcat>();
	}
};
static_assert(alignof(UP2AbilityTask_AnimLayer_Wildcat) == 0x000008, "Wrong alignment on UP2AbilityTask_AnimLayer_Wildcat");
static_assert(sizeof(UP2AbilityTask_AnimLayer_Wildcat) == 0x000090, "Wrong size on UP2AbilityTask_AnimLayer_Wildcat");
static_assert(offsetof(UP2AbilityTask_AnimLayer_Wildcat, State) == 0x000088, "Member 'UP2AbilityTask_AnimLayer_Wildcat::State' has a wrong offset!");

// Class AICommon.P2BTDecorator_CanActivateAbilityBase
// 0x0010 (0x00A0 - 0x0090)
class UP2BTDecorator_CanActivateAbilityBase : public UBTDecorator_BlackboardBase
{
public:
	bool                                          bUseTickInterval;                                  // 0x0090(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_91[0x3];                                       // 0x0091(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         TickInterval;                                      // 0x0094(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUseTargetData;                                    // 0x0098(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_99[0x7];                                       // 0x0099(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"P2BTDecorator_CanActivateAbilityBase">();
	}
	static class UP2BTDecorator_CanActivateAbilityBase* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UP2BTDecorator_CanActivateAbilityBase>();
	}
};
static_assert(alignof(UP2BTDecorator_CanActivateAbilityBase) == 0x000008, "Wrong alignment on UP2BTDecorator_CanActivateAbilityBase");
static_assert(sizeof(UP2BTDecorator_CanActivateAbilityBase) == 0x0000A0, "Wrong size on UP2BTDecorator_CanActivateAbilityBase");
static_assert(offsetof(UP2BTDecorator_CanActivateAbilityBase, bUseTickInterval) == 0x000090, "Member 'UP2BTDecorator_CanActivateAbilityBase::bUseTickInterval' has a wrong offset!");
static_assert(offsetof(UP2BTDecorator_CanActivateAbilityBase, TickInterval) == 0x000094, "Member 'UP2BTDecorator_CanActivateAbilityBase::TickInterval' has a wrong offset!");
static_assert(offsetof(UP2BTDecorator_CanActivateAbilityBase, bUseTargetData) == 0x000098, "Member 'UP2BTDecorator_CanActivateAbilityBase::bUseTargetData' has a wrong offset!");

// Class AICommon.P2BTDecorator_CanActivateAbilityByTag
// 0x0020 (0x00C0 - 0x00A0)
class UP2BTDecorator_CanActivateAbilityByTag final : public UP2BTDecorator_CanActivateAbilityBase
{
public:
	struct FGameplayTagContainer                  AbilityTag;                                        // 0x00A0(0x0020)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"P2BTDecorator_CanActivateAbilityByTag">();
	}
	static class UP2BTDecorator_CanActivateAbilityByTag* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UP2BTDecorator_CanActivateAbilityByTag>();
	}
};
static_assert(alignof(UP2BTDecorator_CanActivateAbilityByTag) == 0x000008, "Wrong alignment on UP2BTDecorator_CanActivateAbilityByTag");
static_assert(sizeof(UP2BTDecorator_CanActivateAbilityByTag) == 0x0000C0, "Wrong size on UP2BTDecorator_CanActivateAbilityByTag");
static_assert(offsetof(UP2BTDecorator_CanActivateAbilityByTag, AbilityTag) == 0x0000A0, "Member 'UP2BTDecorator_CanActivateAbilityByTag::AbilityTag' has a wrong offset!");

// Class AICommon.P2AbilityTask_ApplyRootMotionSourceAnimation
// 0x0018 (0x00E0 - 0x00C8)
class UP2AbilityTask_ApplyRootMotionSourceAnimation final : public UAbilityTask_ApplyRootMotion_Base
{
public:
	TMulticastInlineDelegate<void()>              OnFinished;                                        // 0x00C8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	class UAnimSequence*                          Sequence;                                          // 0x00D8(0x0008)(Net, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UP2AbilityTask_ApplyRootMotionSourceAnimation* ApplyP2RootMotionSourceAnimation(class UGameplayAbility* OwningAbility, class FName TaskInstanceName, class UAnimSequence* AnimSequence)	 // 0x472a644;

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"P2AbilityTask_ApplyRootMotionSourceAnimation">();
	}
	static class UP2AbilityTask_ApplyRootMotionSourceAnimation* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UP2AbilityTask_ApplyRootMotionSourceAnimation>();
	}
};
static_assert(alignof(UP2AbilityTask_ApplyRootMotionSourceAnimation) == 0x000008, "Wrong alignment on UP2AbilityTask_ApplyRootMotionSourceAnimation");
static_assert(sizeof(UP2AbilityTask_ApplyRootMotionSourceAnimation) == 0x0000E0, "Wrong size on UP2AbilityTask_ApplyRootMotionSourceAnimation");
static_assert(offsetof(UP2AbilityTask_ApplyRootMotionSourceAnimation, OnFinished) == 0x0000C8, "Member 'UP2AbilityTask_ApplyRootMotionSourceAnimation::OnFinished' has a wrong offset!");
static_assert(offsetof(UP2AbilityTask_ApplyRootMotionSourceAnimation, Sequence) == 0x0000D8, "Member 'UP2AbilityTask_ApplyRootMotionSourceAnimation::Sequence' has a wrong offset!");

// Class AICommon.P2AbilityTask_ApplyRootMotionSourceJump
// 0x0060 (0x0128 - 0x00C8)
class UP2AbilityTask_ApplyRootMotionSourceJump final : public UAbilityTask_ApplyRootMotion_Base
{
public:
	TMulticastInlineDelegate<void()>              OnPassApex;                                        // 0x00C8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void()>              OnLanded;                                          // 0x00D8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void()>              OnJumpBlocked;                                     // 0x00E8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	float                                         Gravity;                                           // 0x00F8(0x0004)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_FC[0x4];                                       // 0x00FC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                InitialVelocity;                                   // 0x0100(0x0018)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FTimerHandle                           TimerHandle;                                       // 0x0118(0x0008)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bLanded;                                           // 0x0120(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bJumpBlocked;                                      // 0x0121(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	ECollisionResponse                            PrevCollisionResponse;                             // 0x0122(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_123[0x5];                                      // 0x0123(0x0005)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UP2AbilityTask_ApplyRootMotionSourceJump* ApplyP2RootMotionJumpForce(class UGameplayAbility* OwningAbility, class FName TaskInstanceNam, float Gravity_0, const struct FVector& InitialVelocity_0)	 // 0x472a400;

	void HandleCharacterLanded(const struct FHitResult& Hit)	 // 0x472ae68;
	void HandleCharacterMoveBlocked(const struct FHitResult& Hit)	 // 0x472aef4;

	void HandlePassApex() const	 // 0x472af80;

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"P2AbilityTask_ApplyRootMotionSourceJump">();
	}
	static class UP2AbilityTask_ApplyRootMotionSourceJump* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UP2AbilityTask_ApplyRootMotionSourceJump>();
	}
};
static_assert(alignof(UP2AbilityTask_ApplyRootMotionSourceJump) == 0x000008, "Wrong alignment on UP2AbilityTask_ApplyRootMotionSourceJump");
static_assert(sizeof(UP2AbilityTask_ApplyRootMotionSourceJump) == 0x000128, "Wrong size on UP2AbilityTask_ApplyRootMotionSourceJump");
static_assert(offsetof(UP2AbilityTask_ApplyRootMotionSourceJump, OnPassApex) == 0x0000C8, "Member 'UP2AbilityTask_ApplyRootMotionSourceJump::OnPassApex' has a wrong offset!");
static_assert(offsetof(UP2AbilityTask_ApplyRootMotionSourceJump, OnLanded) == 0x0000D8, "Member 'UP2AbilityTask_ApplyRootMotionSourceJump::OnLanded' has a wrong offset!");
static_assert(offsetof(UP2AbilityTask_ApplyRootMotionSourceJump, OnJumpBlocked) == 0x0000E8, "Member 'UP2AbilityTask_ApplyRootMotionSourceJump::OnJumpBlocked' has a wrong offset!");
static_assert(offsetof(UP2AbilityTask_ApplyRootMotionSourceJump, Gravity) == 0x0000F8, "Member 'UP2AbilityTask_ApplyRootMotionSourceJump::Gravity' has a wrong offset!");
static_assert(offsetof(UP2AbilityTask_ApplyRootMotionSourceJump, InitialVelocity) == 0x000100, "Member 'UP2AbilityTask_ApplyRootMotionSourceJump::InitialVelocity' has a wrong offset!");
static_assert(offsetof(UP2AbilityTask_ApplyRootMotionSourceJump, TimerHandle) == 0x000118, "Member 'UP2AbilityTask_ApplyRootMotionSourceJump::TimerHandle' has a wrong offset!");
static_assert(offsetof(UP2AbilityTask_ApplyRootMotionSourceJump, bLanded) == 0x000120, "Member 'UP2AbilityTask_ApplyRootMotionSourceJump::bLanded' has a wrong offset!");
static_assert(offsetof(UP2AbilityTask_ApplyRootMotionSourceJump, bJumpBlocked) == 0x000121, "Member 'UP2AbilityTask_ApplyRootMotionSourceJump::bJumpBlocked' has a wrong offset!");
static_assert(offsetof(UP2AbilityTask_ApplyRootMotionSourceJump, PrevCollisionResponse) == 0x000122, "Member 'UP2AbilityTask_ApplyRootMotionSourceJump::PrevCollisionResponse' has a wrong offset!");

// Class AICommon.P2BTDecorator_AlertedLevel
// 0x0008 (0x0070 - 0x0068)
class UP2BTDecorator_AlertedLevel final : public UBTDecorator
{
public:
	EP2PerceptionAlertedLevelType                 AlertedLevel;                                      // 0x0068(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_69[0x7];                                       // 0x0069(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"P2BTDecorator_AlertedLevel">();
	}
	static class UP2BTDecorator_AlertedLevel* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UP2BTDecorator_AlertedLevel>();
	}
};
static_assert(alignof(UP2BTDecorator_AlertedLevel) == 0x000008, "Wrong alignment on UP2BTDecorator_AlertedLevel");
static_assert(sizeof(UP2BTDecorator_AlertedLevel) == 0x000070, "Wrong size on UP2BTDecorator_AlertedLevel");
static_assert(offsetof(UP2BTDecorator_AlertedLevel, AlertedLevel) == 0x000068, "Member 'UP2BTDecorator_AlertedLevel::AlertedLevel' has a wrong offset!");

// Class AICommon.P2AbilityTask_ApplyRootMotionSourceMontage
// 0x0030 (0x00F8 - 0x00C8)
class UP2AbilityTask_ApplyRootMotionSourceMontage final : public UAbilityTask_ApplyRootMotion_Base
{
public:
	TMulticastInlineDelegate<void()>              OnFinished;                                        // 0x00C8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	class UAnimMontage*                           Montage;                                           // 0x00D8(0x0008)(Net, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         PlayRate;                                          // 0x00E0(0x0004)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FName                                   StartSectionName;                                  // 0x00E4(0x0008)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_EC[0xC];                                       // 0x00EC(0x000C)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UP2AbilityTask_ApplyRootMotionSourceMontage* ApplyP2RootMotionSourceMontage(class UGameplayAbility* OwningAbility, class FName TaskInstanceName, class UAnimMontage* AnimMontage, float PlayRate_0, class FName StartSectionName_0)	 // 0x472a884;

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"P2AbilityTask_ApplyRootMotionSourceMontage">();
	}
	static class UP2AbilityTask_ApplyRootMotionSourceMontage* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UP2AbilityTask_ApplyRootMotionSourceMontage>();
	}
};
static_assert(alignof(UP2AbilityTask_ApplyRootMotionSourceMontage) == 0x000008, "Wrong alignment on UP2AbilityTask_ApplyRootMotionSourceMontage");
static_assert(sizeof(UP2AbilityTask_ApplyRootMotionSourceMontage) == 0x0000F8, "Wrong size on UP2AbilityTask_ApplyRootMotionSourceMontage");
static_assert(offsetof(UP2AbilityTask_ApplyRootMotionSourceMontage, OnFinished) == 0x0000C8, "Member 'UP2AbilityTask_ApplyRootMotionSourceMontage::OnFinished' has a wrong offset!");
static_assert(offsetof(UP2AbilityTask_ApplyRootMotionSourceMontage, Montage) == 0x0000D8, "Member 'UP2AbilityTask_ApplyRootMotionSourceMontage::Montage' has a wrong offset!");
static_assert(offsetof(UP2AbilityTask_ApplyRootMotionSourceMontage, PlayRate) == 0x0000E0, "Member 'UP2AbilityTask_ApplyRootMotionSourceMontage::PlayRate' has a wrong offset!");
static_assert(offsetof(UP2AbilityTask_ApplyRootMotionSourceMontage, StartSectionName) == 0x0000E4, "Member 'UP2AbilityTask_ApplyRootMotionSourceMontage::StartSectionName' has a wrong offset!");

// Class AICommon.P2AbilityTask_ApplyStatusInRange
// 0x0028 (0x00A8 - 0x0080)
class UP2AbilityTask_ApplyStatusInRange final : public UAbilityTask
{
public:
	uint8                                         Pad_80[0x8];                                       // 0x0080(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<TWeakObjectPtr<class AP2HeroCharacter>> AffectedTargets;                                  // 0x0088(0x0010)(ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPrivate)
	class UP2TriggerZoneComponent*                TriggerZoneComponent;                              // 0x0098(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_A0[0x8];                                       // 0x00A0(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"P2AbilityTask_ApplyStatusInRange">();
	}
	static class UP2AbilityTask_ApplyStatusInRange* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UP2AbilityTask_ApplyStatusInRange>();
	}
};
static_assert(alignof(UP2AbilityTask_ApplyStatusInRange) == 0x000008, "Wrong alignment on UP2AbilityTask_ApplyStatusInRange");
static_assert(sizeof(UP2AbilityTask_ApplyStatusInRange) == 0x0000A8, "Wrong size on UP2AbilityTask_ApplyStatusInRange");
static_assert(offsetof(UP2AbilityTask_ApplyStatusInRange, AffectedTargets) == 0x000088, "Member 'UP2AbilityTask_ApplyStatusInRange::AffectedTargets' has a wrong offset!");
static_assert(offsetof(UP2AbilityTask_ApplyStatusInRange, TriggerZoneComponent) == 0x000098, "Member 'UP2AbilityTask_ApplyStatusInRange::TriggerZoneComponent' has a wrong offset!");

// Class AICommon.P2BTDecorator_ObserverBase
// 0x0008 (0x0070 - 0x0068)
class UP2BTDecorator_ObserverBase : public UBTDecorator
{
public:
	float                                         TickInterval;                                      // 0x0068(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_6C[0x4];                                       // 0x006C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"P2BTDecorator_ObserverBase">();
	}
	static class UP2BTDecorator_ObserverBase* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UP2BTDecorator_ObserverBase>();
	}
};
static_assert(alignof(UP2BTDecorator_ObserverBase) == 0x000008, "Wrong alignment on UP2BTDecorator_ObserverBase");
static_assert(sizeof(UP2BTDecorator_ObserverBase) == 0x000070, "Wrong size on UP2BTDecorator_ObserverBase");
static_assert(offsetof(UP2BTDecorator_ObserverBase, TickInterval) == 0x000068, "Member 'UP2BTDecorator_ObserverBase::TickInterval' has a wrong offset!");

// Class AICommon.P2BTDecorator_CheckPerceptionData
// 0x0030 (0x00A0 - 0x0070)
class UP2BTDecorator_CheckPerceptionData final : public UP2BTDecorator_ObserverBase
{
public:
	struct FGameplayTagContainer                  StimulusTags;                                      // 0x0070(0x0020)(Edit, NativeAccessSpecifierPublic)
	bool                                          bUseCustomAgeFilter;                               // 0x0090(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_91[0x3];                                       // 0x0091(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         CustomMaxAge;                                      // 0x0094(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxDistance;                                       // 0x0098(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCheckTargetOnly;                                  // 0x009C(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bHostileOnly;                                      // 0x009D(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9E[0x2];                                       // 0x009E(0x0002)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"P2BTDecorator_CheckPerceptionData">();
	}
	static class UP2BTDecorator_CheckPerceptionData* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UP2BTDecorator_CheckPerceptionData>();
	}
};
static_assert(alignof(UP2BTDecorator_CheckPerceptionData) == 0x000008, "Wrong alignment on UP2BTDecorator_CheckPerceptionData");
static_assert(sizeof(UP2BTDecorator_CheckPerceptionData) == 0x0000A0, "Wrong size on UP2BTDecorator_CheckPerceptionData");
static_assert(offsetof(UP2BTDecorator_CheckPerceptionData, StimulusTags) == 0x000070, "Member 'UP2BTDecorator_CheckPerceptionData::StimulusTags' has a wrong offset!");
static_assert(offsetof(UP2BTDecorator_CheckPerceptionData, bUseCustomAgeFilter) == 0x000090, "Member 'UP2BTDecorator_CheckPerceptionData::bUseCustomAgeFilter' has a wrong offset!");
static_assert(offsetof(UP2BTDecorator_CheckPerceptionData, CustomMaxAge) == 0x000094, "Member 'UP2BTDecorator_CheckPerceptionData::CustomMaxAge' has a wrong offset!");
static_assert(offsetof(UP2BTDecorator_CheckPerceptionData, MaxDistance) == 0x000098, "Member 'UP2BTDecorator_CheckPerceptionData::MaxDistance' has a wrong offset!");
static_assert(offsetof(UP2BTDecorator_CheckPerceptionData, bCheckTargetOnly) == 0x00009C, "Member 'UP2BTDecorator_CheckPerceptionData::bCheckTargetOnly' has a wrong offset!");
static_assert(offsetof(UP2BTDecorator_CheckPerceptionData, bHostileOnly) == 0x00009D, "Member 'UP2BTDecorator_CheckPerceptionData::bHostileOnly' has a wrong offset!");

// Class AICommon.P2AbilityTask_Charge
// 0x0100 (0x0180 - 0x0080)
class UP2AbilityTask_Charge final : public UAbilityTask
{
public:
	uint8                                         Pad_80[0xF8];                                      // 0x0080(0x00F8)(Fixing Size After Last Property [ Dumper-7 ])
	class UMercunaSmoothPath*                     Path;                                              // 0x0178(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void OnPathUpdated(EMercunaPathEvent PathEvent)	 // 0x472af94;

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"P2AbilityTask_Charge">();
	}
	static class UP2AbilityTask_Charge* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UP2AbilityTask_Charge>();
	}
};
static_assert(alignof(UP2AbilityTask_Charge) == 0x000008, "Wrong alignment on UP2AbilityTask_Charge");
static_assert(sizeof(UP2AbilityTask_Charge) == 0x000180, "Wrong size on UP2AbilityTask_Charge");
static_assert(offsetof(UP2AbilityTask_Charge, Path) == 0x000178, "Member 'UP2AbilityTask_Charge::Path' has a wrong offset!");

// Class AICommon.P2AbilityTask_CheckGameplayTags
// 0x0030 (0x00B0 - 0x0080)
class UP2AbilityTask_CheckGameplayTags final : public UAbilityTask
{
public:
	uint8                                         Pad_80[0x10];                                      // 0x0080(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTagContainer                  RequiredTags;                                      // 0x0090(0x0020)(NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"P2AbilityTask_CheckGameplayTags">();
	}
	static class UP2AbilityTask_CheckGameplayTags* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UP2AbilityTask_CheckGameplayTags>();
	}
};
static_assert(alignof(UP2AbilityTask_CheckGameplayTags) == 0x000008, "Wrong alignment on UP2AbilityTask_CheckGameplayTags");
static_assert(sizeof(UP2AbilityTask_CheckGameplayTags) == 0x0000B0, "Wrong size on UP2AbilityTask_CheckGameplayTags");
static_assert(offsetof(UP2AbilityTask_CheckGameplayTags, RequiredTags) == 0x000090, "Member 'UP2AbilityTask_CheckGameplayTags::RequiredTags' has a wrong offset!");

// Class AICommon.P2BTDecorator_HealthComparison
// 0x0010 (0x00A0 - 0x0090)
class UP2BTDecorator_HealthComparison final : public UBTDecorator_BlackboardBase
{
public:
	bool                                          bHealthThresholdAsPercentage;                      // 0x0090(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_91[0x3];                                       // 0x0091(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         HealthTreshold;                                    // 0x0094(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EComparisonType                               Comparison;                                        // 0x0098(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9C[0x4];                                       // 0x009C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"P2BTDecorator_HealthComparison">();
	}
	static class UP2BTDecorator_HealthComparison* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UP2BTDecorator_HealthComparison>();
	}
};
static_assert(alignof(UP2BTDecorator_HealthComparison) == 0x000008, "Wrong alignment on UP2BTDecorator_HealthComparison");
static_assert(sizeof(UP2BTDecorator_HealthComparison) == 0x0000A0, "Wrong size on UP2BTDecorator_HealthComparison");
static_assert(offsetof(UP2BTDecorator_HealthComparison, bHealthThresholdAsPercentage) == 0x000090, "Member 'UP2BTDecorator_HealthComparison::bHealthThresholdAsPercentage' has a wrong offset!");
static_assert(offsetof(UP2BTDecorator_HealthComparison, HealthTreshold) == 0x000094, "Member 'UP2BTDecorator_HealthComparison::HealthTreshold' has a wrong offset!");
static_assert(offsetof(UP2BTDecorator_HealthComparison, Comparison) == 0x000098, "Member 'UP2BTDecorator_HealthComparison::Comparison' has a wrong offset!");

// Class AICommon.P2AbilityTask_DetectionGauge
// 0x0060 (0x00E0 - 0x0080)
class UP2AbilityTask_DetectionGauge final : public UAbilityTask
{
public:
	uint8                                         Pad_80[0x20];                                      // 0x0080(0x0020)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         IncreaseDetectionSpeed;                            // 0x00A0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         DecreaseDetectionSpeed;                            // 0x00A4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         DecreaseDetectionDelay;                            // 0x00A8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_AC[0x4];                                       // 0x00AC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FStimuliImpactTime>             StimulusTagsToListen;                              // 0x00B0(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_C0[0x20];                                      // 0x00C0(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"P2AbilityTask_DetectionGauge">();
	}
	static class UP2AbilityTask_DetectionGauge* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UP2AbilityTask_DetectionGauge>();
	}
};
static_assert(alignof(UP2AbilityTask_DetectionGauge) == 0x000008, "Wrong alignment on UP2AbilityTask_DetectionGauge");
static_assert(sizeof(UP2AbilityTask_DetectionGauge) == 0x0000E0, "Wrong size on UP2AbilityTask_DetectionGauge");
static_assert(offsetof(UP2AbilityTask_DetectionGauge, IncreaseDetectionSpeed) == 0x0000A0, "Member 'UP2AbilityTask_DetectionGauge::IncreaseDetectionSpeed' has a wrong offset!");
static_assert(offsetof(UP2AbilityTask_DetectionGauge, DecreaseDetectionSpeed) == 0x0000A4, "Member 'UP2AbilityTask_DetectionGauge::DecreaseDetectionSpeed' has a wrong offset!");
static_assert(offsetof(UP2AbilityTask_DetectionGauge, DecreaseDetectionDelay) == 0x0000A8, "Member 'UP2AbilityTask_DetectionGauge::DecreaseDetectionDelay' has a wrong offset!");
static_assert(offsetof(UP2AbilityTask_DetectionGauge, StimulusTagsToListen) == 0x0000B0, "Member 'UP2AbilityTask_DetectionGauge::StimulusTagsToListen' has a wrong offset!");

// Class AICommon.P2AbilityTask_MinDistance
// 0x0038 (0x00B8 - 0x0080)
class UP2AbilityTask_MinDistance final : public UAbilityTask
{
public:
	struct FP2MinDistanceTaskConfig               Config;                                            // 0x0080(0x0008)(Net, Transient, NoDestructor, NativeAccessSpecifierPrivate)
	class AActor*                                 TargetActor;                                       // 0x0088(0x0008)(Net, ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class AP2BaseCharacter*                       MyPawn;                                            // 0x0090(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_98[0x20];                                      // 0x0098(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"P2AbilityTask_MinDistance">();
	}
	static class UP2AbilityTask_MinDistance* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UP2AbilityTask_MinDistance>();
	}
};
static_assert(alignof(UP2AbilityTask_MinDistance) == 0x000008, "Wrong alignment on UP2AbilityTask_MinDistance");
static_assert(sizeof(UP2AbilityTask_MinDistance) == 0x0000B8, "Wrong size on UP2AbilityTask_MinDistance");
static_assert(offsetof(UP2AbilityTask_MinDistance, Config) == 0x000080, "Member 'UP2AbilityTask_MinDistance::Config' has a wrong offset!");
static_assert(offsetof(UP2AbilityTask_MinDistance, TargetActor) == 0x000088, "Member 'UP2AbilityTask_MinDistance::TargetActor' has a wrong offset!");
static_assert(offsetof(UP2AbilityTask_MinDistance, MyPawn) == 0x000090, "Member 'UP2AbilityTask_MinDistance::MyPawn' has a wrong offset!");

// Class AICommon.P2BTDecorator_DamageToZone
// 0x0028 (0x0098 - 0x0070)
class UP2BTDecorator_DamageToZone final : public UP2BTDecorator_ObserverBase
{
public:
	struct FGameplayTagContainer                  DamageZoneTags;                                    // 0x0070(0x0020)(Edit, NativeAccessSpecifierPublic)
	float                                         DamageThreshold;                                   // 0x0090(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TimeToConsider;                                    // 0x0094(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"P2BTDecorator_DamageToZone">();
	}
	static class UP2BTDecorator_DamageToZone* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UP2BTDecorator_DamageToZone>();
	}
};
static_assert(alignof(UP2BTDecorator_DamageToZone) == 0x000008, "Wrong alignment on UP2BTDecorator_DamageToZone");
static_assert(sizeof(UP2BTDecorator_DamageToZone) == 0x000098, "Wrong size on UP2BTDecorator_DamageToZone");
static_assert(offsetof(UP2BTDecorator_DamageToZone, DamageZoneTags) == 0x000070, "Member 'UP2BTDecorator_DamageToZone::DamageZoneTags' has a wrong offset!");
static_assert(offsetof(UP2BTDecorator_DamageToZone, DamageThreshold) == 0x000090, "Member 'UP2BTDecorator_DamageToZone::DamageThreshold' has a wrong offset!");
static_assert(offsetof(UP2BTDecorator_DamageToZone, TimeToConsider) == 0x000094, "Member 'UP2BTDecorator_DamageToZone::TimeToConsider' has a wrong offset!");

// Class AICommon.P2AbilityTask_MoveAlongTransformCurve
// 0x00C0 (0x0140 - 0x0080)
class UP2AbilityTask_MoveAlongTransformCurve final : public UAbilityTask
{
public:
	uint8                                         Pad_80[0x18];                                      // 0x0080(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	class UP2TransformCurve*                      TransformCurve;                                    // 0x0098(0x0008)(Net, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FTransform                             Transform;                                         // 0x00A0(0x0060)(Net, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         BlendInTime;                                       // 0x0100(0x0004)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         BlendOutTime;                                      // 0x0104(0x0004)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         Duration;                                          // 0x0108(0x0004)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_10C[0x4];                                      // 0x010C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                EndTarget;                                         // 0x0110(0x0018)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         CurrentTime;                                       // 0x0128(0x0004)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_12C[0x14];                                     // 0x012C(0x0014)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"P2AbilityTask_MoveAlongTransformCurve">();
	}
	static class UP2AbilityTask_MoveAlongTransformCurve* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UP2AbilityTask_MoveAlongTransformCurve>();
	}
};
static_assert(alignof(UP2AbilityTask_MoveAlongTransformCurve) == 0x000010, "Wrong alignment on UP2AbilityTask_MoveAlongTransformCurve");
static_assert(sizeof(UP2AbilityTask_MoveAlongTransformCurve) == 0x000140, "Wrong size on UP2AbilityTask_MoveAlongTransformCurve");
static_assert(offsetof(UP2AbilityTask_MoveAlongTransformCurve, TransformCurve) == 0x000098, "Member 'UP2AbilityTask_MoveAlongTransformCurve::TransformCurve' has a wrong offset!");
static_assert(offsetof(UP2AbilityTask_MoveAlongTransformCurve, Transform) == 0x0000A0, "Member 'UP2AbilityTask_MoveAlongTransformCurve::Transform' has a wrong offset!");
static_assert(offsetof(UP2AbilityTask_MoveAlongTransformCurve, BlendInTime) == 0x000100, "Member 'UP2AbilityTask_MoveAlongTransformCurve::BlendInTime' has a wrong offset!");
static_assert(offsetof(UP2AbilityTask_MoveAlongTransformCurve, BlendOutTime) == 0x000104, "Member 'UP2AbilityTask_MoveAlongTransformCurve::BlendOutTime' has a wrong offset!");
static_assert(offsetof(UP2AbilityTask_MoveAlongTransformCurve, Duration) == 0x000108, "Member 'UP2AbilityTask_MoveAlongTransformCurve::Duration' has a wrong offset!");
static_assert(offsetof(UP2AbilityTask_MoveAlongTransformCurve, EndTarget) == 0x000110, "Member 'UP2AbilityTask_MoveAlongTransformCurve::EndTarget' has a wrong offset!");
static_assert(offsetof(UP2AbilityTask_MoveAlongTransformCurve, CurrentTime) == 0x000128, "Member 'UP2AbilityTask_MoveAlongTransformCurve::CurrentTime' has a wrong offset!");

// Class AICommon.P2AbilityTask_MovementModeOverride
// 0x0040 (0x00C0 - 0x0080)
class UP2AbilityTask_MovementModeOverride final : public UAbilityTask
{
public:
	struct FMovementModeOverride                  Override;                                          // 0x0080(0x0038)(Net, NativeAccessSpecifierPrivate)
	uint8                                         Pad_B8[0x8];                                       // 0x00B8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"P2AbilityTask_MovementModeOverride">();
	}
	static class UP2AbilityTask_MovementModeOverride* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UP2AbilityTask_MovementModeOverride>();
	}
};
static_assert(alignof(UP2AbilityTask_MovementModeOverride) == 0x000008, "Wrong alignment on UP2AbilityTask_MovementModeOverride");
static_assert(sizeof(UP2AbilityTask_MovementModeOverride) == 0x0000C0, "Wrong size on UP2AbilityTask_MovementModeOverride");
static_assert(offsetof(UP2AbilityTask_MovementModeOverride, Override) == 0x000080, "Member 'UP2AbilityTask_MovementModeOverride::Override' has a wrong offset!");

// Class AICommon.P2BTDecorator_CheckCoverState
// 0x0030 (0x0098 - 0x0068)
class UP2BTDecorator_CheckCoverState final : public UBTDecorator
{
public:
	struct FBlackboardKeySelector                 BBCoverPoint;                                      // 0x0068(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)
	EP2AICoverState                               WantedCoverState;                                  // 0x0090(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_91[0x3];                                       // 0x0091(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         TickInterval;                                      // 0x0094(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"P2BTDecorator_CheckCoverState">();
	}
	static class UP2BTDecorator_CheckCoverState* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UP2BTDecorator_CheckCoverState>();
	}
};
static_assert(alignof(UP2BTDecorator_CheckCoverState) == 0x000008, "Wrong alignment on UP2BTDecorator_CheckCoverState");
static_assert(sizeof(UP2BTDecorator_CheckCoverState) == 0x000098, "Wrong size on UP2BTDecorator_CheckCoverState");
static_assert(offsetof(UP2BTDecorator_CheckCoverState, BBCoverPoint) == 0x000068, "Member 'UP2BTDecorator_CheckCoverState::BBCoverPoint' has a wrong offset!");
static_assert(offsetof(UP2BTDecorator_CheckCoverState, WantedCoverState) == 0x000090, "Member 'UP2BTDecorator_CheckCoverState::WantedCoverState' has a wrong offset!");
static_assert(offsetof(UP2BTDecorator_CheckCoverState, TickInterval) == 0x000094, "Member 'UP2BTDecorator_CheckCoverState::TickInterval' has a wrong offset!");

// Class AICommon.P2AbilityTask_PlayMontageAndWait
// 0x0010 (0x0118 - 0x0108)
class UP2AbilityTask_PlayMontageAndWait final : public UAbilityTask_PlayMontageAndWait
{
public:
	uint8                                         Pad_108[0x10];                                     // 0x0108(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"P2AbilityTask_PlayMontageAndWait">();
	}
	static class UP2AbilityTask_PlayMontageAndWait* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UP2AbilityTask_PlayMontageAndWait>();
	}
};
static_assert(alignof(UP2AbilityTask_PlayMontageAndWait) == 0x000008, "Wrong alignment on UP2AbilityTask_PlayMontageAndWait");
static_assert(sizeof(UP2AbilityTask_PlayMontageAndWait) == 0x000118, "Wrong size on UP2AbilityTask_PlayMontageAndWait");

// Class AICommon.P2AbilityTask_PulseAttack
// 0x0080 (0x0100 - 0x0080)
class UP2AbilityTask_PulseAttack final : public UAbilityTask
{
public:
	TMulticastInlineDelegate<void()>              OnCompleted;                                       // 0x0080(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_90[0x50];                                      // 0x0090(0x0050)(Fixing Size After Last Property [ Dumper-7 ])
	class UCurveFloat*                            StunSeverityCurve;                                 // 0x00E0(0x0008)(ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_E8[0x8];                                       // 0x00E8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class AActor*>                         AffectedActors;                                    // 0x00F0(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)

public:
	static class UP2AbilityTask_PulseAttack* MakeNew(class UGameplayAbility* OwningAbility, class FName TaskInstanceName, const struct FVector& Location, const struct FVector& Direction, float StartRadius, float EndRadius, float PulseAngle, float PulseDepth, float Speed, const TSubclassOf<class UP2GameplayEffect_Damage> DamageEffect, const class UCurveFloat* StunSeverityCurve_0)	 // 0x472f59c;

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"P2AbilityTask_PulseAttack">();
	}
	static class UP2AbilityTask_PulseAttack* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UP2AbilityTask_PulseAttack>();
	}
};
static_assert(alignof(UP2AbilityTask_PulseAttack) == 0x000008, "Wrong alignment on UP2AbilityTask_PulseAttack");
static_assert(sizeof(UP2AbilityTask_PulseAttack) == 0x000100, "Wrong size on UP2AbilityTask_PulseAttack");
static_assert(offsetof(UP2AbilityTask_PulseAttack, OnCompleted) == 0x000080, "Member 'UP2AbilityTask_PulseAttack::OnCompleted' has a wrong offset!");
static_assert(offsetof(UP2AbilityTask_PulseAttack, StunSeverityCurve) == 0x0000E0, "Member 'UP2AbilityTask_PulseAttack::StunSeverityCurve' has a wrong offset!");
static_assert(offsetof(UP2AbilityTask_PulseAttack, AffectedActors) == 0x0000F0, "Member 'UP2AbilityTask_PulseAttack::AffectedActors' has a wrong offset!");

// Class AICommon.P2AbilityTask_Sentry_Active
// 0x0010 (0x0090 - 0x0080)
class UP2AbilityTask_Sentry_Active final : public UAbilityTask
{
public:
	struct FP2SentryActiveParameters              ActiveParams;                                      // 0x0080(0x0008)(Transient, NoDestructor, NativeAccessSpecifierPrivate)
	struct FTimerHandle                           TimerHandle;                                       // 0x0088(0x0008)(Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void OnTimer()	 // 0x4730600;

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"P2AbilityTask_Sentry_Active">();
	}
	static class UP2AbilityTask_Sentry_Active* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UP2AbilityTask_Sentry_Active>();
	}
};
static_assert(alignof(UP2AbilityTask_Sentry_Active) == 0x000008, "Wrong alignment on UP2AbilityTask_Sentry_Active");
static_assert(sizeof(UP2AbilityTask_Sentry_Active) == 0x000090, "Wrong size on UP2AbilityTask_Sentry_Active");
static_assert(offsetof(UP2AbilityTask_Sentry_Active, ActiveParams) == 0x000080, "Member 'UP2AbilityTask_Sentry_Active::ActiveParams' has a wrong offset!");
static_assert(offsetof(UP2AbilityTask_Sentry_Active, TimerHandle) == 0x000088, "Member 'UP2AbilityTask_Sentry_Active::TimerHandle' has a wrong offset!");

// Class AICommon.P2AbilityTask_SetCollisionResponse
// 0x0008 (0x0088 - 0x0080)
class UP2AbilityTask_SetCollisionResponse final : public UAbilityTask
{
public:
	ECollisionChannel                             Channel;                                           // 0x0080(0x0001)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	ECollisionResponse                            Response;                                          // 0x0081(0x0001)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_82[0x6];                                       // 0x0082(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"P2AbilityTask_SetCollisionResponse">();
	}
	static class UP2AbilityTask_SetCollisionResponse* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UP2AbilityTask_SetCollisionResponse>();
	}
};
static_assert(alignof(UP2AbilityTask_SetCollisionResponse) == 0x000008, "Wrong alignment on UP2AbilityTask_SetCollisionResponse");
static_assert(sizeof(UP2AbilityTask_SetCollisionResponse) == 0x000088, "Wrong size on UP2AbilityTask_SetCollisionResponse");
static_assert(offsetof(UP2AbilityTask_SetCollisionResponse, Channel) == 0x000080, "Member 'UP2AbilityTask_SetCollisionResponse::Channel' has a wrong offset!");
static_assert(offsetof(UP2AbilityTask_SetCollisionResponse, Response) == 0x000081, "Member 'UP2AbilityTask_SetCollisionResponse::Response' has a wrong offset!");

// Class AICommon.P2BTDecorator_IsUsingSmartObjects
// 0x0018 (0x0080 - 0x0068)
class UP2BTDecorator_IsUsingSmartObjects final : public UBTDecorator
{
public:
	TSubclassOf<class UP2SmartObject>             SmartObjectClass;                                  // 0x0068(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_70[0x10];                                      // 0x0070(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"P2BTDecorator_IsUsingSmartObjects">();
	}
	static class UP2BTDecorator_IsUsingSmartObjects* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UP2BTDecorator_IsUsingSmartObjects>();
	}
};
static_assert(alignof(UP2BTDecorator_IsUsingSmartObjects) == 0x000008, "Wrong alignment on UP2BTDecorator_IsUsingSmartObjects");
static_assert(sizeof(UP2BTDecorator_IsUsingSmartObjects) == 0x000080, "Wrong size on UP2BTDecorator_IsUsingSmartObjects");
static_assert(offsetof(UP2BTDecorator_IsUsingSmartObjects, SmartObjectClass) == 0x000068, "Member 'UP2BTDecorator_IsUsingSmartObjects::SmartObjectClass' has a wrong offset!");

// Class AICommon.P2AbilityTask_UseSmartObject
// 0x00B0 (0x0130 - 0x0080)
class UP2AbilityTask_UseSmartObject final : public UAbilityTask
{
public:
	uint8                                         Pad_80[0x18];                                      // 0x0080(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	class UP2TransformCurve*                      TransformCurve;                                    // 0x0098(0x0008)(Net, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FTransform                             Transform;                                         // 0x00A0(0x0060)(Net, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         BlendInTime;                                       // 0x0100(0x0004)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         BlendOutTime;                                      // 0x0104(0x0004)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         Duration;                                          // 0x0108(0x0004)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         CurrentTime;                                       // 0x010C(0x0004)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FVector                                EndTarget;                                         // 0x0110(0x0018)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_128[0x8];                                      // 0x0128(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"P2AbilityTask_UseSmartObject">();
	}
	static class UP2AbilityTask_UseSmartObject* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UP2AbilityTask_UseSmartObject>();
	}
};
static_assert(alignof(UP2AbilityTask_UseSmartObject) == 0x000010, "Wrong alignment on UP2AbilityTask_UseSmartObject");
static_assert(sizeof(UP2AbilityTask_UseSmartObject) == 0x000130, "Wrong size on UP2AbilityTask_UseSmartObject");
static_assert(offsetof(UP2AbilityTask_UseSmartObject, TransformCurve) == 0x000098, "Member 'UP2AbilityTask_UseSmartObject::TransformCurve' has a wrong offset!");
static_assert(offsetof(UP2AbilityTask_UseSmartObject, Transform) == 0x0000A0, "Member 'UP2AbilityTask_UseSmartObject::Transform' has a wrong offset!");
static_assert(offsetof(UP2AbilityTask_UseSmartObject, BlendInTime) == 0x000100, "Member 'UP2AbilityTask_UseSmartObject::BlendInTime' has a wrong offset!");
static_assert(offsetof(UP2AbilityTask_UseSmartObject, BlendOutTime) == 0x000104, "Member 'UP2AbilityTask_UseSmartObject::BlendOutTime' has a wrong offset!");
static_assert(offsetof(UP2AbilityTask_UseSmartObject, Duration) == 0x000108, "Member 'UP2AbilityTask_UseSmartObject::Duration' has a wrong offset!");
static_assert(offsetof(UP2AbilityTask_UseSmartObject, CurrentTime) == 0x00010C, "Member 'UP2AbilityTask_UseSmartObject::CurrentTime' has a wrong offset!");
static_assert(offsetof(UP2AbilityTask_UseSmartObject, EndTarget) == 0x000110, "Member 'UP2AbilityTask_UseSmartObject::EndTarget' has a wrong offset!");

// Class AICommon.P2AbilityTask_WildCatIdleOnTree
// 0x0070 (0x00F0 - 0x0080)
class UP2AbilityTask_WildCatIdleOnTree final : public UAbilityTask
{
public:
	struct FTransform                             TreeTopTransform;                                  // 0x0080(0x0060)(Net, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_E0[0x10];                                      // 0x00E0(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"P2AbilityTask_WildCatIdleOnTree">();
	}
	static class UP2AbilityTask_WildCatIdleOnTree* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UP2AbilityTask_WildCatIdleOnTree>();
	}
};
static_assert(alignof(UP2AbilityTask_WildCatIdleOnTree) == 0x000010, "Wrong alignment on UP2AbilityTask_WildCatIdleOnTree");
static_assert(sizeof(UP2AbilityTask_WildCatIdleOnTree) == 0x0000F0, "Wrong size on UP2AbilityTask_WildCatIdleOnTree");
static_assert(offsetof(UP2AbilityTask_WildCatIdleOnTree, TreeTopTransform) == 0x000080, "Member 'UP2AbilityTask_WildCatIdleOnTree::TreeTopTransform' has a wrong offset!");

// Class AICommon.P2AbilityTask_WildcatJumpFromTree
// 0x0058 (0x00D8 - 0x0080)
class UP2AbilityTask_WildcatJumpFromTree final : public UAbilityTask
{
public:
	uint8                                         Pad_80[0x18];                                      // 0x0080(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                StartLocation;                                     // 0x0098(0x0018)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FVector                                EndLocation;                                       // 0x00B0(0x0018)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         Duration;                                          // 0x00C8(0x0004)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         Delay;                                             // 0x00CC(0x0004)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         CurrentTime;                                       // 0x00D0(0x0004)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_D4[0x4];                                       // 0x00D4(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"P2AbilityTask_WildcatJumpFromTree">();
	}
	static class UP2AbilityTask_WildcatJumpFromTree* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UP2AbilityTask_WildcatJumpFromTree>();
	}
};
static_assert(alignof(UP2AbilityTask_WildcatJumpFromTree) == 0x000008, "Wrong alignment on UP2AbilityTask_WildcatJumpFromTree");
static_assert(sizeof(UP2AbilityTask_WildcatJumpFromTree) == 0x0000D8, "Wrong size on UP2AbilityTask_WildcatJumpFromTree");
static_assert(offsetof(UP2AbilityTask_WildcatJumpFromTree, StartLocation) == 0x000098, "Member 'UP2AbilityTask_WildcatJumpFromTree::StartLocation' has a wrong offset!");
static_assert(offsetof(UP2AbilityTask_WildcatJumpFromTree, EndLocation) == 0x0000B0, "Member 'UP2AbilityTask_WildcatJumpFromTree::EndLocation' has a wrong offset!");
static_assert(offsetof(UP2AbilityTask_WildcatJumpFromTree, Duration) == 0x0000C8, "Member 'UP2AbilityTask_WildcatJumpFromTree::Duration' has a wrong offset!");
static_assert(offsetof(UP2AbilityTask_WildcatJumpFromTree, Delay) == 0x0000CC, "Member 'UP2AbilityTask_WildcatJumpFromTree::Delay' has a wrong offset!");
static_assert(offsetof(UP2AbilityTask_WildcatJumpFromTree, CurrentTime) == 0x0000D0, "Member 'UP2AbilityTask_WildcatJumpFromTree::CurrentTime' has a wrong offset!");

// Class AICommon.P2AbilityTask_CrocSnapAttackReaction
// 0x0050 (0x00D0 - 0x0080)
class UP2AbilityTask_CrocSnapAttackReaction final : public UAbilityTask
{
public:
	TSubclassOf<class UP2AnimInstance_CroSnapAttackReaction> ReactionAnimLayerClass;                 // 0x0080(0x0008)(Net, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_88[0x8];                                       // 0x0088(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FQuat                                  Rotation;                                          // 0x0090(0x0020)(Net, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         TransitionTime;                                    // 0x00B0(0x0004)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_B4[0x4];                                       // 0x00B4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UCurveFloat*                            CameraTransitionEasingCurve;                       // 0x00B8(0x0008)(Net, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bIsTransitioning;                                  // 0x00C0(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_C1[0x3];                                       // 0x00C1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         CurrentTime;                                       // 0x00C4(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_C8[0x8];                                       // 0x00C8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"P2AbilityTask_CrocSnapAttackReaction">();
	}
	static class UP2AbilityTask_CrocSnapAttackReaction* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UP2AbilityTask_CrocSnapAttackReaction>();
	}
};
static_assert(alignof(UP2AbilityTask_CrocSnapAttackReaction) == 0x000010, "Wrong alignment on UP2AbilityTask_CrocSnapAttackReaction");
static_assert(sizeof(UP2AbilityTask_CrocSnapAttackReaction) == 0x0000D0, "Wrong size on UP2AbilityTask_CrocSnapAttackReaction");
static_assert(offsetof(UP2AbilityTask_CrocSnapAttackReaction, ReactionAnimLayerClass) == 0x000080, "Member 'UP2AbilityTask_CrocSnapAttackReaction::ReactionAnimLayerClass' has a wrong offset!");
static_assert(offsetof(UP2AbilityTask_CrocSnapAttackReaction, Rotation) == 0x000090, "Member 'UP2AbilityTask_CrocSnapAttackReaction::Rotation' has a wrong offset!");
static_assert(offsetof(UP2AbilityTask_CrocSnapAttackReaction, TransitionTime) == 0x0000B0, "Member 'UP2AbilityTask_CrocSnapAttackReaction::TransitionTime' has a wrong offset!");
static_assert(offsetof(UP2AbilityTask_CrocSnapAttackReaction, CameraTransitionEasingCurve) == 0x0000B8, "Member 'UP2AbilityTask_CrocSnapAttackReaction::CameraTransitionEasingCurve' has a wrong offset!");
static_assert(offsetof(UP2AbilityTask_CrocSnapAttackReaction, bIsTransitioning) == 0x0000C0, "Member 'UP2AbilityTask_CrocSnapAttackReaction::bIsTransitioning' has a wrong offset!");
static_assert(offsetof(UP2AbilityTask_CrocSnapAttackReaction, CurrentTime) == 0x0000C4, "Member 'UP2AbilityTask_CrocSnapAttackReaction::CurrentTime' has a wrong offset!");

// Class AICommon.P2Ability_CrocSnapAttackReaction
// 0x0048 (0x04D8 - 0x0490)
class UP2Ability_CrocSnapAttackReaction final : public UP2Ability
{
public:
	TSubclassOf<class UAnimInstance>              ReactionAnimLayerClass;                            // 0x0490(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TimoutDuration;                                    // 0x0498(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TransitionTime;                                    // 0x049C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCurveFloat*                            CameraTransitionEasingCurve;                       // 0x04A0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TWeakObjectPtr<class AActor>                  ReactionInstigator;                                // 0x04A8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_4B0[0x8];                                      // 0x04B0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UP2AbilityTask_CrocSnapAttackReaction*  ReactionTask;                                      // 0x04B8(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_4C0[0x18];                                     // 0x04C0(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnDbnoStatusChanged(const struct FGameplayTag& Tag, int32 NewCount)	 // 0x472fd74;
	void OnTimeout()	 // 0x47305ec;

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"P2Ability_CrocSnapAttackReaction">();
	}
	static class UP2Ability_CrocSnapAttackReaction* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UP2Ability_CrocSnapAttackReaction>();
	}
};
static_assert(alignof(UP2Ability_CrocSnapAttackReaction) == 0x000008, "Wrong alignment on UP2Ability_CrocSnapAttackReaction");
static_assert(sizeof(UP2Ability_CrocSnapAttackReaction) == 0x0004D8, "Wrong size on UP2Ability_CrocSnapAttackReaction");
static_assert(offsetof(UP2Ability_CrocSnapAttackReaction, ReactionAnimLayerClass) == 0x000490, "Member 'UP2Ability_CrocSnapAttackReaction::ReactionAnimLayerClass' has a wrong offset!");
static_assert(offsetof(UP2Ability_CrocSnapAttackReaction, TimoutDuration) == 0x000498, "Member 'UP2Ability_CrocSnapAttackReaction::TimoutDuration' has a wrong offset!");
static_assert(offsetof(UP2Ability_CrocSnapAttackReaction, TransitionTime) == 0x00049C, "Member 'UP2Ability_CrocSnapAttackReaction::TransitionTime' has a wrong offset!");
static_assert(offsetof(UP2Ability_CrocSnapAttackReaction, CameraTransitionEasingCurve) == 0x0004A0, "Member 'UP2Ability_CrocSnapAttackReaction::CameraTransitionEasingCurve' has a wrong offset!");
static_assert(offsetof(UP2Ability_CrocSnapAttackReaction, ReactionInstigator) == 0x0004A8, "Member 'UP2Ability_CrocSnapAttackReaction::ReactionInstigator' has a wrong offset!");
static_assert(offsetof(UP2Ability_CrocSnapAttackReaction, ReactionTask) == 0x0004B8, "Member 'UP2Ability_CrocSnapAttackReaction::ReactionTask' has a wrong offset!");

// Class AICommon.P2BTDecorator_UtilityCurve
// 0x0030 (0x00A0 - 0x0070)
class UP2BTDecorator_UtilityCurve : public UBTUtilityDecorator
{
public:
	struct FBlackboardKeySelector                 BlackboardKey;                                     // 0x0070(0x0028)(Edit, Protected, NativeAccessSpecifierProtected)
	class UCurveFloat*                            UtilityScoreCurve;                                 // 0x0098(0x0008)(Edit, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"P2BTDecorator_UtilityCurve">();
	}
	static class UP2BTDecorator_UtilityCurve* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UP2BTDecorator_UtilityCurve>();
	}
};
static_assert(alignof(UP2BTDecorator_UtilityCurve) == 0x000008, "Wrong alignment on UP2BTDecorator_UtilityCurve");
static_assert(sizeof(UP2BTDecorator_UtilityCurve) == 0x0000A0, "Wrong size on UP2BTDecorator_UtilityCurve");
static_assert(offsetof(UP2BTDecorator_UtilityCurve, BlackboardKey) == 0x000070, "Member 'UP2BTDecorator_UtilityCurve::BlackboardKey' has a wrong offset!");
static_assert(offsetof(UP2BTDecorator_UtilityCurve, UtilityScoreCurve) == 0x000098, "Member 'UP2BTDecorator_UtilityCurve::UtilityScoreCurve' has a wrong offset!");

// Class AICommon.P2Action_InteractableRechargeSentry
// 0x0010 (0x0208 - 0x01F8)
class UP2Action_InteractableRechargeSentry final : public UP2Action
{
public:
	struct FGameplayTag                           RechargeTag;                                       // 0x01F8(0x0008)(Edit, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FGameplayTag                           RefillGameplayCueTag;                              // 0x0200(0x0008)(Edit, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"P2Action_InteractableRechargeSentry">();
	}
	static class UP2Action_InteractableRechargeSentry* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UP2Action_InteractableRechargeSentry>();
	}
};
static_assert(alignof(UP2Action_InteractableRechargeSentry) == 0x000008, "Wrong alignment on UP2Action_InteractableRechargeSentry");
static_assert(sizeof(UP2Action_InteractableRechargeSentry) == 0x000208, "Wrong size on UP2Action_InteractableRechargeSentry");
static_assert(offsetof(UP2Action_InteractableRechargeSentry, RechargeTag) == 0x0001F8, "Member 'UP2Action_InteractableRechargeSentry::RechargeTag' has a wrong offset!");
static_assert(offsetof(UP2Action_InteractableRechargeSentry, RefillGameplayCueTag) == 0x000200, "Member 'UP2Action_InteractableRechargeSentry::RefillGameplayCueTag' has a wrong offset!");

// Class AICommon.P2AIAirlockDevice
// 0x0010 (0x02C0 - 0x02B0)
class AP2AIAirlockDevice : public AActor
{
public:
	uint8                                         Pad_2B0[0x10];                                     // 0x02B0(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void AirlockSealChange(bool InSealState)	 // 0x472f4cc;
	void AllowAirlockAccess(bool SkipDelay)	 // 0xae1e64;
	void OnBossDeath()	 // 0xae1e64;

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"P2AIAirlockDevice">();
	}
	static class AP2AIAirlockDevice* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<AP2AIAirlockDevice>();
	}
};
static_assert(alignof(AP2AIAirlockDevice) == 0x000008, "Wrong alignment on AP2AIAirlockDevice");
static_assert(sizeof(AP2AIAirlockDevice) == 0x0002C0, "Wrong size on AP2AIAirlockDevice");

// Class AICommon.P2AIController
// 0x0050 (0x0428 - 0x03D8)
class AP2AIController : public AAIController
{
public:
	uint8                                         Pad_3D8[0x10];                                     // 0x03D8(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class UBehaviorTree*                          StateOverrideBehaviorTree;                         // 0x03E8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UP2StateTreeComponent*                  StateTreeComponent;                                // 0x03F0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   SelfRightDirectionKey;                             // 0x03F8(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bInfightingNearPlayers;                            // 0x0400(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_401[0x7];                                      // 0x0401(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UP2SmartObjectUserComponent*            SmartObjectUserComponent;                          // 0x0408(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_410[0x18];                                     // 0x0410(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"P2AIController">();
	}
	static class AP2AIController* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<AP2AIController>();
	}
};
static_assert(alignof(AP2AIController) == 0x000008, "Wrong alignment on AP2AIController");
static_assert(sizeof(AP2AIController) == 0x000428, "Wrong size on AP2AIController");
static_assert(offsetof(AP2AIController, StateOverrideBehaviorTree) == 0x0003E8, "Member 'AP2AIController::StateOverrideBehaviorTree' has a wrong offset!");
static_assert(offsetof(AP2AIController, StateTreeComponent) == 0x0003F0, "Member 'AP2AIController::StateTreeComponent' has a wrong offset!");
static_assert(offsetof(AP2AIController, SelfRightDirectionKey) == 0x0003F8, "Member 'AP2AIController::SelfRightDirectionKey' has a wrong offset!");
static_assert(offsetof(AP2AIController, bInfightingNearPlayers) == 0x000400, "Member 'AP2AIController::bInfightingNearPlayers' has a wrong offset!");
static_assert(offsetof(AP2AIController, SmartObjectUserComponent) == 0x000408, "Member 'AP2AIController::SmartObjectUserComponent' has a wrong offset!");

// Class AICommon.P2BTDecorator_IsLookedAt
// 0x0030 (0x0098 - 0x0068)
class UP2BTDecorator_IsLookedAt final : public UBTDecorator
{
public:
	struct FBlackboardKeySelector                 TargetKey;                                         // 0x0068(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)
	ECollisionChannel                             ChannelForVisibility;                              // 0x0090(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_91[0x3];                                       // 0x0091(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         TickInterval;                                      // 0x0094(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"P2BTDecorator_IsLookedAt">();
	}
	static class UP2BTDecorator_IsLookedAt* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UP2BTDecorator_IsLookedAt>();
	}
};
static_assert(alignof(UP2BTDecorator_IsLookedAt) == 0x000008, "Wrong alignment on UP2BTDecorator_IsLookedAt");
static_assert(sizeof(UP2BTDecorator_IsLookedAt) == 0x000098, "Wrong size on UP2BTDecorator_IsLookedAt");
static_assert(offsetof(UP2BTDecorator_IsLookedAt, TargetKey) == 0x000068, "Member 'UP2BTDecorator_IsLookedAt::TargetKey' has a wrong offset!");
static_assert(offsetof(UP2BTDecorator_IsLookedAt, ChannelForVisibility) == 0x000090, "Member 'UP2BTDecorator_IsLookedAt::ChannelForVisibility' has a wrong offset!");
static_assert(offsetof(UP2BTDecorator_IsLookedAt, TickInterval) == 0x000094, "Member 'UP2BTDecorator_IsLookedAt::TickInterval' has a wrong offset!");

// Class AICommon.P2AIController_Sentry
// 0x0000 (0x0428 - 0x0428)
class AP2AIController_Sentry final : public AP2AIController
{
public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"P2AIController_Sentry">();
	}
	static class AP2AIController_Sentry* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<AP2AIController_Sentry>();
	}
};
static_assert(alignof(AP2AIController_Sentry) == 0x000008, "Wrong alignment on AP2AIController_Sentry");
static_assert(sizeof(AP2AIController_Sentry) == 0x000428, "Wrong size on AP2AIController_Sentry");

// Class AICommon.P2SmartObjectProxy
// 0x0000 (0x02B0 - 0x02B0)
class AP2SmartObjectProxy : public AActor
{
public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"P2SmartObjectProxy">();
	}
	static class AP2SmartObjectProxy* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<AP2SmartObjectProxy>();
	}
};
static_assert(alignof(AP2SmartObjectProxy) == 0x000008, "Wrong alignment on AP2SmartObjectProxy");
static_assert(sizeof(AP2SmartObjectProxy) == 0x0002B0, "Wrong size on AP2SmartObjectProxy");

// Class AICommon.P2SmartObjectProxy_MontageBased
// 0x0000 (0x02B0 - 0x02B0)
class AP2SmartObjectProxy_MontageBased final : public AP2SmartObjectProxy
{
public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"P2SmartObjectProxy_MontageBased">();
	}
	static class AP2SmartObjectProxy_MontageBased* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<AP2SmartObjectProxy_MontageBased>();
	}
};
static_assert(alignof(AP2SmartObjectProxy_MontageBased) == 0x000008, "Wrong alignment on AP2SmartObjectProxy_MontageBased");
static_assert(sizeof(AP2SmartObjectProxy_MontageBased) == 0x0002B0, "Wrong size on AP2SmartObjectProxy_MontageBased");

// Class AICommon.P2AIController_WildCat
// 0x0008 (0x0430 - 0x0428)
class AP2AIController_WildCat final : public AP2AIController
{
public:
	class UP2WildCatImpatienceComponent*          ImpatienceComponent;                               // 0x0428(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"P2AIController_WildCat">();
	}
	static class AP2AIController_WildCat* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<AP2AIController_WildCat>();
	}
};
static_assert(alignof(AP2AIController_WildCat) == 0x000008, "Wrong alignment on AP2AIController_WildCat");
static_assert(sizeof(AP2AIController_WildCat) == 0x000430, "Wrong size on AP2AIController_WildCat");
static_assert(offsetof(AP2AIController_WildCat, ImpatienceComponent) == 0x000428, "Member 'AP2AIController_WildCat::ImpatienceComponent' has a wrong offset!");

// Class AICommon.P2AICoverManager
// 0x0100 (0x03B0 - 0x02B0)
class alignas(0x10) AP2AICoverManager final : public AActor
{
public:
	class FName                                   AgentName;                                         // 0x02B0(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bOverrideAgentHeight;                              // 0x02B8(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2B9[0x3];                                      // 0x02B9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         AgentHeightOverride;                               // 0x02BC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bOverrideAgentRadius;                              // 0x02C0(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2C1[0x3];                                      // 0x02C1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         AgentRadiusOverride;                               // 0x02C4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EP2AICoverGenerationType                      GenerationType;                                    // 0x02C8(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2C9[0x3];                                      // 0x02C9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         StepSize;                                          // 0x02CC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MinDot;                                            // 0x02D0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	ECollisionChannel                             CollisionChannel;                                  // 0x02D4(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2D5[0x3];                                      // 0x02D5(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         TraceLengthCover;                                  // 0x02D8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         TraceLengthFree;                                   // 0x02DC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         SphereSize;                                        // 0x02E0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bConnectSegments;                                  // 0x02E4(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bDrawCovers;                                       // 0x02E5(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2E6[0x2];                                      // 0x02E6(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         DrawCoversDistance;                                // 0x02E8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2EC[0x4];                                      // 0x02EC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UP2AICoverPoint*>                CoverPoints;                                       // 0x02F0(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	uint8                                         Pad_300[0xB0];                                     // 0x0300(0x00B0)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Clear()	 // 0x17c7f2c;
	void Generate()	 // 0x17c7f2c;

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"P2AICoverManager">();
	}
	static class AP2AICoverManager* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<AP2AICoverManager>();
	}
};
static_assert(alignof(AP2AICoverManager) == 0x000010, "Wrong alignment on AP2AICoverManager");
static_assert(sizeof(AP2AICoverManager) == 0x0003B0, "Wrong size on AP2AICoverManager");
static_assert(offsetof(AP2AICoverManager, AgentName) == 0x0002B0, "Member 'AP2AICoverManager::AgentName' has a wrong offset!");
static_assert(offsetof(AP2AICoverManager, bOverrideAgentHeight) == 0x0002B8, "Member 'AP2AICoverManager::bOverrideAgentHeight' has a wrong offset!");
static_assert(offsetof(AP2AICoverManager, AgentHeightOverride) == 0x0002BC, "Member 'AP2AICoverManager::AgentHeightOverride' has a wrong offset!");
static_assert(offsetof(AP2AICoverManager, bOverrideAgentRadius) == 0x0002C0, "Member 'AP2AICoverManager::bOverrideAgentRadius' has a wrong offset!");
static_assert(offsetof(AP2AICoverManager, AgentRadiusOverride) == 0x0002C4, "Member 'AP2AICoverManager::AgentRadiusOverride' has a wrong offset!");
static_assert(offsetof(AP2AICoverManager, GenerationType) == 0x0002C8, "Member 'AP2AICoverManager::GenerationType' has a wrong offset!");
static_assert(offsetof(AP2AICoverManager, StepSize) == 0x0002CC, "Member 'AP2AICoverManager::StepSize' has a wrong offset!");
static_assert(offsetof(AP2AICoverManager, MinDot) == 0x0002D0, "Member 'AP2AICoverManager::MinDot' has a wrong offset!");
static_assert(offsetof(AP2AICoverManager, CollisionChannel) == 0x0002D4, "Member 'AP2AICoverManager::CollisionChannel' has a wrong offset!");
static_assert(offsetof(AP2AICoverManager, TraceLengthCover) == 0x0002D8, "Member 'AP2AICoverManager::TraceLengthCover' has a wrong offset!");
static_assert(offsetof(AP2AICoverManager, TraceLengthFree) == 0x0002DC, "Member 'AP2AICoverManager::TraceLengthFree' has a wrong offset!");
static_assert(offsetof(AP2AICoverManager, SphereSize) == 0x0002E0, "Member 'AP2AICoverManager::SphereSize' has a wrong offset!");
static_assert(offsetof(AP2AICoverManager, bConnectSegments) == 0x0002E4, "Member 'AP2AICoverManager::bConnectSegments' has a wrong offset!");
static_assert(offsetof(AP2AICoverManager, bDrawCovers) == 0x0002E5, "Member 'AP2AICoverManager::bDrawCovers' has a wrong offset!");
static_assert(offsetof(AP2AICoverManager, DrawCoversDistance) == 0x0002E8, "Member 'AP2AICoverManager::DrawCoversDistance' has a wrong offset!");
static_assert(offsetof(AP2AICoverManager, CoverPoints) == 0x0002F0, "Member 'AP2AICoverManager::CoverPoints' has a wrong offset!");

// Class AICommon.P2AICoverPoint
// 0x0050 (0x0078 - 0x0028)
class UP2AICoverPoint final : public UObject
{
public:
	struct FVector                                Location;                                          // 0x0028(0x0018)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               Rotation;                                          // 0x0040(0x0018)(ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	float                                         Radius;                                            // 0x0058(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HalfHeight;                                        // 0x005C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bFrontCover;                                       // 0x0060(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bRightCover;                                       // 0x0061(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bLeftCover;                                        // 0x0062(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_63[0x15];                                      // 0x0063(0x0015)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"P2AICoverPoint">();
	}
	static class UP2AICoverPoint* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UP2AICoverPoint>();
	}
};
static_assert(alignof(UP2AICoverPoint) == 0x000008, "Wrong alignment on UP2AICoverPoint");
static_assert(sizeof(UP2AICoverPoint) == 0x000078, "Wrong size on UP2AICoverPoint");
static_assert(offsetof(UP2AICoverPoint, Location) == 0x000028, "Member 'UP2AICoverPoint::Location' has a wrong offset!");
static_assert(offsetof(UP2AICoverPoint, Rotation) == 0x000040, "Member 'UP2AICoverPoint::Rotation' has a wrong offset!");
static_assert(offsetof(UP2AICoverPoint, Radius) == 0x000058, "Member 'UP2AICoverPoint::Radius' has a wrong offset!");
static_assert(offsetof(UP2AICoverPoint, HalfHeight) == 0x00005C, "Member 'UP2AICoverPoint::HalfHeight' has a wrong offset!");
static_assert(offsetof(UP2AICoverPoint, bFrontCover) == 0x000060, "Member 'UP2AICoverPoint::bFrontCover' has a wrong offset!");
static_assert(offsetof(UP2AICoverPoint, bRightCover) == 0x000061, "Member 'UP2AICoverPoint::bRightCover' has a wrong offset!");
static_assert(offsetof(UP2AICoverPoint, bLeftCover) == 0x000062, "Member 'UP2AICoverPoint::bLeftCover' has a wrong offset!");

// Class AICommon.P2BTDecorator_SentryAimingCheck
// 0x0008 (0x0070 - 0x0068)
class UP2BTDecorator_SentryAimingCheck final : public UBTDecorator
{
public:
	float                                         TickInterval;                                      // 0x0068(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_6C[0x4];                                       // 0x006C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"P2BTDecorator_SentryAimingCheck">();
	}
	static class UP2BTDecorator_SentryAimingCheck* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UP2BTDecorator_SentryAimingCheck>();
	}
};
static_assert(alignof(UP2BTDecorator_SentryAimingCheck) == 0x000008, "Wrong alignment on UP2BTDecorator_SentryAimingCheck");
static_assert(sizeof(UP2BTDecorator_SentryAimingCheck) == 0x000070, "Wrong size on UP2BTDecorator_SentryAimingCheck");
static_assert(offsetof(UP2BTDecorator_SentryAimingCheck, TickInterval) == 0x000068, "Member 'UP2BTDecorator_SentryAimingCheck::TickInterval' has a wrong offset!");

// Class AICommon.P2AICoverSubsystem
// 0x0050 (0x0080 - 0x0030)
class UP2AICoverSubsystem final : public UWorldSubsystem
{
public:
	TMap<class FName, class AP2AICoverManager*>   RegisteredCoverManagers;                           // 0x0030(0x0050)(NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"P2AICoverSubsystem">();
	}
	static class UP2AICoverSubsystem* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UP2AICoverSubsystem>();
	}
};
static_assert(alignof(UP2AICoverSubsystem) == 0x000008, "Wrong alignment on UP2AICoverSubsystem");
static_assert(sizeof(UP2AICoverSubsystem) == 0x000080, "Wrong size on UP2AICoverSubsystem");
static_assert(offsetof(UP2AICoverSubsystem, RegisteredCoverManagers) == 0x000030, "Member 'UP2AICoverSubsystem::RegisteredCoverManagers' has a wrong offset!");

// Class AICommon.P2SmartObjectsGenerationVolume
// 0x0010 (0x02F8 - 0x02E8)
class AP2SmartObjectsGenerationVolume final : public AVolume
{
public:
	class UP2SmartObjectDefinitionsData*          DefinitionsData;                                   // 0x02E8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCheckVolumeBounds;                                // 0x02F0(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2F1[0x7];                                      // 0x02F1(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"P2SmartObjectsGenerationVolume">();
	}
	static class AP2SmartObjectsGenerationVolume* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<AP2SmartObjectsGenerationVolume>();
	}
};
static_assert(alignof(AP2SmartObjectsGenerationVolume) == 0x000008, "Wrong alignment on AP2SmartObjectsGenerationVolume");
static_assert(sizeof(AP2SmartObjectsGenerationVolume) == 0x0002F8, "Wrong size on AP2SmartObjectsGenerationVolume");
static_assert(offsetof(AP2SmartObjectsGenerationVolume, DefinitionsData) == 0x0002E8, "Member 'AP2SmartObjectsGenerationVolume::DefinitionsData' has a wrong offset!");
static_assert(offsetof(AP2SmartObjectsGenerationVolume, bCheckVolumeBounds) == 0x0002F0, "Member 'AP2SmartObjectsGenerationVolume::bCheckVolumeBounds' has a wrong offset!");

// Class AICommon.P2AIDangerSourceComponent
// 0x0050 (0x0110 - 0x00C0)
class UP2AIDangerSourceComponent final : public UActorComponent
{
public:
	float                                         MinEventLocationDelta;                             // 0x00C0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Radius;                                            // 0x00C4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Strength;                                          // 0x00C8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bRequiresTrace;                                    // 0x00CC(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_CD[0x3];                                       // 0x00CD(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTagContainer                  Tags;                                              // 0x00D0(0x0020)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	uint8                                         Pad_F0[0x20];                                      // 0x00F0(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnDangerEvent(const struct FVector& InEventLocation)	 // 0x472fcec;
	void OnProjectileBounce(const struct FHitResult& InImpactResult, const struct FVector& InImpactVelocity)	 // 0x473046c;
	void OnProjectileStop(const struct FHitResult& InImpactResult)	 // 0x4730550;

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"P2AIDangerSourceComponent">();
	}
	static class UP2AIDangerSourceComponent* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UP2AIDangerSourceComponent>();
	}
};
static_assert(alignof(UP2AIDangerSourceComponent) == 0x000008, "Wrong alignment on UP2AIDangerSourceComponent");
static_assert(sizeof(UP2AIDangerSourceComponent) == 0x000110, "Wrong size on UP2AIDangerSourceComponent");
static_assert(offsetof(UP2AIDangerSourceComponent, MinEventLocationDelta) == 0x0000C0, "Member 'UP2AIDangerSourceComponent::MinEventLocationDelta' has a wrong offset!");
static_assert(offsetof(UP2AIDangerSourceComponent, Radius) == 0x0000C4, "Member 'UP2AIDangerSourceComponent::Radius' has a wrong offset!");
static_assert(offsetof(UP2AIDangerSourceComponent, Strength) == 0x0000C8, "Member 'UP2AIDangerSourceComponent::Strength' has a wrong offset!");
static_assert(offsetof(UP2AIDangerSourceComponent, bRequiresTrace) == 0x0000CC, "Member 'UP2AIDangerSourceComponent::bRequiresTrace' has a wrong offset!");
static_assert(offsetof(UP2AIDangerSourceComponent, Tags) == 0x0000D0, "Member 'UP2AIDangerSourceComponent::Tags' has a wrong offset!");

// Class AICommon.P2AIDirector
// 0x0030 (0x0068 - 0x0038)
class UP2AIDirector final : public UAISubsystem
{
public:
	TArray<struct FSoftClassPath>                 AIDirectorTaskClassNames;                          // 0x0038(0x0010)(Edit, ZeroConstructor, Config, GlobalConfig, Protected, NativeAccessSpecifierProtected)
	TArray<class UP2AIDirectorTask*>              Tasks;                                             // 0x0048(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	uint8                                         Pad_58[0x10];                                      // 0x0058(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"P2AIDirector">();
	}
	static class UP2AIDirector* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UP2AIDirector>();
	}
};
static_assert(alignof(UP2AIDirector) == 0x000008, "Wrong alignment on UP2AIDirector");
static_assert(sizeof(UP2AIDirector) == 0x000068, "Wrong size on UP2AIDirector");
static_assert(offsetof(UP2AIDirector, AIDirectorTaskClassNames) == 0x000038, "Member 'UP2AIDirector::AIDirectorTaskClassNames' has a wrong offset!");
static_assert(offsetof(UP2AIDirector, Tasks) == 0x000048, "Member 'UP2AIDirector::Tasks' has a wrong offset!");

// Class AICommon.P2BTDecorator_NpcGroupMemberIsNearDanger
// 0x0010 (0x0078 - 0x0068)
class UP2BTDecorator_NpcGroupMemberIsNearDanger final : public UBTDecorator
{
public:
	struct FGameplayTag                           DangerTypeTag;                                     // 0x0068(0x0008)(Edit, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         TickInterval;                                      // 0x0070(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_74[0x4];                                       // 0x0074(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"P2BTDecorator_NpcGroupMemberIsNearDanger">();
	}
	static class UP2BTDecorator_NpcGroupMemberIsNearDanger* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UP2BTDecorator_NpcGroupMemberIsNearDanger>();
	}
};
static_assert(alignof(UP2BTDecorator_NpcGroupMemberIsNearDanger) == 0x000008, "Wrong alignment on UP2BTDecorator_NpcGroupMemberIsNearDanger");
static_assert(sizeof(UP2BTDecorator_NpcGroupMemberIsNearDanger) == 0x000078, "Wrong size on UP2BTDecorator_NpcGroupMemberIsNearDanger");
static_assert(offsetof(UP2BTDecorator_NpcGroupMemberIsNearDanger, DangerTypeTag) == 0x000068, "Member 'UP2BTDecorator_NpcGroupMemberIsNearDanger::DangerTypeTag' has a wrong offset!");
static_assert(offsetof(UP2BTDecorator_NpcGroupMemberIsNearDanger, TickInterval) == 0x000070, "Member 'UP2BTDecorator_NpcGroupMemberIsNearDanger::TickInterval' has a wrong offset!");

// Class AICommon.P2AIDirectorTask
// 0x0008 (0x0030 - 0x0028)
class UP2AIDirectorTask : public UObject
{
public:
	uint8                                         Pad_28[0x8];                                       // 0x0028(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"P2AIDirectorTask">();
	}
	static class UP2AIDirectorTask* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UP2AIDirectorTask>();
	}
};
static_assert(alignof(UP2AIDirectorTask) == 0x000008, "Wrong alignment on UP2AIDirectorTask");
static_assert(sizeof(UP2AIDirectorTask) == 0x000030, "Wrong size on UP2AIDirectorTask");

// Class AICommon.P2SmartObject
// 0x0030 (0x0058 - 0x0028)
class UP2SmartObject : public UObject
{
public:
	float                                         Priority;                                          // 0x0028(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C[0x4];                                       // 0x002C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TMulticastInlineDelegate<void(class APawn* Pawn)> OnLeftDelegate;                                // 0x0030(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	class UP2SmartObjectDefinition*               Definition;                                        // 0x0040(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TWeakObjectPtr<class APawn>                   Occupant;                                          // 0x0048(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bIsUsed;                                           // 0x0050(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_51[0x7];                                       // 0x0051(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	bool Enter(class APawn* Pawn)	 // 0x477695c;
	void Leave(class APawn* Pawn)	 // 0x4776d3c;
	void OnEnter(class APawn* Pawn)	 // 0x4776f68;
	void OnLeave(class APawn* Pawn)	 // 0x477702c;
	void OnRequestLeave(class APawn* Pawn)	 // 0x41465b4;
	bool RequestLeave(class APawn* Pawn)	 // 0x47771a4;

	bool IsOccupied() const	 // 0x4776b54;
	bool IsOccupiedBy(class APawn* Pawn) const	 // 0x4776b78;
	bool IsReserved() const	 // 0x4776c48;
	bool IsReservedBy(class APawn* Pawn) const	 // 0x4776c6c;

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"P2SmartObject">();
	}
	static class UP2SmartObject* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UP2SmartObject>();
	}
};
static_assert(alignof(UP2SmartObject) == 0x000008, "Wrong alignment on UP2SmartObject");
static_assert(sizeof(UP2SmartObject) == 0x000058, "Wrong size on UP2SmartObject");
static_assert(offsetof(UP2SmartObject, Priority) == 0x000028, "Member 'UP2SmartObject::Priority' has a wrong offset!");
static_assert(offsetof(UP2SmartObject, OnLeftDelegate) == 0x000030, "Member 'UP2SmartObject::OnLeftDelegate' has a wrong offset!");
static_assert(offsetof(UP2SmartObject, Definition) == 0x000040, "Member 'UP2SmartObject::Definition' has a wrong offset!");
static_assert(offsetof(UP2SmartObject, Occupant) == 0x000048, "Member 'UP2SmartObject::Occupant' has a wrong offset!");
static_assert(offsetof(UP2SmartObject, bIsUsed) == 0x000050, "Member 'UP2SmartObject::bIsUsed' has a wrong offset!");

// Class AICommon.P2SmartObject_AbilityDriven
// 0x0020 (0x0078 - 0x0058)
class UP2SmartObject_AbilityDriven : public UP2SmartObject
{
public:
	TSubclassOf<class UP2NpcAbility>              Ability;                                           // 0x0058(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_60[0x18];                                      // 0x0060(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnAbilityEnded(const struct FAbilityEndedData& Data)	 // 0x477abf4;

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"P2SmartObject_AbilityDriven">();
	}
	static class UP2SmartObject_AbilityDriven* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UP2SmartObject_AbilityDriven>();
	}
};
static_assert(alignof(UP2SmartObject_AbilityDriven) == 0x000008, "Wrong alignment on UP2SmartObject_AbilityDriven");
static_assert(sizeof(UP2SmartObject_AbilityDriven) == 0x000078, "Wrong size on UP2SmartObject_AbilityDriven");
static_assert(offsetof(UP2SmartObject_AbilityDriven, Ability) == 0x000058, "Member 'UP2SmartObject_AbilityDriven::Ability' has a wrong offset!");

// Class AICommon.P2SmartObject_BruteThrowable
// 0x0060 (0x00D8 - 0x0078)
class UP2SmartObject_BruteThrowable final : public UP2SmartObject_AbilityDriven
{
public:
	struct FBoxSphereBounds                       Bounds;                                            // 0x0078(0x0038)(ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPrivate)
	struct FVector                                EntryLocation;                                     // 0x00B0(0x0018)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_C8[0x8];                                       // 0x00C8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class AP2BruteThrowable*                      Proxy;                                             // 0x00D0(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	struct FVector GetEnterLocation() const	 // 0x477a748;

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"P2SmartObject_BruteThrowable">();
	}
	static class UP2SmartObject_BruteThrowable* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UP2SmartObject_BruteThrowable>();
	}
};
static_assert(alignof(UP2SmartObject_BruteThrowable) == 0x000008, "Wrong alignment on UP2SmartObject_BruteThrowable");
static_assert(sizeof(UP2SmartObject_BruteThrowable) == 0x0000D8, "Wrong size on UP2SmartObject_BruteThrowable");
static_assert(offsetof(UP2SmartObject_BruteThrowable, Bounds) == 0x000078, "Member 'UP2SmartObject_BruteThrowable::Bounds' has a wrong offset!");
static_assert(offsetof(UP2SmartObject_BruteThrowable, EntryLocation) == 0x0000B0, "Member 'UP2SmartObject_BruteThrowable::EntryLocation' has a wrong offset!");
static_assert(offsetof(UP2SmartObject_BruteThrowable, Proxy) == 0x0000D0, "Member 'UP2SmartObject_BruteThrowable::Proxy' has a wrong offset!");

// Class AICommon.P2AIDirectorTask_Freeze
// 0x0030 (0x0060 - 0x0030)
class UP2AIDirectorTask_Freeze final : public UP2AIDirectorTask
{
public:
	TArray<class AAIController*>                  Npcs;                                              // 0x0030(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	TArray<class AAIController*>                  NpcsToCheck;                                       // 0x0040(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	uint8                                         Pad_50[0x10];                                      // 0x0050(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnActorDestroyed(class AActor* InDestroyedActor)	 // 0x472fb6c;
	void OnActorEndPlay(class AActor* InActor, EEndPlayReason InEndPlayReason)	 // 0x17ad3f0;
	void OnNpcDeath(class UP2HealthComponent* InHealthComponent)	 // 0x472ffbc;
	void OnPawnChanged(class APawn* InOldPawn, class APawn* InNewPawn)	 // 0x473032c;

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"P2AIDirectorTask_Freeze">();
	}
	static class UP2AIDirectorTask_Freeze* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UP2AIDirectorTask_Freeze>();
	}
};
static_assert(alignof(UP2AIDirectorTask_Freeze) == 0x000008, "Wrong alignment on UP2AIDirectorTask_Freeze");
static_assert(sizeof(UP2AIDirectorTask_Freeze) == 0x000060, "Wrong size on UP2AIDirectorTask_Freeze");
static_assert(offsetof(UP2AIDirectorTask_Freeze, Npcs) == 0x000030, "Member 'UP2AIDirectorTask_Freeze::Npcs' has a wrong offset!");
static_assert(offsetof(UP2AIDirectorTask_Freeze, NpcsToCheck) == 0x000040, "Member 'UP2AIDirectorTask_Freeze::NpcsToCheck' has a wrong offset!");

// Class AICommon.P2BTDecorator_ReceivedDamageWithTag
// 0x0018 (0x0080 - 0x0068)
class UP2BTDecorator_ReceivedDamageWithTag final : public UBTDecorator
{
public:
	struct FGameplayTag                           DamageTag;                                         // 0x0068(0x0008)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DamageThreshold;                                   // 0x0070(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TimeToConsider;                                    // 0x0074(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_78[0x8];                                       // 0x0078(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnReceivedDamage(const struct FP2DamageData& AttributeChangeData, class UBehaviorTreeComponent* OwnerComp)	 // 0x474203c;

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"P2BTDecorator_ReceivedDamageWithTag">();
	}
	static class UP2BTDecorator_ReceivedDamageWithTag* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UP2BTDecorator_ReceivedDamageWithTag>();
	}
};
static_assert(alignof(UP2BTDecorator_ReceivedDamageWithTag) == 0x000008, "Wrong alignment on UP2BTDecorator_ReceivedDamageWithTag");
static_assert(sizeof(UP2BTDecorator_ReceivedDamageWithTag) == 0x000080, "Wrong size on UP2BTDecorator_ReceivedDamageWithTag");
static_assert(offsetof(UP2BTDecorator_ReceivedDamageWithTag, DamageTag) == 0x000068, "Member 'UP2BTDecorator_ReceivedDamageWithTag::DamageTag' has a wrong offset!");
static_assert(offsetof(UP2BTDecorator_ReceivedDamageWithTag, DamageThreshold) == 0x000070, "Member 'UP2BTDecorator_ReceivedDamageWithTag::DamageThreshold' has a wrong offset!");
static_assert(offsetof(UP2BTDecorator_ReceivedDamageWithTag, TimeToConsider) == 0x000074, "Member 'UP2BTDecorator_ReceivedDamageWithTag::TimeToConsider' has a wrong offset!");

// Class AICommon.P2AIDirectorTask_GroupManager
// 0x00D0 (0x0100 - 0x0030)
class UP2AIDirectorTask_GroupManager final : public UP2AIDirectorTask
{
public:
	uint8                                         Pad_30[0xD0];                                      // 0x0030(0x00D0)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnActorDestroyed(class AActor* InDestroyedActor)	 // 0x472fc2c;
	void OnNpcDeath(class UP2HealthComponent* InHealthComponent)	 // 0x473007c;

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"P2AIDirectorTask_GroupManager">();
	}
	static class UP2AIDirectorTask_GroupManager* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UP2AIDirectorTask_GroupManager>();
	}
};
static_assert(alignof(UP2AIDirectorTask_GroupManager) == 0x000008, "Wrong alignment on UP2AIDirectorTask_GroupManager");
static_assert(sizeof(UP2AIDirectorTask_GroupManager) == 0x000100, "Wrong size on UP2AIDirectorTask_GroupManager");

// Class AICommon.P2AIDirectorTask_Spawning
// 0x0688 (0x06B8 - 0x0030)
class UP2AIDirectorTask_Spawning final : public UP2AIDirectorTask
{
public:
	TMulticastInlineDelegate<void(int32 InSeed, const TArray<struct FP2NpcSpawningCell>& InCells, const TArray<struct FP2NpcSpawningGeneratedPoint>& InPoints, const TArray<struct FP2NpcSpawningSpawnedCreature>& InTextureCreatures, const TArray<struct FP2NpcSpawningSpawnedCreature>& InVolumeCreatures, float InTimeSpent)> OnFinishSpawning; // 0x0030(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_40[0x678];                                     // 0x0040(0x0678)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnMatchStarted(class AP2GameMode* InGameMode)	 // 0x472fefc;
	void OnNpcDeath(class UP2HealthComponent* InHealthComponent, const struct FP2FinalBlowImpulseData& InImpulse)	 // 0x473013c;
	void OnNpcDestroyed(class AActor* InDestroyedActor)	 // 0x473026c;
	void OnWaveTriggered(const int32 InWaveIndex, const struct FP2NpcSpawningWave& InWave)	 // 0x4730618;

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"P2AIDirectorTask_Spawning">();
	}
	static class UP2AIDirectorTask_Spawning* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UP2AIDirectorTask_Spawning>();
	}
};
static_assert(alignof(UP2AIDirectorTask_Spawning) == 0x000008, "Wrong alignment on UP2AIDirectorTask_Spawning");
static_assert(sizeof(UP2AIDirectorTask_Spawning) == 0x0006B8, "Wrong size on UP2AIDirectorTask_Spawning");
static_assert(offsetof(UP2AIDirectorTask_Spawning, OnFinishSpawning) == 0x000030, "Member 'UP2AIDirectorTask_Spawning::OnFinishSpawning' has a wrong offset!");

// Class AICommon.P2BTDecorator_WildCatImpatienceLow
// 0x0008 (0x0070 - 0x0068)
class UP2BTDecorator_WildCatImpatienceLow final : public UBTDecorator
{
public:
	float                                         HighImpatienceThreshold;                           // 0x0068(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_6C[0x4];                                       // 0x006C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"P2BTDecorator_WildCatImpatienceLow">();
	}
	static class UP2BTDecorator_WildCatImpatienceLow* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UP2BTDecorator_WildCatImpatienceLow>();
	}
};
static_assert(alignof(UP2BTDecorator_WildCatImpatienceLow) == 0x000008, "Wrong alignment on UP2BTDecorator_WildCatImpatienceLow");
static_assert(sizeof(UP2BTDecorator_WildCatImpatienceLow) == 0x000070, "Wrong size on UP2BTDecorator_WildCatImpatienceLow");
static_assert(offsetof(UP2BTDecorator_WildCatImpatienceLow, HighImpatienceThreshold) == 0x000068, "Member 'UP2BTDecorator_WildCatImpatienceLow::HighImpatienceThreshold' has a wrong offset!");

// Class AICommon.P2SmartObject_WildCatTree
// 0x0098 (0x0110 - 0x0078)
class UP2SmartObject_WildCatTree final : public UP2SmartObject_AbilityDriven
{
public:
	struct FBoxSphereBounds                       Bounds;                                            // 0x0078(0x0038)(ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPrivate)
	struct FTransform                             Transform;                                         // 0x00B0(0x0060)(IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"P2SmartObject_WildCatTree">();
	}
	static class UP2SmartObject_WildCatTree* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UP2SmartObject_WildCatTree>();
	}
};
static_assert(alignof(UP2SmartObject_WildCatTree) == 0x000010, "Wrong alignment on UP2SmartObject_WildCatTree");
static_assert(sizeof(UP2SmartObject_WildCatTree) == 0x000110, "Wrong size on UP2SmartObject_WildCatTree");
static_assert(offsetof(UP2SmartObject_WildCatTree, Bounds) == 0x000078, "Member 'UP2SmartObject_WildCatTree::Bounds' has a wrong offset!");
static_assert(offsetof(UP2SmartObject_WildCatTree, Transform) == 0x0000B0, "Member 'UP2SmartObject_WildCatTree::Transform' has a wrong offset!");

// Class AICommon.P2AIPerceptionStimuliSourceComponent
// 0x0000 (0x00D8 - 0x00D8)
class UP2AIPerceptionStimuliSourceComponent : public UAIPerceptionStimuliSourceComponent
{
public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"P2AIPerceptionStimuliSourceComponent">();
	}
	static class UP2AIPerceptionStimuliSourceComponent* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UP2AIPerceptionStimuliSourceComponent>();
	}
};
static_assert(alignof(UP2AIPerceptionStimuliSourceComponent) == 0x000008, "Wrong alignment on UP2AIPerceptionStimuliSourceComponent");
static_assert(sizeof(UP2AIPerceptionStimuliSourceComponent) == 0x0000D8, "Wrong size on UP2AIPerceptionStimuliSourceComponent");

// Class AICommon.P2AIPerceptionSystem
// 0x0020 (0x0158 - 0x0138)
class UP2AIPerceptionSystem final : public UAIPerceptionSystem
{
public:
	bool                                          bIgnoreAllPlayers;                                 // 0x0138(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_139[0x7];                                      // 0x0139(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<TWeakObjectPtr<class APlayerController>> IgnoredPlayers;                                  // 0x0140(0x0010)(ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
	class AP2AIStimuliSource_World*               WorldStimuliSource;                                // 0x0150(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class AP2AIStimuliSource_World* GetWorldStimuliSource(class UObject* WorldContextObject)	 // 0x4734620;

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"P2AIPerceptionSystem">();
	}
	static class UP2AIPerceptionSystem* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UP2AIPerceptionSystem>();
	}
};
static_assert(alignof(UP2AIPerceptionSystem) == 0x000008, "Wrong alignment on UP2AIPerceptionSystem");
static_assert(sizeof(UP2AIPerceptionSystem) == 0x000158, "Wrong size on UP2AIPerceptionSystem");
static_assert(offsetof(UP2AIPerceptionSystem, bIgnoreAllPlayers) == 0x000138, "Member 'UP2AIPerceptionSystem::bIgnoreAllPlayers' has a wrong offset!");
static_assert(offsetof(UP2AIPerceptionSystem, IgnoredPlayers) == 0x000140, "Member 'UP2AIPerceptionSystem::IgnoredPlayers' has a wrong offset!");
static_assert(offsetof(UP2AIPerceptionSystem, WorldStimuliSource) == 0x000150, "Member 'UP2AIPerceptionSystem::WorldStimuliSource' has a wrong offset!");

// Class AICommon.P2AISenseConfig_Danger
// 0x0010 (0x0058 - 0x0048)
class UP2AISenseConfig_Danger final : public UAISenseConfig
{
public:
	float                                         DetectionRadius;                                   // 0x0048(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, DisableEditOnInstance, NoClear, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FAISenseAffiliationFilter              DetectionByAffiliation;                            // 0x004C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, Config, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
	TSubclassOf<class UP2AISense_Danger>          Implementation;                                    // 0x0050(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, DisableEditOnInstance, NoClear, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"P2AISenseConfig_Danger">();
	}
	static class UP2AISenseConfig_Danger* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UP2AISenseConfig_Danger>();
	}
};
static_assert(alignof(UP2AISenseConfig_Danger) == 0x000008, "Wrong alignment on UP2AISenseConfig_Danger");
static_assert(sizeof(UP2AISenseConfig_Danger) == 0x000058, "Wrong size on UP2AISenseConfig_Danger");
static_assert(offsetof(UP2AISenseConfig_Danger, DetectionRadius) == 0x000048, "Member 'UP2AISenseConfig_Danger::DetectionRadius' has a wrong offset!");
static_assert(offsetof(UP2AISenseConfig_Danger, DetectionByAffiliation) == 0x00004C, "Member 'UP2AISenseConfig_Danger::DetectionByAffiliation' has a wrong offset!");
static_assert(offsetof(UP2AISenseConfig_Danger, Implementation) == 0x000050, "Member 'UP2AISenseConfig_Danger::Implementation' has a wrong offset!");

// Class AICommon.P2AISense_Danger
// 0x0060 (0x00E0 - 0x0080)
class UP2AISense_Danger final : public UAISense
{
public:
	uint8                                         Pad_80[0x60];                                      // 0x0080(0x0060)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"P2AISense_Danger">();
	}
	static class UP2AISense_Danger* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UP2AISense_Danger>();
	}
};
static_assert(alignof(UP2AISense_Danger) == 0x000008, "Wrong alignment on UP2AISense_Danger");
static_assert(sizeof(UP2AISense_Danger) == 0x0000E0, "Wrong size on UP2AISense_Danger");

// Class AICommon.P2AISenseEvent_Danger
// 0x0060 (0x0088 - 0x0028)
class UP2AISenseEvent_Danger final : public UAISenseEvent
{
public:
	struct FP2DangerEvent                         Event;                                             // 0x0028(0x0060)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"P2AISenseEvent_Danger">();
	}
	static class UP2AISenseEvent_Danger* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UP2AISenseEvent_Danger>();
	}
};
static_assert(alignof(UP2AISenseEvent_Danger) == 0x000008, "Wrong alignment on UP2AISenseEvent_Danger");
static_assert(sizeof(UP2AISenseEvent_Danger) == 0x000088, "Wrong size on UP2AISenseEvent_Danger");
static_assert(offsetof(UP2AISenseEvent_Danger, Event) == 0x000028, "Member 'UP2AISenseEvent_Danger::Event' has a wrong offset!");

// Class AICommon.P2AISenseConfig_Hearing
// 0x0018 (0x0078 - 0x0060)
class UP2AISenseConfig_Hearing final : public UAISenseConfig_Hearing
{
public:
	TArray<struct FP2HearingCurveTablePerStimulusTag> HearingCurveTablePerStimulus;                  // 0x0060(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	class UCurveFloat*                            VerticalDeltaToLoudnessMultiplierCurve;            // 0x0070(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"P2AISenseConfig_Hearing">();
	}
	static class UP2AISenseConfig_Hearing* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UP2AISenseConfig_Hearing>();
	}
};
static_assert(alignof(UP2AISenseConfig_Hearing) == 0x000008, "Wrong alignment on UP2AISenseConfig_Hearing");
static_assert(sizeof(UP2AISenseConfig_Hearing) == 0x000078, "Wrong size on UP2AISenseConfig_Hearing");
static_assert(offsetof(UP2AISenseConfig_Hearing, HearingCurveTablePerStimulus) == 0x000060, "Member 'UP2AISenseConfig_Hearing::HearingCurveTablePerStimulus' has a wrong offset!");
static_assert(offsetof(UP2AISenseConfig_Hearing, VerticalDeltaToLoudnessMultiplierCurve) == 0x000070, "Member 'UP2AISenseConfig_Hearing::VerticalDeltaToLoudnessMultiplierCurve' has a wrong offset!");

// Class AICommon.P2AISense_Hearing
// 0x0128 (0x0210 - 0x00E8)
class UP2AISense_Hearing final : public UAISense_Hearing
{
public:
	double                                        TickBudgetMs;                                      // 0x00E8(0x0008)(Edit, ZeroConstructor, Config, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	double                                        MaxAllowedDelayForBudgetingSec;                    // 0x00F0(0x0008)(Edit, ZeroConstructor, Config, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_F8[0xB8];                                      // 0x00F8(0x00B8)(Fixing Size After Last Property [ Dumper-7 ])
	class AP2AudioRoomsCluster*                   AudioRoomsCluster;                                 // 0x01B0(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_1B8[0x58];                                     // 0x01B8(0x0058)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static void ReportP2NoiseEvent(class UObject* WorldContextObject, const struct FVector& NoiseLocation, float Loudness, class AActor* Instigator, float MaxRange, class FName Tag, const struct FGameplayTagContainer& GameplayTags)	 // 0x473a034;

	void CacheListenersAudioRooms()	 // 0x4739fd4;

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"P2AISense_Hearing">();
	}
	static class UP2AISense_Hearing* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UP2AISense_Hearing>();
	}
};
static_assert(alignof(UP2AISense_Hearing) == 0x000008, "Wrong alignment on UP2AISense_Hearing");
static_assert(sizeof(UP2AISense_Hearing) == 0x000210, "Wrong size on UP2AISense_Hearing");
static_assert(offsetof(UP2AISense_Hearing, TickBudgetMs) == 0x0000E8, "Member 'UP2AISense_Hearing::TickBudgetMs' has a wrong offset!");
static_assert(offsetof(UP2AISense_Hearing, MaxAllowedDelayForBudgetingSec) == 0x0000F0, "Member 'UP2AISense_Hearing::MaxAllowedDelayForBudgetingSec' has a wrong offset!");
static_assert(offsetof(UP2AISense_Hearing, AudioRoomsCluster) == 0x0001B0, "Member 'UP2AISense_Hearing::AudioRoomsCluster' has a wrong offset!");

// Class AICommon.P2BTService_GetGroupLeader
// 0x0028 (0x0098 - 0x0070)
class UP2BTService_GetGroupLeader final : public UBTService
{
public:
	struct FBlackboardKeySelector                 GroupLeaderKey;                                    // 0x0070(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"P2BTService_GetGroupLeader">();
	}
	static class UP2BTService_GetGroupLeader* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UP2BTService_GetGroupLeader>();
	}
};
static_assert(alignof(UP2BTService_GetGroupLeader) == 0x000008, "Wrong alignment on UP2BTService_GetGroupLeader");
static_assert(sizeof(UP2BTService_GetGroupLeader) == 0x000098, "Wrong size on UP2BTService_GetGroupLeader");
static_assert(offsetof(UP2BTService_GetGroupLeader, GroupLeaderKey) == 0x000070, "Member 'UP2BTService_GetGroupLeader::GroupLeaderKey' has a wrong offset!");

// Class AICommon.P2AISenseConfig_Shared
// 0x0030 (0x0078 - 0x0048)
class UP2AISenseConfig_Shared final : public UAISenseConfig
{
public:
	TSubclassOf<class UP2AISense_Shared>          Implementation;                                    // 0x0048(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, DisableEditOnInstance, NoClear, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SenseRange;                                        // 0x0050(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_54[0x4];                                       // 0x0054(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTagContainer                  IgnoreActorsWithTags;                              // 0x0058(0x0020)(Edit, BlueprintVisible, BlueprintReadOnly, Config, DisableEditOnInstance, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"P2AISenseConfig_Shared">();
	}
	static class UP2AISenseConfig_Shared* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UP2AISenseConfig_Shared>();
	}
};
static_assert(alignof(UP2AISenseConfig_Shared) == 0x000008, "Wrong alignment on UP2AISenseConfig_Shared");
static_assert(sizeof(UP2AISenseConfig_Shared) == 0x000078, "Wrong size on UP2AISenseConfig_Shared");
static_assert(offsetof(UP2AISenseConfig_Shared, Implementation) == 0x000048, "Member 'UP2AISenseConfig_Shared::Implementation' has a wrong offset!");
static_assert(offsetof(UP2AISenseConfig_Shared, SenseRange) == 0x000050, "Member 'UP2AISenseConfig_Shared::SenseRange' has a wrong offset!");
static_assert(offsetof(UP2AISenseConfig_Shared, IgnoreActorsWithTags) == 0x000058, "Member 'UP2AISenseConfig_Shared::IgnoreActorsWithTags' has a wrong offset!");

// Class AICommon.P2AISenseEvent_Shared
// 0x0038 (0x0060 - 0x0028)
class UP2AISenseEvent_Shared final : public UAISenseEvent
{
public:
	uint8                                         Pad_28[0x38];                                      // 0x0028(0x0038)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"P2AISenseEvent_Shared">();
	}
	static class UP2AISenseEvent_Shared* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UP2AISenseEvent_Shared>();
	}
};
static_assert(alignof(UP2AISenseEvent_Shared) == 0x000008, "Wrong alignment on UP2AISenseEvent_Shared");
static_assert(sizeof(UP2AISenseEvent_Shared) == 0x000060, "Wrong size on UP2AISenseEvent_Shared");

// Class AICommon.P2BTService_Cover
// 0x0038 (0x00A8 - 0x0070)
class UP2BTService_Cover final : public UBTService
{
public:
	struct FBlackboardKeySelector                 BBCoverPoint;                                      // 0x0070(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)
	float                                         MinSuppressedTimeToHide;                           // 0x0098(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MinHiddenTime;                                     // 0x009C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         AdjustmentMaxDist;                                 // 0x00A0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bUseWeaponObstruction;                             // 0x00A4(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_A5[0x3];                                       // 0x00A5(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"P2BTService_Cover">();
	}
	static class UP2BTService_Cover* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UP2BTService_Cover>();
	}
};
static_assert(alignof(UP2BTService_Cover) == 0x000008, "Wrong alignment on UP2BTService_Cover");
static_assert(sizeof(UP2BTService_Cover) == 0x0000A8, "Wrong size on UP2BTService_Cover");
static_assert(offsetof(UP2BTService_Cover, BBCoverPoint) == 0x000070, "Member 'UP2BTService_Cover::BBCoverPoint' has a wrong offset!");
static_assert(offsetof(UP2BTService_Cover, MinSuppressedTimeToHide) == 0x000098, "Member 'UP2BTService_Cover::MinSuppressedTimeToHide' has a wrong offset!");
static_assert(offsetof(UP2BTService_Cover, MinHiddenTime) == 0x00009C, "Member 'UP2BTService_Cover::MinHiddenTime' has a wrong offset!");
static_assert(offsetof(UP2BTService_Cover, AdjustmentMaxDist) == 0x0000A0, "Member 'UP2BTService_Cover::AdjustmentMaxDist' has a wrong offset!");
static_assert(offsetof(UP2BTService_Cover, bUseWeaponObstruction) == 0x0000A4, "Member 'UP2BTService_Cover::bUseWeaponObstruction' has a wrong offset!");

// Class AICommon.P2AISense_Shared
// 0x0060 (0x00E0 - 0x0080)
class UP2AISense_Shared final : public UAISense
{
public:
	uint8                                         Pad_80[0x60];                                      // 0x0080(0x0060)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static void SharePerception(class UObject* WorldContextObject, class AActor* Instigator, float MaxShareDistance)	 // 0x473a3ec;

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"P2AISense_Shared">();
	}
	static class UP2AISense_Shared* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UP2AISense_Shared>();
	}
};
static_assert(alignof(UP2AISense_Shared) == 0x000008, "Wrong alignment on UP2AISense_Shared");
static_assert(sizeof(UP2AISense_Shared) == 0x0000E0, "Wrong size on UP2AISense_Shared");

// Class AICommon.P2BTService_GhostBase
// 0x0048 (0x00B8 - 0x0070)
class UP2BTService_GhostBase : public UBTService
{
public:
	struct FGameplayTagContainer                  BlockTags;                                         // 0x0070(0x0020)(Edit, Protected, NativeAccessSpecifierProtected)
	struct FBlackboardKeySelector                 BBTarget;                                          // 0x0090(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"P2BTService_GhostBase">();
	}
	static class UP2BTService_GhostBase* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UP2BTService_GhostBase>();
	}
};
static_assert(alignof(UP2BTService_GhostBase) == 0x000008, "Wrong alignment on UP2BTService_GhostBase");
static_assert(sizeof(UP2BTService_GhostBase) == 0x0000B8, "Wrong size on UP2BTService_GhostBase");
static_assert(offsetof(UP2BTService_GhostBase, BlockTags) == 0x000070, "Member 'UP2BTService_GhostBase::BlockTags' has a wrong offset!");
static_assert(offsetof(UP2BTService_GhostBase, BBTarget) == 0x000090, "Member 'UP2BTService_GhostBase::BBTarget' has a wrong offset!");

// Class AICommon.P2BTService_GhostCrouch
// 0x0000 (0x00B8 - 0x00B8)
class UP2BTService_GhostCrouch final : public UP2BTService_GhostBase
{
public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"P2BTService_GhostCrouch">();
	}
	static class UP2BTService_GhostCrouch* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UP2BTService_GhostCrouch>();
	}
};
static_assert(alignof(UP2BTService_GhostCrouch) == 0x000008, "Wrong alignment on UP2BTService_GhostCrouch");
static_assert(sizeof(UP2BTService_GhostCrouch) == 0x0000B8, "Wrong size on UP2BTService_GhostCrouch");

// Class AICommon.P2AISenseConfig_Sight
// 0x0018 (0x0088 - 0x0070)
class UP2AISenseConfig_Sight final : public UAISenseConfig_Sight
{
public:
	float                                         SpottingRadius;                                    // 0x0070(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SpottingPeripheralVisionAngleDegrees;              // 0x0074(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCurveFloat*                            DistanceStrengthCurve;                             // 0x0078(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCurveFloat*                            DirectionStrengthCurve;                            // 0x0080(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"P2AISenseConfig_Sight">();
	}
	static class UP2AISenseConfig_Sight* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UP2AISenseConfig_Sight>();
	}
};
static_assert(alignof(UP2AISenseConfig_Sight) == 0x000008, "Wrong alignment on UP2AISenseConfig_Sight");
static_assert(sizeof(UP2AISenseConfig_Sight) == 0x000088, "Wrong size on UP2AISenseConfig_Sight");
static_assert(offsetof(UP2AISenseConfig_Sight, SpottingRadius) == 0x000070, "Member 'UP2AISenseConfig_Sight::SpottingRadius' has a wrong offset!");
static_assert(offsetof(UP2AISenseConfig_Sight, SpottingPeripheralVisionAngleDegrees) == 0x000074, "Member 'UP2AISenseConfig_Sight::SpottingPeripheralVisionAngleDegrees' has a wrong offset!");
static_assert(offsetof(UP2AISenseConfig_Sight, DistanceStrengthCurve) == 0x000078, "Member 'UP2AISenseConfig_Sight::DistanceStrengthCurve' has a wrong offset!");
static_assert(offsetof(UP2AISenseConfig_Sight, DirectionStrengthCurve) == 0x000080, "Member 'UP2AISenseConfig_Sight::DirectionStrengthCurve' has a wrong offset!");

// Class AICommon.P2BlackboardValueModifier
// 0x0028 (0x0050 - 0x0028)
class UP2BlackboardValueModifier : public UObject
{
public:
	struct FBlackboardKeySelector                 Key;                                               // 0x0028(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"P2BlackboardValueModifier">();
	}
	static class UP2BlackboardValueModifier* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UP2BlackboardValueModifier>();
	}
};
static_assert(alignof(UP2BlackboardValueModifier) == 0x000008, "Wrong alignment on UP2BlackboardValueModifier");
static_assert(sizeof(UP2BlackboardValueModifier) == 0x000050, "Wrong size on UP2BlackboardValueModifier");
static_assert(offsetof(UP2BlackboardValueModifier, Key) == 0x000028, "Member 'UP2BlackboardValueModifier::Key' has a wrong offset!");

// Class AICommon.P2BlackboardValueModifier_SetBase
// 0x0000 (0x0050 - 0x0050)
class UP2BlackboardValueModifier_SetBase : public UP2BlackboardValueModifier
{
public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"P2BlackboardValueModifier_SetBase">();
	}
	static class UP2BlackboardValueModifier_SetBase* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UP2BlackboardValueModifier_SetBase>();
	}
};
static_assert(alignof(UP2BlackboardValueModifier_SetBase) == 0x000008, "Wrong alignment on UP2BlackboardValueModifier_SetBase");
static_assert(sizeof(UP2BlackboardValueModifier_SetBase) == 0x000050, "Wrong size on UP2BlackboardValueModifier_SetBase");

// Class AICommon.P2AISense_Sight
// 0x0050 (0x0200 - 0x01B0)
class UP2AISense_Sight final : public UAISense_Sight
{
public:
	uint8                                         Pad_1B0[0x50];                                     // 0x01B0(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"P2AISense_Sight">();
	}
	static class UP2AISense_Sight* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UP2AISense_Sight>();
	}
};
static_assert(alignof(UP2AISense_Sight) == 0x000008, "Wrong alignment on UP2AISense_Sight");
static_assert(sizeof(UP2AISense_Sight) == 0x000200, "Wrong size on UP2AISense_Sight");

// Class AICommon.P2JumpLinkGenerator
// 0x0000 (0x0028 - 0x0028)
class UP2JumpLinkGenerator final : public UObject
{
public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"P2JumpLinkGenerator">();
	}
	static class UP2JumpLinkGenerator* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UP2JumpLinkGenerator>();
	}
};
static_assert(alignof(UP2JumpLinkGenerator) == 0x000008, "Wrong alignment on UP2JumpLinkGenerator");
static_assert(sizeof(UP2JumpLinkGenerator) == 0x000028, "Wrong size on UP2JumpLinkGenerator");

// Class AICommon.P2AISense_Sight_APS
// 0x0000 (0x01B0 - 0x01B0)
class UP2AISense_Sight_APS final : public UAISense_Sight
{
public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"P2AISense_Sight_APS">();
	}
	static class UP2AISense_Sight_APS* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UP2AISense_Sight_APS>();
	}
};
static_assert(alignof(UP2AISense_Sight_APS) == 0x000008, "Wrong alignment on UP2AISense_Sight_APS");
static_assert(sizeof(UP2AISense_Sight_APS) == 0x0001B0, "Wrong size on UP2AISense_Sight_APS");

// Class AICommon.P2BTService_GhostUtility
// 0x0180 (0x0238 - 0x00B8)
class UP2BTService_GhostUtility final : public UP2BTService_GhostBase
{
public:
	class UEnvQuery*                              QueryTemplate;                                     // 0x00B8(0x0008)(Edit, ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FBlackboardKeySelector                 BBUtilityAllowed;                                  // 0x00C0(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)
	struct FBlackboardKeySelector                 BBUtilityReady;                                    // 0x00E8(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)
	struct FBlackboardKeySelector                 BBUtilityThrowVelocity;                            // 0x0110(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)
	bool                                          bClearUtilityOnFail;                               // 0x0138(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_139[0x3];                                      // 0x0139(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         DelayBetweenChoices;                               // 0x013C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_140[0xF8];                                     // 0x0140(0x00F8)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"P2BTService_GhostUtility">();
	}
	static class UP2BTService_GhostUtility* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UP2BTService_GhostUtility>();
	}
};
static_assert(alignof(UP2BTService_GhostUtility) == 0x000008, "Wrong alignment on UP2BTService_GhostUtility");
static_assert(sizeof(UP2BTService_GhostUtility) == 0x000238, "Wrong size on UP2BTService_GhostUtility");
static_assert(offsetof(UP2BTService_GhostUtility, QueryTemplate) == 0x0000B8, "Member 'UP2BTService_GhostUtility::QueryTemplate' has a wrong offset!");
static_assert(offsetof(UP2BTService_GhostUtility, BBUtilityAllowed) == 0x0000C0, "Member 'UP2BTService_GhostUtility::BBUtilityAllowed' has a wrong offset!");
static_assert(offsetof(UP2BTService_GhostUtility, BBUtilityReady) == 0x0000E8, "Member 'UP2BTService_GhostUtility::BBUtilityReady' has a wrong offset!");
static_assert(offsetof(UP2BTService_GhostUtility, BBUtilityThrowVelocity) == 0x000110, "Member 'UP2BTService_GhostUtility::BBUtilityThrowVelocity' has a wrong offset!");
static_assert(offsetof(UP2BTService_GhostUtility, bClearUtilityOnFail) == 0x000138, "Member 'UP2BTService_GhostUtility::bClearUtilityOnFail' has a wrong offset!");
static_assert(offsetof(UP2BTService_GhostUtility, DelayBetweenChoices) == 0x00013C, "Member 'UP2BTService_GhostUtility::DelayBetweenChoices' has a wrong offset!");

// Class AICommon.P2AISenseConfig_Sight_V2
// 0x0008 (0x0078 - 0x0070)
class UP2AISenseConfig_Sight_V2 final : public UAISenseConfig_Sight
{
public:
	class UP2SightSenseData*                      SenseDataAsset;                                    // 0x0070(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"P2AISenseConfig_Sight_V2">();
	}
	static class UP2AISenseConfig_Sight_V2* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UP2AISenseConfig_Sight_V2>();
	}
};
static_assert(alignof(UP2AISenseConfig_Sight_V2) == 0x000008, "Wrong alignment on UP2AISenseConfig_Sight_V2");
static_assert(sizeof(UP2AISenseConfig_Sight_V2) == 0x000078, "Wrong size on UP2AISenseConfig_Sight_V2");
static_assert(offsetof(UP2AISenseConfig_Sight_V2, SenseDataAsset) == 0x000070, "Member 'UP2AISenseConfig_Sight_V2::SenseDataAsset' has a wrong offset!");

// Class AICommon.P2AISense_Sight_V2
// 0x0150 (0x0300 - 0x01B0)
class UP2AISense_Sight_V2 final : public UAISense_Sight
{
public:
	double                                        MaxDistanceToCheckLightSources;                    // 0x01B0(0x0008)(Edit, ZeroConstructor, Config, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         FlashlightAngleMultiplier;                         // 0x01B8(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         FlashlightRadiusMultiplier;                        // 0x01BC(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1C0[0x140];                                    // 0x01C0(0x0140)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"P2AISense_Sight_V2">();
	}
	static class UP2AISense_Sight_V2* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UP2AISense_Sight_V2>();
	}
};
static_assert(alignof(UP2AISense_Sight_V2) == 0x000008, "Wrong alignment on UP2AISense_Sight_V2");
static_assert(sizeof(UP2AISense_Sight_V2) == 0x000300, "Wrong size on UP2AISense_Sight_V2");
static_assert(offsetof(UP2AISense_Sight_V2, MaxDistanceToCheckLightSources) == 0x0001B0, "Member 'UP2AISense_Sight_V2::MaxDistanceToCheckLightSources' has a wrong offset!");
static_assert(offsetof(UP2AISense_Sight_V2, FlashlightAngleMultiplier) == 0x0001B8, "Member 'UP2AISense_Sight_V2::FlashlightAngleMultiplier' has a wrong offset!");
static_assert(offsetof(UP2AISense_Sight_V2, FlashlightRadiusMultiplier) == 0x0001BC, "Member 'UP2AISense_Sight_V2::FlashlightRadiusMultiplier' has a wrong offset!");

// Class AICommon.P2BTService_GhostAimDirection
// 0x0060 (0x0118 - 0x00B8)
class UP2BTService_GhostAimDirection final : public UP2BTService_GhostBase
{
public:
	float                                         PathLengthToForceMovementDirection;                // 0x00B8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_BC[0x4];                                       // 0x00BC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FBlackboardKeySelector                 BBFocalPointOverride;                              // 0x00C0(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)
	bool                                          bUseFormationDirectionWhileMoving;                 // 0x00E8(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_E9[0x7];                                       // 0x00E9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector2D                              LookAtFormationDirectionRate;                      // 0x00F0(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector2D                              LookAtFormationDirectionDuration;                  // 0x0100(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bCanApplySway;                                     // 0x0110(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_111[0x7];                                      // 0x0111(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"P2BTService_GhostAimDirection">();
	}
	static class UP2BTService_GhostAimDirection* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UP2BTService_GhostAimDirection>();
	}
};
static_assert(alignof(UP2BTService_GhostAimDirection) == 0x000008, "Wrong alignment on UP2BTService_GhostAimDirection");
static_assert(sizeof(UP2BTService_GhostAimDirection) == 0x000118, "Wrong size on UP2BTService_GhostAimDirection");
static_assert(offsetof(UP2BTService_GhostAimDirection, PathLengthToForceMovementDirection) == 0x0000B8, "Member 'UP2BTService_GhostAimDirection::PathLengthToForceMovementDirection' has a wrong offset!");
static_assert(offsetof(UP2BTService_GhostAimDirection, BBFocalPointOverride) == 0x0000C0, "Member 'UP2BTService_GhostAimDirection::BBFocalPointOverride' has a wrong offset!");
static_assert(offsetof(UP2BTService_GhostAimDirection, bUseFormationDirectionWhileMoving) == 0x0000E8, "Member 'UP2BTService_GhostAimDirection::bUseFormationDirectionWhileMoving' has a wrong offset!");
static_assert(offsetof(UP2BTService_GhostAimDirection, LookAtFormationDirectionRate) == 0x0000F0, "Member 'UP2BTService_GhostAimDirection::LookAtFormationDirectionRate' has a wrong offset!");
static_assert(offsetof(UP2BTService_GhostAimDirection, LookAtFormationDirectionDuration) == 0x000100, "Member 'UP2BTService_GhostAimDirection::LookAtFormationDirectionDuration' has a wrong offset!");
static_assert(offsetof(UP2BTService_GhostAimDirection, bCanApplySway) == 0x000110, "Member 'UP2BTService_GhostAimDirection::bCanApplySway' has a wrong offset!");

// Class AICommon.P2HeroNoiseSourceComponent
// 0x0008 (0x00D0 - 0x00C8)
class UP2HeroNoiseSourceComponent : public UP2PawnComponent
{
public:
	class UP2HeroNoiseSourceConfig*               NoiseSourceConfig;                                 // 0x00C8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	void OnAbilityActivated(class UGameplayAbility* Ability)	 // 0x4757d64;
	void OnJumped()	 // 0x4757fb4;
	void OnLanded(const struct FHitResult& Hit)	 // 0x4757fc8;

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"P2HeroNoiseSourceComponent">();
	}
	static class UP2HeroNoiseSourceComponent* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UP2HeroNoiseSourceComponent>();
	}
};
static_assert(alignof(UP2HeroNoiseSourceComponent) == 0x000008, "Wrong alignment on UP2HeroNoiseSourceComponent");
static_assert(sizeof(UP2HeroNoiseSourceComponent) == 0x0000D0, "Wrong size on UP2HeroNoiseSourceComponent");
static_assert(offsetof(UP2HeroNoiseSourceComponent, NoiseSourceConfig) == 0x0000C8, "Member 'UP2HeroNoiseSourceComponent::NoiseSourceConfig' has a wrong offset!");

// Class AICommon.P2AISenseConfig_Smell
// 0x0010 (0x0058 - 0x0048)
class UP2AISenseConfig_Smell final : public UAISenseConfig
{
public:
	TSubclassOf<class UP2AISense_Smell>           Implementation;                                    // 0x0048(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, DisableEditOnInstance, NoClear, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SmellRange;                                        // 0x0050(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FAISenseAffiliationFilter              DetectionByAffiliation;                            // 0x0054(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, Config, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"P2AISenseConfig_Smell">();
	}
	static class UP2AISenseConfig_Smell* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UP2AISenseConfig_Smell>();
	}
};
static_assert(alignof(UP2AISenseConfig_Smell) == 0x000008, "Wrong alignment on UP2AISenseConfig_Smell");
static_assert(sizeof(UP2AISenseConfig_Smell) == 0x000058, "Wrong size on UP2AISenseConfig_Smell");
static_assert(offsetof(UP2AISenseConfig_Smell, Implementation) == 0x000048, "Member 'UP2AISenseConfig_Smell::Implementation' has a wrong offset!");
static_assert(offsetof(UP2AISenseConfig_Smell, SmellRange) == 0x000050, "Member 'UP2AISenseConfig_Smell::SmellRange' has a wrong offset!");
static_assert(offsetof(UP2AISenseConfig_Smell, DetectionByAffiliation) == 0x000054, "Member 'UP2AISenseConfig_Smell::DetectionByAffiliation' has a wrong offset!");

// Class AICommon.P2AISense_Smell
// 0x0050 (0x00D0 - 0x0080)
class UP2AISense_Smell final : public UAISense
{
public:
	uint8                                         Pad_80[0x50];                                      // 0x0080(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"P2AISense_Smell">();
	}
	static class UP2AISense_Smell* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UP2AISense_Smell>();
	}
};
static_assert(alignof(UP2AISense_Smell) == 0x000008, "Wrong alignment on UP2AISense_Smell");
static_assert(sizeof(UP2AISense_Smell) == 0x0000D0, "Wrong size on UP2AISense_Smell");

// Class AICommon.P2BTDecorator_HasAttackTicket
// 0x0030 (0x0098 - 0x0068)
class UP2BTDecorator_HasAttackTicket final : public UBTDecorator
{
public:
	struct FBlackboardKeySelector                 TargetKey;                                         // 0x0068(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	float                                         TickInterval;                                      // 0x0090(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_94[0x4];                                       // 0x0094(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"P2BTDecorator_HasAttackTicket">();
	}
	static class UP2BTDecorator_HasAttackTicket* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UP2BTDecorator_HasAttackTicket>();
	}
};
static_assert(alignof(UP2BTDecorator_HasAttackTicket) == 0x000008, "Wrong alignment on UP2BTDecorator_HasAttackTicket");
static_assert(sizeof(UP2BTDecorator_HasAttackTicket) == 0x000098, "Wrong size on UP2BTDecorator_HasAttackTicket");
static_assert(offsetof(UP2BTDecorator_HasAttackTicket, TargetKey) == 0x000068, "Member 'UP2BTDecorator_HasAttackTicket::TargetKey' has a wrong offset!");
static_assert(offsetof(UP2BTDecorator_HasAttackTicket, TickInterval) == 0x000090, "Member 'UP2BTDecorator_HasAttackTicket::TickInterval' has a wrong offset!");

// Class AICommon.P2AISenseConfig_Suppression
// 0x0010 (0x0058 - 0x0048)
class UP2AISenseConfig_Suppression final : public UAISenseConfig
{
public:
	float                                         DetectionRadius;                                   // 0x0048(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, DisableEditOnInstance, NoClear, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FAISenseAffiliationFilter              DetectionByAffiliation;                            // 0x004C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, Config, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
	TSubclassOf<class UP2AISense_Suppression>     Implementation;                                    // 0x0050(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, DisableEditOnInstance, NoClear, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"P2AISenseConfig_Suppression">();
	}
	static class UP2AISenseConfig_Suppression* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UP2AISenseConfig_Suppression>();
	}
};
static_assert(alignof(UP2AISenseConfig_Suppression) == 0x000008, "Wrong alignment on UP2AISenseConfig_Suppression");
static_assert(sizeof(UP2AISenseConfig_Suppression) == 0x000058, "Wrong size on UP2AISenseConfig_Suppression");
static_assert(offsetof(UP2AISenseConfig_Suppression, DetectionRadius) == 0x000048, "Member 'UP2AISenseConfig_Suppression::DetectionRadius' has a wrong offset!");
static_assert(offsetof(UP2AISenseConfig_Suppression, DetectionByAffiliation) == 0x00004C, "Member 'UP2AISenseConfig_Suppression::DetectionByAffiliation' has a wrong offset!");
static_assert(offsetof(UP2AISenseConfig_Suppression, Implementation) == 0x000050, "Member 'UP2AISenseConfig_Suppression::Implementation' has a wrong offset!");

// Class AICommon.P2AISense_Suppression
// 0x0070 (0x00F0 - 0x0080)
class UP2AISense_Suppression final : public UAISense
{
public:
	uint8                                         Pad_80[0x70];                                      // 0x0080(0x0070)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"P2AISense_Suppression">();
	}
	static class UP2AISense_Suppression* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UP2AISense_Suppression>();
	}
};
static_assert(alignof(UP2AISense_Suppression) == 0x000008, "Wrong alignment on UP2AISense_Suppression");
static_assert(sizeof(UP2AISense_Suppression) == 0x0000F0, "Wrong size on UP2AISense_Suppression");

// Class AICommon.P2BTService_OverrideSensesConfig
// 0x0008 (0x0078 - 0x0070)
class UP2BTService_OverrideSensesConfig final : public UBTService
{
public:
	class UP2NpcSensesConfig*                     SensesConfigDataAsset;                             // 0x0070(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"P2BTService_OverrideSensesConfig">();
	}
	static class UP2BTService_OverrideSensesConfig* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UP2BTService_OverrideSensesConfig>();
	}
};
static_assert(alignof(UP2BTService_OverrideSensesConfig) == 0x000008, "Wrong alignment on UP2BTService_OverrideSensesConfig");
static_assert(sizeof(UP2BTService_OverrideSensesConfig) == 0x000078, "Wrong size on UP2BTService_OverrideSensesConfig");
static_assert(offsetof(UP2BTService_OverrideSensesConfig, SensesConfigDataAsset) == 0x000070, "Member 'UP2BTService_OverrideSensesConfig::SensesConfigDataAsset' has a wrong offset!");

// Class AICommon.P2AISenseEvent_Suppression
// 0x0070 (0x0098 - 0x0028)
class UP2AISenseEvent_Suppression final : public UAISenseEvent
{
public:
	struct FP2AISuppressionEvent                  Event;                                             // 0x0028(0x0070)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"P2AISenseEvent_Suppression">();
	}
	static class UP2AISenseEvent_Suppression* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UP2AISenseEvent_Suppression>();
	}
};
static_assert(alignof(UP2AISenseEvent_Suppression) == 0x000008, "Wrong alignment on UP2AISenseEvent_Suppression");
static_assert(sizeof(UP2AISenseEvent_Suppression) == 0x000098, "Wrong size on UP2AISenseEvent_Suppression");
static_assert(offsetof(UP2AISenseEvent_Suppression, Event) == 0x000028, "Member 'UP2AISenseEvent_Suppression::Event' has a wrong offset!");

// Class AICommon.P2AISettings
// 0x0000 (0x0038 - 0x0038)
class UP2AISettings final : public UDeveloperSettings
{
public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"P2AISettings">();
	}
	static class UP2AISettings* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UP2AISettings>();
	}
};
static_assert(alignof(UP2AISettings) == 0x000008, "Wrong alignment on UP2AISettings");
static_assert(sizeof(UP2AISettings) == 0x000038, "Wrong size on UP2AISettings");

// Class AICommon.P2BTDecorator_IsAbilityActiveByClass
// 0x0028 (0x0090 - 0x0068)
class UP2BTDecorator_IsAbilityActiveByClass final : public UBTDecorator
{
public:
	TSubclassOf<class UP2NpcAbility>              AbilityClass;                                      // 0x0068(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_70[0x20];                                      // 0x0070(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void AbilityStatusChanged(class UGameplayAbility* Ability) const	 // 0x473dc60;

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"P2BTDecorator_IsAbilityActiveByClass">();
	}
	static class UP2BTDecorator_IsAbilityActiveByClass* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UP2BTDecorator_IsAbilityActiveByClass>();
	}
};
static_assert(alignof(UP2BTDecorator_IsAbilityActiveByClass) == 0x000008, "Wrong alignment on UP2BTDecorator_IsAbilityActiveByClass");
static_assert(sizeof(UP2BTDecorator_IsAbilityActiveByClass) == 0x000090, "Wrong size on UP2BTDecorator_IsAbilityActiveByClass");
static_assert(offsetof(UP2BTDecorator_IsAbilityActiveByClass, AbilityClass) == 0x000068, "Member 'UP2BTDecorator_IsAbilityActiveByClass::AbilityClass' has a wrong offset!");

// Class AICommon.P2AISignificanceSubsystem
// 0x0008 (0x0048 - 0x0040)
class UP2AISignificanceSubsystem final : public UTickableWorldSubsystem
{
public:
	class USignificanceManager*                   SignificanceManager;                               // 0x0040(0x0008)(ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"P2AISignificanceSubsystem">();
	}
	static class UP2AISignificanceSubsystem* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UP2AISignificanceSubsystem>();
	}
};
static_assert(alignof(UP2AISignificanceSubsystem) == 0x000008, "Wrong alignment on UP2AISignificanceSubsystem");
static_assert(sizeof(UP2AISignificanceSubsystem) == 0x000048, "Wrong size on UP2AISignificanceSubsystem");
static_assert(offsetof(UP2AISignificanceSubsystem, SignificanceManager) == 0x000040, "Member 'UP2AISignificanceSubsystem::SignificanceManager' has a wrong offset!");

// Class AICommon.P2AIStimuliSource_World
// 0x0008 (0x02B8 - 0x02B0)
class AP2AIStimuliSource_World final : public AActor
{
public:
	uint8                                         Pad_2B0[0x8];                                      // 0x02B0(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"P2AIStimuliSource_World">();
	}
	static class AP2AIStimuliSource_World* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<AP2AIStimuliSource_World>();
	}
};
static_assert(alignof(AP2AIStimuliSource_World) == 0x000008, "Wrong alignment on AP2AIStimuliSource_World");
static_assert(sizeof(AP2AIStimuliSource_World) == 0x0002B8, "Wrong size on AP2AIStimuliSource_World");

// Class AICommon.P2BlackboardValueModifier_SetClass
// 0x0008 (0x0058 - 0x0050)
class UP2BlackboardValueModifier_SetClass final : public UP2BlackboardValueModifier_SetBase
{
public:
	TSubclassOf<class UObject>                    Class_0;                                           // 0x0050(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"P2BlackboardValueModifier_SetClass">();
	}
	static class UP2BlackboardValueModifier_SetClass* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UP2BlackboardValueModifier_SetClass>();
	}
};
static_assert(alignof(UP2BlackboardValueModifier_SetClass) == 0x000008, "Wrong alignment on UP2BlackboardValueModifier_SetClass");
static_assert(sizeof(UP2BlackboardValueModifier_SetClass) == 0x000058, "Wrong size on UP2BlackboardValueModifier_SetClass");
static_assert(offsetof(UP2BlackboardValueModifier_SetClass, Class_0) == 0x000050, "Member 'UP2BlackboardValueModifier_SetClass::Class_0' has a wrong offset!");

// Class AICommon.P2AISystem
// 0x0028 (0x0198 - 0x0170)
class UP2AISystem final : public UAISystem
{
public:
	struct FSoftClassPath                         AIDirectorClassName;                               // 0x0170(0x0020)(Edit, ZeroConstructor, Config, GlobalConfig, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UP2AIDirector*                          AIDirector;                                        // 0x0190(0x0008)(ZeroConstructor, Transient, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"P2AISystem">();
	}
	static class UP2AISystem* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UP2AISystem>();
	}
};
static_assert(alignof(UP2AISystem) == 0x000008, "Wrong alignment on UP2AISystem");
static_assert(sizeof(UP2AISystem) == 0x000198, "Wrong size on UP2AISystem");
static_assert(offsetof(UP2AISystem, AIDirectorClassName) == 0x000170, "Member 'UP2AISystem::AIDirectorClassName' has a wrong offset!");
static_assert(offsetof(UP2AISystem, AIDirector) == 0x000190, "Member 'UP2AISystem::AIDirector' has a wrong offset!");

// Class AICommon.P2AITickManagerSubsystem
// 0x0110 (0x0150 - 0x0040)
class UP2AITickManagerSubsystem final : public UTickableWorldSubsystem
{
public:
	uint8                                         Pad_40[0xE4];                                      // 0x0040(0x00E4)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ElasticBudget;                                     // 0x0124(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint32                                        Strides[0x4];                                      // 0x0128(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_138[0x18];                                     // 0x0138(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"P2AITickManagerSubsystem">();
	}
	static class UP2AITickManagerSubsystem* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UP2AITickManagerSubsystem>();
	}
};
static_assert(alignof(UP2AITickManagerSubsystem) == 0x000008, "Wrong alignment on UP2AITickManagerSubsystem");
static_assert(sizeof(UP2AITickManagerSubsystem) == 0x000150, "Wrong size on UP2AITickManagerSubsystem");
static_assert(offsetof(UP2AITickManagerSubsystem, ElasticBudget) == 0x000124, "Member 'UP2AITickManagerSubsystem::ElasticBudget' has a wrong offset!");
static_assert(offsetof(UP2AITickManagerSubsystem, Strides) == 0x000128, "Member 'UP2AITickManagerSubsystem::Strides' has a wrong offset!");

// Class AICommon.P2BTService_ReserveMeleeSlot
// 0x0030 (0x00A0 - 0x0070)
class UP2BTService_ReserveMeleeSlot final : public UBTService
{
public:
	struct FBlackboardKeySelector                 SlotKey;                                           // 0x0070(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	TWeakObjectPtr<class UP2MeleeTargetSlot>      Slot;                                              // 0x0098(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"P2BTService_ReserveMeleeSlot">();
	}
	static class UP2BTService_ReserveMeleeSlot* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UP2BTService_ReserveMeleeSlot>();
	}
};
static_assert(alignof(UP2BTService_ReserveMeleeSlot) == 0x000008, "Wrong alignment on UP2BTService_ReserveMeleeSlot");
static_assert(sizeof(UP2BTService_ReserveMeleeSlot) == 0x0000A0, "Wrong size on UP2BTService_ReserveMeleeSlot");
static_assert(offsetof(UP2BTService_ReserveMeleeSlot, SlotKey) == 0x000070, "Member 'UP2BTService_ReserveMeleeSlot::SlotKey' has a wrong offset!");
static_assert(offsetof(UP2BTService_ReserveMeleeSlot, Slot) == 0x000098, "Member 'UP2BTService_ReserveMeleeSlot::Slot' has a wrong offset!");

// Class AICommon.P2NpcAnimInstance
// 0x0210 (0x0560 - 0x0350)
class UP2NpcAnimInstance : public UAnimInstance
{
public:
	struct FGameplayTagBlueprintPropertyMap       GameplayTagPropertyMap;                            // 0x0348(0x0020)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	TMap<struct FGameplayTag, int32>              StanceTagToIndexMap;                               // 0x0368(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FP2AnimSpeedBounds                     SneakBounds;                                       // 0x03B8(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, Protected, NativeAccessSpecifierProtected)
	float                                         SneakPlayRate;                                     // 0x03C4(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FP2AnimSpeedBounds                     WalkBounds;                                        // 0x03C8(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, Protected, NativeAccessSpecifierProtected)
	float                                         WalkPlayRate;                                      // 0x03D4(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FP2AnimSpeedBounds                     TrotBounds;                                        // 0x03D8(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, Protected, NativeAccessSpecifierProtected)
	float                                         TrotPlayRate;                                      // 0x03E4(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FP2AnimSpeedBounds                     RunBounds;                                         // 0x03E8(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, Protected, NativeAccessSpecifierProtected)
	float                                         RunPlayRate;                                       // 0x03F4(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   RootBoneName;                                      // 0x03F8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         CurvatureInterpSpeed;                              // 0x0400(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         Speed2D;                                           // 0x0404(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FGameplayTag                           CurrentStance;                                     // 0x0408(0x0008)(BlueprintVisible, BlueprintReadOnly, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         CurrentStanceIndex;                                // 0x0410(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         bIsMoving2D : 1;                                   // 0x0414(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (BlueprintVisible, BlueprintReadOnly, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bIsPlayingRootMotion : 1;                          // 0x0414(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (BlueprintVisible, BlueprintReadOnly, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bIsSneaking : 1;                                   // 0x0414(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (BlueprintVisible, BlueprintReadOnly, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bIsTrotting : 1;                                   // 0x0414(0x0001)(BitIndex: 0x03, PropSize: 0x0001 (BlueprintVisible, BlueprintReadOnly, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bIsWalking : 1;                                    // 0x0414(0x0001)(BitIndex: 0x04, PropSize: 0x0001 (BlueprintVisible, BlueprintReadOnly, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bIsStalking : 1;                                   // 0x0414(0x0001)(BitIndex: 0x05, PropSize: 0x0001 (BlueprintVisible, BlueprintReadOnly, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         Pad_415[0x3];                                      // 0x0415(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRotator                               AimRotation;                                       // 0x0418(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)
	struct FRotator                               AimRotationDelta;                                  // 0x0430(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)
	float                                         PathCurvature;                                     // 0x0448(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_44C[0x4];                                      // 0x044C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                GroundNormalVector;                                // 0x0450(0x0018)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FRotator                               RootGroundRotation;                                // 0x0468(0x0018)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)
	float                                         GroundDistance;                                    // 0x0480(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         LocalVelocityYaw;                                  // 0x0484(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         RootYawOffset;                                     // 0x0488(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   LookingSocketName;                                 // 0x048C(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   RootSocketName;                                    // 0x0494(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FFloatRange                            LookAtYawRange;                                    // 0x049C(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FFloatRange                            LookAtPitchRange;                                  // 0x04AC(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         LookAtVerticalOffset;                              // 0x04BC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FP2Remap                               LookAtSpeedRemap;                                  // 0x04C0(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, Protected, NativeAccessSpecifierProtected)
	float                                         LookAtAlphaInterpSpeed;                            // 0x04E8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         LookAtRotationInterpSpeed;                         // 0x04EC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   DisableLookAtCurveName;                            // 0x04F0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         LookAtBlendOutStartDistance;                       // 0x04F8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         LookAtBlendOutEndDistance;                         // 0x04FC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_500[0x18];                                     // 0x0500(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRotator                               LookAtRotation;                                    // 0x0518(0x0018)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)
	struct FVector                                LookAtLocation;                                    // 0x0530(0x0018)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         LookAtAlpha;                                       // 0x0548(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bActiveAnimLayer;                                  // 0x054C(0x0001)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_54D[0xB];                                      // 0x054D(0x000B)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class UAnimInstance>              ActiveAnimLayerClass;                              // 0x0558(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"P2NpcAnimInstance">();
	}
	static class UP2NpcAnimInstance* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UP2NpcAnimInstance>();
	}
};
static_assert(alignof(UP2NpcAnimInstance) == 0x000010, "Wrong alignment on UP2NpcAnimInstance");
static_assert(sizeof(UP2NpcAnimInstance) == 0x000560, "Wrong size on UP2NpcAnimInstance");
static_assert(offsetof(UP2NpcAnimInstance, GameplayTagPropertyMap) == 0x000348, "Member 'UP2NpcAnimInstance::GameplayTagPropertyMap' has a wrong offset!");
static_assert(offsetof(UP2NpcAnimInstance, StanceTagToIndexMap) == 0x000368, "Member 'UP2NpcAnimInstance::StanceTagToIndexMap' has a wrong offset!");
static_assert(offsetof(UP2NpcAnimInstance, SneakBounds) == 0x0003B8, "Member 'UP2NpcAnimInstance::SneakBounds' has a wrong offset!");
static_assert(offsetof(UP2NpcAnimInstance, SneakPlayRate) == 0x0003C4, "Member 'UP2NpcAnimInstance::SneakPlayRate' has a wrong offset!");
static_assert(offsetof(UP2NpcAnimInstance, WalkBounds) == 0x0003C8, "Member 'UP2NpcAnimInstance::WalkBounds' has a wrong offset!");
static_assert(offsetof(UP2NpcAnimInstance, WalkPlayRate) == 0x0003D4, "Member 'UP2NpcAnimInstance::WalkPlayRate' has a wrong offset!");
static_assert(offsetof(UP2NpcAnimInstance, TrotBounds) == 0x0003D8, "Member 'UP2NpcAnimInstance::TrotBounds' has a wrong offset!");
static_assert(offsetof(UP2NpcAnimInstance, TrotPlayRate) == 0x0003E4, "Member 'UP2NpcAnimInstance::TrotPlayRate' has a wrong offset!");
static_assert(offsetof(UP2NpcAnimInstance, RunBounds) == 0x0003E8, "Member 'UP2NpcAnimInstance::RunBounds' has a wrong offset!");
static_assert(offsetof(UP2NpcAnimInstance, RunPlayRate) == 0x0003F4, "Member 'UP2NpcAnimInstance::RunPlayRate' has a wrong offset!");
static_assert(offsetof(UP2NpcAnimInstance, RootBoneName) == 0x0003F8, "Member 'UP2NpcAnimInstance::RootBoneName' has a wrong offset!");
static_assert(offsetof(UP2NpcAnimInstance, CurvatureInterpSpeed) == 0x000400, "Member 'UP2NpcAnimInstance::CurvatureInterpSpeed' has a wrong offset!");
static_assert(offsetof(UP2NpcAnimInstance, Speed2D) == 0x000404, "Member 'UP2NpcAnimInstance::Speed2D' has a wrong offset!");
static_assert(offsetof(UP2NpcAnimInstance, CurrentStance) == 0x000408, "Member 'UP2NpcAnimInstance::CurrentStance' has a wrong offset!");
static_assert(offsetof(UP2NpcAnimInstance, CurrentStanceIndex) == 0x000410, "Member 'UP2NpcAnimInstance::CurrentStanceIndex' has a wrong offset!");
static_assert(offsetof(UP2NpcAnimInstance, AimRotation) == 0x000418, "Member 'UP2NpcAnimInstance::AimRotation' has a wrong offset!");
static_assert(offsetof(UP2NpcAnimInstance, AimRotationDelta) == 0x000430, "Member 'UP2NpcAnimInstance::AimRotationDelta' has a wrong offset!");
static_assert(offsetof(UP2NpcAnimInstance, PathCurvature) == 0x000448, "Member 'UP2NpcAnimInstance::PathCurvature' has a wrong offset!");
static_assert(offsetof(UP2NpcAnimInstance, GroundNormalVector) == 0x000450, "Member 'UP2NpcAnimInstance::GroundNormalVector' has a wrong offset!");
static_assert(offsetof(UP2NpcAnimInstance, RootGroundRotation) == 0x000468, "Member 'UP2NpcAnimInstance::RootGroundRotation' has a wrong offset!");
static_assert(offsetof(UP2NpcAnimInstance, GroundDistance) == 0x000480, "Member 'UP2NpcAnimInstance::GroundDistance' has a wrong offset!");
static_assert(offsetof(UP2NpcAnimInstance, LocalVelocityYaw) == 0x000484, "Member 'UP2NpcAnimInstance::LocalVelocityYaw' has a wrong offset!");
static_assert(offsetof(UP2NpcAnimInstance, RootYawOffset) == 0x000488, "Member 'UP2NpcAnimInstance::RootYawOffset' has a wrong offset!");
static_assert(offsetof(UP2NpcAnimInstance, LookingSocketName) == 0x00048C, "Member 'UP2NpcAnimInstance::LookingSocketName' has a wrong offset!");
static_assert(offsetof(UP2NpcAnimInstance, RootSocketName) == 0x000494, "Member 'UP2NpcAnimInstance::RootSocketName' has a wrong offset!");
static_assert(offsetof(UP2NpcAnimInstance, LookAtYawRange) == 0x00049C, "Member 'UP2NpcAnimInstance::LookAtYawRange' has a wrong offset!");
static_assert(offsetof(UP2NpcAnimInstance, LookAtPitchRange) == 0x0004AC, "Member 'UP2NpcAnimInstance::LookAtPitchRange' has a wrong offset!");
static_assert(offsetof(UP2NpcAnimInstance, LookAtVerticalOffset) == 0x0004BC, "Member 'UP2NpcAnimInstance::LookAtVerticalOffset' has a wrong offset!");
static_assert(offsetof(UP2NpcAnimInstance, LookAtSpeedRemap) == 0x0004C0, "Member 'UP2NpcAnimInstance::LookAtSpeedRemap' has a wrong offset!");
static_assert(offsetof(UP2NpcAnimInstance, LookAtAlphaInterpSpeed) == 0x0004E8, "Member 'UP2NpcAnimInstance::LookAtAlphaInterpSpeed' has a wrong offset!");
static_assert(offsetof(UP2NpcAnimInstance, LookAtRotationInterpSpeed) == 0x0004EC, "Member 'UP2NpcAnimInstance::LookAtRotationInterpSpeed' has a wrong offset!");
static_assert(offsetof(UP2NpcAnimInstance, DisableLookAtCurveName) == 0x0004F0, "Member 'UP2NpcAnimInstance::DisableLookAtCurveName' has a wrong offset!");
static_assert(offsetof(UP2NpcAnimInstance, LookAtBlendOutStartDistance) == 0x0004F8, "Member 'UP2NpcAnimInstance::LookAtBlendOutStartDistance' has a wrong offset!");
static_assert(offsetof(UP2NpcAnimInstance, LookAtBlendOutEndDistance) == 0x0004FC, "Member 'UP2NpcAnimInstance::LookAtBlendOutEndDistance' has a wrong offset!");
static_assert(offsetof(UP2NpcAnimInstance, LookAtRotation) == 0x000518, "Member 'UP2NpcAnimInstance::LookAtRotation' has a wrong offset!");
static_assert(offsetof(UP2NpcAnimInstance, LookAtLocation) == 0x000530, "Member 'UP2NpcAnimInstance::LookAtLocation' has a wrong offset!");
static_assert(offsetof(UP2NpcAnimInstance, LookAtAlpha) == 0x000548, "Member 'UP2NpcAnimInstance::LookAtAlpha' has a wrong offset!");
static_assert(offsetof(UP2NpcAnimInstance, bActiveAnimLayer) == 0x00054C, "Member 'UP2NpcAnimInstance::bActiveAnimLayer' has a wrong offset!");
static_assert(offsetof(UP2NpcAnimInstance, ActiveAnimLayerClass) == 0x000558, "Member 'UP2NpcAnimInstance::ActiveAnimLayerClass' has a wrong offset!");

// Class AICommon.P2NpcAnimInstance_Croc
// 0x0030 (0x0590 - 0x0560)
class UP2NpcAnimInstance_Croc final : public UP2NpcAnimInstance
{
public:
	struct FQuat                                  SnapRotation;                                      // 0x0560(0x0020)(Edit, BlueprintVisible, BlueprintReadOnly, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIsSnapped;                                        // 0x0580(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_581[0xF];                                      // 0x0581(0x000F)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"P2NpcAnimInstance_Croc">();
	}
	static class UP2NpcAnimInstance_Croc* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UP2NpcAnimInstance_Croc>();
	}
};
static_assert(alignof(UP2NpcAnimInstance_Croc) == 0x000010, "Wrong alignment on UP2NpcAnimInstance_Croc");
static_assert(sizeof(UP2NpcAnimInstance_Croc) == 0x000590, "Wrong size on UP2NpcAnimInstance_Croc");
static_assert(offsetof(UP2NpcAnimInstance_Croc, SnapRotation) == 0x000560, "Member 'UP2NpcAnimInstance_Croc::SnapRotation' has a wrong offset!");
static_assert(offsetof(UP2NpcAnimInstance_Croc, bIsSnapped) == 0x000580, "Member 'UP2NpcAnimInstance_Croc::bIsSnapped' has a wrong offset!");

// Class AICommon.P2BTService_PollMeleeSlotLocation
// 0x0058 (0x00C8 - 0x0070)
class UP2BTService_PollMeleeSlotLocation final : public UBTService
{
public:
	double                                        Distance;                                          // 0x0070(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FBlackboardKeySelector                 Slot;                                              // 0x0078(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FBlackboardKeySelector                 Result;                                            // 0x00A0(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"P2BTService_PollMeleeSlotLocation">();
	}
	static class UP2BTService_PollMeleeSlotLocation* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UP2BTService_PollMeleeSlotLocation>();
	}
};
static_assert(alignof(UP2BTService_PollMeleeSlotLocation) == 0x000008, "Wrong alignment on UP2BTService_PollMeleeSlotLocation");
static_assert(sizeof(UP2BTService_PollMeleeSlotLocation) == 0x0000C8, "Wrong size on UP2BTService_PollMeleeSlotLocation");
static_assert(offsetof(UP2BTService_PollMeleeSlotLocation, Distance) == 0x000070, "Member 'UP2BTService_PollMeleeSlotLocation::Distance' has a wrong offset!");
static_assert(offsetof(UP2BTService_PollMeleeSlotLocation, Slot) == 0x000078, "Member 'UP2BTService_PollMeleeSlotLocation::Slot' has a wrong offset!");
static_assert(offsetof(UP2BTService_PollMeleeSlotLocation, Result) == 0x0000A0, "Member 'UP2BTService_PollMeleeSlotLocation::Result' has a wrong offset!");

// Class AICommon.P2AnimInstance_CroSnapAttackReaction
// 0x0010 (0x0360 - 0x0350)
class UP2AnimInstance_CroSnapAttackReaction final : public UAnimInstance
{
public:
	struct FRotator                               SnapRotation;                                      // 0x0348(0x0018)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"P2AnimInstance_CroSnapAttackReaction">();
	}
	static class UP2AnimInstance_CroSnapAttackReaction* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UP2AnimInstance_CroSnapAttackReaction>();
	}
};
static_assert(alignof(UP2AnimInstance_CroSnapAttackReaction) == 0x000010, "Wrong alignment on UP2AnimInstance_CroSnapAttackReaction");
static_assert(sizeof(UP2AnimInstance_CroSnapAttackReaction) == 0x000360, "Wrong size on UP2AnimInstance_CroSnapAttackReaction");
static_assert(offsetof(UP2AnimInstance_CroSnapAttackReaction, SnapRotation) == 0x000348, "Member 'UP2AnimInstance_CroSnapAttackReaction::SnapRotation' has a wrong offset!");

// Class AICommon.P2NpcLayerAnimInstance
// 0x0000 (0x0350 - 0x0350)
class UP2NpcLayerAnimInstance : public UAnimInstance
{
public:
	class UP2AbilityTask_AnimLayer*               AnimLayerTask;                                     // 0x0348(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"P2NpcLayerAnimInstance">();
	}
	static class UP2NpcLayerAnimInstance* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UP2NpcLayerAnimInstance>();
	}
};
static_assert(alignof(UP2NpcLayerAnimInstance) == 0x000010, "Wrong alignment on UP2NpcLayerAnimInstance");
static_assert(sizeof(UP2NpcLayerAnimInstance) == 0x000350, "Wrong size on UP2NpcLayerAnimInstance");
static_assert(offsetof(UP2NpcLayerAnimInstance, AnimLayerTask) == 0x000348, "Member 'UP2NpcLayerAnimInstance::AnimLayerTask' has a wrong offset!");

// Class AICommon.P2BlackboardValueModifier_SetObject
// 0x0008 (0x0058 - 0x0050)
class UP2BlackboardValueModifier_SetObject final : public UP2BlackboardValueModifier_SetBase
{
public:
	class UObject*                                Object;                                            // 0x0050(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"P2BlackboardValueModifier_SetObject">();
	}
	static class UP2BlackboardValueModifier_SetObject* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UP2BlackboardValueModifier_SetObject>();
	}
};
static_assert(alignof(UP2BlackboardValueModifier_SetObject) == 0x000008, "Wrong alignment on UP2BlackboardValueModifier_SetObject");
static_assert(sizeof(UP2BlackboardValueModifier_SetObject) == 0x000058, "Wrong size on UP2BlackboardValueModifier_SetObject");
static_assert(offsetof(UP2BlackboardValueModifier_SetObject, Object) == 0x000050, "Member 'UP2BlackboardValueModifier_SetObject::Object' has a wrong offset!");

// Class AICommon.P2AnimLayer_BombugDive
// 0x0030 (0x0380 - 0x0350)
class UP2AnimLayer_BombugDive final : public UP2NpcLayerAnimInstance
{
public:
	EP2BombugMeleeDiveState                       State;                                             // 0x0350(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_351[0x7];                                      // 0x0351(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                DeltaMove;                                         // 0x0358(0x0018)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CurrentStateProgress;                              // 0x0370(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_374[0xC];                                      // 0x0374(0x000C)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"P2AnimLayer_BombugDive">();
	}
	static class UP2AnimLayer_BombugDive* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UP2AnimLayer_BombugDive>();
	}
};
static_assert(alignof(UP2AnimLayer_BombugDive) == 0x000010, "Wrong alignment on UP2AnimLayer_BombugDive");
static_assert(sizeof(UP2AnimLayer_BombugDive) == 0x000380, "Wrong size on UP2AnimLayer_BombugDive");
static_assert(offsetof(UP2AnimLayer_BombugDive, State) == 0x000350, "Member 'UP2AnimLayer_BombugDive::State' has a wrong offset!");
static_assert(offsetof(UP2AnimLayer_BombugDive, DeltaMove) == 0x000358, "Member 'UP2AnimLayer_BombugDive::DeltaMove' has a wrong offset!");
static_assert(offsetof(UP2AnimLayer_BombugDive, CurrentStateProgress) == 0x000370, "Member 'UP2AnimLayer_BombugDive::CurrentStateProgress' has a wrong offset!");

// Class AICommon.P2AnimLayer_RasslerStasis
// 0x0020 (0x0370 - 0x0350)
class UP2AnimLayer_RasslerStasis final : public UP2NpcLayerAnimInstance
{
public:
	float                                         DetectionGaugeValue;                               // 0x0350(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LookAroundMontageTime;                             // 0x0354(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ExitMontageTime;                                   // 0x0358(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EP2RasslerStasisState                         State;                                             // 0x035C(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_35D[0x3];                                      // 0x035D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class UP2StasisAnimationsData*                AnimationSet;                                      // 0x0360(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LookAtYaw;                                         // 0x0368(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LookAtPitch;                                       // 0x036C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	class UP2StasisAnimationsData* GetAnimationSet() const	 // 0x17af534;

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"P2AnimLayer_RasslerStasis">();
	}
	static class UP2AnimLayer_RasslerStasis* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UP2AnimLayer_RasslerStasis>();
	}
};
static_assert(alignof(UP2AnimLayer_RasslerStasis) == 0x000010, "Wrong alignment on UP2AnimLayer_RasslerStasis");
static_assert(sizeof(UP2AnimLayer_RasslerStasis) == 0x000370, "Wrong size on UP2AnimLayer_RasslerStasis");
static_assert(offsetof(UP2AnimLayer_RasslerStasis, DetectionGaugeValue) == 0x000350, "Member 'UP2AnimLayer_RasslerStasis::DetectionGaugeValue' has a wrong offset!");
static_assert(offsetof(UP2AnimLayer_RasslerStasis, LookAroundMontageTime) == 0x000354, "Member 'UP2AnimLayer_RasslerStasis::LookAroundMontageTime' has a wrong offset!");
static_assert(offsetof(UP2AnimLayer_RasslerStasis, ExitMontageTime) == 0x000358, "Member 'UP2AnimLayer_RasslerStasis::ExitMontageTime' has a wrong offset!");
static_assert(offsetof(UP2AnimLayer_RasslerStasis, State) == 0x00035C, "Member 'UP2AnimLayer_RasslerStasis::State' has a wrong offset!");
static_assert(offsetof(UP2AnimLayer_RasslerStasis, AnimationSet) == 0x000360, "Member 'UP2AnimLayer_RasslerStasis::AnimationSet' has a wrong offset!");
static_assert(offsetof(UP2AnimLayer_RasslerStasis, LookAtYaw) == 0x000368, "Member 'UP2AnimLayer_RasslerStasis::LookAtYaw' has a wrong offset!");
static_assert(offsetof(UP2AnimLayer_RasslerStasis, LookAtPitch) == 0x00036C, "Member 'UP2AnimLayer_RasslerStasis::LookAtPitch' has a wrong offset!");

// Class AICommon.P2BTService_ProjectOnNavigation
// 0x0050 (0x00C0 - 0x0070)
class UP2BTService_ProjectOnNavigation final : public UBTService
{
public:
	struct FBlackboardKeySelector                 ProjectionTarget;                                  // 0x0070(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FBlackboardKeySelector                 ProjectionResult;                                  // 0x0098(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"P2BTService_ProjectOnNavigation">();
	}
	static class UP2BTService_ProjectOnNavigation* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UP2BTService_ProjectOnNavigation>();
	}
};
static_assert(alignof(UP2BTService_ProjectOnNavigation) == 0x000008, "Wrong alignment on UP2BTService_ProjectOnNavigation");
static_assert(sizeof(UP2BTService_ProjectOnNavigation) == 0x0000C0, "Wrong size on UP2BTService_ProjectOnNavigation");
static_assert(offsetof(UP2BTService_ProjectOnNavigation, ProjectionTarget) == 0x000070, "Member 'UP2BTService_ProjectOnNavigation::ProjectionTarget' has a wrong offset!");
static_assert(offsetof(UP2BTService_ProjectOnNavigation, ProjectionResult) == 0x000098, "Member 'UP2BTService_ProjectOnNavigation::ProjectionResult' has a wrong offset!");

// Class AICommon.P2AnimLayer_WildcatTree
// 0x0030 (0x0380 - 0x0350)
class UP2AnimLayer_WildcatTree final : public UP2NpcLayerAnimInstance
{
public:
	EP2WildCatTreeState                           State;                                             // 0x0350(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_351[0x3];                                      // 0x0351(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ClimbTime;                                         // 0x0354(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AttackAlpha;                                       // 0x0358(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AttackAngle;                                       // 0x035C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         IdleAimYaw;                                        // 0x0360(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         IdleAimPitch;                                      // 0x0364(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UGameplayTask*                          ClimbTask;                                         // 0x0368(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UGameplayTask*                          AttackTask;                                        // 0x0370(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_378[0x8];                                      // 0x0378(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	class UP2NpcAnimInstance* GetMainAnimInstance() const	 // 0x473a010;

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"P2AnimLayer_WildcatTree">();
	}
	static class UP2AnimLayer_WildcatTree* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UP2AnimLayer_WildcatTree>();
	}
};
static_assert(alignof(UP2AnimLayer_WildcatTree) == 0x000010, "Wrong alignment on UP2AnimLayer_WildcatTree");
static_assert(sizeof(UP2AnimLayer_WildcatTree) == 0x000380, "Wrong size on UP2AnimLayer_WildcatTree");
static_assert(offsetof(UP2AnimLayer_WildcatTree, State) == 0x000350, "Member 'UP2AnimLayer_WildcatTree::State' has a wrong offset!");
static_assert(offsetof(UP2AnimLayer_WildcatTree, ClimbTime) == 0x000354, "Member 'UP2AnimLayer_WildcatTree::ClimbTime' has a wrong offset!");
static_assert(offsetof(UP2AnimLayer_WildcatTree, AttackAlpha) == 0x000358, "Member 'UP2AnimLayer_WildcatTree::AttackAlpha' has a wrong offset!");
static_assert(offsetof(UP2AnimLayer_WildcatTree, AttackAngle) == 0x00035C, "Member 'UP2AnimLayer_WildcatTree::AttackAngle' has a wrong offset!");
static_assert(offsetof(UP2AnimLayer_WildcatTree, IdleAimYaw) == 0x000360, "Member 'UP2AnimLayer_WildcatTree::IdleAimYaw' has a wrong offset!");
static_assert(offsetof(UP2AnimLayer_WildcatTree, IdleAimPitch) == 0x000364, "Member 'UP2AnimLayer_WildcatTree::IdleAimPitch' has a wrong offset!");
static_assert(offsetof(UP2AnimLayer_WildcatTree, ClimbTask) == 0x000368, "Member 'UP2AnimLayer_WildcatTree::ClimbTask' has a wrong offset!");
static_assert(offsetof(UP2AnimLayer_WildcatTree, AttackTask) == 0x000370, "Member 'UP2AnimLayer_WildcatTree::AttackTask' has a wrong offset!");

// Class AICommon.P2AnimNotifyState_GameplayEventDuration
// 0x0008 (0x0038 - 0x0030)
class UP2AnimNotifyState_GameplayEventDuration final : public UAnimNotifyState
{
public:
	struct FGameplayTag                           EventTag;                                          // 0x0030(0x0008)(Edit, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"P2AnimNotifyState_GameplayEventDuration">();
	}
	static class UP2AnimNotifyState_GameplayEventDuration* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UP2AnimNotifyState_GameplayEventDuration>();
	}
};
static_assert(alignof(UP2AnimNotifyState_GameplayEventDuration) == 0x000008, "Wrong alignment on UP2AnimNotifyState_GameplayEventDuration");
static_assert(sizeof(UP2AnimNotifyState_GameplayEventDuration) == 0x000038, "Wrong size on UP2AnimNotifyState_GameplayEventDuration");
static_assert(offsetof(UP2AnimNotifyState_GameplayEventDuration, EventTag) == 0x000030, "Member 'UP2AnimNotifyState_GameplayEventDuration::EventTag' has a wrong offset!");

// Class AICommon.P2BTService_Stance
// 0x0008 (0x0078 - 0x0070)
class UP2BTService_Stance final : public UBTService
{
public:
	struct FGameplayTag                           Stance;                                            // 0x0070(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"P2BTService_Stance">();
	}
	static class UP2BTService_Stance* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UP2BTService_Stance>();
	}
};
static_assert(alignof(UP2BTService_Stance) == 0x000008, "Wrong alignment on UP2BTService_Stance");
static_assert(sizeof(UP2BTService_Stance) == 0x000078, "Wrong size on UP2BTService_Stance");
static_assert(offsetof(UP2BTService_Stance, Stance) == 0x000070, "Member 'UP2BTService_Stance::Stance' has a wrong offset!");

// Class AICommon.P2AnimNotifyState_MotionModifier
// 0x0008 (0x0038 - 0x0030)
class UP2AnimNotifyState_MotionModifier final : public UAnimNotifyState
{
public:
	class UP2RootMotionModifier*                  RootMotionModifier;                                // 0x0030(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, PersistentInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"P2AnimNotifyState_MotionModifier">();
	}
	static class UP2AnimNotifyState_MotionModifier* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UP2AnimNotifyState_MotionModifier>();
	}
};
static_assert(alignof(UP2AnimNotifyState_MotionModifier) == 0x000008, "Wrong alignment on UP2AnimNotifyState_MotionModifier");
static_assert(sizeof(UP2AnimNotifyState_MotionModifier) == 0x000038, "Wrong size on UP2AnimNotifyState_MotionModifier");
static_assert(offsetof(UP2AnimNotifyState_MotionModifier, RootMotionModifier) == 0x000030, "Member 'UP2AnimNotifyState_MotionModifier::RootMotionModifier' has a wrong offset!");

// Class AICommon.P2AnimNotifyState_MovementOverride
// 0x0028 (0x0058 - 0x0030)
class UP2AnimNotifyState_MovementOverride final : public UAnimNotifyState
{
public:
	struct FPawnMovementOverrideConfig            OverrideConfig;                                    // 0x0030(0x0028)(Edit, BlueprintReadOnly, NoDestructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"P2AnimNotifyState_MovementOverride">();
	}
	static class UP2AnimNotifyState_MovementOverride* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UP2AnimNotifyState_MovementOverride>();
	}
};
static_assert(alignof(UP2AnimNotifyState_MovementOverride) == 0x000008, "Wrong alignment on UP2AnimNotifyState_MovementOverride");
static_assert(sizeof(UP2AnimNotifyState_MovementOverride) == 0x000058, "Wrong size on UP2AnimNotifyState_MovementOverride");
static_assert(offsetof(UP2AnimNotifyState_MovementOverride, OverrideConfig) == 0x000030, "Member 'UP2AnimNotifyState_MovementOverride::OverrideConfig' has a wrong offset!");

// Class AICommon.P2BTService_RunEQS
// 0x0000 (0x00F8 - 0x00F8)
class UP2BTService_RunEQS final : public UBTService_RunEQS
{
public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"P2BTService_RunEQS">();
	}
	static class UP2BTService_RunEQS* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UP2BTService_RunEQS>();
	}
};
static_assert(alignof(UP2BTService_RunEQS) == 0x000008, "Wrong alignment on UP2BTService_RunEQS");
static_assert(sizeof(UP2BTService_RunEQS) == 0x0000F8, "Wrong size on UP2BTService_RunEQS");

// Class AICommon.P2AttackTicketComponent
// 0x0040 (0x0100 - 0x00C0)
class UP2AttackTicketComponent : public UActorComponent
{
public:
	int32                                         MaxSimultaneousTickets;                            // 0x00C0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C4[0x4];                                       // 0x00C4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<TWeakObjectPtr<class AAIController>>   CurrentTicketOwners;                               // 0x00C8(0x0010)(ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
	TArray<struct FP2AttackTicketRequest>         RequestingAttackers;                               // 0x00D8(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	class UEnvQuery*                              AttackerScoringQuery;                              // 0x00E8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         EQSInterval;                                       // 0x00F0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_F4[0xC];                                       // 0x00F4(0x000C)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"P2AttackTicketComponent">();
	}
	static class UP2AttackTicketComponent* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UP2AttackTicketComponent>();
	}
};
static_assert(alignof(UP2AttackTicketComponent) == 0x000008, "Wrong alignment on UP2AttackTicketComponent");
static_assert(sizeof(UP2AttackTicketComponent) == 0x000100, "Wrong size on UP2AttackTicketComponent");
static_assert(offsetof(UP2AttackTicketComponent, MaxSimultaneousTickets) == 0x0000C0, "Member 'UP2AttackTicketComponent::MaxSimultaneousTickets' has a wrong offset!");
static_assert(offsetof(UP2AttackTicketComponent, CurrentTicketOwners) == 0x0000C8, "Member 'UP2AttackTicketComponent::CurrentTicketOwners' has a wrong offset!");
static_assert(offsetof(UP2AttackTicketComponent, RequestingAttackers) == 0x0000D8, "Member 'UP2AttackTicketComponent::RequestingAttackers' has a wrong offset!");
static_assert(offsetof(UP2AttackTicketComponent, AttackerScoringQuery) == 0x0000E8, "Member 'UP2AttackTicketComponent::AttackerScoringQuery' has a wrong offset!");
static_assert(offsetof(UP2AttackTicketComponent, EQSInterval) == 0x0000F0, "Member 'UP2AttackTicketComponent::EQSInterval' has a wrong offset!");

// Class AICommon.P2BombugProjectileMovement
// 0x0000 (0x0260 - 0x0260)
class UP2BombugProjectileMovement final : public UProjectileMovementComponent
{
public:
	float                                         FrictionCoefficient;                               // 0x0258(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_25C[0x4];                                      // 0x025C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"P2BombugProjectileMovement">();
	}
	static class UP2BombugProjectileMovement* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UP2BombugProjectileMovement>();
	}
};
static_assert(alignof(UP2BombugProjectileMovement) == 0x000010, "Wrong alignment on UP2BombugProjectileMovement");
static_assert(sizeof(UP2BombugProjectileMovement) == 0x000260, "Wrong size on UP2BombugProjectileMovement");
static_assert(offsetof(UP2BombugProjectileMovement, FrictionCoefficient) == 0x000258, "Member 'UP2BombugProjectileMovement::FrictionCoefficient' has a wrong offset!");

// Class AICommon.P2BTTask_ActivateAbilityWithTargetData
// 0x0058 (0x00F0 - 0x0098)
class UP2BTTask_ActivateAbilityWithTargetData : public UP2BTTask_ActivateAbilityBase
{
public:
	bool                                          bUseTargetData;                                    // 0x0098(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_99[0x7];                                       // 0x0099(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FBlackboardKeySelector                 BlackboardKey;                                     // 0x00A0(0x0028)(Edit, NativeAccessSpecifierPublic)
	uint8                                         Pad_C8[0x28];                                      // 0x00C8(0x0028)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"P2BTTask_ActivateAbilityWithTargetData">();
	}
	static class UP2BTTask_ActivateAbilityWithTargetData* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UP2BTTask_ActivateAbilityWithTargetData>();
	}
};
static_assert(alignof(UP2BTTask_ActivateAbilityWithTargetData) == 0x000008, "Wrong alignment on UP2BTTask_ActivateAbilityWithTargetData");
static_assert(sizeof(UP2BTTask_ActivateAbilityWithTargetData) == 0x0000F0, "Wrong size on UP2BTTask_ActivateAbilityWithTargetData");
static_assert(offsetof(UP2BTTask_ActivateAbilityWithTargetData, bUseTargetData) == 0x000098, "Member 'UP2BTTask_ActivateAbilityWithTargetData::bUseTargetData' has a wrong offset!");
static_assert(offsetof(UP2BTTask_ActivateAbilityWithTargetData, BlackboardKey) == 0x0000A0, "Member 'UP2BTTask_ActivateAbilityWithTargetData::BlackboardKey' has a wrong offset!");

// Class AICommon.P2BTTasK_ActivateAbilityByClass
// 0x0038 (0x0128 - 0x00F0)
class UP2BTTasK_ActivateAbilityByClass final : public UP2BTTask_ActivateAbilityWithTargetData
{
public:
	bool                                          bFromBlackBoard;                                   // 0x00F0(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_F1[0x7];                                       // 0x00F1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FBlackboardKeySelector                 AbilityClassKey;                                   // 0x00F8(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	TSubclassOf<class UP2Ability>                 AbilityClass;                                      // 0x0120(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"P2BTTasK_ActivateAbilityByClass">();
	}
	static class UP2BTTasK_ActivateAbilityByClass* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UP2BTTasK_ActivateAbilityByClass>();
	}
};
static_assert(alignof(UP2BTTasK_ActivateAbilityByClass) == 0x000008, "Wrong alignment on UP2BTTasK_ActivateAbilityByClass");
static_assert(sizeof(UP2BTTasK_ActivateAbilityByClass) == 0x000128, "Wrong size on UP2BTTasK_ActivateAbilityByClass");
static_assert(offsetof(UP2BTTasK_ActivateAbilityByClass, bFromBlackBoard) == 0x0000F0, "Member 'UP2BTTasK_ActivateAbilityByClass::bFromBlackBoard' has a wrong offset!");
static_assert(offsetof(UP2BTTasK_ActivateAbilityByClass, AbilityClassKey) == 0x0000F8, "Member 'UP2BTTasK_ActivateAbilityByClass::AbilityClassKey' has a wrong offset!");
static_assert(offsetof(UP2BTTasK_ActivateAbilityByClass, AbilityClass) == 0x000120, "Member 'UP2BTTasK_ActivateAbilityByClass::AbilityClass' has a wrong offset!");

// Class AICommon.P2MercunaNavLink
// 0x00A0 (0x0580 - 0x04E0)
class AP2MercunaNavLink : public AMercunaNavLink
{
public:
	TMulticastInlineDelegate<void(class APawn* Pawn)> OnNavLinkInteractionEnd;                       // 0x04D8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TSet<TSoftObjectPtr<class AP2BaseCharacter>>  CharactersUsingLink;                               // 0x04E8(0x0050)(Transient, Protected, UObjectWrapper, NativeAccessSpecifierProtected)
	bool                                          bWasGenerated;                                     // 0x0538(0x0001)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_539[0x3];                                      // 0x0539(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         GroundHeight;                                      // 0x053C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         HeightAllowedOffset;                               // 0x0540(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FGuid                                  GenerationKey;                                     // 0x0544(0x0010)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_554[0x4];                                      // 0x0554(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                NavLinkComponentLocation;                          // 0x0558(0x0018)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_570[0x10];                                     // 0x0570(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnAbilityFinished(class AActor* InActor)	 // 0x4757e24;
	void OnReceiveNavLinkStart(class APawn* InPawn, EMercunaNavigationLinkDirection InDirection, const struct FVector& InDestination)	 // 0x47582a0;
	void TryToUpdateLink()	 // 0x17c7f2c;

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"P2MercunaNavLink">();
	}
	static class AP2MercunaNavLink* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<AP2MercunaNavLink>();
	}
};
static_assert(alignof(AP2MercunaNavLink) == 0x000010, "Wrong alignment on AP2MercunaNavLink");
static_assert(sizeof(AP2MercunaNavLink) == 0x000580, "Wrong size on AP2MercunaNavLink");
static_assert(offsetof(AP2MercunaNavLink, OnNavLinkInteractionEnd) == 0x0004D8, "Member 'AP2MercunaNavLink::OnNavLinkInteractionEnd' has a wrong offset!");
static_assert(offsetof(AP2MercunaNavLink, CharactersUsingLink) == 0x0004E8, "Member 'AP2MercunaNavLink::CharactersUsingLink' has a wrong offset!");
static_assert(offsetof(AP2MercunaNavLink, bWasGenerated) == 0x000538, "Member 'AP2MercunaNavLink::bWasGenerated' has a wrong offset!");
static_assert(offsetof(AP2MercunaNavLink, GroundHeight) == 0x00053C, "Member 'AP2MercunaNavLink::GroundHeight' has a wrong offset!");
static_assert(offsetof(AP2MercunaNavLink, HeightAllowedOffset) == 0x000540, "Member 'AP2MercunaNavLink::HeightAllowedOffset' has a wrong offset!");
static_assert(offsetof(AP2MercunaNavLink, GenerationKey) == 0x000544, "Member 'AP2MercunaNavLink::GenerationKey' has a wrong offset!");
static_assert(offsetof(AP2MercunaNavLink, NavLinkComponentLocation) == 0x000558, "Member 'AP2MercunaNavLink::NavLinkComponentLocation' has a wrong offset!");

// Class AICommon.P2BreakableNavLink
// 0x0060 (0x05E0 - 0x0580)
class AP2BreakableNavLink : public AP2MercunaNavLink
{
public:
	uint8                                         Pad_580[0x8];                                      // 0x0580(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftObjectPtr<class AActor>                  LinkOwner;                                         // 0x0588(0x0030)(Edit, Transient, EditConst, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<TWeakObjectPtr<class UP2DestructibleComponent>> HandledDestructibleComponentsCache;       // 0x05B8(0x0010)(ExportObject, ZeroConstructor, ContainsInstancedReference, Protected, UObjectWrapper, NativeAccessSpecifierProtected)
	bool                                          bDisableWhenBroken;                                // 0x05C8(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDisableWhenIndestructible;                        // 0x05C9(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5CA[0x6];                                      // 0x05CA(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FComponentReference>            HandledDestructibleComponents;                     // 0x05D0(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)

public:
	void Break()	 // 0x4739fbc;
	void CheckIfCompletelyDestroyed()	 // 0x4739fe8;

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"P2BreakableNavLink">();
	}
	static class AP2BreakableNavLink* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<AP2BreakableNavLink>();
	}
};
static_assert(alignof(AP2BreakableNavLink) == 0x000010, "Wrong alignment on AP2BreakableNavLink");
static_assert(sizeof(AP2BreakableNavLink) == 0x0005E0, "Wrong size on AP2BreakableNavLink");
static_assert(offsetof(AP2BreakableNavLink, LinkOwner) == 0x000588, "Member 'AP2BreakableNavLink::LinkOwner' has a wrong offset!");
static_assert(offsetof(AP2BreakableNavLink, HandledDestructibleComponentsCache) == 0x0005B8, "Member 'AP2BreakableNavLink::HandledDestructibleComponentsCache' has a wrong offset!");
static_assert(offsetof(AP2BreakableNavLink, bDisableWhenBroken) == 0x0005C8, "Member 'AP2BreakableNavLink::bDisableWhenBroken' has a wrong offset!");
static_assert(offsetof(AP2BreakableNavLink, bDisableWhenIndestructible) == 0x0005C9, "Member 'AP2BreakableNavLink::bDisableWhenIndestructible' has a wrong offset!");
static_assert(offsetof(AP2BreakableNavLink, HandledDestructibleComponents) == 0x0005D0, "Member 'AP2BreakableNavLink::HandledDestructibleComponents' has a wrong offset!");

// Class AICommon.P2BreakableNavLinkGenerator
// 0x0060 (0x0088 - 0x0028)
class UP2BreakableNavLinkGenerator final : public UP2NavLinkGenerator
{
public:
	TSet<TSubclassOf<class AP2BreakableNavLink>>  NavLinkClasses;                                    // 0x0028(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, UObjectWrapper, NativeAccessSpecifierPublic)
	TArray<struct FComponentReference>            HandledBreakables;                                 // 0x0078(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"P2BreakableNavLinkGenerator">();
	}
	static class UP2BreakableNavLinkGenerator* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UP2BreakableNavLinkGenerator>();
	}
};
static_assert(alignof(UP2BreakableNavLinkGenerator) == 0x000008, "Wrong alignment on UP2BreakableNavLinkGenerator");
static_assert(sizeof(UP2BreakableNavLinkGenerator) == 0x000088, "Wrong size on UP2BreakableNavLinkGenerator");
static_assert(offsetof(UP2BreakableNavLinkGenerator, NavLinkClasses) == 0x000028, "Member 'UP2BreakableNavLinkGenerator::NavLinkClasses' has a wrong offset!");
static_assert(offsetof(UP2BreakableNavLinkGenerator, HandledBreakables) == 0x000078, "Member 'UP2BreakableNavLinkGenerator::HandledBreakables' has a wrong offset!");

// Class AICommon.P2BruteDamageCalculation
// 0x0010 (0x00A8 - 0x0098)
class UP2BruteDamageCalculation final : public UP2DamageCalculation
{
public:
	struct FGameplayTag                           OpenedLungsDamageZone;                             // 0x0098(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           ClosedLungsDamageZone;                             // 0x00A0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"P2BruteDamageCalculation">();
	}
	static class UP2BruteDamageCalculation* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UP2BruteDamageCalculation>();
	}
};
static_assert(alignof(UP2BruteDamageCalculation) == 0x000008, "Wrong alignment on UP2BruteDamageCalculation");
static_assert(sizeof(UP2BruteDamageCalculation) == 0x0000A8, "Wrong size on UP2BruteDamageCalculation");
static_assert(offsetof(UP2BruteDamageCalculation, OpenedLungsDamageZone) == 0x000098, "Member 'UP2BruteDamageCalculation::OpenedLungsDamageZone' has a wrong offset!");
static_assert(offsetof(UP2BruteDamageCalculation, ClosedLungsDamageZone) == 0x0000A0, "Member 'UP2BruteDamageCalculation::ClosedLungsDamageZone' has a wrong offset!");

// Class AICommon.P2NpcAbility
// 0x0008 (0x0498 - 0x0490)
class UP2NpcAbility : public UP2Ability
{
public:
	uint8                                         Pad_490[0x8];                                      // 0x0490(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void K2_RequestCancelAbility()	 // 0xae1e64;

	void TryDealDamage(const struct FGameplayAbilityTargetDataHandle& TargetDataHandle, const TSubclassOf<class UP2GameplayEffect_Damage>& EffectClass) const	 // 0x475d4fc;

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"P2NpcAbility">();
	}
	static class UP2NpcAbility* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UP2NpcAbility>();
	}
};
static_assert(alignof(UP2NpcAbility) == 0x000008, "Wrong alignment on UP2NpcAbility");
static_assert(sizeof(UP2NpcAbility) == 0x000498, "Wrong size on UP2NpcAbility");

// Class AICommon.P2NpcAbility_UseSmartObjectMontage
// 0x0140 (0x05D8 - 0x0498)
class UP2NpcAbility_UseSmartObjectMontage : public UP2NpcAbility
{
public:
	class UAbilityTask_PlayMontageAndWait*        PlayMontageTask;                                   // 0x0498(0x0008)(ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UP2AbilityTask_MoveAlongTransformCurve* MoveTask;                                          // 0x04A0(0x0008)(ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UP2AbilityTask_MovementModeOverride*    MovementModeTask;                                  // 0x04A8(0x0008)(ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_4B0[0x128];                                    // 0x04B0(0x0128)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnAnimationEnded()	 // 0x4761238;
	void OnReceiveDamage(class AActor* Instigator, float Damage)	 // 0x4765314;

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"P2NpcAbility_UseSmartObjectMontage">();
	}
	static class UP2NpcAbility_UseSmartObjectMontage* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UP2NpcAbility_UseSmartObjectMontage>();
	}
};
static_assert(alignof(UP2NpcAbility_UseSmartObjectMontage) == 0x000008, "Wrong alignment on UP2NpcAbility_UseSmartObjectMontage");
static_assert(sizeof(UP2NpcAbility_UseSmartObjectMontage) == 0x0005D8, "Wrong size on UP2NpcAbility_UseSmartObjectMontage");
static_assert(offsetof(UP2NpcAbility_UseSmartObjectMontage, PlayMontageTask) == 0x000498, "Member 'UP2NpcAbility_UseSmartObjectMontage::PlayMontageTask' has a wrong offset!");
static_assert(offsetof(UP2NpcAbility_UseSmartObjectMontage, MoveTask) == 0x0004A0, "Member 'UP2NpcAbility_UseSmartObjectMontage::MoveTask' has a wrong offset!");
static_assert(offsetof(UP2NpcAbility_UseSmartObjectMontage, MovementModeTask) == 0x0004A8, "Member 'UP2NpcAbility_UseSmartObjectMontage::MovementModeTask' has a wrong offset!");

// Class AICommon.P2BruteLungsComponent
// 0x0020 (0x00E8 - 0x00C8)
class UP2BruteLungsComponent final : public UP2PawnComponent
{
public:
	float                                         AutocloseDelay;                                    // 0x00C8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DamageCloseThreshold;                              // 0x00CC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EP2BruteLungState                             State;                                             // 0x00D0(0x0001)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_D1[0x17];                                      // 0x00D1(0x0017)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void EndPusBurst()	 // 0x4739ffc;
	void OnReceivedDamage(const struct FP2DamageData& DamageData)	 // 0x1691ef0;
	void StartPusBurst()	 // 0x473a93c;

	bool IsOpen() const	 // 0x16c2d6c;
	bool IsPusBurstActive() const	 // 0x16cdcf4;

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"P2BruteLungsComponent">();
	}
	static class UP2BruteLungsComponent* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UP2BruteLungsComponent>();
	}
};
static_assert(alignof(UP2BruteLungsComponent) == 0x000008, "Wrong alignment on UP2BruteLungsComponent");
static_assert(sizeof(UP2BruteLungsComponent) == 0x0000E8, "Wrong size on UP2BruteLungsComponent");
static_assert(offsetof(UP2BruteLungsComponent, AutocloseDelay) == 0x0000C8, "Member 'UP2BruteLungsComponent::AutocloseDelay' has a wrong offset!");
static_assert(offsetof(UP2BruteLungsComponent, DamageCloseThreshold) == 0x0000CC, "Member 'UP2BruteLungsComponent::DamageCloseThreshold' has a wrong offset!");
static_assert(offsetof(UP2BruteLungsComponent, State) == 0x0000D0, "Member 'UP2BruteLungsComponent::State' has a wrong offset!");

// Class AICommon.P2BTDecorator_AreConditionsTrueForTime
// 0x0008 (0x0070 - 0x0068)
class UP2BTDecorator_AreConditionsTrueForTime final : public UBTDecorator
{
public:
	float                                         CheckingTime;                                      // 0x0068(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RandomDeviation;                                   // 0x006C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"P2BTDecorator_AreConditionsTrueForTime">();
	}
	static class UP2BTDecorator_AreConditionsTrueForTime* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UP2BTDecorator_AreConditionsTrueForTime>();
	}
};
static_assert(alignof(UP2BTDecorator_AreConditionsTrueForTime) == 0x000008, "Wrong alignment on UP2BTDecorator_AreConditionsTrueForTime");
static_assert(sizeof(UP2BTDecorator_AreConditionsTrueForTime) == 0x000070, "Wrong size on UP2BTDecorator_AreConditionsTrueForTime");
static_assert(offsetof(UP2BTDecorator_AreConditionsTrueForTime, CheckingTime) == 0x000068, "Member 'UP2BTDecorator_AreConditionsTrueForTime::CheckingTime' has a wrong offset!");
static_assert(offsetof(UP2BTDecorator_AreConditionsTrueForTime, RandomDeviation) == 0x00006C, "Member 'UP2BTDecorator_AreConditionsTrueForTime::RandomDeviation' has a wrong offset!");

// Class AICommon.P2NpcSensesConfig
// 0x0010 (0x0040 - 0x0030)
class UP2NpcSensesConfig final : public UPrimaryDataAsset
{
public:
	TArray<class UAISenseConfig*>                 SensesConfig;                                      // 0x0030(0x0010)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, DisableEditOnInstance, ContainsInstancedReference, UObjectWrapper, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"P2NpcSensesConfig">();
	}
	static class UP2NpcSensesConfig* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UP2NpcSensesConfig>();
	}
};
static_assert(alignof(UP2NpcSensesConfig) == 0x000008, "Wrong alignment on UP2NpcSensesConfig");
static_assert(sizeof(UP2NpcSensesConfig) == 0x000040, "Wrong size on UP2NpcSensesConfig");
static_assert(offsetof(UP2NpcSensesConfig, SensesConfig) == 0x000030, "Member 'UP2NpcSensesConfig::SensesConfig' has a wrong offset!");

// Class AICommon.P2NpcAbility_UseStalkerHidingSpot
// 0x0020 (0x04B8 - 0x0498)
class UP2NpcAbility_UseStalkerHidingSpot final : public UP2NpcAbility
{
public:
	uint8                                         Pad_498[0x20];                                     // 0x0498(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnAnimationEnded()	 // 0x4761238;
	void OnReceiveDamage(class AActor* Instigator, float Damage)	 // 0x4765454;

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"P2NpcAbility_UseStalkerHidingSpot">();
	}
	static class UP2NpcAbility_UseStalkerHidingSpot* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UP2NpcAbility_UseStalkerHidingSpot>();
	}
};
static_assert(alignof(UP2NpcAbility_UseStalkerHidingSpot) == 0x000008, "Wrong alignment on UP2NpcAbility_UseStalkerHidingSpot");
static_assert(sizeof(UP2NpcAbility_UseStalkerHidingSpot) == 0x0004B8, "Wrong size on UP2NpcAbility_UseStalkerHidingSpot");

// Class AICommon.P2BTDecorator_ArePlayersInRadOf
// 0x0010 (0x00A0 - 0x0090)
class UP2BTDecorator_ArePlayersInRadOf final : public UBTDecorator_BlackboardBase
{
public:
	int32                                         PlayersToFind;                                     // 0x0090(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Radius;                                            // 0x0094(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          OnlyPlayerControlled;                              // 0x0098(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_99[0x7];                                       // 0x0099(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"P2BTDecorator_ArePlayersInRadOf">();
	}
	static class UP2BTDecorator_ArePlayersInRadOf* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UP2BTDecorator_ArePlayersInRadOf>();
	}
};
static_assert(alignof(UP2BTDecorator_ArePlayersInRadOf) == 0x000008, "Wrong alignment on UP2BTDecorator_ArePlayersInRadOf");
static_assert(sizeof(UP2BTDecorator_ArePlayersInRadOf) == 0x0000A0, "Wrong size on UP2BTDecorator_ArePlayersInRadOf");
static_assert(offsetof(UP2BTDecorator_ArePlayersInRadOf, PlayersToFind) == 0x000090, "Member 'UP2BTDecorator_ArePlayersInRadOf::PlayersToFind' has a wrong offset!");
static_assert(offsetof(UP2BTDecorator_ArePlayersInRadOf, Radius) == 0x000094, "Member 'UP2BTDecorator_ArePlayersInRadOf::Radius' has a wrong offset!");
static_assert(offsetof(UP2BTDecorator_ArePlayersInRadOf, OnlyPlayerControlled) == 0x000098, "Member 'UP2BTDecorator_ArePlayersInRadOf::OnlyPlayerControlled' has a wrong offset!");

// Class AICommon.P2BTDecorator_CanActivateAbilityByClass
// 0x0038 (0x00D8 - 0x00A0)
class UP2BTDecorator_CanActivateAbilityByClass final : public UP2BTDecorator_CanActivateAbilityBase
{
public:
	bool                                          bFromBlackBoard;                                   // 0x00A0(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A1[0x7];                                       // 0x00A1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FBlackboardKeySelector                 AbilityClassKey;                                   // 0x00A8(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	TSubclassOf<class UGameplayAbility>           AbilityClass;                                      // 0x00D0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"P2BTDecorator_CanActivateAbilityByClass">();
	}
	static class UP2BTDecorator_CanActivateAbilityByClass* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UP2BTDecorator_CanActivateAbilityByClass>();
	}
};
static_assert(alignof(UP2BTDecorator_CanActivateAbilityByClass) == 0x000008, "Wrong alignment on UP2BTDecorator_CanActivateAbilityByClass");
static_assert(sizeof(UP2BTDecorator_CanActivateAbilityByClass) == 0x0000D8, "Wrong size on UP2BTDecorator_CanActivateAbilityByClass");
static_assert(offsetof(UP2BTDecorator_CanActivateAbilityByClass, bFromBlackBoard) == 0x0000A0, "Member 'UP2BTDecorator_CanActivateAbilityByClass::bFromBlackBoard' has a wrong offset!");
static_assert(offsetof(UP2BTDecorator_CanActivateAbilityByClass, AbilityClassKey) == 0x0000A8, "Member 'UP2BTDecorator_CanActivateAbilityByClass::AbilityClassKey' has a wrong offset!");
static_assert(offsetof(UP2BTDecorator_CanActivateAbilityByClass, AbilityClass) == 0x0000D0, "Member 'UP2BTDecorator_CanActivateAbilityByClass::AbilityClass' has a wrong offset!");

// Class AICommon.P2NpcAbility_PlayEmote
// 0x0010 (0x04A8 - 0x0498)
class UP2NpcAbility_PlayEmote final : public UP2NpcAbility
{
public:
	uint8                                         Pad_498[0x10];                                     // 0x0498(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnAnimationEnded()	 // 0x4761238;
	void OnAnimationInterrupted()	 // 0x47650c4;

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"P2NpcAbility_PlayEmote">();
	}
	static class UP2NpcAbility_PlayEmote* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UP2NpcAbility_PlayEmote>();
	}
};
static_assert(alignof(UP2NpcAbility_PlayEmote) == 0x000008, "Wrong alignment on UP2NpcAbility_PlayEmote");
static_assert(sizeof(UP2NpcAbility_PlayEmote) == 0x0004A8, "Wrong size on UP2NpcAbility_PlayEmote");

// Class AICommon.P2BTDecorator_CanSharePerception
// 0x0008 (0x0070 - 0x0068)
class UP2BTDecorator_CanSharePerception : public UBTDecorator
{
public:
	float                                         SharedPerceptionTimeout;                           // 0x0068(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_6C[0x4];                                       // 0x006C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"P2BTDecorator_CanSharePerception">();
	}
	static class UP2BTDecorator_CanSharePerception* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UP2BTDecorator_CanSharePerception>();
	}
};
static_assert(alignof(UP2BTDecorator_CanSharePerception) == 0x000008, "Wrong alignment on UP2BTDecorator_CanSharePerception");
static_assert(sizeof(UP2BTDecorator_CanSharePerception) == 0x000070, "Wrong size on UP2BTDecorator_CanSharePerception");
static_assert(offsetof(UP2BTDecorator_CanSharePerception, SharedPerceptionTimeout) == 0x000068, "Member 'UP2BTDecorator_CanSharePerception::SharedPerceptionTimeout' has a wrong offset!");

// Class AICommon.P2PayloadObject_DoorHit
// 0x0008 (0x0030 - 0x0028)
class UP2PayloadObject_DoorHit final : public UP2PayloadObject
{
public:
	float                                         VFXRawMagnitude;                                   // 0x0028(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C[0x4];                                       // 0x002C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"P2PayloadObject_DoorHit">();
	}
	static class UP2PayloadObject_DoorHit* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UP2PayloadObject_DoorHit>();
	}
};
static_assert(alignof(UP2PayloadObject_DoorHit) == 0x000008, "Wrong alignment on UP2PayloadObject_DoorHit");
static_assert(sizeof(UP2PayloadObject_DoorHit) == 0x000030, "Wrong size on UP2PayloadObject_DoorHit");
static_assert(offsetof(UP2PayloadObject_DoorHit, VFXRawMagnitude) == 0x000028, "Member 'UP2PayloadObject_DoorHit::VFXRawMagnitude' has a wrong offset!");

// Class AICommon.P2BTDecorator_DamageOverTime
// 0x0018 (0x00A8 - 0x0090)
class UP2BTDecorator_DamageOverTime final : public UBTDecorator_BlackboardBase
{
public:
	float                                         DamageThreshold;                                   // 0x0090(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TimeWindow;                                        // 0x0094(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EComparisonType                               ComparisonType;                                    // 0x0098(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         EqualityTolerance;                                 // 0x009C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A0[0x8];                                       // 0x00A0(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"P2BTDecorator_DamageOverTime">();
	}
	static class UP2BTDecorator_DamageOverTime* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UP2BTDecorator_DamageOverTime>();
	}
};
static_assert(alignof(UP2BTDecorator_DamageOverTime) == 0x000008, "Wrong alignment on UP2BTDecorator_DamageOverTime");
static_assert(sizeof(UP2BTDecorator_DamageOverTime) == 0x0000A8, "Wrong size on UP2BTDecorator_DamageOverTime");
static_assert(offsetof(UP2BTDecorator_DamageOverTime, DamageThreshold) == 0x000090, "Member 'UP2BTDecorator_DamageOverTime::DamageThreshold' has a wrong offset!");
static_assert(offsetof(UP2BTDecorator_DamageOverTime, TimeWindow) == 0x000094, "Member 'UP2BTDecorator_DamageOverTime::TimeWindow' has a wrong offset!");
static_assert(offsetof(UP2BTDecorator_DamageOverTime, ComparisonType) == 0x000098, "Member 'UP2BTDecorator_DamageOverTime::ComparisonType' has a wrong offset!");
static_assert(offsetof(UP2BTDecorator_DamageOverTime, EqualityTolerance) == 0x00009C, "Member 'UP2BTDecorator_DamageOverTime::EqualityTolerance' has a wrong offset!");

// Class AICommon.P2NpcAbility_EvasiveJump
// 0x0010 (0x04A8 - 0x0498)
class UP2NpcAbility_EvasiveJump final : public UP2NpcAbility
{
public:
	TArray<struct FP2NpcEvasiveJumpData>          JumpSet;                                           // 0x0498(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)

public:
	class UAnimMontage* GetBestJumpMontage(const struct FGameplayAbilityActorInfo& ActorInfo, const class AActor* Target) const	 // 0x4760b94;

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"P2NpcAbility_EvasiveJump">();
	}
	static class UP2NpcAbility_EvasiveJump* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UP2NpcAbility_EvasiveJump>();
	}
};
static_assert(alignof(UP2NpcAbility_EvasiveJump) == 0x000008, "Wrong alignment on UP2NpcAbility_EvasiveJump");
static_assert(sizeof(UP2NpcAbility_EvasiveJump) == 0x0004A8, "Wrong size on UP2NpcAbility_EvasiveJump");
static_assert(offsetof(UP2NpcAbility_EvasiveJump, JumpSet) == 0x000498, "Member 'UP2NpcAbility_EvasiveJump::JumpSet' has a wrong offset!");

// Class AICommon.P2NpcAbility_RotateToTarget
// 0x0020 (0x04B8 - 0x0498)
class UP2NpcAbility_RotateToTarget final : public UP2NpcAbility
{
public:
	class FName                                   WarpTargetName;                                    // 0x0498(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<struct FRotationMontageData>           RotationMontages;                                  // 0x04A0(0x0010)(Edit, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_4B0[0x8];                                      // 0x04B0(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnAnimationEnded()	 // 0x4765098;

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"P2NpcAbility_RotateToTarget">();
	}
	static class UP2NpcAbility_RotateToTarget* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UP2NpcAbility_RotateToTarget>();
	}
};
static_assert(alignof(UP2NpcAbility_RotateToTarget) == 0x000008, "Wrong alignment on UP2NpcAbility_RotateToTarget");
static_assert(sizeof(UP2NpcAbility_RotateToTarget) == 0x0004B8, "Wrong size on UP2NpcAbility_RotateToTarget");
static_assert(offsetof(UP2NpcAbility_RotateToTarget, WarpTargetName) == 0x000498, "Member 'UP2NpcAbility_RotateToTarget::WarpTargetName' has a wrong offset!");
static_assert(offsetof(UP2NpcAbility_RotateToTarget, RotationMontages) == 0x0004A0, "Member 'UP2NpcAbility_RotateToTarget::RotationMontages' has a wrong offset!");

// Class AICommon.P2BTDecorator_DistanceCheck
// 0x0088 (0x00F0 - 0x0068)
class UP2BTDecorator_DistanceCheck final : public UBTDecorator
{
public:
	struct FBlackboardKeySelector                 From;                                              // 0x0068(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FBlackboardKeySelector                 To;                                                // 0x0090(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	bool                                          bFromBlackBoard;                                   // 0x00B8(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_B9[0x3];                                       // 0x00B9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         DistanceValue;                                     // 0x00BC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FBlackboardKeySelector                 DistanceKey;                                       // 0x00C0(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	EP2DistanceCheckType                          DistanceType;                                      // 0x00E8(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_E9[0x3];                                       // 0x00E9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         TickInterval;                                      // 0x00EC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"P2BTDecorator_DistanceCheck">();
	}
	static class UP2BTDecorator_DistanceCheck* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UP2BTDecorator_DistanceCheck>();
	}
};
static_assert(alignof(UP2BTDecorator_DistanceCheck) == 0x000008, "Wrong alignment on UP2BTDecorator_DistanceCheck");
static_assert(sizeof(UP2BTDecorator_DistanceCheck) == 0x0000F0, "Wrong size on UP2BTDecorator_DistanceCheck");
static_assert(offsetof(UP2BTDecorator_DistanceCheck, From) == 0x000068, "Member 'UP2BTDecorator_DistanceCheck::From' has a wrong offset!");
static_assert(offsetof(UP2BTDecorator_DistanceCheck, To) == 0x000090, "Member 'UP2BTDecorator_DistanceCheck::To' has a wrong offset!");
static_assert(offsetof(UP2BTDecorator_DistanceCheck, bFromBlackBoard) == 0x0000B8, "Member 'UP2BTDecorator_DistanceCheck::bFromBlackBoard' has a wrong offset!");
static_assert(offsetof(UP2BTDecorator_DistanceCheck, DistanceValue) == 0x0000BC, "Member 'UP2BTDecorator_DistanceCheck::DistanceValue' has a wrong offset!");
static_assert(offsetof(UP2BTDecorator_DistanceCheck, DistanceKey) == 0x0000C0, "Member 'UP2BTDecorator_DistanceCheck::DistanceKey' has a wrong offset!");
static_assert(offsetof(UP2BTDecorator_DistanceCheck, DistanceType) == 0x0000E8, "Member 'UP2BTDecorator_DistanceCheck::DistanceType' has a wrong offset!");
static_assert(offsetof(UP2BTDecorator_DistanceCheck, TickInterval) == 0x0000EC, "Member 'UP2BTDecorator_DistanceCheck::TickInterval' has a wrong offset!");

// Class AICommon.P2BTDecorator_GameplayEventListener
// 0x0028 (0x0090 - 0x0068)
class UP2BTDecorator_GameplayEventListener final : public UBTDecorator
{
public:
	bool                                          bInitialConditionValue;                            // 0x0068(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_69[0x3];                                       // 0x0069(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTag                           EnableEventTag;                                    // 0x006C(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           DisableEventTag;                                   // 0x0074(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_7C[0x14];                                      // 0x007C(0x0014)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"P2BTDecorator_GameplayEventListener">();
	}
	static class UP2BTDecorator_GameplayEventListener* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UP2BTDecorator_GameplayEventListener>();
	}
};
static_assert(alignof(UP2BTDecorator_GameplayEventListener) == 0x000008, "Wrong alignment on UP2BTDecorator_GameplayEventListener");
static_assert(sizeof(UP2BTDecorator_GameplayEventListener) == 0x000090, "Wrong size on UP2BTDecorator_GameplayEventListener");
static_assert(offsetof(UP2BTDecorator_GameplayEventListener, bInitialConditionValue) == 0x000068, "Member 'UP2BTDecorator_GameplayEventListener::bInitialConditionValue' has a wrong offset!");
static_assert(offsetof(UP2BTDecorator_GameplayEventListener, EnableEventTag) == 0x00006C, "Member 'UP2BTDecorator_GameplayEventListener::EnableEventTag' has a wrong offset!");
static_assert(offsetof(UP2BTDecorator_GameplayEventListener, DisableEventTag) == 0x000074, "Member 'UP2BTDecorator_GameplayEventListener::DisableEventTag' has a wrong offset!");

// Class AICommon.P2BTDecorator_GameplayTagQuery
// 0x0080 (0x00E8 - 0x0068)
class UP2BTDecorator_GameplayTagQuery final : public UBTDecorator
{
public:
	struct FBlackboardKeySelector                 ActorForGameplayTagQuery;                          // 0x0068(0x0028)(Edit, Protected, NativeAccessSpecifierProtected)
	struct FGameplayTagQuery                      GameplayTagQuery;                                  // 0x0090(0x0048)(Edit, Protected, NativeAccessSpecifierProtected)
	TArray<struct FGameplayTag>                   QueryTags;                                         // 0x00D8(0x0010)(ZeroConstructor, Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"P2BTDecorator_GameplayTagQuery">();
	}
	static class UP2BTDecorator_GameplayTagQuery* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UP2BTDecorator_GameplayTagQuery>();
	}
};
static_assert(alignof(UP2BTDecorator_GameplayTagQuery) == 0x000008, "Wrong alignment on UP2BTDecorator_GameplayTagQuery");
static_assert(sizeof(UP2BTDecorator_GameplayTagQuery) == 0x0000E8, "Wrong size on UP2BTDecorator_GameplayTagQuery");
static_assert(offsetof(UP2BTDecorator_GameplayTagQuery, ActorForGameplayTagQuery) == 0x000068, "Member 'UP2BTDecorator_GameplayTagQuery::ActorForGameplayTagQuery' has a wrong offset!");
static_assert(offsetof(UP2BTDecorator_GameplayTagQuery, GameplayTagQuery) == 0x000090, "Member 'UP2BTDecorator_GameplayTagQuery::GameplayTagQuery' has a wrong offset!");
static_assert(offsetof(UP2BTDecorator_GameplayTagQuery, QueryTags) == 0x0000D8, "Member 'UP2BTDecorator_GameplayTagQuery::QueryTags' has a wrong offset!");

// Class AICommon.P2NpcAbility_Attack
// 0x0000 (0x0498 - 0x0498)
class UP2NpcAbility_Attack : public UP2NpcAbility
{
public:
	class AActor* GetActorFromTargetData(const struct FGameplayAbilityTargetDataHandle& TargetDataHandle) const	 // 0x475cac4;
	struct FVector GetLocationFromTargetData(const struct FGameplayAbilityTargetDataHandle& TargetDataHandle) const	 // 0x475cb8c;
	bool HasLineOfMotion(const struct FGameplayAbilityTargetDataHandle& TargetDataHandle, bool bDrawDebug, float DrawDebugDuration) const	 // 0x475cc64;
	bool StartCondition(const struct FGameplayAbilityActorInfo& ActorInfo, const struct FGameplayAbilityTargetDataHandle& TargetDataHandle) const	 // 0x475d324;

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"P2NpcAbility_Attack">();
	}
	static class UP2NpcAbility_Attack* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UP2NpcAbility_Attack>();
	}
};
static_assert(alignof(UP2NpcAbility_Attack) == 0x000008, "Wrong alignment on UP2NpcAbility_Attack");
static_assert(sizeof(UP2NpcAbility_Attack) == 0x000498, "Wrong size on UP2NpcAbility_Attack");

// Class AICommon.P2NpcAbility_MultistageAttack
// 0x0050 (0x04E8 - 0x0498)
class UP2NpcAbility_MultistageAttack final : public UP2NpcAbility_Attack
{
public:
	TArray<struct FAttackMontageCandidate>        MontageCandidates;                                 // 0x0498(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, ContainsInstancedReference, NativeAccessSpecifierPublic)
	float                                         RecoveryMontageDurationOffset;                     // 0x04A8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           DamageEventTag;                                    // 0x04AC(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4B4[0x4];                                      // 0x04B4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UAbilityTask*                           AnimMontageTask;                                   // 0x04B8(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAbilityTask_WaitGameplayEvent*         WaitDamageEventTask;                               // 0x04C0(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UP2AbilityTask_MinDistance*             MinDistanceTask;                                   // 0x04C8(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4D0[0x8];                                      // 0x04D0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	EP2AttackStage                                CurrentStage;                                      // 0x04D8(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_4D9[0x7];                                      // 0x04D9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UAnimMontage*                           CurrentAnimMontage;                                // 0x04E0(0x0008)(ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void HandleEvent(const struct FGameplayEventData& Payload)	 // 0x476101c;
	void OnAnimationCancelled()	 // 0x4761224;
	void OnAnimationEnded()	 // 0x4761264;
	void SwitchToNextStage()	 // 0x4761264;

	void ChooseMostSuitableMontage(class UAnimMontage** OutAnimMontage, EP2AttackStage* OutStage) const	 // 0x4760840;

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"P2NpcAbility_MultistageAttack">();
	}
	static class UP2NpcAbility_MultistageAttack* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UP2NpcAbility_MultistageAttack>();
	}
};
static_assert(alignof(UP2NpcAbility_MultistageAttack) == 0x000008, "Wrong alignment on UP2NpcAbility_MultistageAttack");
static_assert(sizeof(UP2NpcAbility_MultistageAttack) == 0x0004E8, "Wrong size on UP2NpcAbility_MultistageAttack");
static_assert(offsetof(UP2NpcAbility_MultistageAttack, MontageCandidates) == 0x000498, "Member 'UP2NpcAbility_MultistageAttack::MontageCandidates' has a wrong offset!");
static_assert(offsetof(UP2NpcAbility_MultistageAttack, RecoveryMontageDurationOffset) == 0x0004A8, "Member 'UP2NpcAbility_MultistageAttack::RecoveryMontageDurationOffset' has a wrong offset!");
static_assert(offsetof(UP2NpcAbility_MultistageAttack, DamageEventTag) == 0x0004AC, "Member 'UP2NpcAbility_MultistageAttack::DamageEventTag' has a wrong offset!");
static_assert(offsetof(UP2NpcAbility_MultistageAttack, AnimMontageTask) == 0x0004B8, "Member 'UP2NpcAbility_MultistageAttack::AnimMontageTask' has a wrong offset!");
static_assert(offsetof(UP2NpcAbility_MultistageAttack, WaitDamageEventTask) == 0x0004C0, "Member 'UP2NpcAbility_MultistageAttack::WaitDamageEventTask' has a wrong offset!");
static_assert(offsetof(UP2NpcAbility_MultistageAttack, MinDistanceTask) == 0x0004C8, "Member 'UP2NpcAbility_MultistageAttack::MinDistanceTask' has a wrong offset!");
static_assert(offsetof(UP2NpcAbility_MultistageAttack, CurrentStage) == 0x0004D8, "Member 'UP2NpcAbility_MultistageAttack::CurrentStage' has a wrong offset!");
static_assert(offsetof(UP2NpcAbility_MultistageAttack, CurrentAnimMontage) == 0x0004E0, "Member 'UP2NpcAbility_MultistageAttack::CurrentAnimMontage' has a wrong offset!");

// Class AICommon.P2BTDecorator_HasGroupRole
// 0x0008 (0x0070 - 0x0068)
class UP2BTDecorator_HasGroupRole final : public UBTDecorator
{
public:
	EGroupRole                                    GroupRole;                                         // 0x0068(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_69[0x7];                                       // 0x0069(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"P2BTDecorator_HasGroupRole">();
	}
	static class UP2BTDecorator_HasGroupRole* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UP2BTDecorator_HasGroupRole>();
	}
};
static_assert(alignof(UP2BTDecorator_HasGroupRole) == 0x000008, "Wrong alignment on UP2BTDecorator_HasGroupRole");
static_assert(sizeof(UP2BTDecorator_HasGroupRole) == 0x000070, "Wrong size on UP2BTDecorator_HasGroupRole");
static_assert(offsetof(UP2BTDecorator_HasGroupRole, GroupRole) == 0x000068, "Member 'UP2BTDecorator_HasGroupRole::GroupRole' has a wrong offset!");

// Class AICommon.P2BTDecorator_InterestLevel
// 0x0008 (0x0078 - 0x0070)
class UP2BTDecorator_InterestLevel final : public UP2BTDecorator_ObserverBase
{
public:
	float                                         ThresholdValue;                                    // 0x0070(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_74[0x4];                                       // 0x0074(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"P2BTDecorator_InterestLevel">();
	}
	static class UP2BTDecorator_InterestLevel* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UP2BTDecorator_InterestLevel>();
	}
};
static_assert(alignof(UP2BTDecorator_InterestLevel) == 0x000008, "Wrong alignment on UP2BTDecorator_InterestLevel");
static_assert(sizeof(UP2BTDecorator_InterestLevel) == 0x000078, "Wrong size on UP2BTDecorator_InterestLevel");
static_assert(offsetof(UP2BTDecorator_InterestLevel, ThresholdValue) == 0x000070, "Member 'UP2BTDecorator_InterestLevel::ThresholdValue' has a wrong offset!");

// Class AICommon.P2AbilityTask_PsycheAimEvasion
// 0x0010 (0x0090 - 0x0080)
class UP2AbilityTask_PsycheAimEvasion final : public UAbilityTask
{
public:
	TSubclassOf<class UP2NpcAbility_PsycheAimEvasion> AbilityClass;                                  // 0x0080(0x0008)(Net, ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TWeakObjectPtr<class UP2ControlRotationModifier_PsycheEvasion> Modifier;                         // 0x0088(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"P2AbilityTask_PsycheAimEvasion">();
	}
	static class UP2AbilityTask_PsycheAimEvasion* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UP2AbilityTask_PsycheAimEvasion>();
	}
};
static_assert(alignof(UP2AbilityTask_PsycheAimEvasion) == 0x000008, "Wrong alignment on UP2AbilityTask_PsycheAimEvasion");
static_assert(sizeof(UP2AbilityTask_PsycheAimEvasion) == 0x000090, "Wrong size on UP2AbilityTask_PsycheAimEvasion");
static_assert(offsetof(UP2AbilityTask_PsycheAimEvasion, AbilityClass) == 0x000080, "Member 'UP2AbilityTask_PsycheAimEvasion::AbilityClass' has a wrong offset!");
static_assert(offsetof(UP2AbilityTask_PsycheAimEvasion, Modifier) == 0x000088, "Member 'UP2AbilityTask_PsycheAimEvasion::Modifier' has a wrong offset!");

// Class AICommon.P2NpcAbility_UseMercunaNavLink
// 0x0048 (0x04E0 - 0x0498)
class UP2NpcAbility_UseMercunaNavLink : public UP2NpcAbility
{
public:
	uint8                                         Pad_498[0x4];                                      // 0x0498(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TWeakObjectPtr<class AP2MercunaNavLink>       MercunaNavLink;                                    // 0x049C(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_4A4[0x3C];                                     // 0x04A4(0x003C)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"P2NpcAbility_UseMercunaNavLink">();
	}
	static class UP2NpcAbility_UseMercunaNavLink* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UP2NpcAbility_UseMercunaNavLink>();
	}
};
static_assert(alignof(UP2NpcAbility_UseMercunaNavLink) == 0x000008, "Wrong alignment on UP2NpcAbility_UseMercunaNavLink");
static_assert(sizeof(UP2NpcAbility_UseMercunaNavLink) == 0x0004E0, "Wrong size on UP2NpcAbility_UseMercunaNavLink");
static_assert(offsetof(UP2NpcAbility_UseMercunaNavLink, MercunaNavLink) == 0x00049C, "Member 'UP2NpcAbility_UseMercunaNavLink::MercunaNavLink' has a wrong offset!");

// Class AICommon.P2NpcAbility_UsePassageLink
// 0x0000 (0x04E0 - 0x04E0)
class UP2NpcAbility_UsePassageLink : public UP2NpcAbility_UseMercunaNavLink
{
public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"P2NpcAbility_UsePassageLink">();
	}
	static class UP2NpcAbility_UsePassageLink* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UP2NpcAbility_UsePassageLink>();
	}
};
static_assert(alignof(UP2NpcAbility_UsePassageLink) == 0x000008, "Wrong alignment on UP2NpcAbility_UsePassageLink");
static_assert(sizeof(UP2NpcAbility_UsePassageLink) == 0x0004E0, "Wrong size on UP2NpcAbility_UsePassageLink");

// Class AICommon.P2NpcAbility_UsePassageLink_Animation
// 0x0038 (0x0518 - 0x04E0)
class UP2NpcAbility_UsePassageLink_Animation final : public UP2NpcAbility_UsePassageLink
{
public:
	float                                         PassageWidthThresholdToUseWideMontage;             // 0x04E0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4E4[0x4];                                      // 0x04E4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UAnimMontage*                           TraversalMontage_WalkWide;                         // 0x04E8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimMontage*                           TraversalMontage_WalkNarrow;                       // 0x04F0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   WarpTargetLink;                                    // 0x04F8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   WarpTargetLinkEnd;                                 // 0x0500(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAbilityTask_PlayMontageAndWait*        PlayMontageTask;                                   // 0x0508(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UP2AbilityTask_MovementModeOverride*    MovementModeOverrideTask;                          // 0x0510(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void OnAnimationEnded()	 // 0x4761238;

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"P2NpcAbility_UsePassageLink_Animation">();
	}
	static class UP2NpcAbility_UsePassageLink_Animation* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UP2NpcAbility_UsePassageLink_Animation>();
	}
};
static_assert(alignof(UP2NpcAbility_UsePassageLink_Animation) == 0x000008, "Wrong alignment on UP2NpcAbility_UsePassageLink_Animation");
static_assert(sizeof(UP2NpcAbility_UsePassageLink_Animation) == 0x000518, "Wrong size on UP2NpcAbility_UsePassageLink_Animation");
static_assert(offsetof(UP2NpcAbility_UsePassageLink_Animation, PassageWidthThresholdToUseWideMontage) == 0x0004E0, "Member 'UP2NpcAbility_UsePassageLink_Animation::PassageWidthThresholdToUseWideMontage' has a wrong offset!");
static_assert(offsetof(UP2NpcAbility_UsePassageLink_Animation, TraversalMontage_WalkWide) == 0x0004E8, "Member 'UP2NpcAbility_UsePassageLink_Animation::TraversalMontage_WalkWide' has a wrong offset!");
static_assert(offsetof(UP2NpcAbility_UsePassageLink_Animation, TraversalMontage_WalkNarrow) == 0x0004F0, "Member 'UP2NpcAbility_UsePassageLink_Animation::TraversalMontage_WalkNarrow' has a wrong offset!");
static_assert(offsetof(UP2NpcAbility_UsePassageLink_Animation, WarpTargetLink) == 0x0004F8, "Member 'UP2NpcAbility_UsePassageLink_Animation::WarpTargetLink' has a wrong offset!");
static_assert(offsetof(UP2NpcAbility_UsePassageLink_Animation, WarpTargetLinkEnd) == 0x000500, "Member 'UP2NpcAbility_UsePassageLink_Animation::WarpTargetLinkEnd' has a wrong offset!");
static_assert(offsetof(UP2NpcAbility_UsePassageLink_Animation, PlayMontageTask) == 0x000508, "Member 'UP2NpcAbility_UsePassageLink_Animation::PlayMontageTask' has a wrong offset!");
static_assert(offsetof(UP2NpcAbility_UsePassageLink_Animation, MovementModeOverrideTask) == 0x000510, "Member 'UP2NpcAbility_UsePassageLink_Animation::MovementModeOverrideTask' has a wrong offset!");

// Class AICommon.P2BTDecorator_IsInMeleeSlot
// 0x0040 (0x00A8 - 0x0068)
class UP2BTDecorator_IsInMeleeSlot final : public UBTDecorator
{
public:
	struct FBlackboardKeySelector                 Slot;                                              // 0x0068(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FFloatRange                            Range;                                             // 0x0090(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SectorHalfAngle;                                   // 0x00A0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A4[0x4];                                       // 0x00A4(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"P2BTDecorator_IsInMeleeSlot">();
	}
	static class UP2BTDecorator_IsInMeleeSlot* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UP2BTDecorator_IsInMeleeSlot>();
	}
};
static_assert(alignof(UP2BTDecorator_IsInMeleeSlot) == 0x000008, "Wrong alignment on UP2BTDecorator_IsInMeleeSlot");
static_assert(sizeof(UP2BTDecorator_IsInMeleeSlot) == 0x0000A8, "Wrong size on UP2BTDecorator_IsInMeleeSlot");
static_assert(offsetof(UP2BTDecorator_IsInMeleeSlot, Slot) == 0x000068, "Member 'UP2BTDecorator_IsInMeleeSlot::Slot' has a wrong offset!");
static_assert(offsetof(UP2BTDecorator_IsInMeleeSlot, Range) == 0x000090, "Member 'UP2BTDecorator_IsInMeleeSlot::Range' has a wrong offset!");
static_assert(offsetof(UP2BTDecorator_IsInMeleeSlot, SectorHalfAngle) == 0x0000A0, "Member 'UP2BTDecorator_IsInMeleeSlot::SectorHalfAngle' has a wrong offset!");

// Class AICommon.P2BTDecorator_IsSuppressed
// 0x0008 (0x0070 - 0x0068)
class UP2BTDecorator_IsSuppressed final : public UBTDecorator
{
public:
	float                                         MaxTimeSince;                                      // 0x0068(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_6C[0x4];                                       // 0x006C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"P2BTDecorator_IsSuppressed">();
	}
	static class UP2BTDecorator_IsSuppressed* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UP2BTDecorator_IsSuppressed>();
	}
};
static_assert(alignof(UP2BTDecorator_IsSuppressed) == 0x000008, "Wrong alignment on UP2BTDecorator_IsSuppressed");
static_assert(sizeof(UP2BTDecorator_IsSuppressed) == 0x000070, "Wrong size on UP2BTDecorator_IsSuppressed");
static_assert(offsetof(UP2BTDecorator_IsSuppressed, MaxTimeSince) == 0x000068, "Member 'UP2BTDecorator_IsSuppressed::MaxTimeSince' has a wrong offset!");

// Class AICommon.P2BTDecorator_IsTargetTraceable
// 0x0060 (0x00C8 - 0x0068)
class UP2BTDecorator_IsTargetTraceable final : public UBTDecorator
{
public:
	struct FBlackboardKeySelector                 From;                                              // 0x0068(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FBlackboardKeySelector                 To;                                                // 0x0090(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	float                                         FromHeightOffset;                                  // 0x00B8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ToHeightOffset;                                    // 0x00BC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECollisionChannel                             CollisionChannel;                                  // 0x00C0(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C1[0x3];                                       // 0x00C1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         TickInterval;                                      // 0x00C4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"P2BTDecorator_IsTargetTraceable">();
	}
	static class UP2BTDecorator_IsTargetTraceable* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UP2BTDecorator_IsTargetTraceable>();
	}
};
static_assert(alignof(UP2BTDecorator_IsTargetTraceable) == 0x000008, "Wrong alignment on UP2BTDecorator_IsTargetTraceable");
static_assert(sizeof(UP2BTDecorator_IsTargetTraceable) == 0x0000C8, "Wrong size on UP2BTDecorator_IsTargetTraceable");
static_assert(offsetof(UP2BTDecorator_IsTargetTraceable, From) == 0x000068, "Member 'UP2BTDecorator_IsTargetTraceable::From' has a wrong offset!");
static_assert(offsetof(UP2BTDecorator_IsTargetTraceable, To) == 0x000090, "Member 'UP2BTDecorator_IsTargetTraceable::To' has a wrong offset!");
static_assert(offsetof(UP2BTDecorator_IsTargetTraceable, FromHeightOffset) == 0x0000B8, "Member 'UP2BTDecorator_IsTargetTraceable::FromHeightOffset' has a wrong offset!");
static_assert(offsetof(UP2BTDecorator_IsTargetTraceable, ToHeightOffset) == 0x0000BC, "Member 'UP2BTDecorator_IsTargetTraceable::ToHeightOffset' has a wrong offset!");
static_assert(offsetof(UP2BTDecorator_IsTargetTraceable, CollisionChannel) == 0x0000C0, "Member 'UP2BTDecorator_IsTargetTraceable::CollisionChannel' has a wrong offset!");
static_assert(offsetof(UP2BTDecorator_IsTargetTraceable, TickInterval) == 0x0000C4, "Member 'UP2BTDecorator_IsTargetTraceable::TickInterval' has a wrong offset!");

// Class AICommon.P2NpcDynamicScaleComponent
// 0x0008 (0x00C8 - 0x00C0)
class UP2NpcDynamicScaleComponent final : public UActorComponent
{
public:
	float                                         DefaultScale;                                      // 0x00C0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Scale;                                             // 0x00C4(0x0004)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void SetScale(float Value)	 // 0x476763c;

	float GetScale() const	 // 0x1603c3c;

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"P2NpcDynamicScaleComponent">();
	}
	static class UP2NpcDynamicScaleComponent* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UP2NpcDynamicScaleComponent>();
	}
};
static_assert(alignof(UP2NpcDynamicScaleComponent) == 0x000008, "Wrong alignment on UP2NpcDynamicScaleComponent");
static_assert(sizeof(UP2NpcDynamicScaleComponent) == 0x0000C8, "Wrong size on UP2NpcDynamicScaleComponent");
static_assert(offsetof(UP2NpcDynamicScaleComponent, DefaultScale) == 0x0000C0, "Member 'UP2NpcDynamicScaleComponent::DefaultScale' has a wrong offset!");
static_assert(offsetof(UP2NpcDynamicScaleComponent, Scale) == 0x0000C4, "Member 'UP2NpcDynamicScaleComponent::Scale' has a wrong offset!");

// Class AICommon.P2BTDecorator_IsTargetUnreachable
// 0x0010 (0x0078 - 0x0068)
class UP2BTDecorator_IsTargetUnreachable final : public UBTDecorator
{
public:
	float                                         TimeToDealDamage;                                  // 0x0068(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DamageThreshold;                                   // 0x006C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TickInterval;                                      // 0x0070(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_74[0x4];                                       // 0x0074(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"P2BTDecorator_IsTargetUnreachable">();
	}
	static class UP2BTDecorator_IsTargetUnreachable* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UP2BTDecorator_IsTargetUnreachable>();
	}
};
static_assert(alignof(UP2BTDecorator_IsTargetUnreachable) == 0x000008, "Wrong alignment on UP2BTDecorator_IsTargetUnreachable");
static_assert(sizeof(UP2BTDecorator_IsTargetUnreachable) == 0x000078, "Wrong size on UP2BTDecorator_IsTargetUnreachable");
static_assert(offsetof(UP2BTDecorator_IsTargetUnreachable, TimeToDealDamage) == 0x000068, "Member 'UP2BTDecorator_IsTargetUnreachable::TimeToDealDamage' has a wrong offset!");
static_assert(offsetof(UP2BTDecorator_IsTargetUnreachable, DamageThreshold) == 0x00006C, "Member 'UP2BTDecorator_IsTargetUnreachable::DamageThreshold' has a wrong offset!");
static_assert(offsetof(UP2BTDecorator_IsTargetUnreachable, TickInterval) == 0x000070, "Member 'UP2BTDecorator_IsTargetUnreachable::TickInterval' has a wrong offset!");

// Class AICommon.P2BTDecorator_Mercuna2D_DoesPathExist
// 0x0068 (0x00D8 - 0x0070)
class UP2BTDecorator_Mercuna2D_DoesPathExist final : public UP2BTDecorator_ObserverBase
{
public:
	EP2PathQueryType                              PathQueryType;                                     // 0x0070(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_71[0x7];                                       // 0x0071(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FBlackboardKeySelector                 StartPointKey;                                     // 0x0078(0x0028)(Edit, Protected, NativeAccessSpecifierProtected)
	struct FBlackboardKeySelector                 EndPointKey;                                       // 0x00A0(0x0028)(Edit, Protected, NativeAccessSpecifierProtected)
	float                                         MaxPathLength;                                     // 0x00C8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MaxPathLengthDistanceMultiplier;                   // 0x00CC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         HorizontalClampingDistance;                        // 0x00D0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         VerticalClampingDistance;                          // 0x00D4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"P2BTDecorator_Mercuna2D_DoesPathExist">();
	}
	static class UP2BTDecorator_Mercuna2D_DoesPathExist* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UP2BTDecorator_Mercuna2D_DoesPathExist>();
	}
};
static_assert(alignof(UP2BTDecorator_Mercuna2D_DoesPathExist) == 0x000008, "Wrong alignment on UP2BTDecorator_Mercuna2D_DoesPathExist");
static_assert(sizeof(UP2BTDecorator_Mercuna2D_DoesPathExist) == 0x0000D8, "Wrong size on UP2BTDecorator_Mercuna2D_DoesPathExist");
static_assert(offsetof(UP2BTDecorator_Mercuna2D_DoesPathExist, PathQueryType) == 0x000070, "Member 'UP2BTDecorator_Mercuna2D_DoesPathExist::PathQueryType' has a wrong offset!");
static_assert(offsetof(UP2BTDecorator_Mercuna2D_DoesPathExist, StartPointKey) == 0x000078, "Member 'UP2BTDecorator_Mercuna2D_DoesPathExist::StartPointKey' has a wrong offset!");
static_assert(offsetof(UP2BTDecorator_Mercuna2D_DoesPathExist, EndPointKey) == 0x0000A0, "Member 'UP2BTDecorator_Mercuna2D_DoesPathExist::EndPointKey' has a wrong offset!");
static_assert(offsetof(UP2BTDecorator_Mercuna2D_DoesPathExist, MaxPathLength) == 0x0000C8, "Member 'UP2BTDecorator_Mercuna2D_DoesPathExist::MaxPathLength' has a wrong offset!");
static_assert(offsetof(UP2BTDecorator_Mercuna2D_DoesPathExist, MaxPathLengthDistanceMultiplier) == 0x0000CC, "Member 'UP2BTDecorator_Mercuna2D_DoesPathExist::MaxPathLengthDistanceMultiplier' has a wrong offset!");
static_assert(offsetof(UP2BTDecorator_Mercuna2D_DoesPathExist, HorizontalClampingDistance) == 0x0000D0, "Member 'UP2BTDecorator_Mercuna2D_DoesPathExist::HorizontalClampingDistance' has a wrong offset!");
static_assert(offsetof(UP2BTDecorator_Mercuna2D_DoesPathExist, VerticalClampingDistance) == 0x0000D4, "Member 'UP2BTDecorator_Mercuna2D_DoesPathExist::VerticalClampingDistance' has a wrong offset!");

// Class AICommon.P2NavLinkGenerationSystem
// 0x00F0 (0x0120 - 0x0030)
class alignas(0x10) UP2NavLinkGenerationSystem final : public UWorldSubsystem
{
public:
	TSoftObjectPtr<class UP2DynamicNavLinkGenerationSettings> DynamicNavLinkGenerationSettings;      // 0x0030(0x0030)(Config, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_60[0xC0];                                      // 0x0060(0x00C0)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"P2NavLinkGenerationSystem">();
	}
	static class UP2NavLinkGenerationSystem* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UP2NavLinkGenerationSystem>();
	}
};
static_assert(alignof(UP2NavLinkGenerationSystem) == 0x000010, "Wrong alignment on UP2NavLinkGenerationSystem");
static_assert(sizeof(UP2NavLinkGenerationSystem) == 0x000120, "Wrong size on UP2NavLinkGenerationSystem");
static_assert(offsetof(UP2NavLinkGenerationSystem, DynamicNavLinkGenerationSettings) == 0x000030, "Member 'UP2NavLinkGenerationSystem::DynamicNavLinkGenerationSettings' has a wrong offset!");

// Class AICommon.P2BTDecorator_NeedsReload
// 0x0008 (0x0070 - 0x0068)
class UP2BTDecorator_NeedsReload final : public UBTDecorator
{
public:
	float                                         TickInterval;                                      // 0x0068(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_6C[0x4];                                       // 0x006C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"P2BTDecorator_NeedsReload">();
	}
	static class UP2BTDecorator_NeedsReload* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UP2BTDecorator_NeedsReload>();
	}
};
static_assert(alignof(UP2BTDecorator_NeedsReload) == 0x000008, "Wrong alignment on UP2BTDecorator_NeedsReload");
static_assert(sizeof(UP2BTDecorator_NeedsReload) == 0x000070, "Wrong size on UP2BTDecorator_NeedsReload");
static_assert(offsetof(UP2BTDecorator_NeedsReload, TickInterval) == 0x000068, "Member 'UP2BTDecorator_NeedsReload::TickInterval' has a wrong offset!");

// Class AICommon.P2BTDecorator_NpcGroupMemberIsLeader
// 0x0030 (0x0098 - 0x0068)
class UP2BTDecorator_NpcGroupMemberIsLeader final : public UBTDecorator
{
public:
	struct FBlackboardKeySelector                 MemberKey;                                         // 0x0068(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)
	float                                         TickInterval;                                      // 0x0090(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_94[0x4];                                       // 0x0094(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"P2BTDecorator_NpcGroupMemberIsLeader">();
	}
	static class UP2BTDecorator_NpcGroupMemberIsLeader* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UP2BTDecorator_NpcGroupMemberIsLeader>();
	}
};
static_assert(alignof(UP2BTDecorator_NpcGroupMemberIsLeader) == 0x000008, "Wrong alignment on UP2BTDecorator_NpcGroupMemberIsLeader");
static_assert(sizeof(UP2BTDecorator_NpcGroupMemberIsLeader) == 0x000098, "Wrong size on UP2BTDecorator_NpcGroupMemberIsLeader");
static_assert(offsetof(UP2BTDecorator_NpcGroupMemberIsLeader, MemberKey) == 0x000068, "Member 'UP2BTDecorator_NpcGroupMemberIsLeader::MemberKey' has a wrong offset!");
static_assert(offsetof(UP2BTDecorator_NpcGroupMemberIsLeader, TickInterval) == 0x000090, "Member 'UP2BTDecorator_NpcGroupMemberIsLeader::TickInterval' has a wrong offset!");

// Class AICommon.P2BTDecorator_NumberOfTargetsAround
// 0x0010 (0x0080 - 0x0070)
class UP2BTDecorator_NumberOfTargetsAround final : public UP2BTDecorator_ObserverBase
{
public:
	int32                                         MinHostilesRequired;                               // 0x0070(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MaxHostilesRequired;                               // 0x0074(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Distance;                                          // 0x0078(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_7C[0x4];                                       // 0x007C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"P2BTDecorator_NumberOfTargetsAround">();
	}
	static class UP2BTDecorator_NumberOfTargetsAround* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UP2BTDecorator_NumberOfTargetsAround>();
	}
};
static_assert(alignof(UP2BTDecorator_NumberOfTargetsAround) == 0x000008, "Wrong alignment on UP2BTDecorator_NumberOfTargetsAround");
static_assert(sizeof(UP2BTDecorator_NumberOfTargetsAround) == 0x000080, "Wrong size on UP2BTDecorator_NumberOfTargetsAround");
static_assert(offsetof(UP2BTDecorator_NumberOfTargetsAround, MinHostilesRequired) == 0x000070, "Member 'UP2BTDecorator_NumberOfTargetsAround::MinHostilesRequired' has a wrong offset!");
static_assert(offsetof(UP2BTDecorator_NumberOfTargetsAround, MaxHostilesRequired) == 0x000074, "Member 'UP2BTDecorator_NumberOfTargetsAround::MaxHostilesRequired' has a wrong offset!");
static_assert(offsetof(UP2BTDecorator_NumberOfTargetsAround, Distance) == 0x000078, "Member 'UP2BTDecorator_NumberOfTargetsAround::Distance' has a wrong offset!");

// Class AICommon.P2BTDecorator_NumOfPlayersInOutRadius
// 0x0010 (0x00B0 - 0x00A0)
class UP2BTDecorator_NumOfPlayersInOutRadius final : public UP2BTDecorator_UtilityCurve
{
public:
	ELookupArea                                   LookupArea;                                        // 0x00A0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         InnerRadius;                                       // 0x00A4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         OuterRadius;                                       // 0x00A8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          OnlyPlayerControlled;                              // 0x00AC(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          CalculateAsPercentage;                             // 0x00AD(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          DrawDebug;                                         // 0x00AE(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_AF[0x1];                                       // 0x00AF(0x0001)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"P2BTDecorator_NumOfPlayersInOutRadius">();
	}
	static class UP2BTDecorator_NumOfPlayersInOutRadius* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UP2BTDecorator_NumOfPlayersInOutRadius>();
	}
};
static_assert(alignof(UP2BTDecorator_NumOfPlayersInOutRadius) == 0x000008, "Wrong alignment on UP2BTDecorator_NumOfPlayersInOutRadius");
static_assert(sizeof(UP2BTDecorator_NumOfPlayersInOutRadius) == 0x0000B0, "Wrong size on UP2BTDecorator_NumOfPlayersInOutRadius");
static_assert(offsetof(UP2BTDecorator_NumOfPlayersInOutRadius, LookupArea) == 0x0000A0, "Member 'UP2BTDecorator_NumOfPlayersInOutRadius::LookupArea' has a wrong offset!");
static_assert(offsetof(UP2BTDecorator_NumOfPlayersInOutRadius, InnerRadius) == 0x0000A4, "Member 'UP2BTDecorator_NumOfPlayersInOutRadius::InnerRadius' has a wrong offset!");
static_assert(offsetof(UP2BTDecorator_NumOfPlayersInOutRadius, OuterRadius) == 0x0000A8, "Member 'UP2BTDecorator_NumOfPlayersInOutRadius::OuterRadius' has a wrong offset!");
static_assert(offsetof(UP2BTDecorator_NumOfPlayersInOutRadius, OnlyPlayerControlled) == 0x0000AC, "Member 'UP2BTDecorator_NumOfPlayersInOutRadius::OnlyPlayerControlled' has a wrong offset!");
static_assert(offsetof(UP2BTDecorator_NumOfPlayersInOutRadius, CalculateAsPercentage) == 0x0000AD, "Member 'UP2BTDecorator_NumOfPlayersInOutRadius::CalculateAsPercentage' has a wrong offset!");
static_assert(offsetof(UP2BTDecorator_NumOfPlayersInOutRadius, DrawDebug) == 0x0000AE, "Member 'UP2BTDecorator_NumOfPlayersInOutRadius::DrawDebug' has a wrong offset!");

// Class AICommon.P2NavSeed
// 0x0000 (0x02B0 - 0x02B0)
class AP2NavSeed final : public AActor
{
public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"P2NavSeed">();
	}
	static class AP2NavSeed* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<AP2NavSeed>();
	}
};
static_assert(alignof(AP2NavSeed) == 0x000008, "Wrong alignment on AP2NavSeed");
static_assert(sizeof(AP2NavSeed) == 0x0002B0, "Wrong size on AP2NavSeed");

// Class AICommon.P2BTDecorator_ObjectiveLock
// 0x0028 (0x0090 - 0x0068)
class UP2BTDecorator_ObjectiveLock final : public UBTDecorator
{
public:
	struct FBlackboardKeySelector                 BBObjective;                                       // 0x0068(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"P2BTDecorator_ObjectiveLock">();
	}
	static class UP2BTDecorator_ObjectiveLock* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UP2BTDecorator_ObjectiveLock>();
	}
};
static_assert(alignof(UP2BTDecorator_ObjectiveLock) == 0x000008, "Wrong alignment on UP2BTDecorator_ObjectiveLock");
static_assert(sizeof(UP2BTDecorator_ObjectiveLock) == 0x000090, "Wrong size on UP2BTDecorator_ObjectiveLock");
static_assert(offsetof(UP2BTDecorator_ObjectiveLock, BBObjective) == 0x000068, "Member 'UP2BTDecorator_ObjectiveLock::BBObjective' has a wrong offset!");

// Class AICommon.P2NpcOptimizationConfig
// 0x0018 (0x0048 - 0x0030)
class UP2NpcOptimizationConfig final : public UDataAsset
{
public:
	float                                         MaxTickInterval;                                   // 0x0030(0x0004)(Edit, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_34[0x4];                                       // 0x0034(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FSignificanceZone>              Zones;                                             // 0x0038(0x0010)(Edit, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"P2NpcOptimizationConfig">();
	}
	static class UP2NpcOptimizationConfig* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UP2NpcOptimizationConfig>();
	}
};
static_assert(alignof(UP2NpcOptimizationConfig) == 0x000008, "Wrong alignment on UP2NpcOptimizationConfig");
static_assert(sizeof(UP2NpcOptimizationConfig) == 0x000048, "Wrong size on UP2NpcOptimizationConfig");
static_assert(offsetof(UP2NpcOptimizationConfig, MaxTickInterval) == 0x000030, "Member 'UP2NpcOptimizationConfig::MaxTickInterval' has a wrong offset!");
static_assert(offsetof(UP2NpcOptimizationConfig, Zones) == 0x000038, "Member 'UP2NpcOptimizationConfig::Zones' has a wrong offset!");

// Class AICommon.P2BTDecorator_PlayerBot_IsWayPointFinished
// 0x0030 (0x0098 - 0x0068)
class UP2BTDecorator_PlayerBot_IsWayPointFinished final : public UBTDecorator
{
public:
	float                                         TickInterval;                                      // 0x0068(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_6C[0x4];                                       // 0x006C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FBlackboardKeySelector                 CurrentWayPointLocationIndex;                      // 0x0070(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"P2BTDecorator_PlayerBot_IsWayPointFinished">();
	}
	static class UP2BTDecorator_PlayerBot_IsWayPointFinished* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UP2BTDecorator_PlayerBot_IsWayPointFinished>();
	}
};
static_assert(alignof(UP2BTDecorator_PlayerBot_IsWayPointFinished) == 0x000008, "Wrong alignment on UP2BTDecorator_PlayerBot_IsWayPointFinished");
static_assert(sizeof(UP2BTDecorator_PlayerBot_IsWayPointFinished) == 0x000098, "Wrong size on UP2BTDecorator_PlayerBot_IsWayPointFinished");
static_assert(offsetof(UP2BTDecorator_PlayerBot_IsWayPointFinished, TickInterval) == 0x000068, "Member 'UP2BTDecorator_PlayerBot_IsWayPointFinished::TickInterval' has a wrong offset!");
static_assert(offsetof(UP2BTDecorator_PlayerBot_IsWayPointFinished, CurrentWayPointLocationIndex) == 0x000070, "Member 'UP2BTDecorator_PlayerBot_IsWayPointFinished::CurrentWayPointLocationIndex' has a wrong offset!");

// Class AICommon.P2BTDecorator_PositionComparison
// 0x0028 (0x00B8 - 0x0090)
class UP2BTDecorator_PositionComparison final : public UBTDecorator_BlackboardBase
{
public:
	bool                                          bCompareX;                                         // 0x0090(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCompareY;                                         // 0x0091(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCompareZ;                                         // 0x0092(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_93[0x1];                                       // 0x0093(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	EComparisonType                               ComparisonTypeX;                                   // 0x0094(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EComparisonType                               ComparisonTypeY;                                   // 0x0098(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EComparisonType                               ComparisonTypeZ;                                   // 0x009C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                EqualityTolerances;                                // 0x00A0(0x0018)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"P2BTDecorator_PositionComparison">();
	}
	static class UP2BTDecorator_PositionComparison* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UP2BTDecorator_PositionComparison>();
	}
};
static_assert(alignof(UP2BTDecorator_PositionComparison) == 0x000008, "Wrong alignment on UP2BTDecorator_PositionComparison");
static_assert(sizeof(UP2BTDecorator_PositionComparison) == 0x0000B8, "Wrong size on UP2BTDecorator_PositionComparison");
static_assert(offsetof(UP2BTDecorator_PositionComparison, bCompareX) == 0x000090, "Member 'UP2BTDecorator_PositionComparison::bCompareX' has a wrong offset!");
static_assert(offsetof(UP2BTDecorator_PositionComparison, bCompareY) == 0x000091, "Member 'UP2BTDecorator_PositionComparison::bCompareY' has a wrong offset!");
static_assert(offsetof(UP2BTDecorator_PositionComparison, bCompareZ) == 0x000092, "Member 'UP2BTDecorator_PositionComparison::bCompareZ' has a wrong offset!");
static_assert(offsetof(UP2BTDecorator_PositionComparison, ComparisonTypeX) == 0x000094, "Member 'UP2BTDecorator_PositionComparison::ComparisonTypeX' has a wrong offset!");
static_assert(offsetof(UP2BTDecorator_PositionComparison, ComparisonTypeY) == 0x000098, "Member 'UP2BTDecorator_PositionComparison::ComparisonTypeY' has a wrong offset!");
static_assert(offsetof(UP2BTDecorator_PositionComparison, ComparisonTypeZ) == 0x00009C, "Member 'UP2BTDecorator_PositionComparison::ComparisonTypeZ' has a wrong offset!");
static_assert(offsetof(UP2BTDecorator_PositionComparison, EqualityTolerances) == 0x0000A0, "Member 'UP2BTDecorator_PositionComparison::EqualityTolerances' has a wrong offset!");

// Class AICommon.P2BTDecorator_RasslerWantsCallForHelp
// 0x0030 (0x00A0 - 0x0070)
class UP2BTDecorator_RasslerWantsCallForHelp final : public UP2BTDecorator_CanSharePerception
{
public:
	float                                         TooFarDistance;                                    // 0x0070(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TooCloseDistance;                                  // 0x0074(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FBlackboardKeySelector                 Target;                                            // 0x0078(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"P2BTDecorator_RasslerWantsCallForHelp">();
	}
	static class UP2BTDecorator_RasslerWantsCallForHelp* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UP2BTDecorator_RasslerWantsCallForHelp>();
	}
};
static_assert(alignof(UP2BTDecorator_RasslerWantsCallForHelp) == 0x000008, "Wrong alignment on UP2BTDecorator_RasslerWantsCallForHelp");
static_assert(sizeof(UP2BTDecorator_RasslerWantsCallForHelp) == 0x0000A0, "Wrong size on UP2BTDecorator_RasslerWantsCallForHelp");
static_assert(offsetof(UP2BTDecorator_RasslerWantsCallForHelp, TooFarDistance) == 0x000070, "Member 'UP2BTDecorator_RasslerWantsCallForHelp::TooFarDistance' has a wrong offset!");
static_assert(offsetof(UP2BTDecorator_RasslerWantsCallForHelp, TooCloseDistance) == 0x000074, "Member 'UP2BTDecorator_RasslerWantsCallForHelp::TooCloseDistance' has a wrong offset!");
static_assert(offsetof(UP2BTDecorator_RasslerWantsCallForHelp, Target) == 0x000078, "Member 'UP2BTDecorator_RasslerWantsCallForHelp::Target' has a wrong offset!");

// Class AICommon.P2NpcAnimInstance_MM
// 0x0090 (0x05F0 - 0x0560)
class UP2NpcAnimInstance_MM : public UP2NpcAnimInstance
{
public:
	struct FTrajectory                            DesiredTrajectory;                                 // 0x0560(0x0010)(BlueprintVisible, Transient, NativeAccessSpecifierPublic)
	bool                                          bHasValidTrajectory;                               // 0x0570(0x0001)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bHadValidTrajectory;                               // 0x0571(0x0001)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bForcePoseSearch;                                  // 0x0572(0x0001)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_573[0x5];                                      // 0x0573(0x0005)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTagContainer                  LocomotionTags;                                    // 0x0578(0x0020)(BlueprintVisible, Transient, NativeAccessSpecifierPublic)
	bool                                          bValidRootMotionSource;                            // 0x0598(0x0001)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_599[0x3];                                      // 0x0599(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         CachedMoveActionTime;                              // 0x059C(0x0004)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bMoveActionActive;                                 // 0x05A0(0x0001)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5A1[0x7];                                      // 0x05A1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UAnimSequence*                          MoveActionAnimSequence;                            // 0x05A8(0x0008)(BlueprintVisible, ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               MoveActionRootRot;                                 // 0x05B0(0x0018)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	class FName                                   MoveActionRootMotionSourceInstanceName;            // 0x05C8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5D0[0x18];                                     // 0x05D0(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	class UP2MoveActionRepComponent*              MoveActionRepComponent;                            // 0x05E8(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"P2NpcAnimInstance_MM">();
	}
	static class UP2NpcAnimInstance_MM* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UP2NpcAnimInstance_MM>();
	}
};
static_assert(alignof(UP2NpcAnimInstance_MM) == 0x000010, "Wrong alignment on UP2NpcAnimInstance_MM");
static_assert(sizeof(UP2NpcAnimInstance_MM) == 0x0005F0, "Wrong size on UP2NpcAnimInstance_MM");
static_assert(offsetof(UP2NpcAnimInstance_MM, DesiredTrajectory) == 0x000560, "Member 'UP2NpcAnimInstance_MM::DesiredTrajectory' has a wrong offset!");
static_assert(offsetof(UP2NpcAnimInstance_MM, bHasValidTrajectory) == 0x000570, "Member 'UP2NpcAnimInstance_MM::bHasValidTrajectory' has a wrong offset!");
static_assert(offsetof(UP2NpcAnimInstance_MM, bHadValidTrajectory) == 0x000571, "Member 'UP2NpcAnimInstance_MM::bHadValidTrajectory' has a wrong offset!");
static_assert(offsetof(UP2NpcAnimInstance_MM, bForcePoseSearch) == 0x000572, "Member 'UP2NpcAnimInstance_MM::bForcePoseSearch' has a wrong offset!");
static_assert(offsetof(UP2NpcAnimInstance_MM, LocomotionTags) == 0x000578, "Member 'UP2NpcAnimInstance_MM::LocomotionTags' has a wrong offset!");
static_assert(offsetof(UP2NpcAnimInstance_MM, bValidRootMotionSource) == 0x000598, "Member 'UP2NpcAnimInstance_MM::bValidRootMotionSource' has a wrong offset!");
static_assert(offsetof(UP2NpcAnimInstance_MM, CachedMoveActionTime) == 0x00059C, "Member 'UP2NpcAnimInstance_MM::CachedMoveActionTime' has a wrong offset!");
static_assert(offsetof(UP2NpcAnimInstance_MM, bMoveActionActive) == 0x0005A0, "Member 'UP2NpcAnimInstance_MM::bMoveActionActive' has a wrong offset!");
static_assert(offsetof(UP2NpcAnimInstance_MM, MoveActionAnimSequence) == 0x0005A8, "Member 'UP2NpcAnimInstance_MM::MoveActionAnimSequence' has a wrong offset!");
static_assert(offsetof(UP2NpcAnimInstance_MM, MoveActionRootRot) == 0x0005B0, "Member 'UP2NpcAnimInstance_MM::MoveActionRootRot' has a wrong offset!");
static_assert(offsetof(UP2NpcAnimInstance_MM, MoveActionRootMotionSourceInstanceName) == 0x0005C8, "Member 'UP2NpcAnimInstance_MM::MoveActionRootMotionSourceInstanceName' has a wrong offset!");
static_assert(offsetof(UP2NpcAnimInstance_MM, MoveActionRepComponent) == 0x0005E8, "Member 'UP2NpcAnimInstance_MM::MoveActionRepComponent' has a wrong offset!");

// Class AICommon.P2BTDecorator_ReserveSmartObject
// 0x0030 (0x0098 - 0x0068)
class UP2BTDecorator_ReserveSmartObject final : public UBTDecorator
{
public:
	struct FBlackboardKeySelector                 SmartObjectKey;                                    // 0x0068(0x0028)(Edit, NativeAccessSpecifierPublic)
	class UP2SmartObject*                         SmartObject;                                       // 0x0090(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"P2BTDecorator_ReserveSmartObject">();
	}
	static class UP2BTDecorator_ReserveSmartObject* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UP2BTDecorator_ReserveSmartObject>();
	}
};
static_assert(alignof(UP2BTDecorator_ReserveSmartObject) == 0x000008, "Wrong alignment on UP2BTDecorator_ReserveSmartObject");
static_assert(sizeof(UP2BTDecorator_ReserveSmartObject) == 0x000098, "Wrong size on UP2BTDecorator_ReserveSmartObject");
static_assert(offsetof(UP2BTDecorator_ReserveSmartObject, SmartObjectKey) == 0x000068, "Member 'UP2BTDecorator_ReserveSmartObject::SmartObjectKey' has a wrong offset!");
static_assert(offsetof(UP2BTDecorator_ReserveSmartObject, SmartObject) == 0x000090, "Member 'UP2BTDecorator_ReserveSmartObject::SmartObject' has a wrong offset!");

// Class AICommon.P2BTDecorator_SmartObjectConeCheck
// 0x0060 (0x00D0 - 0x0070)
class UP2BTDecorator_SmartObjectConeCheck final : public UP2BTDecorator_ObserverBase
{
public:
	struct FBlackboardKeySelector                 SmartObjectKey;                                    // 0x0070(0x0028)(Edit, NativeAccessSpecifierPrivate)
	struct FBlackboardKeySelector                 TargetKey;                                         // 0x0098(0x0028)(Edit, NativeAccessSpecifierPrivate)
	float                                         ConeHalfAngle;                                     // 0x00C0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         Distance;                                          // 0x00C4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bCheckLineOfSight;                                 // 0x00C8(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	ECollisionChannel                             TraceChannel;                                      // 0x00C9(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_CA[0x6];                                       // 0x00CA(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"P2BTDecorator_SmartObjectConeCheck">();
	}
	static class UP2BTDecorator_SmartObjectConeCheck* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UP2BTDecorator_SmartObjectConeCheck>();
	}
};
static_assert(alignof(UP2BTDecorator_SmartObjectConeCheck) == 0x000008, "Wrong alignment on UP2BTDecorator_SmartObjectConeCheck");
static_assert(sizeof(UP2BTDecorator_SmartObjectConeCheck) == 0x0000D0, "Wrong size on UP2BTDecorator_SmartObjectConeCheck");
static_assert(offsetof(UP2BTDecorator_SmartObjectConeCheck, SmartObjectKey) == 0x000070, "Member 'UP2BTDecorator_SmartObjectConeCheck::SmartObjectKey' has a wrong offset!");
static_assert(offsetof(UP2BTDecorator_SmartObjectConeCheck, TargetKey) == 0x000098, "Member 'UP2BTDecorator_SmartObjectConeCheck::TargetKey' has a wrong offset!");
static_assert(offsetof(UP2BTDecorator_SmartObjectConeCheck, ConeHalfAngle) == 0x0000C0, "Member 'UP2BTDecorator_SmartObjectConeCheck::ConeHalfAngle' has a wrong offset!");
static_assert(offsetof(UP2BTDecorator_SmartObjectConeCheck, Distance) == 0x0000C4, "Member 'UP2BTDecorator_SmartObjectConeCheck::Distance' has a wrong offset!");
static_assert(offsetof(UP2BTDecorator_SmartObjectConeCheck, bCheckLineOfSight) == 0x0000C8, "Member 'UP2BTDecorator_SmartObjectConeCheck::bCheckLineOfSight' has a wrong offset!");
static_assert(offsetof(UP2BTDecorator_SmartObjectConeCheck, TraceChannel) == 0x0000C9, "Member 'UP2BTDecorator_SmartObjectConeCheck::TraceChannel' has a wrong offset!");

// Class AICommon.P2BTDecorator_StuckCheck
// 0x0008 (0x0078 - 0x0070)
class UP2BTDecorator_StuckCheck final : public UP2BTDecorator_ObserverBase
{
public:
	float                                         StuckPawnSpeedFraction;                            // 0x0070(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         StuckPawnTimeToFail;                               // 0x0074(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"P2BTDecorator_StuckCheck">();
	}
	static class UP2BTDecorator_StuckCheck* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UP2BTDecorator_StuckCheck>();
	}
};
static_assert(alignof(UP2BTDecorator_StuckCheck) == 0x000008, "Wrong alignment on UP2BTDecorator_StuckCheck");
static_assert(sizeof(UP2BTDecorator_StuckCheck) == 0x000078, "Wrong size on UP2BTDecorator_StuckCheck");
static_assert(offsetof(UP2BTDecorator_StuckCheck, StuckPawnSpeedFraction) == 0x000070, "Member 'UP2BTDecorator_StuckCheck::StuckPawnSpeedFraction' has a wrong offset!");
static_assert(offsetof(UP2BTDecorator_StuckCheck, StuckPawnTimeToFail) == 0x000074, "Member 'UP2BTDecorator_StuckCheck::StuckPawnTimeToFail' has a wrong offset!");

// Class AICommon.P2BTDecorator_TimeLimit
// 0x0008 (0x0078 - 0x0070)
class UP2BTDecorator_TimeLimit final : public UBTDecorator_TimeLimit
{
public:
	float                                         RandomDeviation;                                   // 0x0070(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_74[0x4];                                       // 0x0074(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"P2BTDecorator_TimeLimit">();
	}
	static class UP2BTDecorator_TimeLimit* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UP2BTDecorator_TimeLimit>();
	}
};
static_assert(alignof(UP2BTDecorator_TimeLimit) == 0x000008, "Wrong alignment on UP2BTDecorator_TimeLimit");
static_assert(sizeof(UP2BTDecorator_TimeLimit) == 0x000078, "Wrong size on UP2BTDecorator_TimeLimit");
static_assert(offsetof(UP2BTDecorator_TimeLimit, RandomDeviation) == 0x000070, "Member 'UP2BTDecorator_TimeLimit::RandomDeviation' has a wrong offset!");

// Class AICommon.P2NpcAbility_GhostUseJumpLink
// 0x0040 (0x0520 - 0x04E0)
class UP2NpcAbility_GhostUseJumpLink : public UP2NpcAbility_UseMercunaNavLink
{
public:
	class FName                                   FocalPointOverrideBlackboardKeyName;               // 0x04E0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FocusPointDeltaFactor;                             // 0x04E8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RandomJumpPercentage;                              // 0x04EC(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FallDamageHeight;                                  // 0x04F0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxGapDistance;                                    // 0x04F4(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UGameplayEffect>            JumpBlockGameplayEffectClass;                      // 0x04F8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         JumpBlocksPerJump;                                 // 0x0500(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_504[0x14];                                     // 0x0504(0x0014)(Fixing Size After Last Property [ Dumper-7 ])
	class UP2AbilityTask_WalkTask*                WalkTask;                                          // 0x0518(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void OnJumpEnd()	 // 0x47614e4;
	void OnWalkCompleted()	 // 0x4761548;

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"P2NpcAbility_GhostUseJumpLink">();
	}
	static class UP2NpcAbility_GhostUseJumpLink* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UP2NpcAbility_GhostUseJumpLink>();
	}
};
static_assert(alignof(UP2NpcAbility_GhostUseJumpLink) == 0x000008, "Wrong alignment on UP2NpcAbility_GhostUseJumpLink");
static_assert(sizeof(UP2NpcAbility_GhostUseJumpLink) == 0x000520, "Wrong size on UP2NpcAbility_GhostUseJumpLink");
static_assert(offsetof(UP2NpcAbility_GhostUseJumpLink, FocalPointOverrideBlackboardKeyName) == 0x0004E0, "Member 'UP2NpcAbility_GhostUseJumpLink::FocalPointOverrideBlackboardKeyName' has a wrong offset!");
static_assert(offsetof(UP2NpcAbility_GhostUseJumpLink, FocusPointDeltaFactor) == 0x0004E8, "Member 'UP2NpcAbility_GhostUseJumpLink::FocusPointDeltaFactor' has a wrong offset!");
static_assert(offsetof(UP2NpcAbility_GhostUseJumpLink, RandomJumpPercentage) == 0x0004EC, "Member 'UP2NpcAbility_GhostUseJumpLink::RandomJumpPercentage' has a wrong offset!");
static_assert(offsetof(UP2NpcAbility_GhostUseJumpLink, FallDamageHeight) == 0x0004F0, "Member 'UP2NpcAbility_GhostUseJumpLink::FallDamageHeight' has a wrong offset!");
static_assert(offsetof(UP2NpcAbility_GhostUseJumpLink, MaxGapDistance) == 0x0004F4, "Member 'UP2NpcAbility_GhostUseJumpLink::MaxGapDistance' has a wrong offset!");
static_assert(offsetof(UP2NpcAbility_GhostUseJumpLink, JumpBlockGameplayEffectClass) == 0x0004F8, "Member 'UP2NpcAbility_GhostUseJumpLink::JumpBlockGameplayEffectClass' has a wrong offset!");
static_assert(offsetof(UP2NpcAbility_GhostUseJumpLink, JumpBlocksPerJump) == 0x000500, "Member 'UP2NpcAbility_GhostUseJumpLink::JumpBlocksPerJump' has a wrong offset!");
static_assert(offsetof(UP2NpcAbility_GhostUseJumpLink, WalkTask) == 0x000518, "Member 'UP2NpcAbility_GhostUseJumpLink::WalkTask' has a wrong offset!");

// Class AICommon.P2BTDecorator_WildCatCanJumpToTarget
// 0x0030 (0x0098 - 0x0068)
class UP2BTDecorator_WildCatCanJumpToTarget final : public UBTDecorator
{
public:
	struct FBlackboardKeySelector                 TargetKey;                                         // 0x0068(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)
	ECollisionChannel                             CollisionChannel;                                  // 0x0090(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_91[0x7];                                       // 0x0091(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"P2BTDecorator_WildCatCanJumpToTarget">();
	}
	static class UP2BTDecorator_WildCatCanJumpToTarget* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UP2BTDecorator_WildCatCanJumpToTarget>();
	}
};
static_assert(alignof(UP2BTDecorator_WildCatCanJumpToTarget) == 0x000008, "Wrong alignment on UP2BTDecorator_WildCatCanJumpToTarget");
static_assert(sizeof(UP2BTDecorator_WildCatCanJumpToTarget) == 0x000098, "Wrong size on UP2BTDecorator_WildCatCanJumpToTarget");
static_assert(offsetof(UP2BTDecorator_WildCatCanJumpToTarget, TargetKey) == 0x000068, "Member 'UP2BTDecorator_WildCatCanJumpToTarget::TargetKey' has a wrong offset!");
static_assert(offsetof(UP2BTDecorator_WildCatCanJumpToTarget, CollisionChannel) == 0x000090, "Member 'UP2BTDecorator_WildCatCanJumpToTarget::CollisionChannel' has a wrong offset!");

// Class AICommon.P2BTDecorator_WithAttackTicket
// 0x0038 (0x00A0 - 0x0068)
class UP2BTDecorator_WithAttackTicket final : public UBTDecorator
{
public:
	uint8                                         Pad_68[0x10];                                      // 0x0068(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	struct FBlackboardKeySelector                 TargetKey;                                         // 0x0078(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"P2BTDecorator_WithAttackTicket">();
	}
	static class UP2BTDecorator_WithAttackTicket* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UP2BTDecorator_WithAttackTicket>();
	}
};
static_assert(alignof(UP2BTDecorator_WithAttackTicket) == 0x000008, "Wrong alignment on UP2BTDecorator_WithAttackTicket");
static_assert(sizeof(UP2BTDecorator_WithAttackTicket) == 0x0000A0, "Wrong size on UP2BTDecorator_WithAttackTicket");
static_assert(offsetof(UP2BTDecorator_WithAttackTicket, TargetKey) == 0x000078, "Member 'UP2BTDecorator_WithAttackTicket::TargetKey' has a wrong offset!");

// Class AICommon.P2NpcData
// 0x0378 (0x04F8 - 0x0180)
class UP2NpcData final : public UP2PawnData
{
public:
	class UBehaviorTree*                          BehaviorTree;                                      // 0x0180(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStateTree*                             StateTree;                                         // 0x0188(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UBlackboardData*                        Blackboard;                                        // 0x0190(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TMap<class FName, bool>                       BlackboardDefaultValuesBool;                       // 0x0198(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TMap<class FName, class UObject*>             BlackboardDefaultValuesObject;                     // 0x01E8(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TMap<struct FGameplayTag, class UBehaviorTree*> SubBehaviorTreeOverrides;                        // 0x0238(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	class UP2AIFleeConfig*                        FleeStrategy;                                      // 0x0288(0x0008)(Edit, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, PersistentInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class UAISenseConfig*>                 SensesConfig;                                      // 0x0290(0x0010)(Edit, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, ContainsInstancedReference, UObjectWrapper, NativeAccessSpecifierPublic)
	TSubclassOf<class UAISense>                   DominantSense;                                     // 0x02A0(0x0008)(Edit, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FP2PerceptionAlertedLevelChangePair> AlertedLevelIncreasePairs;                    // 0x02A8(0x0010)(Edit, BlueprintReadOnly, EditFixedSize, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TArray<struct FP2PerceptionAlertedLevelChangePair> AlertedLevelDecreasePairs;                    // 0x02B8(0x0010)(Edit, BlueprintReadOnly, EditFixedSize, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TMap<EP2PerceptionAlertedLevelType, float>    AlertedLevelIncreaseRate;                          // 0x02C8(0x0050)(Edit, BlueprintReadOnly, EditFixedSize, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TMap<EP2PerceptionAlertedLevelType, float>    AlertedLevelDecreaseRate;                          // 0x0318(0x0050)(Edit, BlueprintReadOnly, EditFixedSize, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TMap<TSubclassOf<class UAISense>, float>      InterestLevelIncreasePerSense;                     // 0x0368(0x0050)(Edit, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	class UDataTable*                             InterestLevelPerTagData;                           // 0x03B8(0x0008)(Edit, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MinSpottedTime;                                    // 0x03C0(0x0004)(Edit, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MinVisibleTime;                                    // 0x03C4(0x0004)(Edit, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSet<TSubclassOf<class UAISense>>             SpotSenses;                                        // 0x03C8(0x0050)(Edit, BlueprintReadOnly, DisableEditOnInstance, UObjectWrapper, NativeAccessSpecifierPublic)
	TSet<TSubclassOf<class UAISense>>             SensitiveSenses;                                   // 0x0418(0x0050)(Edit, BlueprintReadOnly, DisableEditOnInstance, UObjectWrapper, NativeAccessSpecifierPublic)
	class UP2NpcOptimizationConfig*               OptimizationConfig;                                // 0x0468(0x0008)(Edit, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UP2NpcOptimizationConfig*               DefaultOptimizationConfig;                         // 0x0470(0x0008)(BlueprintReadOnly, ZeroConstructor, Transient, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UP2NpcStaggerData*                      StaggerData;                                       // 0x0478(0x0008)(Edit, BlueprintReadOnly, ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TMap<struct FGameplayTag, class UP2NpcStaggerData*> StaggerDataOverrides;                        // 0x0480(0x0050)(Edit, BlueprintReadOnly, Protected, UObjectWrapper, NativeAccessSpecifierProtected)
	TArray<class USkeletalMesh*>                  MeshVariations;                                    // 0x04D0(0x0010)(Edit, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, UObjectWrapper, NativeAccessSpecifierPublic)
	int32                                         AttackTicketsRequired;                             // 0x04E0(0x0004)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          CanSpawnInAnomaly;                                 // 0x04E4(0x0001)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bSupportsSimpleSpawn;                              // 0x04E5(0x0001)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4E6[0x2];                                      // 0x04E6(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	class UP2NpcContainerData*                    LootData;                                          // 0x04E8(0x0008)(Edit, BlueprintReadOnly, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AttackReach;                                       // 0x04F0(0x0004)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4F4[0x4];                                      // 0x04F4(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"P2NpcData">();
	}
	static class UP2NpcData* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UP2NpcData>();
	}
};
static_assert(alignof(UP2NpcData) == 0x000008, "Wrong alignment on UP2NpcData");
static_assert(sizeof(UP2NpcData) == 0x0004F8, "Wrong size on UP2NpcData");
static_assert(offsetof(UP2NpcData, BehaviorTree) == 0x000180, "Member 'UP2NpcData::BehaviorTree' has a wrong offset!");
static_assert(offsetof(UP2NpcData, StateTree) == 0x000188, "Member 'UP2NpcData::StateTree' has a wrong offset!");
static_assert(offsetof(UP2NpcData, Blackboard) == 0x000190, "Member 'UP2NpcData::Blackboard' has a wrong offset!");
static_assert(offsetof(UP2NpcData, BlackboardDefaultValuesBool) == 0x000198, "Member 'UP2NpcData::BlackboardDefaultValuesBool' has a wrong offset!");
static_assert(offsetof(UP2NpcData, BlackboardDefaultValuesObject) == 0x0001E8, "Member 'UP2NpcData::BlackboardDefaultValuesObject' has a wrong offset!");
static_assert(offsetof(UP2NpcData, SubBehaviorTreeOverrides) == 0x000238, "Member 'UP2NpcData::SubBehaviorTreeOverrides' has a wrong offset!");
static_assert(offsetof(UP2NpcData, FleeStrategy) == 0x000288, "Member 'UP2NpcData::FleeStrategy' has a wrong offset!");
static_assert(offsetof(UP2NpcData, SensesConfig) == 0x000290, "Member 'UP2NpcData::SensesConfig' has a wrong offset!");
static_assert(offsetof(UP2NpcData, DominantSense) == 0x0002A0, "Member 'UP2NpcData::DominantSense' has a wrong offset!");
static_assert(offsetof(UP2NpcData, AlertedLevelIncreasePairs) == 0x0002A8, "Member 'UP2NpcData::AlertedLevelIncreasePairs' has a wrong offset!");
static_assert(offsetof(UP2NpcData, AlertedLevelDecreasePairs) == 0x0002B8, "Member 'UP2NpcData::AlertedLevelDecreasePairs' has a wrong offset!");
static_assert(offsetof(UP2NpcData, AlertedLevelIncreaseRate) == 0x0002C8, "Member 'UP2NpcData::AlertedLevelIncreaseRate' has a wrong offset!");
static_assert(offsetof(UP2NpcData, AlertedLevelDecreaseRate) == 0x000318, "Member 'UP2NpcData::AlertedLevelDecreaseRate' has a wrong offset!");
static_assert(offsetof(UP2NpcData, InterestLevelIncreasePerSense) == 0x000368, "Member 'UP2NpcData::InterestLevelIncreasePerSense' has a wrong offset!");
static_assert(offsetof(UP2NpcData, InterestLevelPerTagData) == 0x0003B8, "Member 'UP2NpcData::InterestLevelPerTagData' has a wrong offset!");
static_assert(offsetof(UP2NpcData, MinSpottedTime) == 0x0003C0, "Member 'UP2NpcData::MinSpottedTime' has a wrong offset!");
static_assert(offsetof(UP2NpcData, MinVisibleTime) == 0x0003C4, "Member 'UP2NpcData::MinVisibleTime' has a wrong offset!");
static_assert(offsetof(UP2NpcData, SpotSenses) == 0x0003C8, "Member 'UP2NpcData::SpotSenses' has a wrong offset!");
static_assert(offsetof(UP2NpcData, SensitiveSenses) == 0x000418, "Member 'UP2NpcData::SensitiveSenses' has a wrong offset!");
static_assert(offsetof(UP2NpcData, OptimizationConfig) == 0x000468, "Member 'UP2NpcData::OptimizationConfig' has a wrong offset!");
static_assert(offsetof(UP2NpcData, DefaultOptimizationConfig) == 0x000470, "Member 'UP2NpcData::DefaultOptimizationConfig' has a wrong offset!");
static_assert(offsetof(UP2NpcData, StaggerData) == 0x000478, "Member 'UP2NpcData::StaggerData' has a wrong offset!");
static_assert(offsetof(UP2NpcData, StaggerDataOverrides) == 0x000480, "Member 'UP2NpcData::StaggerDataOverrides' has a wrong offset!");
static_assert(offsetof(UP2NpcData, MeshVariations) == 0x0004D0, "Member 'UP2NpcData::MeshVariations' has a wrong offset!");
static_assert(offsetof(UP2NpcData, AttackTicketsRequired) == 0x0004E0, "Member 'UP2NpcData::AttackTicketsRequired' has a wrong offset!");
static_assert(offsetof(UP2NpcData, CanSpawnInAnomaly) == 0x0004E4, "Member 'UP2NpcData::CanSpawnInAnomaly' has a wrong offset!");
static_assert(offsetof(UP2NpcData, bSupportsSimpleSpawn) == 0x0004E5, "Member 'UP2NpcData::bSupportsSimpleSpawn' has a wrong offset!");
static_assert(offsetof(UP2NpcData, LootData) == 0x0004E8, "Member 'UP2NpcData::LootData' has a wrong offset!");
static_assert(offsetof(UP2NpcData, AttackReach) == 0x0004F0, "Member 'UP2NpcData::AttackReach' has a wrong offset!");

// Class AICommon.P2Spawner
// 0x00B0 (0x0388 - 0x02D8)
class AP2Spawner final : public ANavigationObjectBase
{
public:
	uint8                                         Pad_2D8[0x8];                                      // 0x02D8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bAutoSpawn;                                        // 0x02E0(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2E1[0x3];                                      // 0x02E1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         SpawnDelay;                                        // 0x02E4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UP2NpcData*                             NpcData;                                           // 0x02E8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FPrimaryAssetId                        NpcDataId;                                         // 0x02F0(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStateTree*                             StateTreeOverride;                                 // 0x0300(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UBehaviorTree*                          BehaviorOverride;                                  // 0x0308(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UBlackboardData*                        BlackboardOverride;                                // 0x0310(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TMap<struct FGameplayTag, class UBehaviorTree*> DynamicBehaviorOverrides;                        // 0x0318(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, UObjectWrapper, NativeAccessSpecifierPublic)
	TArray<class UP2BlackboardValueModifier*>     BlackboardModifiers;                               // 0x0368(0x0010)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, ContainsInstancedReference, UObjectWrapper, NativeAccessSpecifierPublic)
	uint8                                         Pad_378[0x10];                                     // 0x0378(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnMatchStarting()	 // 0x476be0c;
	void UpdateCapsuleSizeFromData()	 // 0x476c94c;

	void GetNpcCapsuleSizeFromData(float* OutRadius, float* OutHalfHeight) const	 // 0x476b1a0;
	void InitCapsuleSizeFromData() const	 // 0x476bb80;
	bool IsNpcDataValid() const	 // 0x476bb94;
	void OnSpawnedNpc(class AP2NPCharacter* SpawnedNpc) const	 // 0xae1e64;
	class AP2NPCharacter* Spawn() const	 // 0x476c914;
	void SpawnFromDelay() const	 // 0x476c938;

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"P2Spawner">();
	}
	static class AP2Spawner* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<AP2Spawner>();
	}
};
static_assert(alignof(AP2Spawner) == 0x000008, "Wrong alignment on AP2Spawner");
static_assert(sizeof(AP2Spawner) == 0x000388, "Wrong size on AP2Spawner");
static_assert(offsetof(AP2Spawner, bAutoSpawn) == 0x0002E0, "Member 'AP2Spawner::bAutoSpawn' has a wrong offset!");
static_assert(offsetof(AP2Spawner, SpawnDelay) == 0x0002E4, "Member 'AP2Spawner::SpawnDelay' has a wrong offset!");
static_assert(offsetof(AP2Spawner, NpcData) == 0x0002E8, "Member 'AP2Spawner::NpcData' has a wrong offset!");
static_assert(offsetof(AP2Spawner, NpcDataId) == 0x0002F0, "Member 'AP2Spawner::NpcDataId' has a wrong offset!");
static_assert(offsetof(AP2Spawner, StateTreeOverride) == 0x000300, "Member 'AP2Spawner::StateTreeOverride' has a wrong offset!");
static_assert(offsetof(AP2Spawner, BehaviorOverride) == 0x000308, "Member 'AP2Spawner::BehaviorOverride' has a wrong offset!");
static_assert(offsetof(AP2Spawner, BlackboardOverride) == 0x000310, "Member 'AP2Spawner::BlackboardOverride' has a wrong offset!");
static_assert(offsetof(AP2Spawner, DynamicBehaviorOverrides) == 0x000318, "Member 'AP2Spawner::DynamicBehaviorOverrides' has a wrong offset!");
static_assert(offsetof(AP2Spawner, BlackboardModifiers) == 0x000368, "Member 'AP2Spawner::BlackboardModifiers' has a wrong offset!");

// Class AICommon.P2BTService_AddTag
// 0x0010 (0x0080 - 0x0070)
class UP2BTService_AddTag final : public UBTService
{
public:
	struct FGameplayTag                           Tag;                                               // 0x0070(0x0008)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bReplicate;                                        // 0x0078(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_79[0x7];                                       // 0x0079(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"P2BTService_AddTag">();
	}
	static class UP2BTService_AddTag* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UP2BTService_AddTag>();
	}
};
static_assert(alignof(UP2BTService_AddTag) == 0x000008, "Wrong alignment on UP2BTService_AddTag");
static_assert(sizeof(UP2BTService_AddTag) == 0x000080, "Wrong size on UP2BTService_AddTag");
static_assert(offsetof(UP2BTService_AddTag, Tag) == 0x000070, "Member 'UP2BTService_AddTag::Tag' has a wrong offset!");
static_assert(offsetof(UP2BTService_AddTag, bReplicate) == 0x000078, "Member 'UP2BTService_AddTag::bReplicate' has a wrong offset!");

// Class AICommon.P2BTService_ApplyGameplayEffect
// 0x0010 (0x0080 - 0x0070)
class UP2BTService_ApplyGameplayEffect final : public UBTService
{
public:
	bool                                          bRemoveOnExit;                                     // 0x0070(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_71[0x7];                                       // 0x0071(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class UGameplayEffect>            Effect;                                            // 0x0078(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"P2BTService_ApplyGameplayEffect">();
	}
	static class UP2BTService_ApplyGameplayEffect* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UP2BTService_ApplyGameplayEffect>();
	}
};
static_assert(alignof(UP2BTService_ApplyGameplayEffect) == 0x000008, "Wrong alignment on UP2BTService_ApplyGameplayEffect");
static_assert(sizeof(UP2BTService_ApplyGameplayEffect) == 0x000080, "Wrong size on UP2BTService_ApplyGameplayEffect");
static_assert(offsetof(UP2BTService_ApplyGameplayEffect, bRemoveOnExit) == 0x000070, "Member 'UP2BTService_ApplyGameplayEffect::bRemoveOnExit' has a wrong offset!");
static_assert(offsetof(UP2BTService_ApplyGameplayEffect, Effect) == 0x000078, "Member 'UP2BTService_ApplyGameplayEffect::Effect' has a wrong offset!");

// Class AICommon.P2NPCharacter
// 0x0140 (0x0B30 - 0x09F0)
class AP2NPCharacter : public AP2BaseCharacter
{
public:
	uint8                                         Pad_9F0[0x8];                                      // 0x09F0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ReplicatedTrajectoryCurvature;                     // 0x09F8(0x0004)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         RandomMeshIndex;                                   // 0x09FC(0x0004)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(const struct FRepMovement& RepMovement)> OnMovementReplicated;     // 0x0A00(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	class UP2NpcAttributeSet*                     NpcAttributeSet;                                   // 0x0A10(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class AActor*                                 FocusedActor;                                      // 0x0A18(0x0008)(Net, ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector                                FocalPoint;                                        // 0x0A20(0x0018)(Net, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FGameplayTag                           Stance;                                            // 0x0A38(0x0008)(Net, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bStrafingEnabled;                                  // 0x0A40(0x0001)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bRepOrientRotationToMovement;                      // 0x0A41(0x0001)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_A42[0x6];                                      // 0x0A42(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	class UP2MercunaGroundNavigationComponent*    MercunaGroundNavigation;                           // 0x0A48(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UP2NpcComponent*                        NpcComponent;                                      // 0x0A50(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UP2ContainerComponent*                  ContainerComponent;                                // 0x0A58(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UMotionWarpingComponent*                MotionWarpingComponent;                            // 0x0A60(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UP2TrajectoryGenerator*                 P2TrajectoryGeneratorComponent;                    // 0x0A68(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UP2NpcData*                             PawnData;                                          // 0x0A70(0x0008)(Edit, Net, ZeroConstructor, DisableEditOnTemplate, RepNotify, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FPawnMovementOverrideData              PawnMovementOverride;                              // 0x0A78(0x0028)(BlueprintVisible, BlueprintReadOnly, Transient, NoDestructor, NativeAccessSpecifierPrivate)
	uint8                                         Pad_AA0[0x90];                                     // 0x0AA0(0x0090)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ClearCustomViewLocation()	 // 0x2daa6c0;
	void HandleReceivedDamage(class UP2HealthComponent* InHealthComponent, class AActor* InInstigator, float InDamage)	 // 0x16f49b8;
	void OnPostInitializeComponents()	 // 0x171b8d8;
	void OnReceivedDamage(float Damage)	 // 0xae1e64;
	void OnRep_EnableStrafing()	 // 0x17ecea0;
	void OnRep_PawnData(const class UP2NpcData* OldData)	 // 0xdda5b4;
	void OnRep_Stance(const struct FGameplayTag& OldStance)	 // 0x12abf88;
	void OnStanceChanged(const struct FGameplayTag& OldStance)	 // 0xae1e64;
	void SetStance(const struct FGameplayTag& NewStance)	 // 0x476c888;
	void UseCustomViewLocation(const struct FVector& InCustomViewLocation)	 // 0x2daa700;

	class UP2ContainerComponent* GetContainerComponent() const	 // 0x476a864;
	struct FVector GetFocalPoint() const	 // 0x476b124;
	class AActor* GetFocusedActor() const	 // 0x476b14c;
	class UMotionWarpingComponent* GetMotionWarpingComponent() const	 // 0x476b164;
	int32 GetMutationStage() const	 // 0x476b17c;
	struct FVector GetPrevVelocity() const	 // 0x476b278;
	const struct FGameplayTag GetStance() const	 // 0x171496c;
	void OnRep_RepOrientRotationToMovement(const bool OldValue) const	 // 0x476be20;

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"P2NPCharacter">();
	}
	static class AP2NPCharacter* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<AP2NPCharacter>();
	}
};
static_assert(alignof(AP2NPCharacter) == 0x000010, "Wrong alignment on AP2NPCharacter");
static_assert(sizeof(AP2NPCharacter) == 0x000B30, "Wrong size on AP2NPCharacter");
static_assert(offsetof(AP2NPCharacter, ReplicatedTrajectoryCurvature) == 0x0009F8, "Member 'AP2NPCharacter::ReplicatedTrajectoryCurvature' has a wrong offset!");
static_assert(offsetof(AP2NPCharacter, RandomMeshIndex) == 0x0009FC, "Member 'AP2NPCharacter::RandomMeshIndex' has a wrong offset!");
static_assert(offsetof(AP2NPCharacter, OnMovementReplicated) == 0x000A00, "Member 'AP2NPCharacter::OnMovementReplicated' has a wrong offset!");
static_assert(offsetof(AP2NPCharacter, NpcAttributeSet) == 0x000A10, "Member 'AP2NPCharacter::NpcAttributeSet' has a wrong offset!");
static_assert(offsetof(AP2NPCharacter, FocusedActor) == 0x000A18, "Member 'AP2NPCharacter::FocusedActor' has a wrong offset!");
static_assert(offsetof(AP2NPCharacter, FocalPoint) == 0x000A20, "Member 'AP2NPCharacter::FocalPoint' has a wrong offset!");
static_assert(offsetof(AP2NPCharacter, Stance) == 0x000A38, "Member 'AP2NPCharacter::Stance' has a wrong offset!");
static_assert(offsetof(AP2NPCharacter, bStrafingEnabled) == 0x000A40, "Member 'AP2NPCharacter::bStrafingEnabled' has a wrong offset!");
static_assert(offsetof(AP2NPCharacter, bRepOrientRotationToMovement) == 0x000A41, "Member 'AP2NPCharacter::bRepOrientRotationToMovement' has a wrong offset!");
static_assert(offsetof(AP2NPCharacter, MercunaGroundNavigation) == 0x000A48, "Member 'AP2NPCharacter::MercunaGroundNavigation' has a wrong offset!");
static_assert(offsetof(AP2NPCharacter, NpcComponent) == 0x000A50, "Member 'AP2NPCharacter::NpcComponent' has a wrong offset!");
static_assert(offsetof(AP2NPCharacter, ContainerComponent) == 0x000A58, "Member 'AP2NPCharacter::ContainerComponent' has a wrong offset!");
static_assert(offsetof(AP2NPCharacter, MotionWarpingComponent) == 0x000A60, "Member 'AP2NPCharacter::MotionWarpingComponent' has a wrong offset!");
static_assert(offsetof(AP2NPCharacter, P2TrajectoryGeneratorComponent) == 0x000A68, "Member 'AP2NPCharacter::P2TrajectoryGeneratorComponent' has a wrong offset!");
static_assert(offsetof(AP2NPCharacter, PawnData) == 0x000A70, "Member 'AP2NPCharacter::PawnData' has a wrong offset!");
static_assert(offsetof(AP2NPCharacter, PawnMovementOverride) == 0x000A78, "Member 'AP2NPCharacter::PawnMovementOverride' has a wrong offset!");

// Class AICommon.P2SentryActor
// 0x0200 (0x0D30 - 0x0B30)
class AP2SentryActor : public AP2NPCharacter
{
public:
	uint8                                         Pad_B30[0x18];                                     // 0x0B30(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	TMulticastInlineDelegate<void()>              OnTransferredToActor;                              // 0x0B48(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void()>              OnActivationTimerFinished;                         // 0x0B58(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void()>              OnActivationTimerStarted;                          // 0x0B68(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void()>              OnDeactivationTimerFinished;                       // 0x0B78(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void()>              OnDeployableDestroyed;                             // 0x0B88(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	class UP2Deployable*                          Deployable;                                        // 0x0B98(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, DisableEditOnTemplate, EditConst, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class USkeletalMesh>           DestroyedMesh;                                     // 0x0BA0(0x0030)(Edit, BlueprintVisible, BlueprintReadOnly, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UP2NpcData*                             NpcData;                                           // 0x0BD0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FPrimaryAssetId                        NpcDataId;                                         // 0x0BD8(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UNiagaraSystem*                         CosmeticSystem;                                    // 0x0BE8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bSpawnEffectAtSentry;                              // 0x0BF0(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_BF1[0x7];                                      // 0x0BF1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class AActor>                     ProjectileClass;                                   // 0x0BF8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ProjectileSpawnTime;                               // 0x0C00(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ProjectileVelocity;                                // 0x0C04(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         NeutralRange;                                      // 0x0C08(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PredictionTime;                                    // 0x0C0C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ActivationAimOffset;                               // 0x0C10(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDestroyTargetOnActivation;                        // 0x0C14(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C15[0x3];                                      // 0x0C15(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FP2SentryBoneConfig>            BoneConfigs;                                       // 0x0C18(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FGameplayTag                           TargetChangedCueTag;                               // 0x0C28(0x0008)(Edit, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           FireCueTag;                                        // 0x0C30(0x0008)(Edit, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           DestroyTargetCueTag;                               // 0x0C38(0x0008)(Edit, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         TeamId;                                            // 0x0C40(0x0004)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_C44[0x14];                                     // 0x0C44(0x0014)(Fixing Size After Last Property [ Dumper-7 ])
	class USceneComponent*                        EyeComponent;                                      // 0x0C58(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FName                                   EyeBoneName;                                       // 0x0C60(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FP2ReplicatedProperty_SentryTarget     TrackingTarget;                                    // 0x0C68(0x0028)(Net, RepNotify, NoDestructor, NativeAccessSpecifierPrivate)
	struct FVector                                PreviousTargetLocation;                            // 0x0C90(0x0018)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_CA8[0x18];                                     // 0x0CA8(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	TWeakObjectPtr<class UNiagaraComponent>       CosmeticComponent;                                 // 0x0CC0(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_CC8[0x8];                                      // 0x0CC8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             ProjectileSpawnTransform;                          // 0x0CD0(0x0060)(Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void OnRep_Deployable()	 // 0x477717c;
	void OnRep_SetTrackingTarget()	 // 0x4777190;

	struct FVector GetAimedAtLocation() const	 // 0x4776a2c;
	int32 GetTeamId() const	 // 0x4776b28;

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"P2SentryActor">();
	}
	static class AP2SentryActor* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<AP2SentryActor>();
	}
};
static_assert(alignof(AP2SentryActor) == 0x000010, "Wrong alignment on AP2SentryActor");
static_assert(sizeof(AP2SentryActor) == 0x000D30, "Wrong size on AP2SentryActor");
static_assert(offsetof(AP2SentryActor, OnTransferredToActor) == 0x000B48, "Member 'AP2SentryActor::OnTransferredToActor' has a wrong offset!");
static_assert(offsetof(AP2SentryActor, OnActivationTimerFinished) == 0x000B58, "Member 'AP2SentryActor::OnActivationTimerFinished' has a wrong offset!");
static_assert(offsetof(AP2SentryActor, OnActivationTimerStarted) == 0x000B68, "Member 'AP2SentryActor::OnActivationTimerStarted' has a wrong offset!");
static_assert(offsetof(AP2SentryActor, OnDeactivationTimerFinished) == 0x000B78, "Member 'AP2SentryActor::OnDeactivationTimerFinished' has a wrong offset!");
static_assert(offsetof(AP2SentryActor, OnDeployableDestroyed) == 0x000B88, "Member 'AP2SentryActor::OnDeployableDestroyed' has a wrong offset!");
static_assert(offsetof(AP2SentryActor, Deployable) == 0x000B98, "Member 'AP2SentryActor::Deployable' has a wrong offset!");
static_assert(offsetof(AP2SentryActor, DestroyedMesh) == 0x000BA0, "Member 'AP2SentryActor::DestroyedMesh' has a wrong offset!");
static_assert(offsetof(AP2SentryActor, NpcData) == 0x000BD0, "Member 'AP2SentryActor::NpcData' has a wrong offset!");
static_assert(offsetof(AP2SentryActor, NpcDataId) == 0x000BD8, "Member 'AP2SentryActor::NpcDataId' has a wrong offset!");
static_assert(offsetof(AP2SentryActor, CosmeticSystem) == 0x000BE8, "Member 'AP2SentryActor::CosmeticSystem' has a wrong offset!");
static_assert(offsetof(AP2SentryActor, bSpawnEffectAtSentry) == 0x000BF0, "Member 'AP2SentryActor::bSpawnEffectAtSentry' has a wrong offset!");
static_assert(offsetof(AP2SentryActor, ProjectileClass) == 0x000BF8, "Member 'AP2SentryActor::ProjectileClass' has a wrong offset!");
static_assert(offsetof(AP2SentryActor, ProjectileSpawnTime) == 0x000C00, "Member 'AP2SentryActor::ProjectileSpawnTime' has a wrong offset!");
static_assert(offsetof(AP2SentryActor, ProjectileVelocity) == 0x000C04, "Member 'AP2SentryActor::ProjectileVelocity' has a wrong offset!");
static_assert(offsetof(AP2SentryActor, NeutralRange) == 0x000C08, "Member 'AP2SentryActor::NeutralRange' has a wrong offset!");
static_assert(offsetof(AP2SentryActor, PredictionTime) == 0x000C0C, "Member 'AP2SentryActor::PredictionTime' has a wrong offset!");
static_assert(offsetof(AP2SentryActor, ActivationAimOffset) == 0x000C10, "Member 'AP2SentryActor::ActivationAimOffset' has a wrong offset!");
static_assert(offsetof(AP2SentryActor, bDestroyTargetOnActivation) == 0x000C14, "Member 'AP2SentryActor::bDestroyTargetOnActivation' has a wrong offset!");
static_assert(offsetof(AP2SentryActor, BoneConfigs) == 0x000C18, "Member 'AP2SentryActor::BoneConfigs' has a wrong offset!");
static_assert(offsetof(AP2SentryActor, TargetChangedCueTag) == 0x000C28, "Member 'AP2SentryActor::TargetChangedCueTag' has a wrong offset!");
static_assert(offsetof(AP2SentryActor, FireCueTag) == 0x000C30, "Member 'AP2SentryActor::FireCueTag' has a wrong offset!");
static_assert(offsetof(AP2SentryActor, DestroyTargetCueTag) == 0x000C38, "Member 'AP2SentryActor::DestroyTargetCueTag' has a wrong offset!");
static_assert(offsetof(AP2SentryActor, TeamId) == 0x000C40, "Member 'AP2SentryActor::TeamId' has a wrong offset!");
static_assert(offsetof(AP2SentryActor, EyeComponent) == 0x000C58, "Member 'AP2SentryActor::EyeComponent' has a wrong offset!");
static_assert(offsetof(AP2SentryActor, EyeBoneName) == 0x000C60, "Member 'AP2SentryActor::EyeBoneName' has a wrong offset!");
static_assert(offsetof(AP2SentryActor, TrackingTarget) == 0x000C68, "Member 'AP2SentryActor::TrackingTarget' has a wrong offset!");
static_assert(offsetof(AP2SentryActor, PreviousTargetLocation) == 0x000C90, "Member 'AP2SentryActor::PreviousTargetLocation' has a wrong offset!");
static_assert(offsetof(AP2SentryActor, CosmeticComponent) == 0x000CC0, "Member 'AP2SentryActor::CosmeticComponent' has a wrong offset!");
static_assert(offsetof(AP2SentryActor, ProjectileSpawnTransform) == 0x000CD0, "Member 'AP2SentryActor::ProjectileSpawnTransform' has a wrong offset!");

// Class AICommon.P2BTService_TryActivateAbility
// 0x0048 (0x00B8 - 0x0070)
class UP2BTService_TryActivateAbility : public UBTService
{
public:
	bool                                          bUseTargetData;                                    // 0x0070(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_71[0x7];                                       // 0x0071(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FBlackboardKeySelector                 TargetKey;                                         // 0x0078(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)
	TSubclassOf<class UGameplayAbility>           AbilityClass;                                      // 0x00A0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_A8[0x10];                                      // 0x00A8(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"P2BTService_TryActivateAbility">();
	}
	static class UP2BTService_TryActivateAbility* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UP2BTService_TryActivateAbility>();
	}
};
static_assert(alignof(UP2BTService_TryActivateAbility) == 0x000008, "Wrong alignment on UP2BTService_TryActivateAbility");
static_assert(sizeof(UP2BTService_TryActivateAbility) == 0x0000B8, "Wrong size on UP2BTService_TryActivateAbility");
static_assert(offsetof(UP2BTService_TryActivateAbility, bUseTargetData) == 0x000070, "Member 'UP2BTService_TryActivateAbility::bUseTargetData' has a wrong offset!");
static_assert(offsetof(UP2BTService_TryActivateAbility, TargetKey) == 0x000078, "Member 'UP2BTService_TryActivateAbility::TargetKey' has a wrong offset!");
static_assert(offsetof(UP2BTService_TryActivateAbility, AbilityClass) == 0x0000A0, "Member 'UP2BTService_TryActivateAbility::AbilityClass' has a wrong offset!");

// Class AICommon.P2BTService_TryActivateAbilityWithAttackTicket
// 0x0008 (0x00C0 - 0x00B8)
class UP2BTService_TryActivateAbilityWithAttackTicket : public UP2BTService_TryActivateAbility
{
public:
	bool                                          bRequireTicket;                                    // 0x00B8(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_B9[0x7];                                       // 0x00B9(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"P2BTService_TryActivateAbilityWithAttackTicket">();
	}
	static class UP2BTService_TryActivateAbilityWithAttackTicket* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UP2BTService_TryActivateAbilityWithAttackTicket>();
	}
};
static_assert(alignof(UP2BTService_TryActivateAbilityWithAttackTicket) == 0x000008, "Wrong alignment on UP2BTService_TryActivateAbilityWithAttackTicket");
static_assert(sizeof(UP2BTService_TryActivateAbilityWithAttackTicket) == 0x0000C0, "Wrong size on UP2BTService_TryActivateAbilityWithAttackTicket");
static_assert(offsetof(UP2BTService_TryActivateAbilityWithAttackTicket, bRequireTicket) == 0x0000B8, "Member 'UP2BTService_TryActivateAbilityWithAttackTicket::bRequireTicket' has a wrong offset!");

// Class AICommon.P2BTService_BombugSprayService
// 0x0030 (0x00F0 - 0x00C0)
class UP2BTService_BombugSprayService final : public UP2BTService_TryActivateAbilityWithAttackTicket
{
public:
	ECollisionChannel                             CollisionChannel;                                  // 0x00C0(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_C1[0x3];                                       // 0x00C1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ChanceToSwitchToMelee;                             // 0x00C4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FBlackboardKeySelector                 MeleeModeKey;                                      // 0x00C8(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"P2BTService_BombugSprayService">();
	}
	static class UP2BTService_BombugSprayService* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UP2BTService_BombugSprayService>();
	}
};
static_assert(alignof(UP2BTService_BombugSprayService) == 0x000008, "Wrong alignment on UP2BTService_BombugSprayService");
static_assert(sizeof(UP2BTService_BombugSprayService) == 0x0000F0, "Wrong size on UP2BTService_BombugSprayService");
static_assert(offsetof(UP2BTService_BombugSprayService, CollisionChannel) == 0x0000C0, "Member 'UP2BTService_BombugSprayService::CollisionChannel' has a wrong offset!");
static_assert(offsetof(UP2BTService_BombugSprayService, ChanceToSwitchToMelee) == 0x0000C4, "Member 'UP2BTService_BombugSprayService::ChanceToSwitchToMelee' has a wrong offset!");
static_assert(offsetof(UP2BTService_BombugSprayService, MeleeModeKey) == 0x0000C8, "Member 'UP2BTService_BombugSprayService::MeleeModeKey' has a wrong offset!");

// Class AICommon.P2LightSourceReactionData
// 0x0040 (0x0070 - 0x0030)
class UP2LightSourceReactionData final : public UPrimaryDataAsset
{
public:
	struct FGameplayTagContainer                  LevelVolumeTagsToReactOnLightSources;              // 0x0030(0x0020)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	float                                         DetectionIncreaseSpeedByLightSources;              // 0x0050(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_54[0x4];                                       // 0x0054(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UCurveFloat*                            DistanceMultiplierCurve;                           // 0x0058(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCurveFloat*                            DirectionMultiplierCurve;                          // 0x0060(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FColor                                 DebugColor;                                        // 0x0068(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_6C[0x4];                                       // 0x006C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"P2LightSourceReactionData">();
	}
	static class UP2LightSourceReactionData* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UP2LightSourceReactionData>();
	}
};
static_assert(alignof(UP2LightSourceReactionData) == 0x000008, "Wrong alignment on UP2LightSourceReactionData");
static_assert(sizeof(UP2LightSourceReactionData) == 0x000070, "Wrong size on UP2LightSourceReactionData");
static_assert(offsetof(UP2LightSourceReactionData, LevelVolumeTagsToReactOnLightSources) == 0x000030, "Member 'UP2LightSourceReactionData::LevelVolumeTagsToReactOnLightSources' has a wrong offset!");
static_assert(offsetof(UP2LightSourceReactionData, DetectionIncreaseSpeedByLightSources) == 0x000050, "Member 'UP2LightSourceReactionData::DetectionIncreaseSpeedByLightSources' has a wrong offset!");
static_assert(offsetof(UP2LightSourceReactionData, DistanceMultiplierCurve) == 0x000058, "Member 'UP2LightSourceReactionData::DistanceMultiplierCurve' has a wrong offset!");
static_assert(offsetof(UP2LightSourceReactionData, DirectionMultiplierCurve) == 0x000060, "Member 'UP2LightSourceReactionData::DirectionMultiplierCurve' has a wrong offset!");
static_assert(offsetof(UP2LightSourceReactionData, DebugColor) == 0x000068, "Member 'UP2LightSourceReactionData::DebugColor' has a wrong offset!");

// Class AICommon.P2BTService_CheckShortcut
// 0x00C0 (0x0130 - 0x0070)
class UP2BTService_CheckShortcut final : public UBTService
{
public:
	struct FBlackboardKeySelector                 TargetKey;                                         // 0x0070(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FBlackboardKeySelector                 ShortcutStartKey;                                  // 0x0098(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FBlackboardKeySelector                 ShortcutDataKey;                                   // 0x00C0(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FBlackboardKeySelector                 BoolFlagToClear;                                   // 0x00E8(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	float                                         ShortcutCheckDistance;                             // 0x0110(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MinShortcutDistance;                               // 0x0114(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RemainingPathShortcutFraction;                     // 0x0118(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAllowZeroPathDistance;                            // 0x011C(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bClearFlagOnAbilityActivation;                     // 0x011D(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bClampToMercunaNavigable;                          // 0x011E(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11F[0x1];                                      // 0x011F(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ClampNavigableRadius;                              // 0x0120(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ClampNavigableMaxHeightDifference;                 // 0x0124(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UP2ShortcutDataSet*                     ShortcutSet;                                       // 0x0128(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"P2BTService_CheckShortcut">();
	}
	static class UP2BTService_CheckShortcut* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UP2BTService_CheckShortcut>();
	}
};
static_assert(alignof(UP2BTService_CheckShortcut) == 0x000008, "Wrong alignment on UP2BTService_CheckShortcut");
static_assert(sizeof(UP2BTService_CheckShortcut) == 0x000130, "Wrong size on UP2BTService_CheckShortcut");
static_assert(offsetof(UP2BTService_CheckShortcut, TargetKey) == 0x000070, "Member 'UP2BTService_CheckShortcut::TargetKey' has a wrong offset!");
static_assert(offsetof(UP2BTService_CheckShortcut, ShortcutStartKey) == 0x000098, "Member 'UP2BTService_CheckShortcut::ShortcutStartKey' has a wrong offset!");
static_assert(offsetof(UP2BTService_CheckShortcut, ShortcutDataKey) == 0x0000C0, "Member 'UP2BTService_CheckShortcut::ShortcutDataKey' has a wrong offset!");
static_assert(offsetof(UP2BTService_CheckShortcut, BoolFlagToClear) == 0x0000E8, "Member 'UP2BTService_CheckShortcut::BoolFlagToClear' has a wrong offset!");
static_assert(offsetof(UP2BTService_CheckShortcut, ShortcutCheckDistance) == 0x000110, "Member 'UP2BTService_CheckShortcut::ShortcutCheckDistance' has a wrong offset!");
static_assert(offsetof(UP2BTService_CheckShortcut, MinShortcutDistance) == 0x000114, "Member 'UP2BTService_CheckShortcut::MinShortcutDistance' has a wrong offset!");
static_assert(offsetof(UP2BTService_CheckShortcut, RemainingPathShortcutFraction) == 0x000118, "Member 'UP2BTService_CheckShortcut::RemainingPathShortcutFraction' has a wrong offset!");
static_assert(offsetof(UP2BTService_CheckShortcut, bAllowZeroPathDistance) == 0x00011C, "Member 'UP2BTService_CheckShortcut::bAllowZeroPathDistance' has a wrong offset!");
static_assert(offsetof(UP2BTService_CheckShortcut, bClearFlagOnAbilityActivation) == 0x00011D, "Member 'UP2BTService_CheckShortcut::bClearFlagOnAbilityActivation' has a wrong offset!");
static_assert(offsetof(UP2BTService_CheckShortcut, bClampToMercunaNavigable) == 0x00011E, "Member 'UP2BTService_CheckShortcut::bClampToMercunaNavigable' has a wrong offset!");
static_assert(offsetof(UP2BTService_CheckShortcut, ClampNavigableRadius) == 0x000120, "Member 'UP2BTService_CheckShortcut::ClampNavigableRadius' has a wrong offset!");
static_assert(offsetof(UP2BTService_CheckShortcut, ClampNavigableMaxHeightDifference) == 0x000124, "Member 'UP2BTService_CheckShortcut::ClampNavigableMaxHeightDifference' has a wrong offset!");
static_assert(offsetof(UP2BTService_CheckShortcut, ShortcutSet) == 0x000128, "Member 'UP2BTService_CheckShortcut::ShortcutSet' has a wrong offset!");

// Class AICommon.P2NpcSpawningDebugWidget
// 0x0010 (0x05B0 - 0x05A0)
class UP2NpcSpawningDebugWidget final : public UP2PanZoomWidget
{
public:
	uint8                                         Pad_5A0[0x10];                                     // 0x05A0(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnClearUI()	 // 0xae1e64;
	void OnFinishSpawning(int32 InSeed, const TArray<struct FP2NpcSpawningCell>& InCells, const TArray<struct FP2NpcSpawningGeneratedPoint>& InPoints, const TArray<struct FP2NpcSpawningSpawnedCreature>& InTextureCreatures, const TArray<struct FP2NpcSpawningSpawnedCreature>& InVolumeCreatures, float InTimeSpent)	 // 0xae1e64;
	void Regen(bool bInInitializeSeed, int32 InCustomSeed)	 // 0x476bef4;

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"P2NpcSpawningDebugWidget">();
	}
	static class UP2NpcSpawningDebugWidget* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UP2NpcSpawningDebugWidget>();
	}
};
static_assert(alignof(UP2NpcSpawningDebugWidget) == 0x000008, "Wrong alignment on UP2NpcSpawningDebugWidget");
static_assert(sizeof(UP2NpcSpawningDebugWidget) == 0x0005B0, "Wrong size on UP2NpcSpawningDebugWidget");

// Class AICommon.P2BTService_ConditionalRunEQS
// 0x00C8 (0x0160 - 0x0098)
class UP2BTService_ConditionalRunEQS final : public UBTService_BlackboardBase
{
public:
	class UEnvQuery*                              QueryTemplate;                                     // 0x0098(0x0008)(Edit, ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FBlackboardKeySelector                 EQSQueryBlackboardKey;                             // 0x00A0(0x0028)(Edit, Protected, NativeAccessSpecifierProtected)
	struct FGameplayTag                           CooldownTag;                                       // 0x00C8(0x0008)(Edit, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bCheckDistance;                                    // 0x00D0(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_D1[0x3];                                       // 0x00D1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Distance;                                          // 0x00D4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bInverseDistance;                                  // 0x00D8(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_D9[0x7];                                       // 0x00D9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FBlackboardKeySelector                 DistanceBlackboardKey;                             // 0x00E0(0x0028)(Edit, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_108[0x58];                                     // 0x0108(0x0058)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"P2BTService_ConditionalRunEQS">();
	}
	static class UP2BTService_ConditionalRunEQS* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UP2BTService_ConditionalRunEQS>();
	}
};
static_assert(alignof(UP2BTService_ConditionalRunEQS) == 0x000008, "Wrong alignment on UP2BTService_ConditionalRunEQS");
static_assert(sizeof(UP2BTService_ConditionalRunEQS) == 0x000160, "Wrong size on UP2BTService_ConditionalRunEQS");
static_assert(offsetof(UP2BTService_ConditionalRunEQS, QueryTemplate) == 0x000098, "Member 'UP2BTService_ConditionalRunEQS::QueryTemplate' has a wrong offset!");
static_assert(offsetof(UP2BTService_ConditionalRunEQS, EQSQueryBlackboardKey) == 0x0000A0, "Member 'UP2BTService_ConditionalRunEQS::EQSQueryBlackboardKey' has a wrong offset!");
static_assert(offsetof(UP2BTService_ConditionalRunEQS, CooldownTag) == 0x0000C8, "Member 'UP2BTService_ConditionalRunEQS::CooldownTag' has a wrong offset!");
static_assert(offsetof(UP2BTService_ConditionalRunEQS, bCheckDistance) == 0x0000D0, "Member 'UP2BTService_ConditionalRunEQS::bCheckDistance' has a wrong offset!");
static_assert(offsetof(UP2BTService_ConditionalRunEQS, Distance) == 0x0000D4, "Member 'UP2BTService_ConditionalRunEQS::Distance' has a wrong offset!");
static_assert(offsetof(UP2BTService_ConditionalRunEQS, bInverseDistance) == 0x0000D8, "Member 'UP2BTService_ConditionalRunEQS::bInverseDistance' has a wrong offset!");
static_assert(offsetof(UP2BTService_ConditionalRunEQS, DistanceBlackboardKey) == 0x0000E0, "Member 'UP2BTService_ConditionalRunEQS::DistanceBlackboardKey' has a wrong offset!");

// Class AICommon.P2SmartObjectDefinitionsData
// 0x0068 (0x0098 - 0x0030)
class UP2SmartObjectDefinitionsData final : public UPrimaryDataAsset
{
public:
	TArray<struct FDirectoryPath>                 DirectoriesToLoadDefinitions;                      // 0x0030(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	bool                                          bAutoLoadDefinitions;                              // 0x0040(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_41[0x7];                                       // 0x0041(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TSet<class UP2SmartObjectDefinition*>         SupportedDefinitions;                              // 0x0048(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, Protected, UObjectWrapper, NativeAccessSpecifierProtected)

public:
	void LoadDefinitionsFromDirectories()	 // 0x4776dfc;

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"P2SmartObjectDefinitionsData">();
	}
	static class UP2SmartObjectDefinitionsData* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UP2SmartObjectDefinitionsData>();
	}
};
static_assert(alignof(UP2SmartObjectDefinitionsData) == 0x000008, "Wrong alignment on UP2SmartObjectDefinitionsData");
static_assert(sizeof(UP2SmartObjectDefinitionsData) == 0x000098, "Wrong size on UP2SmartObjectDefinitionsData");
static_assert(offsetof(UP2SmartObjectDefinitionsData, DirectoriesToLoadDefinitions) == 0x000030, "Member 'UP2SmartObjectDefinitionsData::DirectoriesToLoadDefinitions' has a wrong offset!");
static_assert(offsetof(UP2SmartObjectDefinitionsData, bAutoLoadDefinitions) == 0x000040, "Member 'UP2SmartObjectDefinitionsData::bAutoLoadDefinitions' has a wrong offset!");
static_assert(offsetof(UP2SmartObjectDefinitionsData, SupportedDefinitions) == 0x000048, "Member 'UP2SmartObjectDefinitionsData::SupportedDefinitions' has a wrong offset!");

// Class AICommon.P2BTService_Croc_UpdateCamouflage
// 0x0000 (0x0070 - 0x0070)
class UP2BTService_Croc_UpdateCamouflage final : public UBTService
{
public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"P2BTService_Croc_UpdateCamouflage">();
	}
	static class UP2BTService_Croc_UpdateCamouflage* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UP2BTService_Croc_UpdateCamouflage>();
	}
};
static_assert(alignof(UP2BTService_Croc_UpdateCamouflage) == 0x000008, "Wrong alignment on UP2BTService_Croc_UpdateCamouflage");
static_assert(sizeof(UP2BTService_Croc_UpdateCamouflage) == 0x000070, "Wrong size on UP2BTService_Croc_UpdateCamouflage");

// Class AICommon.P2BTService_Debug
// 0x0030 (0x00A0 - 0x0070)
class UP2BTService_Debug final : public UBTService
{
public:
	struct FColor                                 Color;                                             // 0x0070(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_74[0x4];                                       // 0x0074(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 Text;                                              // 0x0078(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector                                Offset;                                            // 0x0088(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"P2BTService_Debug">();
	}
	static class UP2BTService_Debug* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UP2BTService_Debug>();
	}
};
static_assert(alignof(UP2BTService_Debug) == 0x000008, "Wrong alignment on UP2BTService_Debug");
static_assert(sizeof(UP2BTService_Debug) == 0x0000A0, "Wrong size on UP2BTService_Debug");
static_assert(offsetof(UP2BTService_Debug, Color) == 0x000070, "Member 'UP2BTService_Debug::Color' has a wrong offset!");
static_assert(offsetof(UP2BTService_Debug, Text) == 0x000078, "Member 'UP2BTService_Debug::Text' has a wrong offset!");
static_assert(offsetof(UP2BTService_Debug, Offset) == 0x000088, "Member 'UP2BTService_Debug::Offset' has a wrong offset!");

// Class AICommon.P2PassageNavLink
// 0x0030 (0x05B0 - 0x0580)
class AP2PassageNavLink final : public AP2MercunaNavLink
{
public:
	TSoftObjectPtr<class AActor>                  LinkOwner;                                         // 0x0580(0x0030)(Edit, Transient, EditConst, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void OnPassageBlockerUpdated(EPassageState InState)	 // 0x47732b0;

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"P2PassageNavLink">();
	}
	static class AP2PassageNavLink* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<AP2PassageNavLink>();
	}
};
static_assert(alignof(AP2PassageNavLink) == 0x000010, "Wrong alignment on AP2PassageNavLink");
static_assert(sizeof(AP2PassageNavLink) == 0x0005B0, "Wrong size on AP2PassageNavLink");
static_assert(offsetof(AP2PassageNavLink, LinkOwner) == 0x000580, "Member 'AP2PassageNavLink::LinkOwner' has a wrong offset!");

// Class AICommon.P2BTService_DisableInterestLevelDecreasing
// 0x0008 (0x0078 - 0x0070)
class UP2BTService_DisableInterestLevelDecreasing final : public UBTService
{
public:
	bool                                          bInterestsDecreasingEnabled;                       // 0x0070(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_71[0x7];                                       // 0x0071(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"P2BTService_DisableInterestLevelDecreasing">();
	}
	static class UP2BTService_DisableInterestLevelDecreasing* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UP2BTService_DisableInterestLevelDecreasing>();
	}
};
static_assert(alignof(UP2BTService_DisableInterestLevelDecreasing) == 0x000008, "Wrong alignment on UP2BTService_DisableInterestLevelDecreasing");
static_assert(sizeof(UP2BTService_DisableInterestLevelDecreasing) == 0x000078, "Wrong size on UP2BTService_DisableInterestLevelDecreasing");
static_assert(offsetof(UP2BTService_DisableInterestLevelDecreasing, bInterestsDecreasingEnabled) == 0x000070, "Member 'UP2BTService_DisableInterestLevelDecreasing::bInterestsDecreasingEnabled' has a wrong offset!");

// Class AICommon.p2BTService_EnableStrafing
// 0x0008 (0x0078 - 0x0070)
class Up2BTService_EnableStrafing final : public UBTService
{
public:
	uint8                                         Pad_70[0x8];                                       // 0x0070(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"p2BTService_EnableStrafing">();
	}
	static class Up2BTService_EnableStrafing* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<Up2BTService_EnableStrafing>();
	}
};
static_assert(alignof(Up2BTService_EnableStrafing) == 0x000008, "Wrong alignment on Up2BTService_EnableStrafing");
static_assert(sizeof(Up2BTService_EnableStrafing) == 0x000078, "Wrong size on Up2BTService_EnableStrafing");

// Class AICommon.P2SmartObjectDefinition
// 0x00B0 (0x00E0 - 0x0030)
class UP2SmartObjectDefinition : public UDataAsset
{
public:
	struct FGameplayTagContainer                  Tags;                                              // 0x0030(0x0020)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FGameplayTagQuery                      UserTagsFilter;                                    // 0x0050(0x0048)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	TSubclassOf<class UP2SmartObject>             Implementation;                                    // 0x0098(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<TSubclassOf<class AP2SmartObjectProxy>> Proxies;                                          // 0x00A0(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
	TArray<class UStaticMesh*>                    FoliageProxies;                                    // 0x00B0(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
	TArray<class UStaticMesh*>                    StaticMeshProxies;                                 // 0x00C0(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
	TArray<TSubclassOf<class UP2SmartObjectProxyComponent>> ProxyComponents;                         // 0x00D0(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"P2SmartObjectDefinition">();
	}
	static class UP2SmartObjectDefinition* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UP2SmartObjectDefinition>();
	}
};
static_assert(alignof(UP2SmartObjectDefinition) == 0x000008, "Wrong alignment on UP2SmartObjectDefinition");
static_assert(sizeof(UP2SmartObjectDefinition) == 0x0000E0, "Wrong size on UP2SmartObjectDefinition");
static_assert(offsetof(UP2SmartObjectDefinition, Tags) == 0x000030, "Member 'UP2SmartObjectDefinition::Tags' has a wrong offset!");
static_assert(offsetof(UP2SmartObjectDefinition, UserTagsFilter) == 0x000050, "Member 'UP2SmartObjectDefinition::UserTagsFilter' has a wrong offset!");
static_assert(offsetof(UP2SmartObjectDefinition, Implementation) == 0x000098, "Member 'UP2SmartObjectDefinition::Implementation' has a wrong offset!");
static_assert(offsetof(UP2SmartObjectDefinition, Proxies) == 0x0000A0, "Member 'UP2SmartObjectDefinition::Proxies' has a wrong offset!");
static_assert(offsetof(UP2SmartObjectDefinition, FoliageProxies) == 0x0000B0, "Member 'UP2SmartObjectDefinition::FoliageProxies' has a wrong offset!");
static_assert(offsetof(UP2SmartObjectDefinition, StaticMeshProxies) == 0x0000C0, "Member 'UP2SmartObjectDefinition::StaticMeshProxies' has a wrong offset!");
static_assert(offsetof(UP2SmartObjectDefinition, ProxyComponents) == 0x0000D0, "Member 'UP2SmartObjectDefinition::ProxyComponents' has a wrong offset!");

// Class AICommon.P2SmartObjectDefinition_WildCatTree
// 0x0048 (0x0128 - 0x00E0)
class UP2SmartObjectDefinition_WildCatTree final : public UP2SmartObjectDefinition
{
public:
	float                                         ClimbUp_Duration;                                  // 0x00E0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ClimbUp_BlendInTime;                               // 0x00E4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UP2TransformCurve*                      ClimbUp_TransformCurve;                            // 0x00E8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ClimbDown_Duration;                                // 0x00F0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ClimbDown_BlendOutTime;                            // 0x00F4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UP2TransformCurve*                      ClimbDown_TransformCurve;                          // 0x00F8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimMontage*                           AttackLandedMontage;                               // 0x0100(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimMontage*                           JumpDownLanded;                                    // 0x0108(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimMontage*                           ClimbDowLandedMontage;                             // 0x0110(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UP2NpcAbility_WildCatUseTree> Ability;                                         // 0x0118(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ClimbSpeed;                                        // 0x0120(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_124[0x4];                                      // 0x0124(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"P2SmartObjectDefinition_WildCatTree">();
	}
	static class UP2SmartObjectDefinition_WildCatTree* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UP2SmartObjectDefinition_WildCatTree>();
	}
};
static_assert(alignof(UP2SmartObjectDefinition_WildCatTree) == 0x000008, "Wrong alignment on UP2SmartObjectDefinition_WildCatTree");
static_assert(sizeof(UP2SmartObjectDefinition_WildCatTree) == 0x000128, "Wrong size on UP2SmartObjectDefinition_WildCatTree");
static_assert(offsetof(UP2SmartObjectDefinition_WildCatTree, ClimbUp_Duration) == 0x0000E0, "Member 'UP2SmartObjectDefinition_WildCatTree::ClimbUp_Duration' has a wrong offset!");
static_assert(offsetof(UP2SmartObjectDefinition_WildCatTree, ClimbUp_BlendInTime) == 0x0000E4, "Member 'UP2SmartObjectDefinition_WildCatTree::ClimbUp_BlendInTime' has a wrong offset!");
static_assert(offsetof(UP2SmartObjectDefinition_WildCatTree, ClimbUp_TransformCurve) == 0x0000E8, "Member 'UP2SmartObjectDefinition_WildCatTree::ClimbUp_TransformCurve' has a wrong offset!");
static_assert(offsetof(UP2SmartObjectDefinition_WildCatTree, ClimbDown_Duration) == 0x0000F0, "Member 'UP2SmartObjectDefinition_WildCatTree::ClimbDown_Duration' has a wrong offset!");
static_assert(offsetof(UP2SmartObjectDefinition_WildCatTree, ClimbDown_BlendOutTime) == 0x0000F4, "Member 'UP2SmartObjectDefinition_WildCatTree::ClimbDown_BlendOutTime' has a wrong offset!");
static_assert(offsetof(UP2SmartObjectDefinition_WildCatTree, ClimbDown_TransformCurve) == 0x0000F8, "Member 'UP2SmartObjectDefinition_WildCatTree::ClimbDown_TransformCurve' has a wrong offset!");
static_assert(offsetof(UP2SmartObjectDefinition_WildCatTree, AttackLandedMontage) == 0x000100, "Member 'UP2SmartObjectDefinition_WildCatTree::AttackLandedMontage' has a wrong offset!");
static_assert(offsetof(UP2SmartObjectDefinition_WildCatTree, JumpDownLanded) == 0x000108, "Member 'UP2SmartObjectDefinition_WildCatTree::JumpDownLanded' has a wrong offset!");
static_assert(offsetof(UP2SmartObjectDefinition_WildCatTree, ClimbDowLandedMontage) == 0x000110, "Member 'UP2SmartObjectDefinition_WildCatTree::ClimbDowLandedMontage' has a wrong offset!");
static_assert(offsetof(UP2SmartObjectDefinition_WildCatTree, Ability) == 0x000118, "Member 'UP2SmartObjectDefinition_WildCatTree::Ability' has a wrong offset!");
static_assert(offsetof(UP2SmartObjectDefinition_WildCatTree, ClimbSpeed) == 0x000120, "Member 'UP2SmartObjectDefinition_WildCatTree::ClimbSpeed' has a wrong offset!");

// Class AICommon.P2BTService_FilterClass
// 0x0008 (0x0078 - 0x0070)
class UP2BTService_FilterClass final : public UBTService
{
public:
	TSubclassOf<class UNavigationQueryFilter>     NavigationFilterClass;                             // 0x0070(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"P2BTService_FilterClass">();
	}
	static class UP2BTService_FilterClass* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UP2BTService_FilterClass>();
	}
};
static_assert(alignof(UP2BTService_FilterClass) == 0x000008, "Wrong alignment on UP2BTService_FilterClass");
static_assert(sizeof(UP2BTService_FilterClass) == 0x000078, "Wrong size on UP2BTService_FilterClass");
static_assert(offsetof(UP2BTService_FilterClass, NavigationFilterClass) == 0x000070, "Member 'UP2BTService_FilterClass::NavigationFilterClass' has a wrong offset!");

// Class AICommon.P2NpcSpawningVolumeBase
// 0x0008 (0x02F0 - 0x02E8)
class AP2NpcSpawningVolumeBase : public AVolume
{
public:
	struct FColor                                 Color;                                             // 0x02E8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2EC[0x4];                                      // 0x02EC(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"P2NpcSpawningVolumeBase">();
	}
	static class AP2NpcSpawningVolumeBase* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<AP2NpcSpawningVolumeBase>();
	}
};
static_assert(alignof(AP2NpcSpawningVolumeBase) == 0x000008, "Wrong alignment on AP2NpcSpawningVolumeBase");
static_assert(sizeof(AP2NpcSpawningVolumeBase) == 0x0002F0, "Wrong size on AP2NpcSpawningVolumeBase");
static_assert(offsetof(AP2NpcSpawningVolumeBase, Color) == 0x0002E8, "Member 'AP2NpcSpawningVolumeBase::Color' has a wrong offset!");

// Class AICommon.P2NpcSpawningExclusionVolume
// 0x0000 (0x02F0 - 0x02F0)
class AP2NpcSpawningExclusionVolume final : public AP2NpcSpawningVolumeBase
{
public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"P2NpcSpawningExclusionVolume">();
	}
	static class AP2NpcSpawningExclusionVolume* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<AP2NpcSpawningExclusionVolume>();
	}
};
static_assert(alignof(AP2NpcSpawningExclusionVolume) == 0x000008, "Wrong alignment on AP2NpcSpawningExclusionVolume");
static_assert(sizeof(AP2NpcSpawningExclusionVolume) == 0x0002F0, "Wrong size on AP2NpcSpawningExclusionVolume");

// Class AICommon.P2BTService_GhostAttack
// 0x0008 (0x00C0 - 0x00B8)
class UP2BTService_GhostAttack final : public UP2BTService_GhostBase
{
public:
	bool                                          bIgnoreGroupRoe;                                   // 0x00B8(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bDebugAllowAttack;                                 // 0x00B9(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bDebugForceAttack;                                 // 0x00BA(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_BB[0x5];                                       // 0x00BB(0x0005)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"P2BTService_GhostAttack">();
	}
	static class UP2BTService_GhostAttack* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UP2BTService_GhostAttack>();
	}
};
static_assert(alignof(UP2BTService_GhostAttack) == 0x000008, "Wrong alignment on UP2BTService_GhostAttack");
static_assert(sizeof(UP2BTService_GhostAttack) == 0x0000C0, "Wrong size on UP2BTService_GhostAttack");
static_assert(offsetof(UP2BTService_GhostAttack, bIgnoreGroupRoe) == 0x0000B8, "Member 'UP2BTService_GhostAttack::bIgnoreGroupRoe' has a wrong offset!");
static_assert(offsetof(UP2BTService_GhostAttack, bDebugAllowAttack) == 0x0000B9, "Member 'UP2BTService_GhostAttack::bDebugAllowAttack' has a wrong offset!");
static_assert(offsetof(UP2BTService_GhostAttack, bDebugForceAttack) == 0x0000BA, "Member 'UP2BTService_GhostAttack::bDebugForceAttack' has a wrong offset!");

// Class AICommon.P2NpcCamouflageComponent
// 0x0040 (0x0100 - 0x00C0)
class UP2NpcCamouflageComponent : public UActorComponent
{
public:
	float                                         TargetIntensityValue;                              // 0x00C0(0x0004)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         TransitionSpeedModifier;                           // 0x00C4(0x0004)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bUseConstantInterpolation;                         // 0x00C8(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_C9[0x3];                                       // 0x00C9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         IntensityValue;                                    // 0x00CC(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          State;                                             // 0x00D0(0x0001)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bIsFrozen;                                         // 0x00D1(0x0001)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_D2[0x2];                                       // 0x00D2(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   MaterialIntensityParameterName;                    // 0x00D4(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FName                                   MaterialAccuracyParameterName;                     // 0x00DC(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_E4[0x4];                                       // 0x00E4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UCurveFloat*                            CamouflageVelocityCurve;                           // 0x00E8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         BaseTransitionTime;                                // 0x00F0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_F4[0xC];                                       // 0x00F4(0x000C)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnRep_IsFrozen(const bool& IsFrozen)	 // 0x178c1bc;
	void OnRep_State(const bool& PrevState)	 // 0x178c1bc;

	bool GetState() const	 // 0x4766ea8;

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"P2NpcCamouflageComponent">();
	}
	static class UP2NpcCamouflageComponent* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UP2NpcCamouflageComponent>();
	}
};
static_assert(alignof(UP2NpcCamouflageComponent) == 0x000008, "Wrong alignment on UP2NpcCamouflageComponent");
static_assert(sizeof(UP2NpcCamouflageComponent) == 0x000100, "Wrong size on UP2NpcCamouflageComponent");
static_assert(offsetof(UP2NpcCamouflageComponent, TargetIntensityValue) == 0x0000C0, "Member 'UP2NpcCamouflageComponent::TargetIntensityValue' has a wrong offset!");
static_assert(offsetof(UP2NpcCamouflageComponent, TransitionSpeedModifier) == 0x0000C4, "Member 'UP2NpcCamouflageComponent::TransitionSpeedModifier' has a wrong offset!");
static_assert(offsetof(UP2NpcCamouflageComponent, bUseConstantInterpolation) == 0x0000C8, "Member 'UP2NpcCamouflageComponent::bUseConstantInterpolation' has a wrong offset!");
static_assert(offsetof(UP2NpcCamouflageComponent, IntensityValue) == 0x0000CC, "Member 'UP2NpcCamouflageComponent::IntensityValue' has a wrong offset!");
static_assert(offsetof(UP2NpcCamouflageComponent, State) == 0x0000D0, "Member 'UP2NpcCamouflageComponent::State' has a wrong offset!");
static_assert(offsetof(UP2NpcCamouflageComponent, bIsFrozen) == 0x0000D1, "Member 'UP2NpcCamouflageComponent::bIsFrozen' has a wrong offset!");
static_assert(offsetof(UP2NpcCamouflageComponent, MaterialIntensityParameterName) == 0x0000D4, "Member 'UP2NpcCamouflageComponent::MaterialIntensityParameterName' has a wrong offset!");
static_assert(offsetof(UP2NpcCamouflageComponent, MaterialAccuracyParameterName) == 0x0000DC, "Member 'UP2NpcCamouflageComponent::MaterialAccuracyParameterName' has a wrong offset!");
static_assert(offsetof(UP2NpcCamouflageComponent, CamouflageVelocityCurve) == 0x0000E8, "Member 'UP2NpcCamouflageComponent::CamouflageVelocityCurve' has a wrong offset!");
static_assert(offsetof(UP2NpcCamouflageComponent, BaseTransitionTime) == 0x0000F0, "Member 'UP2NpcCamouflageComponent::BaseTransitionTime' has a wrong offset!");

// Class AICommon.P2PsycheCamouflageComponent
// 0x0020 (0x0120 - 0x0100)
class UP2PsycheCamouflageComponent final : public UP2NpcCamouflageComponent
{
public:
	class FName                                   CamouflageDistanceParameterName;                   // 0x0100(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         CamouflageDistanceValue;                           // 0x0108(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FName                                   MaskIntensityParameterName;                        // 0x010C(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         FlickerRandomRange;                                // 0x0114(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         FlickerThreshold;                                  // 0x0118(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         FlickerIntensityValue;                             // 0x011C(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"P2PsycheCamouflageComponent">();
	}
	static class UP2PsycheCamouflageComponent* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UP2PsycheCamouflageComponent>();
	}
};
static_assert(alignof(UP2PsycheCamouflageComponent) == 0x000008, "Wrong alignment on UP2PsycheCamouflageComponent");
static_assert(sizeof(UP2PsycheCamouflageComponent) == 0x000120, "Wrong size on UP2PsycheCamouflageComponent");
static_assert(offsetof(UP2PsycheCamouflageComponent, CamouflageDistanceParameterName) == 0x000100, "Member 'UP2PsycheCamouflageComponent::CamouflageDistanceParameterName' has a wrong offset!");
static_assert(offsetof(UP2PsycheCamouflageComponent, CamouflageDistanceValue) == 0x000108, "Member 'UP2PsycheCamouflageComponent::CamouflageDistanceValue' has a wrong offset!");
static_assert(offsetof(UP2PsycheCamouflageComponent, MaskIntensityParameterName) == 0x00010C, "Member 'UP2PsycheCamouflageComponent::MaskIntensityParameterName' has a wrong offset!");
static_assert(offsetof(UP2PsycheCamouflageComponent, FlickerRandomRange) == 0x000114, "Member 'UP2PsycheCamouflageComponent::FlickerRandomRange' has a wrong offset!");
static_assert(offsetof(UP2PsycheCamouflageComponent, FlickerThreshold) == 0x000118, "Member 'UP2PsycheCamouflageComponent::FlickerThreshold' has a wrong offset!");
static_assert(offsetof(UP2PsycheCamouflageComponent, FlickerIntensityValue) == 0x00011C, "Member 'UP2PsycheCamouflageComponent::FlickerIntensityValue' has a wrong offset!");

// Class AICommon.P2BTService_GhostLaserSight
// 0x0008 (0x00C0 - 0x00B8)
class UP2BTService_GhostLaserSight final : public UP2BTService_GhostBase
{
public:
	bool                                          bWantedLaserState;                                 // 0x00B8(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_B9[0x7];                                       // 0x00B9(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"P2BTService_GhostLaserSight">();
	}
	static class UP2BTService_GhostLaserSight* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UP2BTService_GhostLaserSight>();
	}
};
static_assert(alignof(UP2BTService_GhostLaserSight) == 0x000008, "Wrong alignment on UP2BTService_GhostLaserSight");
static_assert(sizeof(UP2BTService_GhostLaserSight) == 0x0000C0, "Wrong size on UP2BTService_GhostLaserSight");
static_assert(offsetof(UP2BTService_GhostLaserSight, bWantedLaserState) == 0x0000B8, "Member 'UP2BTService_GhostLaserSight::bWantedLaserState' has a wrong offset!");

// Class AICommon.P2BTService_GhostMovementSpeed
// 0x0068 (0x0120 - 0x00B8)
class UP2BTService_GhostMovementSpeed final : public UP2BTService_GhostBase
{
public:
	bool                                          bAutoFromPathLength;                               // 0x00B8(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_B9[0x7];                                       // 0x00B9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<float, int32>                            PathLengthMapping;                                 // 0x00C0(0x0050)(Edit, EditFixedSize, Protected, NativeAccessSpecifierProtected)
	bool                                          bSprint;                                           // 0x0110(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_111[0x3];                                      // 0x0111(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         SprintMovementIndex;                               // 0x0114(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         MovementIndex;                                     // 0x0118(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_11C[0x4];                                      // 0x011C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"P2BTService_GhostMovementSpeed">();
	}
	static class UP2BTService_GhostMovementSpeed* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UP2BTService_GhostMovementSpeed>();
	}
};
static_assert(alignof(UP2BTService_GhostMovementSpeed) == 0x000008, "Wrong alignment on UP2BTService_GhostMovementSpeed");
static_assert(sizeof(UP2BTService_GhostMovementSpeed) == 0x000120, "Wrong size on UP2BTService_GhostMovementSpeed");
static_assert(offsetof(UP2BTService_GhostMovementSpeed, bAutoFromPathLength) == 0x0000B8, "Member 'UP2BTService_GhostMovementSpeed::bAutoFromPathLength' has a wrong offset!");
static_assert(offsetof(UP2BTService_GhostMovementSpeed, PathLengthMapping) == 0x0000C0, "Member 'UP2BTService_GhostMovementSpeed::PathLengthMapping' has a wrong offset!");
static_assert(offsetof(UP2BTService_GhostMovementSpeed, bSprint) == 0x000110, "Member 'UP2BTService_GhostMovementSpeed::bSprint' has a wrong offset!");
static_assert(offsetof(UP2BTService_GhostMovementSpeed, SprintMovementIndex) == 0x000114, "Member 'UP2BTService_GhostMovementSpeed::SprintMovementIndex' has a wrong offset!");
static_assert(offsetof(UP2BTService_GhostMovementSpeed, MovementIndex) == 0x000118, "Member 'UP2BTService_GhostMovementSpeed::MovementIndex' has a wrong offset!");

// Class AICommon.P2JumpLinkGeneratorDefinition
// 0x0018 (0x0048 - 0x0030)
class UP2JumpLinkGeneratorDefinition final : public UDataAsset
{
public:
	bool                                          bEnabled;                                          // 0x0030(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_31[0x7];                                       // 0x0031(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FP2JumpLinkGenInfo>             JumpLinks;                                         // 0x0038(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"P2JumpLinkGeneratorDefinition">();
	}
	static class UP2JumpLinkGeneratorDefinition* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UP2JumpLinkGeneratorDefinition>();
	}
};
static_assert(alignof(UP2JumpLinkGeneratorDefinition) == 0x000008, "Wrong alignment on UP2JumpLinkGeneratorDefinition");
static_assert(sizeof(UP2JumpLinkGeneratorDefinition) == 0x000048, "Wrong size on UP2JumpLinkGeneratorDefinition");
static_assert(offsetof(UP2JumpLinkGeneratorDefinition, bEnabled) == 0x000030, "Member 'UP2JumpLinkGeneratorDefinition::bEnabled' has a wrong offset!");
static_assert(offsetof(UP2JumpLinkGeneratorDefinition, JumpLinks) == 0x000038, "Member 'UP2JumpLinkGeneratorDefinition::JumpLinks' has a wrong offset!");

// Class AICommon.P2BTService_GhostReload
// 0x0010 (0x00C8 - 0x00B8)
class UP2BTService_GhostReload final : public UP2BTService_GhostBase
{
public:
	uint8                                         Pad_B8[0x10];                                      // 0x00B8(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnTagChanged(const struct FGameplayTag& GameplayTag, int32 Count)	 // 0x4742210;

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"P2BTService_GhostReload">();
	}
	static class UP2BTService_GhostReload* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UP2BTService_GhostReload>();
	}
};
static_assert(alignof(UP2BTService_GhostReload) == 0x000008, "Wrong alignment on UP2BTService_GhostReload");
static_assert(sizeof(UP2BTService_GhostReload) == 0x0000C8, "Wrong size on UP2BTService_GhostReload");

// Class AICommon.P2NpcSpawningLayerDataAsset
// 0x0218 (0x0248 - 0x0030)
class UP2NpcSpawningLayerDataAsset final : public UPrimaryDataAsset
{
public:
	uint8                                         bDirty : 1;                                        // 0x0030(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, EditConst, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_31[0x7];                                       // 0x0031(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FP2NpcSpawningLayerData                LayerData;                                         // 0x0038(0x0160)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FP2NpcSpawningGrid                     Grid;                                              // 0x0198(0x00B0)(NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"P2NpcSpawningLayerDataAsset">();
	}
	static class UP2NpcSpawningLayerDataAsset* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UP2NpcSpawningLayerDataAsset>();
	}
};
static_assert(alignof(UP2NpcSpawningLayerDataAsset) == 0x000008, "Wrong alignment on UP2NpcSpawningLayerDataAsset");
static_assert(sizeof(UP2NpcSpawningLayerDataAsset) == 0x000248, "Wrong size on UP2NpcSpawningLayerDataAsset");
static_assert(offsetof(UP2NpcSpawningLayerDataAsset, LayerData) == 0x000038, "Member 'UP2NpcSpawningLayerDataAsset::LayerData' has a wrong offset!");
static_assert(offsetof(UP2NpcSpawningLayerDataAsset, Grid) == 0x000198, "Member 'UP2NpcSpawningLayerDataAsset::Grid' has a wrong offset!");

// Class AICommon.P2NpcTestScenario
// 0x0040 (0x0070 - 0x0030)
class UP2NpcTestScenario final : public UPrimaryDataAsset
{
public:
	uint8                                         Pad_30[0x8];                                       // 0x0030(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 ScenarioName;                                      // 0x0038(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UBehaviorTree*                          BehaviorTree;                                      // 0x0048(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FBlackboardKeySelector>         ScenarioKeys;                                      // 0x0050(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FGameplayTag>                   Events;                                            // 0x0060(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"P2NpcTestScenario">();
	}
	static class UP2NpcTestScenario* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UP2NpcTestScenario>();
	}
};
static_assert(alignof(UP2NpcTestScenario) == 0x000008, "Wrong alignment on UP2NpcTestScenario");
static_assert(sizeof(UP2NpcTestScenario) == 0x000070, "Wrong size on UP2NpcTestScenario");
static_assert(offsetof(UP2NpcTestScenario, ScenarioName) == 0x000038, "Member 'UP2NpcTestScenario::ScenarioName' has a wrong offset!");
static_assert(offsetof(UP2NpcTestScenario, BehaviorTree) == 0x000048, "Member 'UP2NpcTestScenario::BehaviorTree' has a wrong offset!");
static_assert(offsetof(UP2NpcTestScenario, ScenarioKeys) == 0x000050, "Member 'UP2NpcTestScenario::ScenarioKeys' has a wrong offset!");
static_assert(offsetof(UP2NpcTestScenario, Events) == 0x000060, "Member 'UP2NpcTestScenario::Events' has a wrong offset!");

// Class AICommon.P2BTService_GhostWeaponSelection
// 0x00A0 (0x0158 - 0x00B8)
class UP2BTService_GhostWeaponSelection final : public UP2BTService_GhostBase
{
public:
	bool                                          bForceSecondarySlotInCQC;                          // 0x00B8(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_B9[0x3];                                       // 0x00B9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         PreferredSlotInCQC;                                // 0x00BC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bUtilitySelectionAllowed;                          // 0x00C0(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_C1[0x7];                                       // 0x00C1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FBlackboardKeySelector                 BBUtilityAllowed;                                  // 0x00C8(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)
	struct FBlackboardKeySelector                 BBUtilityReady;                                    // 0x00F0(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_118[0x40];                                     // 0x0118(0x0040)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"P2BTService_GhostWeaponSelection">();
	}
	static class UP2BTService_GhostWeaponSelection* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UP2BTService_GhostWeaponSelection>();
	}
};
static_assert(alignof(UP2BTService_GhostWeaponSelection) == 0x000008, "Wrong alignment on UP2BTService_GhostWeaponSelection");
static_assert(sizeof(UP2BTService_GhostWeaponSelection) == 0x000158, "Wrong size on UP2BTService_GhostWeaponSelection");
static_assert(offsetof(UP2BTService_GhostWeaponSelection, bForceSecondarySlotInCQC) == 0x0000B8, "Member 'UP2BTService_GhostWeaponSelection::bForceSecondarySlotInCQC' has a wrong offset!");
static_assert(offsetof(UP2BTService_GhostWeaponSelection, PreferredSlotInCQC) == 0x0000BC, "Member 'UP2BTService_GhostWeaponSelection::PreferredSlotInCQC' has a wrong offset!");
static_assert(offsetof(UP2BTService_GhostWeaponSelection, bUtilitySelectionAllowed) == 0x0000C0, "Member 'UP2BTService_GhostWeaponSelection::bUtilitySelectionAllowed' has a wrong offset!");
static_assert(offsetof(UP2BTService_GhostWeaponSelection, BBUtilityAllowed) == 0x0000C8, "Member 'UP2BTService_GhostWeaponSelection::BBUtilityAllowed' has a wrong offset!");
static_assert(offsetof(UP2BTService_GhostWeaponSelection, BBUtilityReady) == 0x0000F0, "Member 'UP2BTService_GhostWeaponSelection::BBUtilityReady' has a wrong offset!");

// Class AICommon.P2BTService_GroupCheckNearbyDanger
// 0x0038 (0x00A8 - 0x0070)
class UP2BTService_GroupCheckNearbyDanger final : public UBTService
{
public:
	struct FGameplayTag                           DangerTypeTag;                                     // 0x0070(0x0008)(Edit, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bSaveClosestDangerLocation;                        // 0x0078(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_79[0x7];                                       // 0x0079(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FBlackboardKeySelector                 DangerLocationKey;                                 // 0x0080(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"P2BTService_GroupCheckNearbyDanger">();
	}
	static class UP2BTService_GroupCheckNearbyDanger* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UP2BTService_GroupCheckNearbyDanger>();
	}
};
static_assert(alignof(UP2BTService_GroupCheckNearbyDanger) == 0x000008, "Wrong alignment on UP2BTService_GroupCheckNearbyDanger");
static_assert(sizeof(UP2BTService_GroupCheckNearbyDanger) == 0x0000A8, "Wrong size on UP2BTService_GroupCheckNearbyDanger");
static_assert(offsetof(UP2BTService_GroupCheckNearbyDanger, DangerTypeTag) == 0x000070, "Member 'UP2BTService_GroupCheckNearbyDanger::DangerTypeTag' has a wrong offset!");
static_assert(offsetof(UP2BTService_GroupCheckNearbyDanger, bSaveClosestDangerLocation) == 0x000078, "Member 'UP2BTService_GroupCheckNearbyDanger::bSaveClosestDangerLocation' has a wrong offset!");
static_assert(offsetof(UP2BTService_GroupCheckNearbyDanger, DangerLocationKey) == 0x000080, "Member 'UP2BTService_GroupCheckNearbyDanger::DangerLocationKey' has a wrong offset!");

// Class AICommon.P2BTService_IgnoreStimuli
// 0x0020 (0x0090 - 0x0070)
class UP2BTService_IgnoreStimuli final : public UBTService
{
public:
	struct FGameplayTagContainer                  IgnoredStimuli;                                    // 0x0070(0x0020)(Edit, BlueprintVisible, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"P2BTService_IgnoreStimuli">();
	}
	static class UP2BTService_IgnoreStimuli* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UP2BTService_IgnoreStimuli>();
	}
};
static_assert(alignof(UP2BTService_IgnoreStimuli) == 0x000008, "Wrong alignment on UP2BTService_IgnoreStimuli");
static_assert(sizeof(UP2BTService_IgnoreStimuli) == 0x000090, "Wrong size on UP2BTService_IgnoreStimuli");
static_assert(offsetof(UP2BTService_IgnoreStimuli, IgnoredStimuli) == 0x000070, "Member 'UP2BTService_IgnoreStimuli::IgnoredStimuli' has a wrong offset!");

// Class AICommon.P2BTService_ModifyBlackboardValues
// 0x0010 (0x0080 - 0x0070)
class UP2BTService_ModifyBlackboardValues final : public UBTService
{
public:
	TArray<class UP2BlackboardValueModifier*>     Modifiers;                                         // 0x0070(0x0010)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, ContainsInstancedReference, UObjectWrapper, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"P2BTService_ModifyBlackboardValues">();
	}
	static class UP2BTService_ModifyBlackboardValues* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UP2BTService_ModifyBlackboardValues>();
	}
};
static_assert(alignof(UP2BTService_ModifyBlackboardValues) == 0x000008, "Wrong alignment on UP2BTService_ModifyBlackboardValues");
static_assert(sizeof(UP2BTService_ModifyBlackboardValues) == 0x000080, "Wrong size on UP2BTService_ModifyBlackboardValues");
static_assert(offsetof(UP2BTService_ModifyBlackboardValues, Modifiers) == 0x000070, "Member 'UP2BTService_ModifyBlackboardValues::Modifiers' has a wrong offset!");

// Class AICommon.P2BlackboardValueModifier_SetBool
// 0x0008 (0x0058 - 0x0050)
class UP2BlackboardValueModifier_SetBool final : public UP2BlackboardValueModifier_SetBase
{
public:
	bool                                          bValue;                                            // 0x0050(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_51[0x7];                                       // 0x0051(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"P2BlackboardValueModifier_SetBool">();
	}
	static class UP2BlackboardValueModifier_SetBool* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UP2BlackboardValueModifier_SetBool>();
	}
};
static_assert(alignof(UP2BlackboardValueModifier_SetBool) == 0x000008, "Wrong alignment on UP2BlackboardValueModifier_SetBool");
static_assert(sizeof(UP2BlackboardValueModifier_SetBool) == 0x000058, "Wrong size on UP2BlackboardValueModifier_SetBool");
static_assert(offsetof(UP2BlackboardValueModifier_SetBool, bValue) == 0x000050, "Member 'UP2BlackboardValueModifier_SetBool::bValue' has a wrong offset!");

// Class AICommon.P2NpcStaggerData
// 0x03E8 (0x0418 - 0x0030)
class UP2NpcStaggerData final : public UDataAsset
{
public:
	struct FP2StaggerLevelData                    LightStaggerData;                                  // 0x0030(0x00F0)(Edit, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FP2StaggerLevelData                    HeavyStaggerData;                                  // 0x0120(0x00F0)(Edit, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FP2StaggerLevelData                    KnockdownStaggerData;                              // 0x0210(0x00F0)(Edit, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FP2StaggerLevelData                    CounterAttackStaggerData;                          // 0x0300(0x00F0)(Edit, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FP2StaggerParryData                    ParryStaggerData;                                  // 0x03F0(0x0028)(Edit, BlueprintReadOnly, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"P2NpcStaggerData">();
	}
	static class UP2NpcStaggerData* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UP2NpcStaggerData>();
	}
};
static_assert(alignof(UP2NpcStaggerData) == 0x000008, "Wrong alignment on UP2NpcStaggerData");
static_assert(sizeof(UP2NpcStaggerData) == 0x000418, "Wrong size on UP2NpcStaggerData");
static_assert(offsetof(UP2NpcStaggerData, LightStaggerData) == 0x000030, "Member 'UP2NpcStaggerData::LightStaggerData' has a wrong offset!");
static_assert(offsetof(UP2NpcStaggerData, HeavyStaggerData) == 0x000120, "Member 'UP2NpcStaggerData::HeavyStaggerData' has a wrong offset!");
static_assert(offsetof(UP2NpcStaggerData, KnockdownStaggerData) == 0x000210, "Member 'UP2NpcStaggerData::KnockdownStaggerData' has a wrong offset!");
static_assert(offsetof(UP2NpcStaggerData, CounterAttackStaggerData) == 0x000300, "Member 'UP2NpcStaggerData::CounterAttackStaggerData' has a wrong offset!");
static_assert(offsetof(UP2NpcStaggerData, ParryStaggerData) == 0x0003F0, "Member 'UP2NpcStaggerData::ParryStaggerData' has a wrong offset!");

// Class AICommon.P2BlackboardValueModifier_SetInt
// 0x0008 (0x0058 - 0x0050)
class UP2BlackboardValueModifier_SetInt final : public UP2BlackboardValueModifier_SetBase
{
public:
	int32                                         Value;                                             // 0x0050(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_54[0x4];                                       // 0x0054(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"P2BlackboardValueModifier_SetInt">();
	}
	static class UP2BlackboardValueModifier_SetInt* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UP2BlackboardValueModifier_SetInt>();
	}
};
static_assert(alignof(UP2BlackboardValueModifier_SetInt) == 0x000008, "Wrong alignment on UP2BlackboardValueModifier_SetInt");
static_assert(sizeof(UP2BlackboardValueModifier_SetInt) == 0x000058, "Wrong size on UP2BlackboardValueModifier_SetInt");
static_assert(offsetof(UP2BlackboardValueModifier_SetInt, Value) == 0x000050, "Member 'UP2BlackboardValueModifier_SetInt::Value' has a wrong offset!");

// Class AICommon.P2NpcGroupSpawner
// 0x00F0 (0x03A0 - 0x02B0)
class AP2NpcGroupSpawner : public AActor
{
public:
	uint8                                         Pad_2B0[0x8];                                      // 0x02B0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bAutoSpawn;                                        // 0x02B8(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAvailableForRespawn;                              // 0x02B9(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bRequireSessionDifficulty;                         // 0x02BA(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2BB[0x5];                                      // 0x02BB(0x0005)(Fixing Size After Last Property [ Dumper-7 ])
	TSet<int32>                                   AllowedSessionDifficulties;                        // 0x02C0(0x0050)(Edit, NativeAccessSpecifierPublic)
	struct FGameplayTagContainer                  ZoneTags;                                          // 0x0310(0x0020)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	class UP2NpcGroupData*                        NpcGroupData;                                      // 0x0330(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FPrimaryAssetId                        NpcGroupDataId;                                    // 0x0338(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FIntPoint                              GroupMembers;                                      // 0x0348(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bRequireLandscape;                                 // 0x0350(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_351[0x7];                                      // 0x0351(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	double                                        HalfHeight;                                        // 0x0358(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SearchRadius;                                      // 0x0360(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUseFirstValidLocation;                            // 0x0364(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bGodMode;                                          // 0x0365(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bOverrideMemberData;                               // 0x0366(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_367[0x1];                                      // 0x0367(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	class UP2NpcGroupMemberData*                  GroupMemberOverrideData;                           // 0x0368(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bOverrideLeaderBehavior;                           // 0x0370(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_371[0x7];                                      // 0x0371(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UBehaviorTree*                          LeaderBehaviorOverride;                            // 0x0378(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bOverrideMemberBlackboardModifiers;                // 0x0380(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_381[0x7];                                      // 0x0381(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UP2BlackboardValueModifier*>     BlackboardModifiers;                               // 0x0388(0x0010)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, ContainsInstancedReference, UObjectWrapper, NativeAccessSpecifierPublic)
	uint8                                         Pad_398[0x8];                                      // 0x0398(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnMatchStarting()	 // 0x4767018;

	bool HasValidNpcData(const class UP2NpcGroupData* InNpcGroupData) const	 // 0x4766ec0;
	class AP2NpcGroupAIController* Spawn() const	 // 0x16a0090;

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"P2NpcGroupSpawner">();
	}
	static class AP2NpcGroupSpawner* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<AP2NpcGroupSpawner>();
	}
};
static_assert(alignof(AP2NpcGroupSpawner) == 0x000008, "Wrong alignment on AP2NpcGroupSpawner");
static_assert(sizeof(AP2NpcGroupSpawner) == 0x0003A0, "Wrong size on AP2NpcGroupSpawner");
static_assert(offsetof(AP2NpcGroupSpawner, bAutoSpawn) == 0x0002B8, "Member 'AP2NpcGroupSpawner::bAutoSpawn' has a wrong offset!");
static_assert(offsetof(AP2NpcGroupSpawner, bAvailableForRespawn) == 0x0002B9, "Member 'AP2NpcGroupSpawner::bAvailableForRespawn' has a wrong offset!");
static_assert(offsetof(AP2NpcGroupSpawner, bRequireSessionDifficulty) == 0x0002BA, "Member 'AP2NpcGroupSpawner::bRequireSessionDifficulty' has a wrong offset!");
static_assert(offsetof(AP2NpcGroupSpawner, AllowedSessionDifficulties) == 0x0002C0, "Member 'AP2NpcGroupSpawner::AllowedSessionDifficulties' has a wrong offset!");
static_assert(offsetof(AP2NpcGroupSpawner, ZoneTags) == 0x000310, "Member 'AP2NpcGroupSpawner::ZoneTags' has a wrong offset!");
static_assert(offsetof(AP2NpcGroupSpawner, NpcGroupData) == 0x000330, "Member 'AP2NpcGroupSpawner::NpcGroupData' has a wrong offset!");
static_assert(offsetof(AP2NpcGroupSpawner, NpcGroupDataId) == 0x000338, "Member 'AP2NpcGroupSpawner::NpcGroupDataId' has a wrong offset!");
static_assert(offsetof(AP2NpcGroupSpawner, GroupMembers) == 0x000348, "Member 'AP2NpcGroupSpawner::GroupMembers' has a wrong offset!");
static_assert(offsetof(AP2NpcGroupSpawner, bRequireLandscape) == 0x000350, "Member 'AP2NpcGroupSpawner::bRequireLandscape' has a wrong offset!");
static_assert(offsetof(AP2NpcGroupSpawner, HalfHeight) == 0x000358, "Member 'AP2NpcGroupSpawner::HalfHeight' has a wrong offset!");
static_assert(offsetof(AP2NpcGroupSpawner, SearchRadius) == 0x000360, "Member 'AP2NpcGroupSpawner::SearchRadius' has a wrong offset!");
static_assert(offsetof(AP2NpcGroupSpawner, bUseFirstValidLocation) == 0x000364, "Member 'AP2NpcGroupSpawner::bUseFirstValidLocation' has a wrong offset!");
static_assert(offsetof(AP2NpcGroupSpawner, bGodMode) == 0x000365, "Member 'AP2NpcGroupSpawner::bGodMode' has a wrong offset!");
static_assert(offsetof(AP2NpcGroupSpawner, bOverrideMemberData) == 0x000366, "Member 'AP2NpcGroupSpawner::bOverrideMemberData' has a wrong offset!");
static_assert(offsetof(AP2NpcGroupSpawner, GroupMemberOverrideData) == 0x000368, "Member 'AP2NpcGroupSpawner::GroupMemberOverrideData' has a wrong offset!");
static_assert(offsetof(AP2NpcGroupSpawner, bOverrideLeaderBehavior) == 0x000370, "Member 'AP2NpcGroupSpawner::bOverrideLeaderBehavior' has a wrong offset!");
static_assert(offsetof(AP2NpcGroupSpawner, LeaderBehaviorOverride) == 0x000378, "Member 'AP2NpcGroupSpawner::LeaderBehaviorOverride' has a wrong offset!");
static_assert(offsetof(AP2NpcGroupSpawner, bOverrideMemberBlackboardModifiers) == 0x000380, "Member 'AP2NpcGroupSpawner::bOverrideMemberBlackboardModifiers' has a wrong offset!");
static_assert(offsetof(AP2NpcGroupSpawner, BlackboardModifiers) == 0x000388, "Member 'AP2NpcGroupSpawner::BlackboardModifiers' has a wrong offset!");

// Class AICommon.P2GhostGroupSpawner
// 0x0020 (0x03C0 - 0x03A0)
class AP2GhostGroupSpawner : public AP2NpcGroupSpawner
{
public:
	uint8                                         bOverrideFormation : 1;                            // 0x03A0(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	EP2GroupFormation                             Formation;                                         // 0x03A1(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverrideFormationDistance : 1;                    // 0x03A2(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_3A3[0x5];                                      // 0x03A3(0x0005)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector2D                              FormationDistance;                                 // 0x03A8(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOverrideRoe : 1;                                  // 0x03B8(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	EP2GroupRoe                                   Roe;                                               // 0x03B9(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bInfiniteAmmo;                                     // 0x03BA(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3BB[0x5];                                      // 0x03BB(0x0005)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"P2GhostGroupSpawner">();
	}
	static class AP2GhostGroupSpawner* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<AP2GhostGroupSpawner>();
	}
};
static_assert(alignof(AP2GhostGroupSpawner) == 0x000008, "Wrong alignment on AP2GhostGroupSpawner");
static_assert(sizeof(AP2GhostGroupSpawner) == 0x0003C0, "Wrong size on AP2GhostGroupSpawner");
static_assert(offsetof(AP2GhostGroupSpawner, Formation) == 0x0003A1, "Member 'AP2GhostGroupSpawner::Formation' has a wrong offset!");
static_assert(offsetof(AP2GhostGroupSpawner, FormationDistance) == 0x0003A8, "Member 'AP2GhostGroupSpawner::FormationDistance' has a wrong offset!");
static_assert(offsetof(AP2GhostGroupSpawner, Roe) == 0x0003B9, "Member 'AP2GhostGroupSpawner::Roe' has a wrong offset!");
static_assert(offsetof(AP2GhostGroupSpawner, bInfiniteAmmo) == 0x0003BA, "Member 'AP2GhostGroupSpawner::bInfiniteAmmo' has a wrong offset!");

// Class AICommon.P2PlayerBotGroupSpawner
// 0x0028 (0x03E8 - 0x03C0)
class AP2PlayerBotGroupSpawner final : public AP2GhostGroupSpawner
{
public:
	struct FGameplayTag                           PlayerBotSpawnerZoneTag;                           // 0x03C0(0x0008)(Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3C8[0x8];                                      // 0x03C8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class USplineComponent*                       WayPointSplineComponent;                           // 0x03D0(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         SpawnTeamID;                                       // 0x03D8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   SpawnedBotName;                                    // 0x03DC(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bSetPlayerBotNameFromSpawnedBotName;               // 0x03E4(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3E5[0x3];                                      // 0x03E5(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	bool BP_SpawnPlayerBot(TArray<class APawn*>* OutSpawnedPlayerBots)	 // 0x4772fe8;

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"P2PlayerBotGroupSpawner">();
	}
	static class AP2PlayerBotGroupSpawner* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<AP2PlayerBotGroupSpawner>();
	}
};
static_assert(alignof(AP2PlayerBotGroupSpawner) == 0x000008, "Wrong alignment on AP2PlayerBotGroupSpawner");
static_assert(sizeof(AP2PlayerBotGroupSpawner) == 0x0003E8, "Wrong size on AP2PlayerBotGroupSpawner");
static_assert(offsetof(AP2PlayerBotGroupSpawner, PlayerBotSpawnerZoneTag) == 0x0003C0, "Member 'AP2PlayerBotGroupSpawner::PlayerBotSpawnerZoneTag' has a wrong offset!");
static_assert(offsetof(AP2PlayerBotGroupSpawner, WayPointSplineComponent) == 0x0003D0, "Member 'AP2PlayerBotGroupSpawner::WayPointSplineComponent' has a wrong offset!");
static_assert(offsetof(AP2PlayerBotGroupSpawner, SpawnTeamID) == 0x0003D8, "Member 'AP2PlayerBotGroupSpawner::SpawnTeamID' has a wrong offset!");
static_assert(offsetof(AP2PlayerBotGroupSpawner, SpawnedBotName) == 0x0003DC, "Member 'AP2PlayerBotGroupSpawner::SpawnedBotName' has a wrong offset!");
static_assert(offsetof(AP2PlayerBotGroupSpawner, bSetPlayerBotNameFromSpawnedBotName) == 0x0003E4, "Member 'AP2PlayerBotGroupSpawner::bSetPlayerBotNameFromSpawnedBotName' has a wrong offset!");

// Class AICommon.P2BlackboardValueModifier_SetFloat
// 0x0008 (0x0058 - 0x0050)
class UP2BlackboardValueModifier_SetFloat final : public UP2BlackboardValueModifier_SetBase
{
public:
	float                                         Value;                                             // 0x0050(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_54[0x4];                                       // 0x0054(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"P2BlackboardValueModifier_SetFloat">();
	}
	static class UP2BlackboardValueModifier_SetFloat* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UP2BlackboardValueModifier_SetFloat>();
	}
};
static_assert(alignof(UP2BlackboardValueModifier_SetFloat) == 0x000008, "Wrong alignment on UP2BlackboardValueModifier_SetFloat");
static_assert(sizeof(UP2BlackboardValueModifier_SetFloat) == 0x000058, "Wrong size on UP2BlackboardValueModifier_SetFloat");
static_assert(offsetof(UP2BlackboardValueModifier_SetFloat, Value) == 0x000050, "Member 'UP2BlackboardValueModifier_SetFloat::Value' has a wrong offset!");

// Class AICommon.P2BlackboardValueModifier_SetActor
// 0x0008 (0x0058 - 0x0050)
class UP2BlackboardValueModifier_SetActor final : public UP2BlackboardValueModifier_SetBase
{
public:
	class AActor*                                 Object;                                            // 0x0050(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"P2BlackboardValueModifier_SetActor">();
	}
	static class UP2BlackboardValueModifier_SetActor* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UP2BlackboardValueModifier_SetActor>();
	}
};
static_assert(alignof(UP2BlackboardValueModifier_SetActor) == 0x000008, "Wrong alignment on UP2BlackboardValueModifier_SetActor");
static_assert(sizeof(UP2BlackboardValueModifier_SetActor) == 0x000058, "Wrong size on UP2BlackboardValueModifier_SetActor");
static_assert(offsetof(UP2BlackboardValueModifier_SetActor, Object) == 0x000050, "Member 'UP2BlackboardValueModifier_SetActor::Object' has a wrong offset!");

// Class AICommon.P2NpcAbility_RasslerCallForHelp
// 0x0000 (0x0498 - 0x0498)
class UP2NpcAbility_RasslerCallForHelp final : public UP2NpcAbility
{
public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"P2NpcAbility_RasslerCallForHelp">();
	}
	static class UP2NpcAbility_RasslerCallForHelp* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UP2NpcAbility_RasslerCallForHelp>();
	}
};
static_assert(alignof(UP2NpcAbility_RasslerCallForHelp) == 0x000008, "Wrong alignment on UP2NpcAbility_RasslerCallForHelp");
static_assert(sizeof(UP2NpcAbility_RasslerCallForHelp) == 0x000498, "Wrong size on UP2NpcAbility_RasslerCallForHelp");

// Class AICommon.P2BlackboardValueModifier_Clear
// 0x0000 (0x0050 - 0x0050)
class UP2BlackboardValueModifier_Clear final : public UP2BlackboardValueModifier_SetBase
{
public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"P2BlackboardValueModifier_Clear">();
	}
	static class UP2BlackboardValueModifier_Clear* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UP2BlackboardValueModifier_Clear>();
	}
};
static_assert(alignof(UP2BlackboardValueModifier_Clear) == 0x000008, "Wrong alignment on UP2BlackboardValueModifier_Clear");
static_assert(sizeof(UP2BlackboardValueModifier_Clear) == 0x000050, "Wrong size on UP2BlackboardValueModifier_Clear");

// Class AICommon.P2BTService_PlayerBot_WayPoint
// 0x00A0 (0x0110 - 0x0070)
class UP2BTService_PlayerBot_WayPoint final : public UBTService
{
public:
	struct FBlackboardKeySelector                 SelfActorKey;                                      // 0x0070(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FBlackboardKeySelector                 bIsInsideWayPointAttemptAreaKey;                   // 0x0098(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FBlackboardKeySelector                 CurrentWayPointLocationIndexKey;                   // 0x00C0(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FBlackboardKeySelector                 MaxWayPointLocationIndexKey;                       // 0x00E8(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"P2BTService_PlayerBot_WayPoint">();
	}
	static class UP2BTService_PlayerBot_WayPoint* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UP2BTService_PlayerBot_WayPoint>();
	}
};
static_assert(alignof(UP2BTService_PlayerBot_WayPoint) == 0x000008, "Wrong alignment on UP2BTService_PlayerBot_WayPoint");
static_assert(sizeof(UP2BTService_PlayerBot_WayPoint) == 0x000110, "Wrong size on UP2BTService_PlayerBot_WayPoint");
static_assert(offsetof(UP2BTService_PlayerBot_WayPoint, SelfActorKey) == 0x000070, "Member 'UP2BTService_PlayerBot_WayPoint::SelfActorKey' has a wrong offset!");
static_assert(offsetof(UP2BTService_PlayerBot_WayPoint, bIsInsideWayPointAttemptAreaKey) == 0x000098, "Member 'UP2BTService_PlayerBot_WayPoint::bIsInsideWayPointAttemptAreaKey' has a wrong offset!");
static_assert(offsetof(UP2BTService_PlayerBot_WayPoint, CurrentWayPointLocationIndexKey) == 0x0000C0, "Member 'UP2BTService_PlayerBot_WayPoint::CurrentWayPointLocationIndexKey' has a wrong offset!");
static_assert(offsetof(UP2BTService_PlayerBot_WayPoint, MaxWayPointLocationIndexKey) == 0x0000E8, "Member 'UP2BTService_PlayerBot_WayPoint::MaxWayPointLocationIndexKey' has a wrong offset!");

// Class AICommon.P2ShortcutActivationData
// 0x0040 (0x0068 - 0x0028)
class UP2ShortcutActivationData final : public UObject
{
public:
	class UP2ShortcutDataAsset*                   ShortcutDataAsset;                                 // 0x0028(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                StartLocationWS;                                   // 0x0030(0x0018)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                EndLocationWS;                                     // 0x0048(0x0018)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUseStart;                                         // 0x0060(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_61[0x7];                                       // 0x0061(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"P2ShortcutActivationData">();
	}
	static class UP2ShortcutActivationData* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UP2ShortcutActivationData>();
	}
};
static_assert(alignof(UP2ShortcutActivationData) == 0x000008, "Wrong alignment on UP2ShortcutActivationData");
static_assert(sizeof(UP2ShortcutActivationData) == 0x000068, "Wrong size on UP2ShortcutActivationData");
static_assert(offsetof(UP2ShortcutActivationData, ShortcutDataAsset) == 0x000028, "Member 'UP2ShortcutActivationData::ShortcutDataAsset' has a wrong offset!");
static_assert(offsetof(UP2ShortcutActivationData, StartLocationWS) == 0x000030, "Member 'UP2ShortcutActivationData::StartLocationWS' has a wrong offset!");
static_assert(offsetof(UP2ShortcutActivationData, EndLocationWS) == 0x000048, "Member 'UP2ShortcutActivationData::EndLocationWS' has a wrong offset!");
static_assert(offsetof(UP2ShortcutActivationData, bUseStart) == 0x000060, "Member 'UP2ShortcutActivationData::bUseStart' has a wrong offset!");

// Class AICommon.P2BTService_ProcessFleeing
// 0x0028 (0x0098 - 0x0070)
class UP2BTService_ProcessFleeing final : public UBTService
{
public:
	struct FBlackboardKeySelector                 IsFleeingKey;                                      // 0x0070(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"P2BTService_ProcessFleeing">();
	}
	static class UP2BTService_ProcessFleeing* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UP2BTService_ProcessFleeing>();
	}
};
static_assert(alignof(UP2BTService_ProcessFleeing) == 0x000008, "Wrong alignment on UP2BTService_ProcessFleeing");
static_assert(sizeof(UP2BTService_ProcessFleeing) == 0x000098, "Wrong size on UP2BTService_ProcessFleeing");
static_assert(offsetof(UP2BTService_ProcessFleeing, IsFleeingKey) == 0x000070, "Member 'UP2BTService_ProcessFleeing::IsFleeingKey' has a wrong offset!");

// Class AICommon.P2BTService_ProcessPerception
// 0x00F8 (0x0168 - 0x0070)
class UP2BTService_ProcessPerception final : public UBTService
{
public:
	struct FBlackboardKeySelector                 TargetKey;                                         // 0x0070(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FBlackboardKeySelector                 SeesTargetKey;                                     // 0x0098(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FBlackboardKeySelector                 HasSensedAnythingKey;                              // 0x00C0(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FBlackboardKeySelector                 LastSensedLocationKey;                             // 0x00E8(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FBlackboardKeySelector                 HasStimuliTeleportedKey;                           // 0x0110(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FBlackboardKeySelector                 HasStimuliMovedKey;                                // 0x0138(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	double                                        StimuliTeleportTolerance;                          // 0x0160(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"P2BTService_ProcessPerception">();
	}
	static class UP2BTService_ProcessPerception* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UP2BTService_ProcessPerception>();
	}
};
static_assert(alignof(UP2BTService_ProcessPerception) == 0x000008, "Wrong alignment on UP2BTService_ProcessPerception");
static_assert(sizeof(UP2BTService_ProcessPerception) == 0x000168, "Wrong size on UP2BTService_ProcessPerception");
static_assert(offsetof(UP2BTService_ProcessPerception, TargetKey) == 0x000070, "Member 'UP2BTService_ProcessPerception::TargetKey' has a wrong offset!");
static_assert(offsetof(UP2BTService_ProcessPerception, SeesTargetKey) == 0x000098, "Member 'UP2BTService_ProcessPerception::SeesTargetKey' has a wrong offset!");
static_assert(offsetof(UP2BTService_ProcessPerception, HasSensedAnythingKey) == 0x0000C0, "Member 'UP2BTService_ProcessPerception::HasSensedAnythingKey' has a wrong offset!");
static_assert(offsetof(UP2BTService_ProcessPerception, LastSensedLocationKey) == 0x0000E8, "Member 'UP2BTService_ProcessPerception::LastSensedLocationKey' has a wrong offset!");
static_assert(offsetof(UP2BTService_ProcessPerception, HasStimuliTeleportedKey) == 0x000110, "Member 'UP2BTService_ProcessPerception::HasStimuliTeleportedKey' has a wrong offset!");
static_assert(offsetof(UP2BTService_ProcessPerception, HasStimuliMovedKey) == 0x000138, "Member 'UP2BTService_ProcessPerception::HasStimuliMovedKey' has a wrong offset!");
static_assert(offsetof(UP2BTService_ProcessPerception, StimuliTeleportTolerance) == 0x000160, "Member 'UP2BTService_ProcessPerception::StimuliTeleportTolerance' has a wrong offset!");

// Class AICommon.P2BTService_ProcessStimuli
// 0x00D0 (0x0140 - 0x0070)
class UP2BTService_ProcessStimuli final : public UBTService
{
public:
	struct FBlackboardKeySelector                 HasSensedAnythingKey;                              // 0x0070(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)
	struct FBlackboardKeySelector                 HasNewStimuliKey;                                  // 0x0098(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)
	struct FBlackboardKeySelector                 HasStimuliTeleportedKey;                           // 0x00C0(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)
	struct FBlackboardKeySelector                 HasStimuliMovedKey;                                // 0x00E8(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)
	struct FBlackboardKeySelector                 LastSensedLocationKey;                             // 0x0110(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)
	float                                         StimuliEqualsTolerance;                            // 0x0138(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         StimuliTeleportTolerance;                          // 0x013C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"P2BTService_ProcessStimuli">();
	}
	static class UP2BTService_ProcessStimuli* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UP2BTService_ProcessStimuli>();
	}
};
static_assert(alignof(UP2BTService_ProcessStimuli) == 0x000008, "Wrong alignment on UP2BTService_ProcessStimuli");
static_assert(sizeof(UP2BTService_ProcessStimuli) == 0x000140, "Wrong size on UP2BTService_ProcessStimuli");
static_assert(offsetof(UP2BTService_ProcessStimuli, HasSensedAnythingKey) == 0x000070, "Member 'UP2BTService_ProcessStimuli::HasSensedAnythingKey' has a wrong offset!");
static_assert(offsetof(UP2BTService_ProcessStimuli, HasNewStimuliKey) == 0x000098, "Member 'UP2BTService_ProcessStimuli::HasNewStimuliKey' has a wrong offset!");
static_assert(offsetof(UP2BTService_ProcessStimuli, HasStimuliTeleportedKey) == 0x0000C0, "Member 'UP2BTService_ProcessStimuli::HasStimuliTeleportedKey' has a wrong offset!");
static_assert(offsetof(UP2BTService_ProcessStimuli, HasStimuliMovedKey) == 0x0000E8, "Member 'UP2BTService_ProcessStimuli::HasStimuliMovedKey' has a wrong offset!");
static_assert(offsetof(UP2BTService_ProcessStimuli, LastSensedLocationKey) == 0x000110, "Member 'UP2BTService_ProcessStimuli::LastSensedLocationKey' has a wrong offset!");
static_assert(offsetof(UP2BTService_ProcessStimuli, StimuliEqualsTolerance) == 0x000138, "Member 'UP2BTService_ProcessStimuli::StimuliEqualsTolerance' has a wrong offset!");
static_assert(offsetof(UP2BTService_ProcessStimuli, StimuliTeleportTolerance) == 0x00013C, "Member 'UP2BTService_ProcessStimuli::StimuliTeleportTolerance' has a wrong offset!");

// Class AICommon.P2NpcAbility_UseJumpLink
// 0x0020 (0x0500 - 0x04E0)
class UP2NpcAbility_UseJumpLink final : public UP2NpcAbility_UseMercunaNavLink
{
public:
	class UP2JumpLinkData*                        JumpLinkData;                                      // 0x04E0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EMovementMode                                 MovementMode;                                      // 0x04E8(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_4E9[0x7];                                      // 0x04E9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UAbilityTask_PlayMontageAndWait*        PlayMontageTask;                                   // 0x04F0(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UP2AbilityTask_JumpMovementMode*        MovementModeTask;                                  // 0x04F8(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void OnAnimationEnded()	 // 0x4761548;

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"P2NpcAbility_UseJumpLink">();
	}
	static class UP2NpcAbility_UseJumpLink* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UP2NpcAbility_UseJumpLink>();
	}
};
static_assert(alignof(UP2NpcAbility_UseJumpLink) == 0x000008, "Wrong alignment on UP2NpcAbility_UseJumpLink");
static_assert(sizeof(UP2NpcAbility_UseJumpLink) == 0x000500, "Wrong size on UP2NpcAbility_UseJumpLink");
static_assert(offsetof(UP2NpcAbility_UseJumpLink, JumpLinkData) == 0x0004E0, "Member 'UP2NpcAbility_UseJumpLink::JumpLinkData' has a wrong offset!");
static_assert(offsetof(UP2NpcAbility_UseJumpLink, MovementMode) == 0x0004E8, "Member 'UP2NpcAbility_UseJumpLink::MovementMode' has a wrong offset!");
static_assert(offsetof(UP2NpcAbility_UseJumpLink, PlayMontageTask) == 0x0004F0, "Member 'UP2NpcAbility_UseJumpLink::PlayMontageTask' has a wrong offset!");
static_assert(offsetof(UP2NpcAbility_UseJumpLink, MovementModeTask) == 0x0004F8, "Member 'UP2NpcAbility_UseJumpLink::MovementModeTask' has a wrong offset!");

// Class AICommon.P2BTService_RequestAttackTicket
// 0x0000 (0x0098 - 0x0098)
class UP2BTService_RequestAttackTicket final : public UBTService_BlackboardBase
{
public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"P2BTService_RequestAttackTicket">();
	}
	static class UP2BTService_RequestAttackTicket* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UP2BTService_RequestAttackTicket>();
	}
};
static_assert(alignof(UP2BTService_RequestAttackTicket) == 0x000008, "Wrong alignment on UP2BTService_RequestAttackTicket");
static_assert(sizeof(UP2BTService_RequestAttackTicket) == 0x000098, "Wrong size on UP2BTService_RequestAttackTicket");

// Class AICommon.P2BTService_SelectNextAttack
// 0x0060 (0x00D0 - 0x0070)
class UP2BTService_SelectNextAttack final : public UBTService
{
public:
	TArray<TSubclassOf<class UP2NpcAbility_Attack>> Abilities;                                       // 0x0070(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
	struct FBlackboardKeySelector                 TargetKey;                                         // 0x0080(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FBlackboardKeySelector                 ResultKey;                                         // 0x00A8(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"P2BTService_SelectNextAttack">();
	}
	static class UP2BTService_SelectNextAttack* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UP2BTService_SelectNextAttack>();
	}
};
static_assert(alignof(UP2BTService_SelectNextAttack) == 0x000008, "Wrong alignment on UP2BTService_SelectNextAttack");
static_assert(sizeof(UP2BTService_SelectNextAttack) == 0x0000D0, "Wrong size on UP2BTService_SelectNextAttack");
static_assert(offsetof(UP2BTService_SelectNextAttack, Abilities) == 0x000070, "Member 'UP2BTService_SelectNextAttack::Abilities' has a wrong offset!");
static_assert(offsetof(UP2BTService_SelectNextAttack, TargetKey) == 0x000080, "Member 'UP2BTService_SelectNextAttack::TargetKey' has a wrong offset!");
static_assert(offsetof(UP2BTService_SelectNextAttack, ResultKey) == 0x0000A8, "Member 'UP2BTService_SelectNextAttack::ResultKey' has a wrong offset!");

// Class AICommon.P2BTService_SelectTarget
// 0x0168 (0x0200 - 0x0098)
class UP2BTService_SelectTarget final : public UBTService_BlackboardBase
{
public:
	class UEnvQuery*                              QueryTemplate;                                     // 0x0098(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FBlackboardKeySelector                 EQSQueryBlackboardKey;                             // 0x00A0(0x0028)(Edit, NativeAccessSpecifierPublic)
	struct FBlackboardKeySelector                 TargetLocationKey;                                 // 0x00C8(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FBlackboardKeySelector                 IsTargetSpottedKey;                                // 0x00F0(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FBlackboardKeySelector                 IsTargetVisibleKey;                                // 0x0118(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	EPBlackboardClearTargetBehavior               ClearTargetBehavior;                               // 0x0140(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_144[0x4];                                      // 0x0144(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTagContainer                  PauseTags;                                         // 0x0148(0x0020)(Edit, NativeAccessSpecifierPublic)
	uint8                                         Pad_168[0x98];                                     // 0x0168(0x0098)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"P2BTService_SelectTarget">();
	}
	static class UP2BTService_SelectTarget* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UP2BTService_SelectTarget>();
	}
};
static_assert(alignof(UP2BTService_SelectTarget) == 0x000008, "Wrong alignment on UP2BTService_SelectTarget");
static_assert(sizeof(UP2BTService_SelectTarget) == 0x000200, "Wrong size on UP2BTService_SelectTarget");
static_assert(offsetof(UP2BTService_SelectTarget, QueryTemplate) == 0x000098, "Member 'UP2BTService_SelectTarget::QueryTemplate' has a wrong offset!");
static_assert(offsetof(UP2BTService_SelectTarget, EQSQueryBlackboardKey) == 0x0000A0, "Member 'UP2BTService_SelectTarget::EQSQueryBlackboardKey' has a wrong offset!");
static_assert(offsetof(UP2BTService_SelectTarget, TargetLocationKey) == 0x0000C8, "Member 'UP2BTService_SelectTarget::TargetLocationKey' has a wrong offset!");
static_assert(offsetof(UP2BTService_SelectTarget, IsTargetSpottedKey) == 0x0000F0, "Member 'UP2BTService_SelectTarget::IsTargetSpottedKey' has a wrong offset!");
static_assert(offsetof(UP2BTService_SelectTarget, IsTargetVisibleKey) == 0x000118, "Member 'UP2BTService_SelectTarget::IsTargetVisibleKey' has a wrong offset!");
static_assert(offsetof(UP2BTService_SelectTarget, ClearTargetBehavior) == 0x000140, "Member 'UP2BTService_SelectTarget::ClearTargetBehavior' has a wrong offset!");
static_assert(offsetof(UP2BTService_SelectTarget, PauseTags) == 0x000148, "Member 'UP2BTService_SelectTarget::PauseTags' has a wrong offset!");

// Class AICommon.P2BTService_SentryTracking
// 0x0050 (0x00C0 - 0x0070)
class UP2BTService_SentryTracking final : public UBTService
{
public:
	struct FBlackboardKeySelector                 TargetKey;                                         // 0x0070(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)
	struct FBlackboardKeySelector                 AimedAtLocationKey;                                // 0x0098(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"P2BTService_SentryTracking">();
	}
	static class UP2BTService_SentryTracking* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UP2BTService_SentryTracking>();
	}
};
static_assert(alignof(UP2BTService_SentryTracking) == 0x000008, "Wrong alignment on UP2BTService_SentryTracking");
static_assert(sizeof(UP2BTService_SentryTracking) == 0x0000C0, "Wrong size on UP2BTService_SentryTracking");
static_assert(offsetof(UP2BTService_SentryTracking, TargetKey) == 0x000070, "Member 'UP2BTService_SentryTracking::TargetKey' has a wrong offset!");
static_assert(offsetof(UP2BTService_SentryTracking, AimedAtLocationKey) == 0x000098, "Member 'UP2BTService_SentryTracking::AimedAtLocationKey' has a wrong offset!");

// Class AICommon.P2PsycheMindControlComponent
// 0x0068 (0x01B0 - 0x0148)
class UP2PsycheMindControlComponent final : public UP2TriggerZoneComponent
{
public:
	float                                         MindControlHorizontalRange;                        // 0x0148(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MindControlVerticalRange;                          // 0x014C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UP2GameplayEffect_Damage>   DamageType;                                        // 0x0150(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UGameplayEffect>            AuxiliaryEffect;                                   // 0x0158(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MindControlLevel;                                  // 0x0160(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FGameplayTag                           StatusEffectTag;                                   // 0x0164(0x0008)(Edit, BlueprintVisible, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_16C[0x4];                                      // 0x016C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTagContainer                  RequiredLevelVolumeTags;                           // 0x0170(0x0020)(Edit, BlueprintVisible, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)
	float                                         CooldownTimeOnDamage;                              // 0x0190(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_194[0xC];                                      // 0x0194(0x000C)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<TWeakObjectPtr<class AActor>>          AffectedActors;                                    // 0x01A0(0x0010)(ZeroConstructor, Protected, UObjectWrapper, NativeAccessSpecifierProtected)

public:
	void OnDamage(class UP2HealthComponent* HealthComponent, class AActor* Instigator, float Damage)	 // 0x179dd78;
	void OnDeath(class UP2HealthComponent* HealthComponent, const struct FP2FinalBlowImpulseData& Impulse)	 // 0x4773180;
	void UpdateCooldown(float NewCooldown)	 // 0x47738d4;

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"P2PsycheMindControlComponent">();
	}
	static class UP2PsycheMindControlComponent* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UP2PsycheMindControlComponent>();
	}
};
static_assert(alignof(UP2PsycheMindControlComponent) == 0x000008, "Wrong alignment on UP2PsycheMindControlComponent");
static_assert(sizeof(UP2PsycheMindControlComponent) == 0x0001B0, "Wrong size on UP2PsycheMindControlComponent");
static_assert(offsetof(UP2PsycheMindControlComponent, MindControlHorizontalRange) == 0x000148, "Member 'UP2PsycheMindControlComponent::MindControlHorizontalRange' has a wrong offset!");
static_assert(offsetof(UP2PsycheMindControlComponent, MindControlVerticalRange) == 0x00014C, "Member 'UP2PsycheMindControlComponent::MindControlVerticalRange' has a wrong offset!");
static_assert(offsetof(UP2PsycheMindControlComponent, DamageType) == 0x000150, "Member 'UP2PsycheMindControlComponent::DamageType' has a wrong offset!");
static_assert(offsetof(UP2PsycheMindControlComponent, AuxiliaryEffect) == 0x000158, "Member 'UP2PsycheMindControlComponent::AuxiliaryEffect' has a wrong offset!");
static_assert(offsetof(UP2PsycheMindControlComponent, MindControlLevel) == 0x000160, "Member 'UP2PsycheMindControlComponent::MindControlLevel' has a wrong offset!");
static_assert(offsetof(UP2PsycheMindControlComponent, StatusEffectTag) == 0x000164, "Member 'UP2PsycheMindControlComponent::StatusEffectTag' has a wrong offset!");
static_assert(offsetof(UP2PsycheMindControlComponent, RequiredLevelVolumeTags) == 0x000170, "Member 'UP2PsycheMindControlComponent::RequiredLevelVolumeTags' has a wrong offset!");
static_assert(offsetof(UP2PsycheMindControlComponent, CooldownTimeOnDamage) == 0x000190, "Member 'UP2PsycheMindControlComponent::CooldownTimeOnDamage' has a wrong offset!");
static_assert(offsetof(UP2PsycheMindControlComponent, AffectedActors) == 0x0001A0, "Member 'UP2PsycheMindControlComponent::AffectedActors' has a wrong offset!");

// Class AICommon.P2BTService_Stalker_ProcessPerception
// 0x0100 (0x0198 - 0x0098)
class UP2BTService_Stalker_ProcessPerception final : public UBTService_BlueprintBase
{
public:
	struct FBlackboardKeySelector                 SelfKey;                                           // 0x0098(0x0028)(Edit, NativeAccessSpecifierPublic)
	struct FBlackboardKeySelector                 TargetKey;                                         // 0x00C0(0x0028)(Edit, NativeAccessSpecifierPublic)
	struct FBlackboardKeySelector                 BloodLustKey;                                      // 0x00E8(0x0028)(Edit, NativeAccessSpecifierPublic)
	struct FBlackboardKeySelector                 FearKey;                                           // 0x0110(0x0028)(Edit, NativeAccessSpecifierPublic)
	struct FBlackboardKeySelector                 StateKey;                                          // 0x0138(0x0028)(Edit, NativeAccessSpecifierPublic)
	struct FFloatRange                            BloodLustHysteresis;                               // 0x0160(0x0010)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FFloatRange                            FearHysteresis;                                    // 0x0170(0x0010)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BloodLustChangeRateStalking;                       // 0x0180(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BloodLustChangeRateStalkingSeen;                   // 0x0184(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BloodLustChangeRateAttacking;                      // 0x0188(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FearChangeRate;                                    // 0x018C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Bloodlust;                                         // 0x0190(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         Fear;                                              // 0x0194(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"P2BTService_Stalker_ProcessPerception">();
	}
	static class UP2BTService_Stalker_ProcessPerception* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UP2BTService_Stalker_ProcessPerception>();
	}
};
static_assert(alignof(UP2BTService_Stalker_ProcessPerception) == 0x000008, "Wrong alignment on UP2BTService_Stalker_ProcessPerception");
static_assert(sizeof(UP2BTService_Stalker_ProcessPerception) == 0x000198, "Wrong size on UP2BTService_Stalker_ProcessPerception");
static_assert(offsetof(UP2BTService_Stalker_ProcessPerception, SelfKey) == 0x000098, "Member 'UP2BTService_Stalker_ProcessPerception::SelfKey' has a wrong offset!");
static_assert(offsetof(UP2BTService_Stalker_ProcessPerception, TargetKey) == 0x0000C0, "Member 'UP2BTService_Stalker_ProcessPerception::TargetKey' has a wrong offset!");
static_assert(offsetof(UP2BTService_Stalker_ProcessPerception, BloodLustKey) == 0x0000E8, "Member 'UP2BTService_Stalker_ProcessPerception::BloodLustKey' has a wrong offset!");
static_assert(offsetof(UP2BTService_Stalker_ProcessPerception, FearKey) == 0x000110, "Member 'UP2BTService_Stalker_ProcessPerception::FearKey' has a wrong offset!");
static_assert(offsetof(UP2BTService_Stalker_ProcessPerception, StateKey) == 0x000138, "Member 'UP2BTService_Stalker_ProcessPerception::StateKey' has a wrong offset!");
static_assert(offsetof(UP2BTService_Stalker_ProcessPerception, BloodLustHysteresis) == 0x000160, "Member 'UP2BTService_Stalker_ProcessPerception::BloodLustHysteresis' has a wrong offset!");
static_assert(offsetof(UP2BTService_Stalker_ProcessPerception, FearHysteresis) == 0x000170, "Member 'UP2BTService_Stalker_ProcessPerception::FearHysteresis' has a wrong offset!");
static_assert(offsetof(UP2BTService_Stalker_ProcessPerception, BloodLustChangeRateStalking) == 0x000180, "Member 'UP2BTService_Stalker_ProcessPerception::BloodLustChangeRateStalking' has a wrong offset!");
static_assert(offsetof(UP2BTService_Stalker_ProcessPerception, BloodLustChangeRateStalkingSeen) == 0x000184, "Member 'UP2BTService_Stalker_ProcessPerception::BloodLustChangeRateStalkingSeen' has a wrong offset!");
static_assert(offsetof(UP2BTService_Stalker_ProcessPerception, BloodLustChangeRateAttacking) == 0x000188, "Member 'UP2BTService_Stalker_ProcessPerception::BloodLustChangeRateAttacking' has a wrong offset!");
static_assert(offsetof(UP2BTService_Stalker_ProcessPerception, FearChangeRate) == 0x00018C, "Member 'UP2BTService_Stalker_ProcessPerception::FearChangeRate' has a wrong offset!");
static_assert(offsetof(UP2BTService_Stalker_ProcessPerception, Bloodlust) == 0x000190, "Member 'UP2BTService_Stalker_ProcessPerception::Bloodlust' has a wrong offset!");
static_assert(offsetof(UP2BTService_Stalker_ProcessPerception, Fear) == 0x000194, "Member 'UP2BTService_Stalker_ProcessPerception::Fear' has a wrong offset!");

// Class AICommon.P2RecastNavMesh
// 0x0050 (0x0628 - 0x05D8)
class AP2RecastNavMesh final : public ARecastNavMesh
{
public:
	TSet<uint64>                                  AccessiblePolys;                                   // 0x05D8(0x0050)(NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"P2RecastNavMesh">();
	}
	static class AP2RecastNavMesh* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<AP2RecastNavMesh>();
	}
};
static_assert(alignof(AP2RecastNavMesh) == 0x000008, "Wrong alignment on AP2RecastNavMesh");
static_assert(sizeof(AP2RecastNavMesh) == 0x000628, "Wrong size on AP2RecastNavMesh");
static_assert(offsetof(AP2RecastNavMesh, AccessiblePolys) == 0x0005D8, "Member 'AP2RecastNavMesh::AccessiblePolys' has a wrong offset!");

// Class AICommon.P2BTService_StayInMeleeSlot
// 0x0098 (0x0108 - 0x0070)
class UP2BTService_StayInMeleeSlot final : public UBTService
{
public:
	struct FBlackboardKeySelector                 TargetKey;                                         // 0x0070(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FBlackboardKeySelector                 SlotKey;                                           // 0x0098(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FBlackboardKeySelector                 IsInsideSlotKey;                                   // 0x00C0(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	double                                        RequiredFreeSpace;                                 // 0x00E8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	double                                        MaxDistanceFromOrigin;                             // 0x00F0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_F8[0x10];                                      // 0x00F8(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"P2BTService_StayInMeleeSlot">();
	}
	static class UP2BTService_StayInMeleeSlot* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UP2BTService_StayInMeleeSlot>();
	}
};
static_assert(alignof(UP2BTService_StayInMeleeSlot) == 0x000008, "Wrong alignment on UP2BTService_StayInMeleeSlot");
static_assert(sizeof(UP2BTService_StayInMeleeSlot) == 0x000108, "Wrong size on UP2BTService_StayInMeleeSlot");
static_assert(offsetof(UP2BTService_StayInMeleeSlot, TargetKey) == 0x000070, "Member 'UP2BTService_StayInMeleeSlot::TargetKey' has a wrong offset!");
static_assert(offsetof(UP2BTService_StayInMeleeSlot, SlotKey) == 0x000098, "Member 'UP2BTService_StayInMeleeSlot::SlotKey' has a wrong offset!");
static_assert(offsetof(UP2BTService_StayInMeleeSlot, IsInsideSlotKey) == 0x0000C0, "Member 'UP2BTService_StayInMeleeSlot::IsInsideSlotKey' has a wrong offset!");
static_assert(offsetof(UP2BTService_StayInMeleeSlot, RequiredFreeSpace) == 0x0000E8, "Member 'UP2BTService_StayInMeleeSlot::RequiredFreeSpace' has a wrong offset!");
static_assert(offsetof(UP2BTService_StayInMeleeSlot, MaxDistanceFromOrigin) == 0x0000F0, "Member 'UP2BTService_StayInMeleeSlot::MaxDistanceFromOrigin' has a wrong offset!");

// Class AICommon.P2BTTask_3DMoveToOnHeight
// 0x0098 (0x0130 - 0x0098)
class UP2BTTask_3DMoveToOnHeight final : public UBTTask_BlackboardBase
{
public:
	float                                         SampleInterval;                                    // 0x0098(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bHeightFromBlackboard;                             // 0x009C(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_9D[0x3];                                       // 0x009D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         DesiredHeightAboveGround;                          // 0x00A0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_A4[0x4];                                       // 0x00A4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FBlackboardKeySelector                 HeightBlackboardKey;                               // 0x00A8(0x0028)(Edit, Protected, NativeAccessSpecifierProtected)
	float                                         ClampRadius;                                       // 0x00D0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         EndDistance;                                       // 0x00D4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         Speed;                                             // 0x00D8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bUsePartialPath;                                   // 0x00DC(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	ECollisionChannel                             GroundTraceChannel;                                // 0x00DD(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bEnableHeightSmoothing;                            // 0x00DE(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_DF[0x1];                                       // 0x00DF(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         SmoothingWindowRadius;                             // 0x00E0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         SmoothingIterations;                               // 0x00E4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MaxRaisePerIteration;                              // 0x00E8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bUseGridSampling;                                  // 0x00EC(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_ED[0x3];                                       // 0x00ED(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         GridHalfExtent;                                    // 0x00F0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         GridCellSize;                                      // 0x00F4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         LateralDeviationWeight;                            // 0x00F8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bUseCircularGrid;                                  // 0x00FC(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_FD[0x3];                                       // 0x00FD(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         GridHeightDifferenceThreshold;                     // 0x0100(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_104[0x14];                                     // 0x0104(0x0014)(Fixing Size After Last Property [ Dumper-7 ])
	class AActor*                                 CachedPawn;                                        // 0x0118(0x0008)(ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UMercuna3DNavigationComponent*          NavigationComponent;                               // 0x0120(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class AMercunaNavOctree*                      NavOctree;                                         // 0x0128(0x0008)(ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"P2BTTask_3DMoveToOnHeight">();
	}
	static class UP2BTTask_3DMoveToOnHeight* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UP2BTTask_3DMoveToOnHeight>();
	}
};
static_assert(alignof(UP2BTTask_3DMoveToOnHeight) == 0x000008, "Wrong alignment on UP2BTTask_3DMoveToOnHeight");
static_assert(sizeof(UP2BTTask_3DMoveToOnHeight) == 0x000130, "Wrong size on UP2BTTask_3DMoveToOnHeight");
static_assert(offsetof(UP2BTTask_3DMoveToOnHeight, SampleInterval) == 0x000098, "Member 'UP2BTTask_3DMoveToOnHeight::SampleInterval' has a wrong offset!");
static_assert(offsetof(UP2BTTask_3DMoveToOnHeight, bHeightFromBlackboard) == 0x00009C, "Member 'UP2BTTask_3DMoveToOnHeight::bHeightFromBlackboard' has a wrong offset!");
static_assert(offsetof(UP2BTTask_3DMoveToOnHeight, DesiredHeightAboveGround) == 0x0000A0, "Member 'UP2BTTask_3DMoveToOnHeight::DesiredHeightAboveGround' has a wrong offset!");
static_assert(offsetof(UP2BTTask_3DMoveToOnHeight, HeightBlackboardKey) == 0x0000A8, "Member 'UP2BTTask_3DMoveToOnHeight::HeightBlackboardKey' has a wrong offset!");
static_assert(offsetof(UP2BTTask_3DMoveToOnHeight, ClampRadius) == 0x0000D0, "Member 'UP2BTTask_3DMoveToOnHeight::ClampRadius' has a wrong offset!");
static_assert(offsetof(UP2BTTask_3DMoveToOnHeight, EndDistance) == 0x0000D4, "Member 'UP2BTTask_3DMoveToOnHeight::EndDistance' has a wrong offset!");
static_assert(offsetof(UP2BTTask_3DMoveToOnHeight, Speed) == 0x0000D8, "Member 'UP2BTTask_3DMoveToOnHeight::Speed' has a wrong offset!");
static_assert(offsetof(UP2BTTask_3DMoveToOnHeight, bUsePartialPath) == 0x0000DC, "Member 'UP2BTTask_3DMoveToOnHeight::bUsePartialPath' has a wrong offset!");
static_assert(offsetof(UP2BTTask_3DMoveToOnHeight, GroundTraceChannel) == 0x0000DD, "Member 'UP2BTTask_3DMoveToOnHeight::GroundTraceChannel' has a wrong offset!");
static_assert(offsetof(UP2BTTask_3DMoveToOnHeight, bEnableHeightSmoothing) == 0x0000DE, "Member 'UP2BTTask_3DMoveToOnHeight::bEnableHeightSmoothing' has a wrong offset!");
static_assert(offsetof(UP2BTTask_3DMoveToOnHeight, SmoothingWindowRadius) == 0x0000E0, "Member 'UP2BTTask_3DMoveToOnHeight::SmoothingWindowRadius' has a wrong offset!");
static_assert(offsetof(UP2BTTask_3DMoveToOnHeight, SmoothingIterations) == 0x0000E4, "Member 'UP2BTTask_3DMoveToOnHeight::SmoothingIterations' has a wrong offset!");
static_assert(offsetof(UP2BTTask_3DMoveToOnHeight, MaxRaisePerIteration) == 0x0000E8, "Member 'UP2BTTask_3DMoveToOnHeight::MaxRaisePerIteration' has a wrong offset!");
static_assert(offsetof(UP2BTTask_3DMoveToOnHeight, bUseGridSampling) == 0x0000EC, "Member 'UP2BTTask_3DMoveToOnHeight::bUseGridSampling' has a wrong offset!");
static_assert(offsetof(UP2BTTask_3DMoveToOnHeight, GridHalfExtent) == 0x0000F0, "Member 'UP2BTTask_3DMoveToOnHeight::GridHalfExtent' has a wrong offset!");
static_assert(offsetof(UP2BTTask_3DMoveToOnHeight, GridCellSize) == 0x0000F4, "Member 'UP2BTTask_3DMoveToOnHeight::GridCellSize' has a wrong offset!");
static_assert(offsetof(UP2BTTask_3DMoveToOnHeight, LateralDeviationWeight) == 0x0000F8, "Member 'UP2BTTask_3DMoveToOnHeight::LateralDeviationWeight' has a wrong offset!");
static_assert(offsetof(UP2BTTask_3DMoveToOnHeight, bUseCircularGrid) == 0x0000FC, "Member 'UP2BTTask_3DMoveToOnHeight::bUseCircularGrid' has a wrong offset!");
static_assert(offsetof(UP2BTTask_3DMoveToOnHeight, GridHeightDifferenceThreshold) == 0x000100, "Member 'UP2BTTask_3DMoveToOnHeight::GridHeightDifferenceThreshold' has a wrong offset!");
static_assert(offsetof(UP2BTTask_3DMoveToOnHeight, CachedPawn) == 0x000118, "Member 'UP2BTTask_3DMoveToOnHeight::CachedPawn' has a wrong offset!");
static_assert(offsetof(UP2BTTask_3DMoveToOnHeight, NavigationComponent) == 0x000120, "Member 'UP2BTTask_3DMoveToOnHeight::NavigationComponent' has a wrong offset!");
static_assert(offsetof(UP2BTTask_3DMoveToOnHeight, NavOctree) == 0x000128, "Member 'UP2BTTask_3DMoveToOnHeight::NavOctree' has a wrong offset!");

// Class AICommon.P2RootMotionModifier
// 0x0018 (0x0040 - 0x0028)
class UP2RootMotionModifier : public UObject
{
public:
	uint8                                         Pad_28[0x8];                                       // 0x0028(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UAnimSequenceBase*                      Animation;                                         // 0x0030(0x0008)(ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_38[0x8];                                       // 0x0038(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"P2RootMotionModifier">();
	}
	static class UP2RootMotionModifier* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UP2RootMotionModifier>();
	}
};
static_assert(alignof(UP2RootMotionModifier) == 0x000008, "Wrong alignment on UP2RootMotionModifier");
static_assert(sizeof(UP2RootMotionModifier) == 0x000040, "Wrong size on UP2RootMotionModifier");
static_assert(offsetof(UP2RootMotionModifier, Animation) == 0x000030, "Member 'UP2RootMotionModifier::Animation' has a wrong offset!");

// Class AICommon.P2RootMotionModifierScale
// 0x0008 (0x0048 - 0x0040)
class UP2RootMotionModifierScale final : public UP2RootMotionModifier
{
public:
	float                                         Scale;                                             // 0x0040(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_44[0x4];                                       // 0x0044(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"P2RootMotionModifierScale">();
	}
	static class UP2RootMotionModifierScale* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UP2RootMotionModifierScale>();
	}
};
static_assert(alignof(UP2RootMotionModifierScale) == 0x000008, "Wrong alignment on UP2RootMotionModifierScale");
static_assert(sizeof(UP2RootMotionModifierScale) == 0x000048, "Wrong size on UP2RootMotionModifierScale");
static_assert(offsetof(UP2RootMotionModifierScale, Scale) == 0x000040, "Member 'UP2RootMotionModifierScale::Scale' has a wrong offset!");

// Class AICommon.P2BTTask_3DMoveToRandomly
// 0x0070 (0x0108 - 0x0098)
class UP2BTTask_3DMoveToRandomly final : public UBTTask_BlackboardBase
{
public:
	struct FP2MoveToRange                         WaypointLateralOffsetRange;                        // 0x0098(0x0008)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FP2MoveToRange                         WaypointDistanceRange;                             // 0x00A0(0x0008)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	float                                         Speed;                                             // 0x00A8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         EndDistance;                                       // 0x00AC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMercunaPath*                           FoundPath;                                         // 0x00B0(0x0008)(ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class AActor*                                 OwnerPawn;                                         // 0x00B8(0x0008)(ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_C0[0x8];                                       // 0x00C0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class AMercunaNavOctree*                      NavOctree;                                         // 0x00C8(0x0008)(ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_D0[0x10];                                      // 0x00D0(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	TWeakObjectPtr<class UMercuna3DTask_MoveTo>   MoveTask;                                          // 0x00E0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_E8[0x20];                                      // 0x00E8(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnPathUpdated(EMercunaPathEvent PathEvent)	 // 0x4745834;

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"P2BTTask_3DMoveToRandomly">();
	}
	static class UP2BTTask_3DMoveToRandomly* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UP2BTTask_3DMoveToRandomly>();
	}
};
static_assert(alignof(UP2BTTask_3DMoveToRandomly) == 0x000008, "Wrong alignment on UP2BTTask_3DMoveToRandomly");
static_assert(sizeof(UP2BTTask_3DMoveToRandomly) == 0x000108, "Wrong size on UP2BTTask_3DMoveToRandomly");
static_assert(offsetof(UP2BTTask_3DMoveToRandomly, WaypointLateralOffsetRange) == 0x000098, "Member 'UP2BTTask_3DMoveToRandomly::WaypointLateralOffsetRange' has a wrong offset!");
static_assert(offsetof(UP2BTTask_3DMoveToRandomly, WaypointDistanceRange) == 0x0000A0, "Member 'UP2BTTask_3DMoveToRandomly::WaypointDistanceRange' has a wrong offset!");
static_assert(offsetof(UP2BTTask_3DMoveToRandomly, Speed) == 0x0000A8, "Member 'UP2BTTask_3DMoveToRandomly::Speed' has a wrong offset!");
static_assert(offsetof(UP2BTTask_3DMoveToRandomly, EndDistance) == 0x0000AC, "Member 'UP2BTTask_3DMoveToRandomly::EndDistance' has a wrong offset!");
static_assert(offsetof(UP2BTTask_3DMoveToRandomly, FoundPath) == 0x0000B0, "Member 'UP2BTTask_3DMoveToRandomly::FoundPath' has a wrong offset!");
static_assert(offsetof(UP2BTTask_3DMoveToRandomly, OwnerPawn) == 0x0000B8, "Member 'UP2BTTask_3DMoveToRandomly::OwnerPawn' has a wrong offset!");
static_assert(offsetof(UP2BTTask_3DMoveToRandomly, NavOctree) == 0x0000C8, "Member 'UP2BTTask_3DMoveToRandomly::NavOctree' has a wrong offset!");
static_assert(offsetof(UP2BTTask_3DMoveToRandomly, MoveTask) == 0x0000E0, "Member 'UP2BTTask_3DMoveToRandomly::MoveTask' has a wrong offset!");

// Class AICommon.P2NpcSpawningCosmeticActor
// 0x0000 (0x02B0 - 0x02B0)
class AP2NpcSpawningCosmeticActor final : public AActor
{
public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"P2NpcSpawningCosmeticActor">();
	}
	static class AP2NpcSpawningCosmeticActor* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<AP2NpcSpawningCosmeticActor>();
	}
};
static_assert(alignof(AP2NpcSpawningCosmeticActor) == 0x000008, "Wrong alignment on AP2NpcSpawningCosmeticActor");
static_assert(sizeof(AP2NpcSpawningCosmeticActor) == 0x0002B0, "Wrong size on AP2NpcSpawningCosmeticActor");

// Class AICommon.P2BTTasK_ActivateAbilityByTag
// 0x0020 (0x0110 - 0x00F0)
class UP2BTTasK_ActivateAbilityByTag final : public UP2BTTask_ActivateAbilityWithTargetData
{
public:
	struct FGameplayTagContainer                  AbilityTag;                                        // 0x00F0(0x0020)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"P2BTTasK_ActivateAbilityByTag">();
	}
	static class UP2BTTasK_ActivateAbilityByTag* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UP2BTTasK_ActivateAbilityByTag>();
	}
};
static_assert(alignof(UP2BTTasK_ActivateAbilityByTag) == 0x000008, "Wrong alignment on UP2BTTasK_ActivateAbilityByTag");
static_assert(sizeof(UP2BTTasK_ActivateAbilityByTag) == 0x000110, "Wrong size on UP2BTTasK_ActivateAbilityByTag");
static_assert(offsetof(UP2BTTasK_ActivateAbilityByTag, AbilityTag) == 0x0000F0, "Member 'UP2BTTasK_ActivateAbilityByTag::AbilityTag' has a wrong offset!");

// Class AICommon.P2BTTask_ApplyGameplayEffect
// 0x0008 (0x0078 - 0x0070)
class UP2BTTask_ApplyGameplayEffect final : public UBTTaskNode
{
public:
	TSubclassOf<class UGameplayEffect>            Effect;                                            // 0x0070(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"P2BTTask_ApplyGameplayEffect">();
	}
	static class UP2BTTask_ApplyGameplayEffect* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UP2BTTask_ApplyGameplayEffect>();
	}
};
static_assert(alignof(UP2BTTask_ApplyGameplayEffect) == 0x000008, "Wrong alignment on UP2BTTask_ApplyGameplayEffect");
static_assert(sizeof(UP2BTTask_ApplyGameplayEffect) == 0x000078, "Wrong size on UP2BTTask_ApplyGameplayEffect");
static_assert(offsetof(UP2BTTask_ApplyGameplayEffect, Effect) == 0x000070, "Member 'UP2BTTask_ApplyGameplayEffect::Effect' has a wrong offset!");

// Class AICommon.P2BTTask_AwaitSmartObjectLeft
// 0x0008 (0x0078 - 0x0070)
class UP2BTTask_AwaitSmartObjectLeft : public UBTTaskNode
{
public:
	uint8                                         Pad_70[0x8];                                       // 0x0070(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"P2BTTask_AwaitSmartObjectLeft">();
	}
	static class UP2BTTask_AwaitSmartObjectLeft* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UP2BTTask_AwaitSmartObjectLeft>();
	}
};
static_assert(alignof(UP2BTTask_AwaitSmartObjectLeft) == 0x000008, "Wrong alignment on UP2BTTask_AwaitSmartObjectLeft");
static_assert(sizeof(UP2BTTask_AwaitSmartObjectLeft) == 0x000078, "Wrong size on UP2BTTask_AwaitSmartObjectLeft");

// Class AICommon.P2BTTask_CancelAbilityByClass
// 0x0028 (0x0098 - 0x0070)
class UP2BTTask_CancelAbilityByClass final : public UBTTaskNode
{
public:
	TSubclassOf<class UP2Ability>                 AbilityClass;                                      // 0x0070(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_78[0x20];                                      // 0x0078(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnAbilityEnded(const struct FAbilityEndedData& AbilityEndedData)	 // 0x474551c;

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"P2BTTask_CancelAbilityByClass">();
	}
	static class UP2BTTask_CancelAbilityByClass* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UP2BTTask_CancelAbilityByClass>();
	}
};
static_assert(alignof(UP2BTTask_CancelAbilityByClass) == 0x000008, "Wrong alignment on UP2BTTask_CancelAbilityByClass");
static_assert(sizeof(UP2BTTask_CancelAbilityByClass) == 0x000098, "Wrong size on UP2BTTask_CancelAbilityByClass");
static_assert(offsetof(UP2BTTask_CancelAbilityByClass, AbilityClass) == 0x000070, "Member 'UP2BTTask_CancelAbilityByClass::AbilityClass' has a wrong offset!");

// Class AICommon.P2GhostLootData
// 0x0020 (0x0050 - 0x0030)
class UP2GhostLootData final : public UPrimaryDataAsset
{
public:
	bool                                          bAllowRepetition;                                  // 0x0030(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_31[0x3];                                       // 0x0031(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FIntPoint                              NumOfItems;                                        // 0x0034(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3C[0x4];                                       // 0x003C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FP2LootConfig>                  Configs;                                           // 0x0040(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"P2GhostLootData">();
	}
	static class UP2GhostLootData* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UP2GhostLootData>();
	}
};
static_assert(alignof(UP2GhostLootData) == 0x000008, "Wrong alignment on UP2GhostLootData");
static_assert(sizeof(UP2GhostLootData) == 0x000050, "Wrong size on UP2GhostLootData");
static_assert(offsetof(UP2GhostLootData, bAllowRepetition) == 0x000030, "Member 'UP2GhostLootData::bAllowRepetition' has a wrong offset!");
static_assert(offsetof(UP2GhostLootData, NumOfItems) == 0x000034, "Member 'UP2GhostLootData::NumOfItems' has a wrong offset!");
static_assert(offsetof(UP2GhostLootData, Configs) == 0x000040, "Member 'UP2GhostLootData::Configs' has a wrong offset!");

// Class AICommon.P2EnvQueryTest_WithinRange
// 0x0098 (0x02A0 - 0x0208)
class UP2EnvQueryTest_WithinRange final : public UEnvQueryTest
{
public:
	bool                                          bTaperBeforeMinimum;                               // 0x0208(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_209[0x3];                                      // 0x0209(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MinValue;                                          // 0x020C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bTaperAfterMaximum;                                // 0x0210(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_211[0x3];                                      // 0x0211(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MaxValue;                                          // 0x0214(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FAIDataProviderFloatValue              RangeClampMin;                                     // 0x0218(0x0038)(Edit, DisableEditOnInstance, ContainsInstancedReference, NativeAccessSpecifierPublic)
	struct FAIDataProviderFloatValue              RangeClampMax;                                     // 0x0250(0x0038)(Edit, DisableEditOnInstance, ContainsInstancedReference, NativeAccessSpecifierPublic)
	bool                                          bConstantScoreWithinRange;                         // 0x0288(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_289[0x3];                                      // 0x0289(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ScoringFactorWithinRange;                          // 0x028C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDistance3D;                                       // 0x0290(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_291[0x7];                                      // 0x0291(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class UEnvQueryContext>           DistanceTo;                                        // 0x0298(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"P2EnvQueryTest_WithinRange">();
	}
	static class UP2EnvQueryTest_WithinRange* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UP2EnvQueryTest_WithinRange>();
	}
};
static_assert(alignof(UP2EnvQueryTest_WithinRange) == 0x000008, "Wrong alignment on UP2EnvQueryTest_WithinRange");
static_assert(sizeof(UP2EnvQueryTest_WithinRange) == 0x0002A0, "Wrong size on UP2EnvQueryTest_WithinRange");
static_assert(offsetof(UP2EnvQueryTest_WithinRange, bTaperBeforeMinimum) == 0x000208, "Member 'UP2EnvQueryTest_WithinRange::bTaperBeforeMinimum' has a wrong offset!");
static_assert(offsetof(UP2EnvQueryTest_WithinRange, MinValue) == 0x00020C, "Member 'UP2EnvQueryTest_WithinRange::MinValue' has a wrong offset!");
static_assert(offsetof(UP2EnvQueryTest_WithinRange, bTaperAfterMaximum) == 0x000210, "Member 'UP2EnvQueryTest_WithinRange::bTaperAfterMaximum' has a wrong offset!");
static_assert(offsetof(UP2EnvQueryTest_WithinRange, MaxValue) == 0x000214, "Member 'UP2EnvQueryTest_WithinRange::MaxValue' has a wrong offset!");
static_assert(offsetof(UP2EnvQueryTest_WithinRange, RangeClampMin) == 0x000218, "Member 'UP2EnvQueryTest_WithinRange::RangeClampMin' has a wrong offset!");
static_assert(offsetof(UP2EnvQueryTest_WithinRange, RangeClampMax) == 0x000250, "Member 'UP2EnvQueryTest_WithinRange::RangeClampMax' has a wrong offset!");
static_assert(offsetof(UP2EnvQueryTest_WithinRange, bConstantScoreWithinRange) == 0x000288, "Member 'UP2EnvQueryTest_WithinRange::bConstantScoreWithinRange' has a wrong offset!");
static_assert(offsetof(UP2EnvQueryTest_WithinRange, ScoringFactorWithinRange) == 0x00028C, "Member 'UP2EnvQueryTest_WithinRange::ScoringFactorWithinRange' has a wrong offset!");
static_assert(offsetof(UP2EnvQueryTest_WithinRange, bDistance3D) == 0x000290, "Member 'UP2EnvQueryTest_WithinRange::bDistance3D' has a wrong offset!");
static_assert(offsetof(UP2EnvQueryTest_WithinRange, DistanceTo) == 0x000298, "Member 'UP2EnvQueryTest_WithinRange::DistanceTo' has a wrong offset!");

// Class AICommon.P2BTTask_Cover
// 0x00A0 (0x0148 - 0x00A8)
class UP2BTTask_Cover final : public UBTTask_BlueprintBase
{
public:
	struct FBlackboardKeySelector                 CoverKey;                                          // 0x00A8(0x0028)(Edit, Protected, NativeAccessSpecifierProtected)
	struct FBlackboardKeySelector                 CoverStateKey;                                     // 0x00D0(0x0028)(Edit, Protected, NativeAccessSpecifierProtected)
	float                                         MinTimeInCover;                                    // 0x00F8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MinTimeInCoverRandomDeviation;                     // 0x00FC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MaxTimeInCover;                                    // 0x0100(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MaxTimeInCoverRandomDeviation;                     // 0x0104(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MaxInvalidCoverTime;                               // 0x0108(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bCanSwitchCover;                                   // 0x010C(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_10D[0x3];                                      // 0x010D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class UEnvQuery*                              FindCoverQueryTemplate;                            // 0x0110(0x0008)(Edit, ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EEnvQueryRunMode                              FindCoverQueryRunMode;                             // 0x0118(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_119[0x7];                                      // 0x0119(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UEnvQuery*                              ValidateCoverQueryTemplate;                        // 0x0120(0x0008)(Edit, ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bSprintMovingToCover;                              // 0x0128(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_129[0x1F];                                     // 0x0129(0x001F)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnMoveCompleted(const struct FAIRequestID& InRequestId, EMercunaMoveResult InResult)	 // 0x47456f4;

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"P2BTTask_Cover">();
	}
	static class UP2BTTask_Cover* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UP2BTTask_Cover>();
	}
};
static_assert(alignof(UP2BTTask_Cover) == 0x000008, "Wrong alignment on UP2BTTask_Cover");
static_assert(sizeof(UP2BTTask_Cover) == 0x000148, "Wrong size on UP2BTTask_Cover");
static_assert(offsetof(UP2BTTask_Cover, CoverKey) == 0x0000A8, "Member 'UP2BTTask_Cover::CoverKey' has a wrong offset!");
static_assert(offsetof(UP2BTTask_Cover, CoverStateKey) == 0x0000D0, "Member 'UP2BTTask_Cover::CoverStateKey' has a wrong offset!");
static_assert(offsetof(UP2BTTask_Cover, MinTimeInCover) == 0x0000F8, "Member 'UP2BTTask_Cover::MinTimeInCover' has a wrong offset!");
static_assert(offsetof(UP2BTTask_Cover, MinTimeInCoverRandomDeviation) == 0x0000FC, "Member 'UP2BTTask_Cover::MinTimeInCoverRandomDeviation' has a wrong offset!");
static_assert(offsetof(UP2BTTask_Cover, MaxTimeInCover) == 0x000100, "Member 'UP2BTTask_Cover::MaxTimeInCover' has a wrong offset!");
static_assert(offsetof(UP2BTTask_Cover, MaxTimeInCoverRandomDeviation) == 0x000104, "Member 'UP2BTTask_Cover::MaxTimeInCoverRandomDeviation' has a wrong offset!");
static_assert(offsetof(UP2BTTask_Cover, MaxInvalidCoverTime) == 0x000108, "Member 'UP2BTTask_Cover::MaxInvalidCoverTime' has a wrong offset!");
static_assert(offsetof(UP2BTTask_Cover, bCanSwitchCover) == 0x00010C, "Member 'UP2BTTask_Cover::bCanSwitchCover' has a wrong offset!");
static_assert(offsetof(UP2BTTask_Cover, FindCoverQueryTemplate) == 0x000110, "Member 'UP2BTTask_Cover::FindCoverQueryTemplate' has a wrong offset!");
static_assert(offsetof(UP2BTTask_Cover, FindCoverQueryRunMode) == 0x000118, "Member 'UP2BTTask_Cover::FindCoverQueryRunMode' has a wrong offset!");
static_assert(offsetof(UP2BTTask_Cover, ValidateCoverQueryTemplate) == 0x000120, "Member 'UP2BTTask_Cover::ValidateCoverQueryTemplate' has a wrong offset!");
static_assert(offsetof(UP2BTTask_Cover, bSprintMovingToCover) == 0x000128, "Member 'UP2BTTask_Cover::bSprintMovingToCover' has a wrong offset!");

// Class AICommon.P2EnvQueryInstance_CoverBase
// 0x0010 (0x0088 - 0x0078)
class UP2EnvQueryInstance_CoverBase : public UEnvQueryInstanceBlueprintWrapper
{
public:
	uint8                                         Pad_78[0x10];                                      // 0x0078(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnFinish(class UEnvQueryInstanceBlueprintWrapper* InQueryInstance, EEnvQueryStatus InQueryStatus)	 // 0x47455b0;

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"P2EnvQueryInstance_CoverBase">();
	}
	static class UP2EnvQueryInstance_CoverBase* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UP2EnvQueryInstance_CoverBase>();
	}
};
static_assert(alignof(UP2EnvQueryInstance_CoverBase) == 0x000008, "Wrong alignment on UP2EnvQueryInstance_CoverBase");
static_assert(sizeof(UP2EnvQueryInstance_CoverBase) == 0x000088, "Wrong size on UP2EnvQueryInstance_CoverBase");

// Class AICommon.P2GhostUtilityData
// 0x0020 (0x0050 - 0x0030)
class UP2GhostUtilityData final : public UPrimaryDataAsset
{
public:
	struct FGameplayTag                           UtilityCooldownTag;                                // 0x0030(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         UsageCooldown;                                     // 0x0038(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MinTargetHiddenTime;                               // 0x003C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxTargetHiddenTime;                               // 0x0040(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MinTargetDistance;                                 // 0x0044(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxTargetDistance;                                 // 0x0048(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SafetyDistance;                                    // 0x004C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"P2GhostUtilityData">();
	}
	static class UP2GhostUtilityData* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UP2GhostUtilityData>();
	}
};
static_assert(alignof(UP2GhostUtilityData) == 0x000008, "Wrong alignment on UP2GhostUtilityData");
static_assert(sizeof(UP2GhostUtilityData) == 0x000050, "Wrong size on UP2GhostUtilityData");
static_assert(offsetof(UP2GhostUtilityData, UtilityCooldownTag) == 0x000030, "Member 'UP2GhostUtilityData::UtilityCooldownTag' has a wrong offset!");
static_assert(offsetof(UP2GhostUtilityData, UsageCooldown) == 0x000038, "Member 'UP2GhostUtilityData::UsageCooldown' has a wrong offset!");
static_assert(offsetof(UP2GhostUtilityData, MinTargetHiddenTime) == 0x00003C, "Member 'UP2GhostUtilityData::MinTargetHiddenTime' has a wrong offset!");
static_assert(offsetof(UP2GhostUtilityData, MaxTargetHiddenTime) == 0x000040, "Member 'UP2GhostUtilityData::MaxTargetHiddenTime' has a wrong offset!");
static_assert(offsetof(UP2GhostUtilityData, MinTargetDistance) == 0x000044, "Member 'UP2GhostUtilityData::MinTargetDistance' has a wrong offset!");
static_assert(offsetof(UP2GhostUtilityData, MaxTargetDistance) == 0x000048, "Member 'UP2GhostUtilityData::MaxTargetDistance' has a wrong offset!");
static_assert(offsetof(UP2GhostUtilityData, SafetyDistance) == 0x00004C, "Member 'UP2GhostUtilityData::SafetyDistance' has a wrong offset!");

// Class AICommon.P2EnvQueryInstance_CoverFind
// 0x0050 (0x00D8 - 0x0088)
class UP2EnvQueryInstance_CoverFind final : public UP2EnvQueryInstance_CoverBase
{
public:
	uint8                                         Pad_88[0x50];                                      // 0x0088(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"P2EnvQueryInstance_CoverFind">();
	}
	static class UP2EnvQueryInstance_CoverFind* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UP2EnvQueryInstance_CoverFind>();
	}
};
static_assert(alignof(UP2EnvQueryInstance_CoverFind) == 0x000008, "Wrong alignment on UP2EnvQueryInstance_CoverFind");
static_assert(sizeof(UP2EnvQueryInstance_CoverFind) == 0x0000D8, "Wrong size on UP2EnvQueryInstance_CoverFind");

// Class AICommon.P2EnvQueryInstance_CoverValidate
// 0x0000 (0x0088 - 0x0088)
class UP2EnvQueryInstance_CoverValidate final : public UP2EnvQueryInstance_CoverBase
{
public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"P2EnvQueryInstance_CoverValidate">();
	}
	static class UP2EnvQueryInstance_CoverValidate* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UP2EnvQueryInstance_CoverValidate>();
	}
};
static_assert(alignof(UP2EnvQueryInstance_CoverValidate) == 0x000008, "Wrong alignment on UP2EnvQueryInstance_CoverValidate");
static_assert(sizeof(UP2EnvQueryInstance_CoverValidate) == 0x000088, "Wrong size on UP2EnvQueryInstance_CoverValidate");

// Class AICommon.P2BTTask_ForgetStimuli
// 0x0038 (0x00A8 - 0x0070)
class UP2BTTask_ForgetStimuli final : public UBTTaskNode
{
public:
	bool                                          bInRange;                                          // 0x0070(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_71[0x7];                                       // 0x0071(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FBlackboardKeySelector                 Center;                                            // 0x0078(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	float                                         Radius;                                            // 0x00A0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A4[0x4];                                       // 0x00A4(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"P2BTTask_ForgetStimuli">();
	}
	static class UP2BTTask_ForgetStimuli* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UP2BTTask_ForgetStimuli>();
	}
};
static_assert(alignof(UP2BTTask_ForgetStimuli) == 0x000008, "Wrong alignment on UP2BTTask_ForgetStimuli");
static_assert(sizeof(UP2BTTask_ForgetStimuli) == 0x0000A8, "Wrong size on UP2BTTask_ForgetStimuli");
static_assert(offsetof(UP2BTTask_ForgetStimuli, bInRange) == 0x000070, "Member 'UP2BTTask_ForgetStimuli::bInRange' has a wrong offset!");
static_assert(offsetof(UP2BTTask_ForgetStimuli, Center) == 0x000078, "Member 'UP2BTTask_ForgetStimuli::Center' has a wrong offset!");
static_assert(offsetof(UP2BTTask_ForgetStimuli, Radius) == 0x0000A0, "Member 'UP2BTTask_ForgetStimuli::Radius' has a wrong offset!");

// Class AICommon.P2BTTask_ForgetTarget
// 0x0028 (0x0098 - 0x0070)
class UP2BTTask_ForgetTarget final : public UBTTaskNode
{
public:
	struct FBlackboardKeySelector                 Target;                                            // 0x0070(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"P2BTTask_ForgetTarget">();
	}
	static class UP2BTTask_ForgetTarget* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UP2BTTask_ForgetTarget>();
	}
};
static_assert(alignof(UP2BTTask_ForgetTarget) == 0x000008, "Wrong alignment on UP2BTTask_ForgetTarget");
static_assert(sizeof(UP2BTTask_ForgetTarget) == 0x000098, "Wrong size on UP2BTTask_ForgetTarget");
static_assert(offsetof(UP2BTTask_ForgetTarget, Target) == 0x000070, "Member 'UP2BTTask_ForgetTarget::Target' has a wrong offset!");

// Class AICommon.P2NpcGroupData
// 0x0048 (0x0078 - 0x0030)
class UP2NpcGroupData : public UPrimaryDataAsset
{
public:
	TSubclassOf<class AP2NpcGroupAIController>    GroupAIControllerClass;                            // 0x0030(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStateTree*                             StateTree;                                         // 0x0038(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class UP2NpcGroupMemberData*>          GroupMembersNpcData;                               // 0x0040(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	int32                                         MaxMembersAttackingSameTarget;                     // 0x0050(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_54[0x4];                                       // 0x0054(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector2D                              MinIntervalToAttackSameTarget;                     // 0x0058(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              MinIntervalToUseUtiltiyOnSameTarget;               // 0x0068(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"P2NpcGroupData">();
	}
	static class UP2NpcGroupData* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UP2NpcGroupData>();
	}
};
static_assert(alignof(UP2NpcGroupData) == 0x000008, "Wrong alignment on UP2NpcGroupData");
static_assert(sizeof(UP2NpcGroupData) == 0x000078, "Wrong size on UP2NpcGroupData");
static_assert(offsetof(UP2NpcGroupData, GroupAIControllerClass) == 0x000030, "Member 'UP2NpcGroupData::GroupAIControllerClass' has a wrong offset!");
static_assert(offsetof(UP2NpcGroupData, StateTree) == 0x000038, "Member 'UP2NpcGroupData::StateTree' has a wrong offset!");
static_assert(offsetof(UP2NpcGroupData, GroupMembersNpcData) == 0x000040, "Member 'UP2NpcGroupData::GroupMembersNpcData' has a wrong offset!");
static_assert(offsetof(UP2NpcGroupData, MaxMembersAttackingSameTarget) == 0x000050, "Member 'UP2NpcGroupData::MaxMembersAttackingSameTarget' has a wrong offset!");
static_assert(offsetof(UP2NpcGroupData, MinIntervalToAttackSameTarget) == 0x000058, "Member 'UP2NpcGroupData::MinIntervalToAttackSameTarget' has a wrong offset!");
static_assert(offsetof(UP2NpcGroupData, MinIntervalToUseUtiltiyOnSameTarget) == 0x000068, "Member 'UP2NpcGroupData::MinIntervalToUseUtiltiyOnSameTarget' has a wrong offset!");

// Class AICommon.P2GhostGroupData
// 0x0000 (0x0078 - 0x0078)
class UP2GhostGroupData final : public UP2NpcGroupData
{
public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"P2GhostGroupData">();
	}
	static class UP2GhostGroupData* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UP2GhostGroupData>();
	}
};
static_assert(alignof(UP2GhostGroupData) == 0x000008, "Wrong alignment on UP2GhostGroupData");
static_assert(sizeof(UP2GhostGroupData) == 0x000078, "Wrong size on UP2GhostGroupData");

// Class AICommon.P2BTTask_GhostCrouch
// 0x0008 (0x0078 - 0x0070)
class UP2BTTask_GhostCrouch final : public UBTTaskNode
{
public:
	bool                                          bCrouch;                                           // 0x0070(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_71[0x3];                                       // 0x0071(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Time;                                              // 0x0074(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"P2BTTask_GhostCrouch">();
	}
	static class UP2BTTask_GhostCrouch* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UP2BTTask_GhostCrouch>();
	}
};
static_assert(alignof(UP2BTTask_GhostCrouch) == 0x000008, "Wrong alignment on UP2BTTask_GhostCrouch");
static_assert(sizeof(UP2BTTask_GhostCrouch) == 0x000078, "Wrong size on UP2BTTask_GhostCrouch");
static_assert(offsetof(UP2BTTask_GhostCrouch, bCrouch) == 0x000070, "Member 'UP2BTTask_GhostCrouch::bCrouch' has a wrong offset!");
static_assert(offsetof(UP2BTTask_GhostCrouch, Time) == 0x000074, "Member 'UP2BTTask_GhostCrouch::Time' has a wrong offset!");

// Class AICommon.P2GeneratedNavlinkComponent
// 0x0030 (0x00F0 - 0x00C0)
class UP2GeneratedNavlinkComponent final : public UActorComponent
{
public:
	TSoftObjectPtr<class AActor>                  ProxyActor;                                        // 0x00C0(0x0030)(UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"P2GeneratedNavlinkComponent">();
	}
	static class UP2GeneratedNavlinkComponent* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UP2GeneratedNavlinkComponent>();
	}
};
static_assert(alignof(UP2GeneratedNavlinkComponent) == 0x000008, "Wrong alignment on UP2GeneratedNavlinkComponent");
static_assert(sizeof(UP2GeneratedNavlinkComponent) == 0x0000F0, "Wrong size on UP2GeneratedNavlinkComponent");
static_assert(offsetof(UP2GeneratedNavlinkComponent, ProxyActor) == 0x0000C0, "Member 'UP2GeneratedNavlinkComponent::ProxyActor' has a wrong offset!");

// Class AICommon.P2BTTask_GhostThrow
// 0x0100 (0x0170 - 0x0070)
class UP2BTTask_GhostThrow final : public UBTTaskNode
{
public:
	struct FVector                                AimFactors;                                        // 0x0070(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         AimTime;                                           // 0x0088(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         AimRandomDeviation;                                // 0x008C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         PostThrowTime;                                     // 0x0090(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_94[0x4];                                       // 0x0094(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FBlackboardKeySelector                 BBUtilityAllowed;                                  // 0x0098(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)
	struct FBlackboardKeySelector                 BBUtilityThrowVelocity;                            // 0x00C0(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)
	struct FBlackboardKeySelector                 BBFocalPointOverride;                              // 0x00E8(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)
	bool                                          bDrawDebug;                                        // 0x0110(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_111[0x3];                                      // 0x0111(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         DrawDebugTime;                                     // 0x0114(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FColor                                 DebugColor;                                        // 0x0118(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_11C[0x54];                                     // 0x011C(0x0054)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"P2BTTask_GhostThrow">();
	}
	static class UP2BTTask_GhostThrow* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UP2BTTask_GhostThrow>();
	}
};
static_assert(alignof(UP2BTTask_GhostThrow) == 0x000008, "Wrong alignment on UP2BTTask_GhostThrow");
static_assert(sizeof(UP2BTTask_GhostThrow) == 0x000170, "Wrong size on UP2BTTask_GhostThrow");
static_assert(offsetof(UP2BTTask_GhostThrow, AimFactors) == 0x000070, "Member 'UP2BTTask_GhostThrow::AimFactors' has a wrong offset!");
static_assert(offsetof(UP2BTTask_GhostThrow, AimTime) == 0x000088, "Member 'UP2BTTask_GhostThrow::AimTime' has a wrong offset!");
static_assert(offsetof(UP2BTTask_GhostThrow, AimRandomDeviation) == 0x00008C, "Member 'UP2BTTask_GhostThrow::AimRandomDeviation' has a wrong offset!");
static_assert(offsetof(UP2BTTask_GhostThrow, PostThrowTime) == 0x000090, "Member 'UP2BTTask_GhostThrow::PostThrowTime' has a wrong offset!");
static_assert(offsetof(UP2BTTask_GhostThrow, BBUtilityAllowed) == 0x000098, "Member 'UP2BTTask_GhostThrow::BBUtilityAllowed' has a wrong offset!");
static_assert(offsetof(UP2BTTask_GhostThrow, BBUtilityThrowVelocity) == 0x0000C0, "Member 'UP2BTTask_GhostThrow::BBUtilityThrowVelocity' has a wrong offset!");
static_assert(offsetof(UP2BTTask_GhostThrow, BBFocalPointOverride) == 0x0000E8, "Member 'UP2BTTask_GhostThrow::BBFocalPointOverride' has a wrong offset!");
static_assert(offsetof(UP2BTTask_GhostThrow, bDrawDebug) == 0x000110, "Member 'UP2BTTask_GhostThrow::bDrawDebug' has a wrong offset!");
static_assert(offsetof(UP2BTTask_GhostThrow, DrawDebugTime) == 0x000114, "Member 'UP2BTTask_GhostThrow::DrawDebugTime' has a wrong offset!");
static_assert(offsetof(UP2BTTask_GhostThrow, DebugColor) == 0x000118, "Member 'UP2BTTask_GhostThrow::DebugColor' has a wrong offset!");

// Class AICommon.P2BTTask_GhostTrackLeader
// 0x0010 (0x0080 - 0x0070)
class UP2BTTask_GhostTrackLeader final : public UBTTaskNode
{
public:
	uint8                                         Pad_70[0x10];                                      // 0x0070(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnMoveCompleted(const struct FAIRequestID& InRequestId, const EMercunaMoveResult InResult)	 // 0x4749ca0;

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"P2BTTask_GhostTrackLeader">();
	}
	static class UP2BTTask_GhostTrackLeader* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UP2BTTask_GhostTrackLeader>();
	}
};
static_assert(alignof(UP2BTTask_GhostTrackLeader) == 0x000008, "Wrong alignment on UP2BTTask_GhostTrackLeader");
static_assert(sizeof(UP2BTTask_GhostTrackLeader) == 0x000080, "Wrong size on UP2BTTask_GhostTrackLeader");

// Class AICommon.P2BTTask_IgnoreTarget
// 0x0030 (0x00A0 - 0x0070)
class UP2BTTask_IgnoreTarget final : public UBTTaskNode
{
public:
	struct FBlackboardKeySelector                 Target;                                            // 0x0070(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)
	float                                         Time;                                              // 0x0098(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_9C[0x4];                                       // 0x009C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"P2BTTask_IgnoreTarget">();
	}
	static class UP2BTTask_IgnoreTarget* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UP2BTTask_IgnoreTarget>();
	}
};
static_assert(alignof(UP2BTTask_IgnoreTarget) == 0x000008, "Wrong alignment on UP2BTTask_IgnoreTarget");
static_assert(sizeof(UP2BTTask_IgnoreTarget) == 0x0000A0, "Wrong size on UP2BTTask_IgnoreTarget");
static_assert(offsetof(UP2BTTask_IgnoreTarget, Target) == 0x000070, "Member 'UP2BTTask_IgnoreTarget::Target' has a wrong offset!");
static_assert(offsetof(UP2BTTask_IgnoreTarget, Time) == 0x000098, "Member 'UP2BTTask_IgnoreTarget::Time' has a wrong offset!");

// Class AICommon.P2GhostGroupObjectiveSpawner
// 0x0028 (0x02D8 - 0x02B0)
class AP2GhostGroupObjectiveSpawner final : public AActor
{
public:
	class FName                                   AgentName;                                         // 0x02B0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         ScanRadius;                                        // 0x02B8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2BC[0x4];                                      // 0x02BC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class AP2GhostGroupObjective>     ObjectiveClass;                                    // 0x02C0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<struct FP2GroupObjectiveZoneDefinition> ZoneDefinitions;                                  // 0x02C8(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Protected, NativeAccessSpecifierProtected)

public:
	void Clear()	 // 0x17c7f2c;
	bool GatherDataToSpawnObjectives(TArray<struct FVector>* OutLocations, TArray<float>* OutAreasRadius)	 // 0xae1e64;
	void Generate()	 // 0x17c7f2c;
	void SnapToNavMesh()	 // 0x17c7f2c;

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"P2GhostGroupObjectiveSpawner">();
	}
	static class AP2GhostGroupObjectiveSpawner* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<AP2GhostGroupObjectiveSpawner>();
	}
};
static_assert(alignof(AP2GhostGroupObjectiveSpawner) == 0x000008, "Wrong alignment on AP2GhostGroupObjectiveSpawner");
static_assert(sizeof(AP2GhostGroupObjectiveSpawner) == 0x0002D8, "Wrong size on AP2GhostGroupObjectiveSpawner");
static_assert(offsetof(AP2GhostGroupObjectiveSpawner, AgentName) == 0x0002B0, "Member 'AP2GhostGroupObjectiveSpawner::AgentName' has a wrong offset!");
static_assert(offsetof(AP2GhostGroupObjectiveSpawner, ScanRadius) == 0x0002B8, "Member 'AP2GhostGroupObjectiveSpawner::ScanRadius' has a wrong offset!");
static_assert(offsetof(AP2GhostGroupObjectiveSpawner, ObjectiveClass) == 0x0002C0, "Member 'AP2GhostGroupObjectiveSpawner::ObjectiveClass' has a wrong offset!");
static_assert(offsetof(AP2GhostGroupObjectiveSpawner, ZoneDefinitions) == 0x0002C8, "Member 'AP2GhostGroupObjectiveSpawner::ZoneDefinitions' has a wrong offset!");

// Class AICommon.P2BTTask_LeaveCurrentSmartObject
// 0x0008 (0x0080 - 0x0078)
class UP2BTTask_LeaveCurrentSmartObject final : public UP2BTTask_AwaitSmartObjectLeft
{
public:
	uint8                                         Pad_78[0x8];                                       // 0x0078(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"P2BTTask_LeaveCurrentSmartObject">();
	}
	static class UP2BTTask_LeaveCurrentSmartObject* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UP2BTTask_LeaveCurrentSmartObject>();
	}
};
static_assert(alignof(UP2BTTask_LeaveCurrentSmartObject) == 0x000008, "Wrong alignment on UP2BTTask_LeaveCurrentSmartObject");
static_assert(sizeof(UP2BTTask_LeaveCurrentSmartObject) == 0x000080, "Wrong size on UP2BTTask_LeaveCurrentSmartObject");

// Class AICommon.P2EnvQueryTest_StimuliStrength
// 0x0058 (0x0260 - 0x0208)
class UP2EnvQueryTest_StimuliStrength final : public UEnvQueryTest
{
public:
	struct FGameplayTagContainer                  StimulusTags;                                      // 0x0208(0x0020)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FAIDataProviderFloatValue              TimeWindow;                                        // 0x0228(0x0038)(Edit, DisableEditOnInstance, ContainsInstancedReference, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"P2EnvQueryTest_StimuliStrength">();
	}
	static class UP2EnvQueryTest_StimuliStrength* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UP2EnvQueryTest_StimuliStrength>();
	}
};
static_assert(alignof(UP2EnvQueryTest_StimuliStrength) == 0x000008, "Wrong alignment on UP2EnvQueryTest_StimuliStrength");
static_assert(sizeof(UP2EnvQueryTest_StimuliStrength) == 0x000260, "Wrong size on UP2EnvQueryTest_StimuliStrength");
static_assert(offsetof(UP2EnvQueryTest_StimuliStrength, StimulusTags) == 0x000208, "Member 'UP2EnvQueryTest_StimuliStrength::StimulusTags' has a wrong offset!");
static_assert(offsetof(UP2EnvQueryTest_StimuliStrength, TimeWindow) == 0x000228, "Member 'UP2EnvQueryTest_StimuliStrength::TimeWindow' has a wrong offset!");

// Class AICommon.P2BTTask_ModifyBlackboardValues
// 0x0010 (0x0080 - 0x0070)
class UP2BTTask_ModifyBlackboardValues final : public UBTTaskNode
{
public:
	TArray<class UP2BlackboardValueModifier*>     Modifiers;                                         // 0x0070(0x0010)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, ContainsInstancedReference, Protected, UObjectWrapper, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"P2BTTask_ModifyBlackboardValues">();
	}
	static class UP2BTTask_ModifyBlackboardValues* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UP2BTTask_ModifyBlackboardValues>();
	}
};
static_assert(alignof(UP2BTTask_ModifyBlackboardValues) == 0x000008, "Wrong alignment on UP2BTTask_ModifyBlackboardValues");
static_assert(sizeof(UP2BTTask_ModifyBlackboardValues) == 0x000080, "Wrong size on UP2BTTask_ModifyBlackboardValues");
static_assert(offsetof(UP2BTTask_ModifyBlackboardValues, Modifiers) == 0x000070, "Member 'UP2BTTask_ModifyBlackboardValues::Modifiers' has a wrong offset!");

// Class AICommon.P2BTTask_MoveToFlank
// 0x0160 (0x01D0 - 0x0070)
class UP2BTTask_MoveToFlank final : public UBTTaskNode
{
public:
	float                                         OuterRadius;                                       // 0x0070(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         InnerRadius;                                       // 0x0074(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Speed;                                             // 0x0078(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         EndDistance;                                       // 0x007C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         UpdateInterval;                                    // 0x0080(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_84[0x4];                                       // 0x0084(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FBlackboardKeySelector                 TargetKey;                                         // 0x0088(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	uint8                                         Pad_B0[0xA0];                                      // 0x00B0(0x00A0)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         NumWaitingPaths;                                   // 0x0150(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_154[0x4];                                      // 0x0154(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UMercunaPath*                           Paths[0x5];                                        // 0x0158(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UMercunaPath*                           PendingPaths[0x5];                                 // 0x0180(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_1A8[0x8];                                      // 0x01A8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UMercunaGroundTask_MoveTo*              MoveTask;                                          // 0x01B0(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UBehaviorTreeComponent*                 OwnerCache;                                        // 0x01B8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         TimeToUpdate;                                      // 0x01C0(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         TooCloseRange;                                     // 0x01C4(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FAIRequestID                           MoveRequestId;                                     // 0x01C8(0x0004)(NoDestructor, NativeAccessSpecifierPrivate)
	uint8                                         Pad_1CC[0x4];                                      // 0x01CC(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnMoveCompleted(const struct FAIRequestID& RequestID, const EMercunaMoveResult Result)	 // 0x4749de4;
	void OnPathUpdated(EMercunaPathEvent PathEvent)	 // 0x4749f24;

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"P2BTTask_MoveToFlank">();
	}
	static class UP2BTTask_MoveToFlank* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UP2BTTask_MoveToFlank>();
	}
};
static_assert(alignof(UP2BTTask_MoveToFlank) == 0x000008, "Wrong alignment on UP2BTTask_MoveToFlank");
static_assert(sizeof(UP2BTTask_MoveToFlank) == 0x0001D0, "Wrong size on UP2BTTask_MoveToFlank");
static_assert(offsetof(UP2BTTask_MoveToFlank, OuterRadius) == 0x000070, "Member 'UP2BTTask_MoveToFlank::OuterRadius' has a wrong offset!");
static_assert(offsetof(UP2BTTask_MoveToFlank, InnerRadius) == 0x000074, "Member 'UP2BTTask_MoveToFlank::InnerRadius' has a wrong offset!");
static_assert(offsetof(UP2BTTask_MoveToFlank, Speed) == 0x000078, "Member 'UP2BTTask_MoveToFlank::Speed' has a wrong offset!");
static_assert(offsetof(UP2BTTask_MoveToFlank, EndDistance) == 0x00007C, "Member 'UP2BTTask_MoveToFlank::EndDistance' has a wrong offset!");
static_assert(offsetof(UP2BTTask_MoveToFlank, UpdateInterval) == 0x000080, "Member 'UP2BTTask_MoveToFlank::UpdateInterval' has a wrong offset!");
static_assert(offsetof(UP2BTTask_MoveToFlank, TargetKey) == 0x000088, "Member 'UP2BTTask_MoveToFlank::TargetKey' has a wrong offset!");
static_assert(offsetof(UP2BTTask_MoveToFlank, NumWaitingPaths) == 0x000150, "Member 'UP2BTTask_MoveToFlank::NumWaitingPaths' has a wrong offset!");
static_assert(offsetof(UP2BTTask_MoveToFlank, Paths) == 0x000158, "Member 'UP2BTTask_MoveToFlank::Paths' has a wrong offset!");
static_assert(offsetof(UP2BTTask_MoveToFlank, PendingPaths) == 0x000180, "Member 'UP2BTTask_MoveToFlank::PendingPaths' has a wrong offset!");
static_assert(offsetof(UP2BTTask_MoveToFlank, MoveTask) == 0x0001B0, "Member 'UP2BTTask_MoveToFlank::MoveTask' has a wrong offset!");
static_assert(offsetof(UP2BTTask_MoveToFlank, OwnerCache) == 0x0001B8, "Member 'UP2BTTask_MoveToFlank::OwnerCache' has a wrong offset!");
static_assert(offsetof(UP2BTTask_MoveToFlank, TimeToUpdate) == 0x0001C0, "Member 'UP2BTTask_MoveToFlank::TimeToUpdate' has a wrong offset!");
static_assert(offsetof(UP2BTTask_MoveToFlank, TooCloseRange) == 0x0001C4, "Member 'UP2BTTask_MoveToFlank::TooCloseRange' has a wrong offset!");
static_assert(offsetof(UP2BTTask_MoveToFlank, MoveRequestId) == 0x0001C8, "Member 'UP2BTTask_MoveToFlank::MoveRequestId' has a wrong offset!");

// Class AICommon.P2BTTask_MoveToRotationInPlace
// 0x0008 (0x00B0 - 0x00A8)
class UP2BTTask_MoveToRotationInPlace final : public UBTTask_MercunaGround_MoveTo
{
public:
	float                                         MaxAngleToContinueMove;                            // 0x00A8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_AC[0x4];                                       // 0x00AC(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnRotationAbilityEnded(const struct FAbilityEndedData& AbilityEndedData)	 // 0x4749ff8;

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"P2BTTask_MoveToRotationInPlace">();
	}
	static class UP2BTTask_MoveToRotationInPlace* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UP2BTTask_MoveToRotationInPlace>();
	}
};
static_assert(alignof(UP2BTTask_MoveToRotationInPlace) == 0x000008, "Wrong alignment on UP2BTTask_MoveToRotationInPlace");
static_assert(sizeof(UP2BTTask_MoveToRotationInPlace) == 0x0000B0, "Wrong size on UP2BTTask_MoveToRotationInPlace");
static_assert(offsetof(UP2BTTask_MoveToRotationInPlace, MaxAngleToContinueMove) == 0x0000A8, "Member 'UP2BTTask_MoveToRotationInPlace::MaxAngleToContinueMove' has a wrong offset!");

// Class AICommon.P2NpcGroupAIController
// 0x0150 (0x0528 - 0x03D8)
class AP2NpcGroupAIController : public AAIController
{
public:
	float                                         RotationInterpSpeed;                               // 0x03D8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bRotateGroupToLeaderWhenStopped;                   // 0x03DC(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDestroyOnEmpty;                                   // 0x03DD(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3DE[0x2];                                      // 0x03DE(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MinTargetInterestLevel;                            // 0x03E0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BoundsIncreasePerMember;                           // 0x03E4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BoundsExtentZ;                                     // 0x03E8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDisableCollisionBetweenMembers;                   // 0x03EC(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3ED[0xE3];                                     // 0x03ED(0x00E3)(Fixing Size After Last Property [ Dumper-7 ])
	class UP2NpcGroupData*                        GroupData;                                         // 0x04D0(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_4D8[0x50];                                     // 0x04D8(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnMemberDeath(class UP2HealthComponent* InHealthComponent)	 // 0x476702c;
	void OnMemberDestroyed(class AActor* InDestroyedActor)	 // 0x47670f0;
	void OnMemberEndPlay(class AActor* InActor, EEndPlayReason InEndPlayReason)	 // 0x47671b4;
	void OnMemberReceivedDamage(class UP2HealthComponent* InHealthComponent, class AActor* InInstigator, float InDamage)	 // 0x47672f8;
	void OnTargetPerceptionUpdated(class AActor* InActor, const struct FAIStimulus& InStimulus)	 // 0x47674b8;

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"P2NpcGroupAIController">();
	}
	static class AP2NpcGroupAIController* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<AP2NpcGroupAIController>();
	}
};
static_assert(alignof(AP2NpcGroupAIController) == 0x000008, "Wrong alignment on AP2NpcGroupAIController");
static_assert(sizeof(AP2NpcGroupAIController) == 0x000528, "Wrong size on AP2NpcGroupAIController");
static_assert(offsetof(AP2NpcGroupAIController, RotationInterpSpeed) == 0x0003D8, "Member 'AP2NpcGroupAIController::RotationInterpSpeed' has a wrong offset!");
static_assert(offsetof(AP2NpcGroupAIController, bRotateGroupToLeaderWhenStopped) == 0x0003DC, "Member 'AP2NpcGroupAIController::bRotateGroupToLeaderWhenStopped' has a wrong offset!");
static_assert(offsetof(AP2NpcGroupAIController, bDestroyOnEmpty) == 0x0003DD, "Member 'AP2NpcGroupAIController::bDestroyOnEmpty' has a wrong offset!");
static_assert(offsetof(AP2NpcGroupAIController, MinTargetInterestLevel) == 0x0003E0, "Member 'AP2NpcGroupAIController::MinTargetInterestLevel' has a wrong offset!");
static_assert(offsetof(AP2NpcGroupAIController, BoundsIncreasePerMember) == 0x0003E4, "Member 'AP2NpcGroupAIController::BoundsIncreasePerMember' has a wrong offset!");
static_assert(offsetof(AP2NpcGroupAIController, BoundsExtentZ) == 0x0003E8, "Member 'AP2NpcGroupAIController::BoundsExtentZ' has a wrong offset!");
static_assert(offsetof(AP2NpcGroupAIController, bDisableCollisionBetweenMembers) == 0x0003EC, "Member 'AP2NpcGroupAIController::bDisableCollisionBetweenMembers' has a wrong offset!");
static_assert(offsetof(AP2NpcGroupAIController, GroupData) == 0x0004D0, "Member 'AP2NpcGroupAIController::GroupData' has a wrong offset!");

// Class AICommon.P2GhostGroupAIController
// 0x0070 (0x0598 - 0x0528)
class AP2GhostGroupAIController : public AP2NpcGroupAIController
{
public:
	TMulticastInlineDelegate<void(class AP2NpcGroupAIController* InGroup, EP2GroupFormation InNewFormation, EP2GroupFormation InPrevFormation)> OnFormationChangedDelegate; // 0x0528(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(class AP2NpcGroupAIController* InGroup, EP2GroupRoe InNewRoe, EP2GroupRoe InPrevRoe)> OnRoeChangedDelegate; // 0x0538(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	struct FVector2D                              FormationDistance;                                 // 0x0548(0x0010)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_558[0x40];                                     // 0x0558(0x0040)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"P2GhostGroupAIController">();
	}
	static class AP2GhostGroupAIController* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<AP2GhostGroupAIController>();
	}
};
static_assert(alignof(AP2GhostGroupAIController) == 0x000008, "Wrong alignment on AP2GhostGroupAIController");
static_assert(sizeof(AP2GhostGroupAIController) == 0x000598, "Wrong size on AP2GhostGroupAIController");
static_assert(offsetof(AP2GhostGroupAIController, OnFormationChangedDelegate) == 0x000528, "Member 'AP2GhostGroupAIController::OnFormationChangedDelegate' has a wrong offset!");
static_assert(offsetof(AP2GhostGroupAIController, OnRoeChangedDelegate) == 0x000538, "Member 'AP2GhostGroupAIController::OnRoeChangedDelegate' has a wrong offset!");
static_assert(offsetof(AP2GhostGroupAIController, FormationDistance) == 0x000548, "Member 'AP2GhostGroupAIController::FormationDistance' has a wrong offset!");

// Class AICommon.P2BTTask_PlayEmote
// 0x0058 (0x00F0 - 0x0098)
class UP2BTTask_PlayEmote final : public UP2BTTask_ActivateAbilityBase
{
public:
	bool                                          bSucceedOnInterrupted;                             // 0x0098(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bFromBlackBoard;                                   // 0x0099(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9A[0x6];                                       // 0x009A(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	struct FBlackboardKeySelector                 EmotesBlackboardKey;                               // 0x00A0(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	class UAnimMontage*                           EmoteMontage;                                      // 0x00C8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bRandomStartSection;                               // 0x00D0(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D1[0x3];                                       // 0x00D1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   EmoteStartSection;                                 // 0x00D4(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsInterruptible;                                  // 0x00DC(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_DD[0x3];                                       // 0x00DD(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FP2EmoteTaskRootMotionData>     RootMotionWarpingTargets;                          // 0x00E0(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"P2BTTask_PlayEmote">();
	}
	static class UP2BTTask_PlayEmote* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UP2BTTask_PlayEmote>();
	}
};
static_assert(alignof(UP2BTTask_PlayEmote) == 0x000008, "Wrong alignment on UP2BTTask_PlayEmote");
static_assert(sizeof(UP2BTTask_PlayEmote) == 0x0000F0, "Wrong size on UP2BTTask_PlayEmote");
static_assert(offsetof(UP2BTTask_PlayEmote, bSucceedOnInterrupted) == 0x000098, "Member 'UP2BTTask_PlayEmote::bSucceedOnInterrupted' has a wrong offset!");
static_assert(offsetof(UP2BTTask_PlayEmote, bFromBlackBoard) == 0x000099, "Member 'UP2BTTask_PlayEmote::bFromBlackBoard' has a wrong offset!");
static_assert(offsetof(UP2BTTask_PlayEmote, EmotesBlackboardKey) == 0x0000A0, "Member 'UP2BTTask_PlayEmote::EmotesBlackboardKey' has a wrong offset!");
static_assert(offsetof(UP2BTTask_PlayEmote, EmoteMontage) == 0x0000C8, "Member 'UP2BTTask_PlayEmote::EmoteMontage' has a wrong offset!");
static_assert(offsetof(UP2BTTask_PlayEmote, bRandomStartSection) == 0x0000D0, "Member 'UP2BTTask_PlayEmote::bRandomStartSection' has a wrong offset!");
static_assert(offsetof(UP2BTTask_PlayEmote, EmoteStartSection) == 0x0000D4, "Member 'UP2BTTask_PlayEmote::EmoteStartSection' has a wrong offset!");
static_assert(offsetof(UP2BTTask_PlayEmote, bIsInterruptible) == 0x0000DC, "Member 'UP2BTTask_PlayEmote::bIsInterruptible' has a wrong offset!");
static_assert(offsetof(UP2BTTask_PlayEmote, RootMotionWarpingTargets) == 0x0000E0, "Member 'UP2BTTask_PlayEmote::RootMotionWarpingTargets' has a wrong offset!");

// Class AICommon.P2BTTask_PlayerBot_GetWayPointLocation
// 0x0078 (0x00E8 - 0x0070)
class UP2BTTask_PlayerBot_GetWayPointLocation final : public UBTTaskNode
{
public:
	struct FBlackboardKeySelector                 NextWayPointLocationKey;                           // 0x0070(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FBlackboardKeySelector                 CurrentWayPointLocationIndexKey;                   // 0x0098(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FBlackboardKeySelector                 MaxWayPointLocationIndexKey;                       // 0x00C0(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"P2BTTask_PlayerBot_GetWayPointLocation">();
	}
	static class UP2BTTask_PlayerBot_GetWayPointLocation* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UP2BTTask_PlayerBot_GetWayPointLocation>();
	}
};
static_assert(alignof(UP2BTTask_PlayerBot_GetWayPointLocation) == 0x000008, "Wrong alignment on UP2BTTask_PlayerBot_GetWayPointLocation");
static_assert(sizeof(UP2BTTask_PlayerBot_GetWayPointLocation) == 0x0000E8, "Wrong size on UP2BTTask_PlayerBot_GetWayPointLocation");
static_assert(offsetof(UP2BTTask_PlayerBot_GetWayPointLocation, NextWayPointLocationKey) == 0x000070, "Member 'UP2BTTask_PlayerBot_GetWayPointLocation::NextWayPointLocationKey' has a wrong offset!");
static_assert(offsetof(UP2BTTask_PlayerBot_GetWayPointLocation, CurrentWayPointLocationIndexKey) == 0x000098, "Member 'UP2BTTask_PlayerBot_GetWayPointLocation::CurrentWayPointLocationIndexKey' has a wrong offset!");
static_assert(offsetof(UP2BTTask_PlayerBot_GetWayPointLocation, MaxWayPointLocationIndexKey) == 0x0000C0, "Member 'UP2BTTask_PlayerBot_GetWayPointLocation::MaxWayPointLocationIndexKey' has a wrong offset!");

// Class AICommon.P2BTTask_PollMeleeSlotLocation
// 0x0060 (0x00D0 - 0x0070)
class UP2BTTask_PollMeleeSlotLocation final : public UBTTaskNode
{
public:
	struct FBlackboardKeySelector                 SlotKey;                                           // 0x0070(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	double                                        Distance;                                          // 0x0098(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	double                                        Variance;                                          // 0x00A0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FBlackboardKeySelector                 ResultKey;                                         // 0x00A8(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"P2BTTask_PollMeleeSlotLocation">();
	}
	static class UP2BTTask_PollMeleeSlotLocation* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UP2BTTask_PollMeleeSlotLocation>();
	}
};
static_assert(alignof(UP2BTTask_PollMeleeSlotLocation) == 0x000008, "Wrong alignment on UP2BTTask_PollMeleeSlotLocation");
static_assert(sizeof(UP2BTTask_PollMeleeSlotLocation) == 0x0000D0, "Wrong size on UP2BTTask_PollMeleeSlotLocation");
static_assert(offsetof(UP2BTTask_PollMeleeSlotLocation, SlotKey) == 0x000070, "Member 'UP2BTTask_PollMeleeSlotLocation::SlotKey' has a wrong offset!");
static_assert(offsetof(UP2BTTask_PollMeleeSlotLocation, Distance) == 0x000098, "Member 'UP2BTTask_PollMeleeSlotLocation::Distance' has a wrong offset!");
static_assert(offsetof(UP2BTTask_PollMeleeSlotLocation, Variance) == 0x0000A0, "Member 'UP2BTTask_PollMeleeSlotLocation::Variance' has a wrong offset!");
static_assert(offsetof(UP2BTTask_PollMeleeSlotLocation, ResultKey) == 0x0000A8, "Member 'UP2BTTask_PollMeleeSlotLocation::ResultKey' has a wrong offset!");

// Class AICommon.P2NpcAbility_MontageBasedAttack
// 0x0028 (0x04C0 - 0x0498)
class UP2NpcAbility_MontageBasedAttack : public UP2NpcAbility_Attack
{
public:
	class UAnimMontage*                           Montage;                                           // 0x0498(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AnimRate;                                          // 0x04A0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           GameplayEventTag;                                  // 0x04A4(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUseP2MontageTask;                                 // 0x04AC(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4AD[0x3];                                      // 0x04AD(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class UAbilityTask*                           MontageTask;                                       // 0x04B0(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAbilityTask_WaitGameplayEvent*         WaitEventTask;                                     // 0x04B8(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	class FName GetStartSectionForTarget(const struct FGameplayAbilityTargetDataHandle& TargetData)	 // 0x4760d3c;
	void HandleEvent(const struct FGameplayEventData& Payload)	 // 0x4760f00;
	void OnAnimationCanceled()	 // 0x476120c;
	void OnAnimationEnded()	 // 0x476124c;
	void OnInitialize(const struct FGameplayAbilityTargetDataHandle& TargetData)	 // 0x476141c;
	class UAnimMontage* ProvideMontage(const struct FGameplayEventData& TriggerEventData)	 // 0x4761570;
	void RelinkSection()	 // 0x476163c;

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"P2NpcAbility_MontageBasedAttack">();
	}
	static class UP2NpcAbility_MontageBasedAttack* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UP2NpcAbility_MontageBasedAttack>();
	}
};
static_assert(alignof(UP2NpcAbility_MontageBasedAttack) == 0x000008, "Wrong alignment on UP2NpcAbility_MontageBasedAttack");
static_assert(sizeof(UP2NpcAbility_MontageBasedAttack) == 0x0004C0, "Wrong size on UP2NpcAbility_MontageBasedAttack");
static_assert(offsetof(UP2NpcAbility_MontageBasedAttack, Montage) == 0x000498, "Member 'UP2NpcAbility_MontageBasedAttack::Montage' has a wrong offset!");
static_assert(offsetof(UP2NpcAbility_MontageBasedAttack, AnimRate) == 0x0004A0, "Member 'UP2NpcAbility_MontageBasedAttack::AnimRate' has a wrong offset!");
static_assert(offsetof(UP2NpcAbility_MontageBasedAttack, GameplayEventTag) == 0x0004A4, "Member 'UP2NpcAbility_MontageBasedAttack::GameplayEventTag' has a wrong offset!");
static_assert(offsetof(UP2NpcAbility_MontageBasedAttack, bUseP2MontageTask) == 0x0004AC, "Member 'UP2NpcAbility_MontageBasedAttack::bUseP2MontageTask' has a wrong offset!");
static_assert(offsetof(UP2NpcAbility_MontageBasedAttack, MontageTask) == 0x0004B0, "Member 'UP2NpcAbility_MontageBasedAttack::MontageTask' has a wrong offset!");
static_assert(offsetof(UP2NpcAbility_MontageBasedAttack, WaitEventTask) == 0x0004B8, "Member 'UP2NpcAbility_MontageBasedAttack::WaitEventTask' has a wrong offset!");

// Class AICommon.P2NpcAbility_BaseSpawningAttack
// 0x0070 (0x0530 - 0x04C0)
class UP2NpcAbility_BaseSpawningAttack : public UP2NpcAbility_MontageBasedAttack
{
public:
	TSubclassOf<class AActor>                     SpawnActorClass;                                   // 0x04C0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MinDistance;                                       // 0x04C8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MaxDistance;                                       // 0x04CC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MaxHeadingErrorHalfAngleDegrees;                   // 0x04D0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         SpawnDelay;                                        // 0x04D4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bUseLeading;                                       // 0x04D8(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_4D9[0x7];                                      // 0x04D9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                AimOffset;                                         // 0x04E0(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FGameplayTag                           StartSpawnCueTag;                                  // 0x04F8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_500[0x28];                                     // 0x0500(0x0028)(Fixing Size After Last Property [ Dumper-7 ])
	class UP2AbilityTask_AttackAim*               AimTask;                                           // 0x0528(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void OnAbilityFinished()	 // 0x475ce74;

	void OnSpawned(class AActor* SpawnedActor) const	 // 0xae1e64;
	class AActor* Spawn() const	 // 0x475d2fc;

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"P2NpcAbility_BaseSpawningAttack">();
	}
	static class UP2NpcAbility_BaseSpawningAttack* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UP2NpcAbility_BaseSpawningAttack>();
	}
};
static_assert(alignof(UP2NpcAbility_BaseSpawningAttack) == 0x000008, "Wrong alignment on UP2NpcAbility_BaseSpawningAttack");
static_assert(sizeof(UP2NpcAbility_BaseSpawningAttack) == 0x000530, "Wrong size on UP2NpcAbility_BaseSpawningAttack");
static_assert(offsetof(UP2NpcAbility_BaseSpawningAttack, SpawnActorClass) == 0x0004C0, "Member 'UP2NpcAbility_BaseSpawningAttack::SpawnActorClass' has a wrong offset!");
static_assert(offsetof(UP2NpcAbility_BaseSpawningAttack, MinDistance) == 0x0004C8, "Member 'UP2NpcAbility_BaseSpawningAttack::MinDistance' has a wrong offset!");
static_assert(offsetof(UP2NpcAbility_BaseSpawningAttack, MaxDistance) == 0x0004CC, "Member 'UP2NpcAbility_BaseSpawningAttack::MaxDistance' has a wrong offset!");
static_assert(offsetof(UP2NpcAbility_BaseSpawningAttack, MaxHeadingErrorHalfAngleDegrees) == 0x0004D0, "Member 'UP2NpcAbility_BaseSpawningAttack::MaxHeadingErrorHalfAngleDegrees' has a wrong offset!");
static_assert(offsetof(UP2NpcAbility_BaseSpawningAttack, SpawnDelay) == 0x0004D4, "Member 'UP2NpcAbility_BaseSpawningAttack::SpawnDelay' has a wrong offset!");
static_assert(offsetof(UP2NpcAbility_BaseSpawningAttack, bUseLeading) == 0x0004D8, "Member 'UP2NpcAbility_BaseSpawningAttack::bUseLeading' has a wrong offset!");
static_assert(offsetof(UP2NpcAbility_BaseSpawningAttack, AimOffset) == 0x0004E0, "Member 'UP2NpcAbility_BaseSpawningAttack::AimOffset' has a wrong offset!");
static_assert(offsetof(UP2NpcAbility_BaseSpawningAttack, StartSpawnCueTag) == 0x0004F8, "Member 'UP2NpcAbility_BaseSpawningAttack::StartSpawnCueTag' has a wrong offset!");
static_assert(offsetof(UP2NpcAbility_BaseSpawningAttack, AimTask) == 0x000528, "Member 'UP2NpcAbility_BaseSpawningAttack::AimTask' has a wrong offset!");

// Class AICommon.P2BTTask_PollSmartObjectEnterLocation
// 0x0050 (0x00C0 - 0x0070)
class UP2BTTask_PollSmartObjectEnterLocation final : public UBTTaskNode
{
public:
	struct FBlackboardKeySelector                 ResultKey;                                         // 0x0070(0x0028)(Edit, NativeAccessSpecifierPublic)
	struct FBlackboardKeySelector                 SmartObjectKey;                                    // 0x0098(0x0028)(Edit, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"P2BTTask_PollSmartObjectEnterLocation">();
	}
	static class UP2BTTask_PollSmartObjectEnterLocation* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UP2BTTask_PollSmartObjectEnterLocation>();
	}
};
static_assert(alignof(UP2BTTask_PollSmartObjectEnterLocation) == 0x000008, "Wrong alignment on UP2BTTask_PollSmartObjectEnterLocation");
static_assert(sizeof(UP2BTTask_PollSmartObjectEnterLocation) == 0x0000C0, "Wrong size on UP2BTTask_PollSmartObjectEnterLocation");
static_assert(offsetof(UP2BTTask_PollSmartObjectEnterLocation, ResultKey) == 0x000070, "Member 'UP2BTTask_PollSmartObjectEnterLocation::ResultKey' has a wrong offset!");
static_assert(offsetof(UP2BTTask_PollSmartObjectEnterLocation, SmartObjectKey) == 0x000098, "Member 'UP2BTTask_PollSmartObjectEnterLocation::SmartObjectKey' has a wrong offset!");

// Class AICommon.P2NpcFlyingCharacter
// 0x0040 (0x0B70 - 0x0B30)
class AP2NpcFlyingCharacter : public AP2NPCharacter
{
public:
	bool                                          bIsFlying;                                         // 0x0B30(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, EditConst, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_B31[0x7];                                      // 0x0B31(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TMulticastInlineDelegate<void()>              OnStartFlying;                                     // 0x0B38(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, Protected, NativeAccessSpecifierProtected)
	TMulticastInlineDelegate<void()>              OnStopFlying;                                      // 0x0B48(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, Protected, NativeAccessSpecifierProtected)
	class UMercuna3DMovementComponent*            Mer3DMovementComponent;                            // 0x0B58(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UP2Mercuna3DNavigationComponent*        Mer3DNavigationComponent;                          // 0x0B60(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_B68[0x8];                                      // 0x0B68(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnRep_IsFlying() const	 // 0x17a1abc;

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"P2NpcFlyingCharacter">();
	}
	static class AP2NpcFlyingCharacter* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<AP2NpcFlyingCharacter>();
	}
};
static_assert(alignof(AP2NpcFlyingCharacter) == 0x000010, "Wrong alignment on AP2NpcFlyingCharacter");
static_assert(sizeof(AP2NpcFlyingCharacter) == 0x000B70, "Wrong size on AP2NpcFlyingCharacter");
static_assert(offsetof(AP2NpcFlyingCharacter, bIsFlying) == 0x000B30, "Member 'AP2NpcFlyingCharacter::bIsFlying' has a wrong offset!");
static_assert(offsetof(AP2NpcFlyingCharacter, OnStartFlying) == 0x000B38, "Member 'AP2NpcFlyingCharacter::OnStartFlying' has a wrong offset!");
static_assert(offsetof(AP2NpcFlyingCharacter, OnStopFlying) == 0x000B48, "Member 'AP2NpcFlyingCharacter::OnStopFlying' has a wrong offset!");
static_assert(offsetof(AP2NpcFlyingCharacter, Mer3DMovementComponent) == 0x000B58, "Member 'AP2NpcFlyingCharacter::Mer3DMovementComponent' has a wrong offset!");
static_assert(offsetof(AP2NpcFlyingCharacter, Mer3DNavigationComponent) == 0x000B60, "Member 'AP2NpcFlyingCharacter::Mer3DNavigationComponent' has a wrong offset!");

// Class AICommon.P2BTTask_RotateToTarget
// 0x0030 (0x00A0 - 0x0070)
class UP2BTTask_RotateToTarget final : public UBTTaskNode
{
public:
	struct FBlackboardKeySelector                 Target;                                            // 0x0070(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	float                                         PrecisionDeg;                                      // 0x0098(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9C[0x4];                                       // 0x009C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"P2BTTask_RotateToTarget">();
	}
	static class UP2BTTask_RotateToTarget* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UP2BTTask_RotateToTarget>();
	}
};
static_assert(alignof(UP2BTTask_RotateToTarget) == 0x000008, "Wrong alignment on UP2BTTask_RotateToTarget");
static_assert(sizeof(UP2BTTask_RotateToTarget) == 0x0000A0, "Wrong size on UP2BTTask_RotateToTarget");
static_assert(offsetof(UP2BTTask_RotateToTarget, Target) == 0x000070, "Member 'UP2BTTask_RotateToTarget::Target' has a wrong offset!");
static_assert(offsetof(UP2BTTask_RotateToTarget, PrecisionDeg) == 0x000098, "Member 'UP2BTTask_RotateToTarget::PrecisionDeg' has a wrong offset!");

// Class AICommon.P2BTTask_SendGameplayEvent
// 0x0038 (0x00A8 - 0x0070)
class UP2BTTask_SendGameplayEvent final : public UBTTaskNode
{
public:
	bool                                          bSendEventToTarget;                                // 0x0070(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_71[0x7];                                       // 0x0071(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FBlackboardKeySelector                 Target;                                            // 0x0078(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FGameplayTag                           EventTag;                                          // 0x00A0(0x0008)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"P2BTTask_SendGameplayEvent">();
	}
	static class UP2BTTask_SendGameplayEvent* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UP2BTTask_SendGameplayEvent>();
	}
};
static_assert(alignof(UP2BTTask_SendGameplayEvent) == 0x000008, "Wrong alignment on UP2BTTask_SendGameplayEvent");
static_assert(sizeof(UP2BTTask_SendGameplayEvent) == 0x0000A8, "Wrong size on UP2BTTask_SendGameplayEvent");
static_assert(offsetof(UP2BTTask_SendGameplayEvent, bSendEventToTarget) == 0x000070, "Member 'UP2BTTask_SendGameplayEvent::bSendEventToTarget' has a wrong offset!");
static_assert(offsetof(UP2BTTask_SendGameplayEvent, Target) == 0x000078, "Member 'UP2BTTask_SendGameplayEvent::Target' has a wrong offset!");
static_assert(offsetof(UP2BTTask_SendGameplayEvent, EventTag) == 0x0000A0, "Member 'UP2BTTask_SendGameplayEvent::EventTag' has a wrong offset!");

// Class AICommon.P2BTTask_SendStateTreeEvent
// 0x0008 (0x0078 - 0x0070)
class UP2BTTask_SendStateTreeEvent final : public UBTTaskNode
{
public:
	struct FGameplayTag                           EventTag;                                          // 0x0070(0x0008)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"P2BTTask_SendStateTreeEvent">();
	}
	static class UP2BTTask_SendStateTreeEvent* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UP2BTTask_SendStateTreeEvent>();
	}
};
static_assert(alignof(UP2BTTask_SendStateTreeEvent) == 0x000008, "Wrong alignment on UP2BTTask_SendStateTreeEvent");
static_assert(sizeof(UP2BTTask_SendStateTreeEvent) == 0x000078, "Wrong size on UP2BTTask_SendStateTreeEvent");
static_assert(offsetof(UP2BTTask_SendStateTreeEvent, EventTag) == 0x000070, "Member 'UP2BTTask_SendStateTreeEvent::EventTag' has a wrong offset!");

// Class AICommon.P2NpcAbility_Stagger
// 0x0010 (0x04A8 - 0x0498)
class UP2NpcAbility_Stagger : public UP2NpcAbility
{
public:
	uint8                                         Pad_498[0x10];                                     // 0x0498(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnAnimationEnded()	 // 0x47650ac;
	void OnAnimationInterrupted()	 // 0x47650d8;

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"P2NpcAbility_Stagger">();
	}
	static class UP2NpcAbility_Stagger* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UP2NpcAbility_Stagger>();
	}
};
static_assert(alignof(UP2NpcAbility_Stagger) == 0x000008, "Wrong alignment on UP2NpcAbility_Stagger");
static_assert(sizeof(UP2NpcAbility_Stagger) == 0x0004A8, "Wrong size on UP2NpcAbility_Stagger");

// Class AICommon.P2NpcAbility_BomBugStagger
// 0x0010 (0x04B8 - 0x04A8)
class UP2NpcAbility_BomBugStagger final : public UP2NpcAbility_Stagger
{
public:
	class UEnvQuery*                              LandingLocQuery;                                   // 0x04A8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_4B0[0x8];                                      // 0x04B0(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"P2NpcAbility_BomBugStagger">();
	}
	static class UP2NpcAbility_BomBugStagger* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UP2NpcAbility_BomBugStagger>();
	}
};
static_assert(alignof(UP2NpcAbility_BomBugStagger) == 0x000008, "Wrong alignment on UP2NpcAbility_BomBugStagger");
static_assert(sizeof(UP2NpcAbility_BomBugStagger) == 0x0004B8, "Wrong size on UP2NpcAbility_BomBugStagger");
static_assert(offsetof(UP2NpcAbility_BomBugStagger, LandingLocQuery) == 0x0004A8, "Member 'UP2NpcAbility_BomBugStagger::LandingLocQuery' has a wrong offset!");

// Class AICommon.P2BTTask_Shortcut
// 0x0038 (0x00D0 - 0x0098)
class UP2BTTask_Shortcut final : public UP2BTTask_ActivateAbilityBase
{
public:
	bool                                          bSucceedOnInterrupted;                             // 0x0098(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_99[0x7];                                       // 0x0099(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UP2ShortcutDataAsset*                   ShortcutDataAsset;                                 // 0x00A0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FBlackboardKeySelector                 ShortcutEndKey;                                    // 0x00A8(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"P2BTTask_Shortcut">();
	}
	static class UP2BTTask_Shortcut* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UP2BTTask_Shortcut>();
	}
};
static_assert(alignof(UP2BTTask_Shortcut) == 0x000008, "Wrong alignment on UP2BTTask_Shortcut");
static_assert(sizeof(UP2BTTask_Shortcut) == 0x0000D0, "Wrong size on UP2BTTask_Shortcut");
static_assert(offsetof(UP2BTTask_Shortcut, bSucceedOnInterrupted) == 0x000098, "Member 'UP2BTTask_Shortcut::bSucceedOnInterrupted' has a wrong offset!");
static_assert(offsetof(UP2BTTask_Shortcut, ShortcutDataAsset) == 0x0000A0, "Member 'UP2BTTask_Shortcut::ShortcutDataAsset' has a wrong offset!");
static_assert(offsetof(UP2BTTask_Shortcut, ShortcutEndKey) == 0x0000A8, "Member 'UP2BTTask_Shortcut::ShortcutEndKey' has a wrong offset!");

// Class AICommon.P2BTTask_UpdateLure
// 0x0030 (0x00A0 - 0x0070)
class UP2BTTask_UpdateLure final : public UBTTaskNode
{
public:
	TSubclassOf<class UGameplayEffect>            LureGE_Definition;                                 // 0x0070(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FBlackboardKeySelector                 LureLocationKey;                                   // 0x0078(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"P2BTTask_UpdateLure">();
	}
	static class UP2BTTask_UpdateLure* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UP2BTTask_UpdateLure>();
	}
};
static_assert(alignof(UP2BTTask_UpdateLure) == 0x000008, "Wrong alignment on UP2BTTask_UpdateLure");
static_assert(sizeof(UP2BTTask_UpdateLure) == 0x0000A0, "Wrong size on UP2BTTask_UpdateLure");
static_assert(offsetof(UP2BTTask_UpdateLure, LureGE_Definition) == 0x000070, "Member 'UP2BTTask_UpdateLure::LureGE_Definition' has a wrong offset!");
static_assert(offsetof(UP2BTTask_UpdateLure, LureLocationKey) == 0x000078, "Member 'UP2BTTask_UpdateLure::LureLocationKey' has a wrong offset!");

// Class AICommon.P2BTTask_UseSmartObject
// 0x0038 (0x00A8 - 0x0070)
class UP2BTTask_UseSmartObject final : public UBTTaskNode
{
public:
	struct FBlackboardKeySelector                 SmartObjectKey;                                    // 0x0070(0x0028)(Edit, NativeAccessSpecifierPrivate)
	bool                                          bIsBlocking;                                       // 0x0098(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_99[0xF];                                       // 0x0099(0x000F)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"P2BTTask_UseSmartObject">();
	}
	static class UP2BTTask_UseSmartObject* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UP2BTTask_UseSmartObject>();
	}
};
static_assert(alignof(UP2BTTask_UseSmartObject) == 0x000008, "Wrong alignment on UP2BTTask_UseSmartObject");
static_assert(sizeof(UP2BTTask_UseSmartObject) == 0x0000A8, "Wrong size on UP2BTTask_UseSmartObject");
static_assert(offsetof(UP2BTTask_UseSmartObject, SmartObjectKey) == 0x000070, "Member 'UP2BTTask_UseSmartObject::SmartObjectKey' has a wrong offset!");
static_assert(offsetof(UP2BTTask_UseSmartObject, bIsBlocking) == 0x000098, "Member 'UP2BTTask_UseSmartObject::bIsBlocking' has a wrong offset!");

// Class AICommon.P2BTTask_WaitAbilityEnded
// 0x0028 (0x0098 - 0x0070)
class UP2BTTask_WaitAbilityEnded final : public UBTTaskNode
{
public:
	TSubclassOf<class UP2Ability>                 AbilityClass;                                      // 0x0070(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_78[0x20];                                      // 0x0078(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnAbilityEnded(const struct FAbilityEndedData& AbilityEndedData)	 // 0x474551c;

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"P2BTTask_WaitAbilityEnded">();
	}
	static class UP2BTTask_WaitAbilityEnded* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UP2BTTask_WaitAbilityEnded>();
	}
};
static_assert(alignof(UP2BTTask_WaitAbilityEnded) == 0x000008, "Wrong alignment on UP2BTTask_WaitAbilityEnded");
static_assert(sizeof(UP2BTTask_WaitAbilityEnded) == 0x000098, "Wrong size on UP2BTTask_WaitAbilityEnded");
static_assert(offsetof(UP2BTTask_WaitAbilityEnded, AbilityClass) == 0x000070, "Member 'UP2BTTask_WaitAbilityEnded::AbilityClass' has a wrong offset!");

// Class AICommon.P2NpcAbility_BruteLungsDamageReaction
// 0x0010 (0x04A8 - 0x0498)
class UP2NpcAbility_BruteLungsDamageReaction final : public UP2NpcAbility
{
public:
	class UAnimMontage*                           ReactionMontage;                                   // 0x0498(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAbilityTask_PlayMontageAndWait*        MontageTask;                                       // 0x04A0(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void OnAnimationEnded()	 // 0x47305ec;

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"P2NpcAbility_BruteLungsDamageReaction">();
	}
	static class UP2NpcAbility_BruteLungsDamageReaction* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UP2NpcAbility_BruteLungsDamageReaction>();
	}
};
static_assert(alignof(UP2NpcAbility_BruteLungsDamageReaction) == 0x000008, "Wrong alignment on UP2NpcAbility_BruteLungsDamageReaction");
static_assert(sizeof(UP2NpcAbility_BruteLungsDamageReaction) == 0x0004A8, "Wrong size on UP2NpcAbility_BruteLungsDamageReaction");
static_assert(offsetof(UP2NpcAbility_BruteLungsDamageReaction, ReactionMontage) == 0x000498, "Member 'UP2NpcAbility_BruteLungsDamageReaction::ReactionMontage' has a wrong offset!");
static_assert(offsetof(UP2NpcAbility_BruteLungsDamageReaction, MontageTask) == 0x0004A0, "Member 'UP2NpcAbility_BruteLungsDamageReaction::MontageTask' has a wrong offset!");

// Class AICommon.P2BTTask_WaitAttackPermission
// 0x0010 (0x00A8 - 0x0098)
class UP2BTTask_WaitAttackPermission final : public UBTTask_BlackboardBase
{
public:
	uint8                                         Pad_98[0x10];                                      // 0x0098(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnRequestGranted()	 // 0x4749fe4;

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"P2BTTask_WaitAttackPermission">();
	}
	static class UP2BTTask_WaitAttackPermission* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UP2BTTask_WaitAttackPermission>();
	}
};
static_assert(alignof(UP2BTTask_WaitAttackPermission) == 0x000008, "Wrong alignment on UP2BTTask_WaitAttackPermission");
static_assert(sizeof(UP2BTTask_WaitAttackPermission) == 0x0000A8, "Wrong size on UP2BTTask_WaitAttackPermission");

// Class AICommon.P2GhostAccuracyData
// 0x0100 (0x0130 - 0x0030)
class UP2GhostAccuracyData final : public UPrimaryDataAsset
{
public:
	struct FVector2D                              TargetHitAccuracyPenalty;                          // 0x0030(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              TargetMissAccuracyPenalty;                         // 0x0040(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FScalableFloat                         ChanceToAvoidAccuracyPenalty;                      // 0x0050(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FScalableFloat                         VisibleTargetAccuracyIncreaseRate;                 // 0x0078(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	float                                         StandingFactor;                                    // 0x00A0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CrouchingFactor;                                   // 0x00A4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FScalableFloat                         VelocityFactor;                                    // 0x00A8(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	float                                         SprintingngFactor;                                 // 0x00D0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D4[0x4];                                       // 0x00D4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FScalableFloat                         LostTargetAccuracyDecreaseRate;                    // 0x00D8(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FScalableFloat                         TargetMinAccuracy;                                 // 0x0100(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	float                                         RotationRate;                                      // 0x0128(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_12C[0x4];                                      // 0x012C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"P2GhostAccuracyData">();
	}
	static class UP2GhostAccuracyData* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UP2GhostAccuracyData>();
	}
};
static_assert(alignof(UP2GhostAccuracyData) == 0x000008, "Wrong alignment on UP2GhostAccuracyData");
static_assert(sizeof(UP2GhostAccuracyData) == 0x000130, "Wrong size on UP2GhostAccuracyData");
static_assert(offsetof(UP2GhostAccuracyData, TargetHitAccuracyPenalty) == 0x000030, "Member 'UP2GhostAccuracyData::TargetHitAccuracyPenalty' has a wrong offset!");
static_assert(offsetof(UP2GhostAccuracyData, TargetMissAccuracyPenalty) == 0x000040, "Member 'UP2GhostAccuracyData::TargetMissAccuracyPenalty' has a wrong offset!");
static_assert(offsetof(UP2GhostAccuracyData, ChanceToAvoidAccuracyPenalty) == 0x000050, "Member 'UP2GhostAccuracyData::ChanceToAvoidAccuracyPenalty' has a wrong offset!");
static_assert(offsetof(UP2GhostAccuracyData, VisibleTargetAccuracyIncreaseRate) == 0x000078, "Member 'UP2GhostAccuracyData::VisibleTargetAccuracyIncreaseRate' has a wrong offset!");
static_assert(offsetof(UP2GhostAccuracyData, StandingFactor) == 0x0000A0, "Member 'UP2GhostAccuracyData::StandingFactor' has a wrong offset!");
static_assert(offsetof(UP2GhostAccuracyData, CrouchingFactor) == 0x0000A4, "Member 'UP2GhostAccuracyData::CrouchingFactor' has a wrong offset!");
static_assert(offsetof(UP2GhostAccuracyData, VelocityFactor) == 0x0000A8, "Member 'UP2GhostAccuracyData::VelocityFactor' has a wrong offset!");
static_assert(offsetof(UP2GhostAccuracyData, SprintingngFactor) == 0x0000D0, "Member 'UP2GhostAccuracyData::SprintingngFactor' has a wrong offset!");
static_assert(offsetof(UP2GhostAccuracyData, LostTargetAccuracyDecreaseRate) == 0x0000D8, "Member 'UP2GhostAccuracyData::LostTargetAccuracyDecreaseRate' has a wrong offset!");
static_assert(offsetof(UP2GhostAccuracyData, TargetMinAccuracy) == 0x000100, "Member 'UP2GhostAccuracyData::TargetMinAccuracy' has a wrong offset!");
static_assert(offsetof(UP2GhostAccuracyData, RotationRate) == 0x000128, "Member 'UP2GhostAccuracyData::RotationRate' has a wrong offset!");

// Class AICommon.P2BTTask_WaitGameplayEvent
// 0x0018 (0x0088 - 0x0070)
class UP2BTTask_WaitGameplayEvent final : public UBTTaskNode
{
public:
	struct FGameplayTag                           EventTag;                                          // 0x0070(0x0008)(Edit, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_78[0x10];                                      // 0x0078(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"P2BTTask_WaitGameplayEvent">();
	}
	static class UP2BTTask_WaitGameplayEvent* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UP2BTTask_WaitGameplayEvent>();
	}
};
static_assert(alignof(UP2BTTask_WaitGameplayEvent) == 0x000008, "Wrong alignment on UP2BTTask_WaitGameplayEvent");
static_assert(sizeof(UP2BTTask_WaitGameplayEvent) == 0x000088, "Wrong size on UP2BTTask_WaitGameplayEvent");
static_assert(offsetof(UP2BTTask_WaitGameplayEvent, EventTag) == 0x000070, "Member 'UP2BTTask_WaitGameplayEvent::EventTag' has a wrong offset!");

// Class AICommon.P2BTTask_WaitGameplayTagQuery
// 0x0088 (0x00F8 - 0x0070)
class UP2BTTask_WaitGameplayTagQuery final : public UBTTaskNode
{
public:
	struct FBlackboardKeySelector                 ActorForGameplayTagQuery;                          // 0x0070(0x0028)(Edit, Protected, NativeAccessSpecifierProtected)
	struct FGameplayTagQuery                      GameplayTagQuery;                                  // 0x0098(0x0048)(Edit, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_E0[0x18];                                      // 0x00E0(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"P2BTTask_WaitGameplayTagQuery">();
	}
	static class UP2BTTask_WaitGameplayTagQuery* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UP2BTTask_WaitGameplayTagQuery>();
	}
};
static_assert(alignof(UP2BTTask_WaitGameplayTagQuery) == 0x000008, "Wrong alignment on UP2BTTask_WaitGameplayTagQuery");
static_assert(sizeof(UP2BTTask_WaitGameplayTagQuery) == 0x0000F8, "Wrong size on UP2BTTask_WaitGameplayTagQuery");
static_assert(offsetof(UP2BTTask_WaitGameplayTagQuery, ActorForGameplayTagQuery) == 0x000070, "Member 'UP2BTTask_WaitGameplayTagQuery::ActorForGameplayTagQuery' has a wrong offset!");
static_assert(offsetof(UP2BTTask_WaitGameplayTagQuery, GameplayTagQuery) == 0x000098, "Member 'UP2BTTask_WaitGameplayTagQuery::GameplayTagQuery' has a wrong offset!");

// Class AICommon.P2BTTask_WildCatOverrideImpatience
// 0x0008 (0x0078 - 0x0070)
class UP2BTTask_WildCatOverrideImpatience final : public UBTTaskNode
{
public:
	float                                         ImpatienceValue;                                   // 0x0070(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_74[0x4];                                       // 0x0074(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"P2BTTask_WildCatOverrideImpatience">();
	}
	static class UP2BTTask_WildCatOverrideImpatience* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UP2BTTask_WildCatOverrideImpatience>();
	}
};
static_assert(alignof(UP2BTTask_WildCatOverrideImpatience) == 0x000008, "Wrong alignment on UP2BTTask_WildCatOverrideImpatience");
static_assert(sizeof(UP2BTTask_WildCatOverrideImpatience) == 0x000078, "Wrong size on UP2BTTask_WildCatOverrideImpatience");
static_assert(offsetof(UP2BTTask_WildCatOverrideImpatience, ImpatienceValue) == 0x000070, "Member 'UP2BTTask_WildCatOverrideImpatience::ImpatienceValue' has a wrong offset!");

// Class AICommon.P2MeleeCondition
// 0x0008 (0x0030 - 0x0028)
class UP2MeleeCondition : public UObject
{
public:
	bool                                          bInverseCondition;                                 // 0x0028(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_29[0x7];                                       // 0x0029(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"P2MeleeCondition">();
	}
	static class UP2MeleeCondition* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UP2MeleeCondition>();
	}
};
static_assert(alignof(UP2MeleeCondition) == 0x000008, "Wrong alignment on UP2MeleeCondition");
static_assert(sizeof(UP2MeleeCondition) == 0x000030, "Wrong size on UP2MeleeCondition");
static_assert(offsetof(UP2MeleeCondition, bInverseCondition) == 0x000028, "Member 'UP2MeleeCondition::bInverseCondition' has a wrong offset!");

// Class AICommon.P2BTUtils
// 0x0000 (0x0028 - 0x0028)
class UP2BTUtils final : public UObject
{
public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"P2BTUtils">();
	}
	static class UP2BTUtils* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UP2BTUtils>();
	}
};
static_assert(alignof(UP2BTUtils) == 0x000008, "Wrong alignment on UP2BTUtils");
static_assert(sizeof(UP2BTUtils) == 0x000028, "Wrong size on UP2BTUtils");

// Class AICommon.P2NpcSuppressionTargetReplicationComponent
// 0x0010 (0x00D0 - 0x00C0)
class UP2NpcSuppressionTargetReplicationComponent final : public UActorComponent
{
public:
	float                                         Radius;                                            // 0x00C0(0x0004)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_C4[0xC];                                       // 0x00C4(0x000C)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnRep_Radius()	 // 0x1747c04;

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"P2NpcSuppressionTargetReplicationComponent">();
	}
	static class UP2NpcSuppressionTargetReplicationComponent* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UP2NpcSuppressionTargetReplicationComponent>();
	}
};
static_assert(alignof(UP2NpcSuppressionTargetReplicationComponent) == 0x000008, "Wrong alignment on UP2NpcSuppressionTargetReplicationComponent");
static_assert(sizeof(UP2NpcSuppressionTargetReplicationComponent) == 0x0000D0, "Wrong size on UP2NpcSuppressionTargetReplicationComponent");
static_assert(offsetof(UP2NpcSuppressionTargetReplicationComponent, Radius) == 0x0000C0, "Member 'UP2NpcSuppressionTargetReplicationComponent::Radius' has a wrong offset!");

// Class AICommon.P2CameraModifier_CrocSnapAttack
// 0x0018 (0x0060 - 0x0048)
class UP2CameraModifier_CrocSnapAttack final : public UCameraModifier
{
public:
	struct FVector                                CrocLocation;                                      // 0x0048(0x0018)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"P2CameraModifier_CrocSnapAttack">();
	}
	static class UP2CameraModifier_CrocSnapAttack* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UP2CameraModifier_CrocSnapAttack>();
	}
};
static_assert(alignof(UP2CameraModifier_CrocSnapAttack) == 0x000008, "Wrong alignment on UP2CameraModifier_CrocSnapAttack");
static_assert(sizeof(UP2CameraModifier_CrocSnapAttack) == 0x000060, "Wrong size on UP2CameraModifier_CrocSnapAttack");
static_assert(offsetof(UP2CameraModifier_CrocSnapAttack, CrocLocation) == 0x000048, "Member 'UP2CameraModifier_CrocSnapAttack::CrocLocation' has a wrong offset!");

// Class AICommon.P2CharacterSpatialQuerySubsystem
// 0x0160 (0x01A0 - 0x0040)
class UP2CharacterSpatialQuerySubsystem final : public UTickableWorldSubsystem
{
public:
	uint8                                         Pad_40[0x160];                                     // 0x0040(0x0160)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnActorDestroyed(class AActor* InActor)	 // 0x47498e4;

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"P2CharacterSpatialQuerySubsystem">();
	}
	static class UP2CharacterSpatialQuerySubsystem* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UP2CharacterSpatialQuerySubsystem>();
	}
};
static_assert(alignof(UP2CharacterSpatialQuerySubsystem) == 0x000008, "Wrong alignment on UP2CharacterSpatialQuerySubsystem");
static_assert(sizeof(UP2CharacterSpatialQuerySubsystem) == 0x0001A0, "Wrong size on UP2CharacterSpatialQuerySubsystem");

// Class AICommon.P2MeleeCondition_HasLineOfSight
// 0x0008 (0x0038 - 0x0030)
class UP2MeleeCondition_HasLineOfSight final : public UP2MeleeCondition
{
public:
	ECollisionChannel                             TraceChannel;                                      // 0x0030(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_31[0x7];                                       // 0x0031(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"P2MeleeCondition_HasLineOfSight">();
	}
	static class UP2MeleeCondition_HasLineOfSight* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UP2MeleeCondition_HasLineOfSight>();
	}
};
static_assert(alignof(UP2MeleeCondition_HasLineOfSight) == 0x000008, "Wrong alignment on UP2MeleeCondition_HasLineOfSight");
static_assert(sizeof(UP2MeleeCondition_HasLineOfSight) == 0x000038, "Wrong size on UP2MeleeCondition_HasLineOfSight");
static_assert(offsetof(UP2MeleeCondition_HasLineOfSight, TraceChannel) == 0x000030, "Member 'UP2MeleeCondition_HasLineOfSight::TraceChannel' has a wrong offset!");

// Class AICommon.P2CharacterVisibilitySettings
// 0x0078 (0x00B0 - 0x0038)
class UP2CharacterVisibilitySettings final : public UDeveloperSettings
{
public:
	uint8                                         Pad_38[0x14];                                      // 0x0038(0x0014)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         TickTimeLimit;                                     // 0x004C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SurroundingLightWeight;                            // 0x0050(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          EnableSurroundingLights;                           // 0x0054(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_55[0x3];                                       // 0x0055(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         QueryRadius;                                       // 0x0058(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TraceOffsetFactor;                                 // 0x005C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          LineTrace;                                         // 0x0060(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          TraceComplex;                                      // 0x0061(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          NormalizeBrightness;                               // 0x0062(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_63[0x1];                                       // 0x0063(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MaxLightBrightness;                                // 0x0064(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DirectionalLightDistance;                          // 0x0068(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AtmoLightWeight;                                   // 0x006C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AtmoFogWeight;                                     // 0x0070(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          EnableAtmos;                                       // 0x0074(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_75[0x3];                                       // 0x0075(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTag                           SurfaceLayerTag;                                   // 0x0078(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, Config, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FP2CharacterVisibilityAtmosDefinition> SurfaceZoneDefinitions;                     // 0x0080(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, NativeAccessSpecifierPublic)
	TArray<struct FP2CharacterVisibilityAtmosDefinition> NonSurfaceZoneDefinitions;                  // 0x0090(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, NativeAccessSpecifierPublic)
	float                                         GroundSurfaceWeight;                               // 0x00A0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          EnableGroundSurface;                               // 0x00A4(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A5[0x3];                                       // 0x00A5(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         GroundMaterialTraceOffsetFactor;                   // 0x00A8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         GroundMaterialLandscapeModifier;                   // 0x00AC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"P2CharacterVisibilitySettings">();
	}
	static class UP2CharacterVisibilitySettings* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UP2CharacterVisibilitySettings>();
	}
};
static_assert(alignof(UP2CharacterVisibilitySettings) == 0x000008, "Wrong alignment on UP2CharacterVisibilitySettings");
static_assert(sizeof(UP2CharacterVisibilitySettings) == 0x0000B0, "Wrong size on UP2CharacterVisibilitySettings");
static_assert(offsetof(UP2CharacterVisibilitySettings, TickTimeLimit) == 0x00004C, "Member 'UP2CharacterVisibilitySettings::TickTimeLimit' has a wrong offset!");
static_assert(offsetof(UP2CharacterVisibilitySettings, SurroundingLightWeight) == 0x000050, "Member 'UP2CharacterVisibilitySettings::SurroundingLightWeight' has a wrong offset!");
static_assert(offsetof(UP2CharacterVisibilitySettings, EnableSurroundingLights) == 0x000054, "Member 'UP2CharacterVisibilitySettings::EnableSurroundingLights' has a wrong offset!");
static_assert(offsetof(UP2CharacterVisibilitySettings, QueryRadius) == 0x000058, "Member 'UP2CharacterVisibilitySettings::QueryRadius' has a wrong offset!");
static_assert(offsetof(UP2CharacterVisibilitySettings, TraceOffsetFactor) == 0x00005C, "Member 'UP2CharacterVisibilitySettings::TraceOffsetFactor' has a wrong offset!");
static_assert(offsetof(UP2CharacterVisibilitySettings, LineTrace) == 0x000060, "Member 'UP2CharacterVisibilitySettings::LineTrace' has a wrong offset!");
static_assert(offsetof(UP2CharacterVisibilitySettings, TraceComplex) == 0x000061, "Member 'UP2CharacterVisibilitySettings::TraceComplex' has a wrong offset!");
static_assert(offsetof(UP2CharacterVisibilitySettings, NormalizeBrightness) == 0x000062, "Member 'UP2CharacterVisibilitySettings::NormalizeBrightness' has a wrong offset!");
static_assert(offsetof(UP2CharacterVisibilitySettings, MaxLightBrightness) == 0x000064, "Member 'UP2CharacterVisibilitySettings::MaxLightBrightness' has a wrong offset!");
static_assert(offsetof(UP2CharacterVisibilitySettings, DirectionalLightDistance) == 0x000068, "Member 'UP2CharacterVisibilitySettings::DirectionalLightDistance' has a wrong offset!");
static_assert(offsetof(UP2CharacterVisibilitySettings, AtmoLightWeight) == 0x00006C, "Member 'UP2CharacterVisibilitySettings::AtmoLightWeight' has a wrong offset!");
static_assert(offsetof(UP2CharacterVisibilitySettings, AtmoFogWeight) == 0x000070, "Member 'UP2CharacterVisibilitySettings::AtmoFogWeight' has a wrong offset!");
static_assert(offsetof(UP2CharacterVisibilitySettings, EnableAtmos) == 0x000074, "Member 'UP2CharacterVisibilitySettings::EnableAtmos' has a wrong offset!");
static_assert(offsetof(UP2CharacterVisibilitySettings, SurfaceLayerTag) == 0x000078, "Member 'UP2CharacterVisibilitySettings::SurfaceLayerTag' has a wrong offset!");
static_assert(offsetof(UP2CharacterVisibilitySettings, SurfaceZoneDefinitions) == 0x000080, "Member 'UP2CharacterVisibilitySettings::SurfaceZoneDefinitions' has a wrong offset!");
static_assert(offsetof(UP2CharacterVisibilitySettings, NonSurfaceZoneDefinitions) == 0x000090, "Member 'UP2CharacterVisibilitySettings::NonSurfaceZoneDefinitions' has a wrong offset!");
static_assert(offsetof(UP2CharacterVisibilitySettings, GroundSurfaceWeight) == 0x0000A0, "Member 'UP2CharacterVisibilitySettings::GroundSurfaceWeight' has a wrong offset!");
static_assert(offsetof(UP2CharacterVisibilitySettings, EnableGroundSurface) == 0x0000A4, "Member 'UP2CharacterVisibilitySettings::EnableGroundSurface' has a wrong offset!");
static_assert(offsetof(UP2CharacterVisibilitySettings, GroundMaterialTraceOffsetFactor) == 0x0000A8, "Member 'UP2CharacterVisibilitySettings::GroundMaterialTraceOffsetFactor' has a wrong offset!");
static_assert(offsetof(UP2CharacterVisibilitySettings, GroundMaterialLandscapeModifier) == 0x0000AC, "Member 'UP2CharacterVisibilitySettings::GroundMaterialLandscapeModifier' has a wrong offset!");

// Class AICommon.P2NpcTestScenarioImGui
// 0x0020 (0x0048 - 0x0028)
class UP2NpcTestScenarioImGui final : public UObject
{
public:
	uint8                                         Pad_28[0x20];                                      // 0x0028(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"P2NpcTestScenarioImGui">();
	}
	static class UP2NpcTestScenarioImGui* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UP2NpcTestScenarioImGui>();
	}
};
static_assert(alignof(UP2NpcTestScenarioImGui) == 0x000008, "Wrong alignment on UP2NpcTestScenarioImGui");
static_assert(sizeof(UP2NpcTestScenarioImGui) == 0x000048, "Wrong size on UP2NpcTestScenarioImGui");

// Class AICommon.P2CharacterVisibilitySpatialQuerySubsystem
// 0x0250 (0x0290 - 0x0040)
class alignas(0x10) UP2CharacterVisibilitySpatialQuerySubsystem final : public UTickableWorldSubsystem
{
public:
	TSoftObjectPtr<class UP2CharacterVisibilitySettings> CharacterVisibilitySettings;                // 0x0040(0x0030)(Config, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_70[0x220];                                     // 0x0070(0x0220)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ActivateComponent(class UActorComponent* InComponent, bool bReset)	 // 0x47495e0;
	void DeactivateComponent(class UActorComponent* InComponent)	 // 0x4749740;
	void OnActorDeath(class UP2HealthComponent* InHealthComponent)	 // 0x474981c;
	void OnActorDestroyed(class AActor* InActor)	 // 0x4749be0;

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"P2CharacterVisibilitySpatialQuerySubsystem">();
	}
	static class UP2CharacterVisibilitySpatialQuerySubsystem* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UP2CharacterVisibilitySpatialQuerySubsystem>();
	}
};
static_assert(alignof(UP2CharacterVisibilitySpatialQuerySubsystem) == 0x000010, "Wrong alignment on UP2CharacterVisibilitySpatialQuerySubsystem");
static_assert(sizeof(UP2CharacterVisibilitySpatialQuerySubsystem) == 0x000290, "Wrong size on UP2CharacterVisibilitySpatialQuerySubsystem");
static_assert(offsetof(UP2CharacterVisibilitySpatialQuerySubsystem, CharacterVisibilitySettings) == 0x000040, "Member 'UP2CharacterVisibilitySpatialQuerySubsystem::CharacterVisibilitySettings' has a wrong offset!");

// Class AICommon.P2CheatManagerExtension_NavModifiers
// 0x0008 (0x0080 - 0x0078)
class UP2CheatManagerExtension_NavModifiers final : public UP2CheatManagerExtension
{
public:
	uint8                                         Pad_78[0x8];                                       // 0x0078(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ToggleNavModifiersDebug()	 // 0x431c9f4;

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"P2CheatManagerExtension_NavModifiers">();
	}
	static class UP2CheatManagerExtension_NavModifiers* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UP2CheatManagerExtension_NavModifiers>();
	}
};
static_assert(alignof(UP2CheatManagerExtension_NavModifiers) == 0x000008, "Wrong alignment on UP2CheatManagerExtension_NavModifiers");
static_assert(sizeof(UP2CheatManagerExtension_NavModifiers) == 0x000080, "Wrong size on UP2CheatManagerExtension_NavModifiers");

// Class AICommon.P2ControlRotationModifier_PsycheEvasion
// 0x0010 (0x0058 - 0x0048)
class UP2ControlRotationModifier_PsycheEvasion final : public UP2ControlRotationModifier
{
public:
	TWeakObjectPtr<class AActor>                  PsycheOwner;                                       // 0x0048(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UP2NpcAbility_PsycheAimEvasion> AbilityClass;                                  // 0x0050(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"P2ControlRotationModifier_PsycheEvasion">();
	}
	static class UP2ControlRotationModifier_PsycheEvasion* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UP2ControlRotationModifier_PsycheEvasion>();
	}
};
static_assert(alignof(UP2ControlRotationModifier_PsycheEvasion) == 0x000008, "Wrong alignment on UP2ControlRotationModifier_PsycheEvasion");
static_assert(sizeof(UP2ControlRotationModifier_PsycheEvasion) == 0x000058, "Wrong size on UP2ControlRotationModifier_PsycheEvasion");
static_assert(offsetof(UP2ControlRotationModifier_PsycheEvasion, PsycheOwner) == 0x000048, "Member 'UP2ControlRotationModifier_PsycheEvasion::PsycheOwner' has a wrong offset!");
static_assert(offsetof(UP2ControlRotationModifier_PsycheEvasion, AbilityClass) == 0x000050, "Member 'UP2ControlRotationModifier_PsycheEvasion::AbilityClass' has a wrong offset!");

// Class AICommon.P2PlayerBotCheatExtension
// 0x0000 (0x0078 - 0x0078)
class UP2PlayerBotCheatExtension final : public UP2CheatManagerExtension
{
public:
	void PlayerBotEngageDistance(float InEngageDistance)	 // 0x47733a8;
	void PlayerBotReconDistance(float InReconDistance)	 // 0x477346c;
	void PlayerBotRetreatDistance(float InRetreatDistance)	 // 0x4773530;
	void PlayerBotSpawnInAll(int32 InSquadCount, int32 InSquadMemberCount)	 // 0x47735f4;
	void PlayerBotToggleIgnorePlayer()	 // 0x4773730;

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"P2PlayerBotCheatExtension">();
	}
	static class UP2PlayerBotCheatExtension* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UP2PlayerBotCheatExtension>();
	}
};
static_assert(alignof(UP2PlayerBotCheatExtension) == 0x000008, "Wrong alignment on UP2PlayerBotCheatExtension");
static_assert(sizeof(UP2PlayerBotCheatExtension) == 0x000078, "Wrong size on UP2PlayerBotCheatExtension");

// Class AICommon.P2LureGrenade
// 0x0008 (0x06C0 - 0x06B8)
class UP2LureGrenade final : public UP2Grenade
{
public:
	uint8                                         Pad_6B8[0x8];                                      // 0x06B8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"P2LureGrenade">();
	}
	static class UP2LureGrenade* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UP2LureGrenade>();
	}
};
static_assert(alignof(UP2LureGrenade) == 0x000008, "Wrong alignment on UP2LureGrenade");
static_assert(sizeof(UP2LureGrenade) == 0x0006C0, "Wrong size on UP2LureGrenade");

// Class AICommon.P2CrocCamouflageComponent
// 0x0068 (0x0168 - 0x0100)
class UP2CrocCamouflageComponent final : public UP2NpcCamouflageComponent
{
public:
	TArray<struct FP2CrocPhysMaterialToCamouflageType> PhysMaterialToCamouflageTypes;                // 0x0100(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	float                                         BlendTime;                                         // 0x0110(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         BlendBetweenTypesProgress;                         // 0x0114(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FName                                   CamouflageType;                                    // 0x0118(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FName                                   PreviousCamouflageType;                            // 0x0120(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FVector                                SamplingLocation;                                  // 0x0128(0x0018)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FVector                                PreviousSamplingLocation;                          // 0x0140(0x0018)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FString                                 PhysMaterialName;                                  // 0x0158(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void OnRep_SamplingLocation(const struct FVector& PrevLocation)	 // 0x1565c18;

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"P2CrocCamouflageComponent">();
	}
	static class UP2CrocCamouflageComponent* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UP2CrocCamouflageComponent>();
	}
};
static_assert(alignof(UP2CrocCamouflageComponent) == 0x000008, "Wrong alignment on UP2CrocCamouflageComponent");
static_assert(sizeof(UP2CrocCamouflageComponent) == 0x000168, "Wrong size on UP2CrocCamouflageComponent");
static_assert(offsetof(UP2CrocCamouflageComponent, PhysMaterialToCamouflageTypes) == 0x000100, "Member 'UP2CrocCamouflageComponent::PhysMaterialToCamouflageTypes' has a wrong offset!");
static_assert(offsetof(UP2CrocCamouflageComponent, BlendTime) == 0x000110, "Member 'UP2CrocCamouflageComponent::BlendTime' has a wrong offset!");
static_assert(offsetof(UP2CrocCamouflageComponent, BlendBetweenTypesProgress) == 0x000114, "Member 'UP2CrocCamouflageComponent::BlendBetweenTypesProgress' has a wrong offset!");
static_assert(offsetof(UP2CrocCamouflageComponent, CamouflageType) == 0x000118, "Member 'UP2CrocCamouflageComponent::CamouflageType' has a wrong offset!");
static_assert(offsetof(UP2CrocCamouflageComponent, PreviousCamouflageType) == 0x000120, "Member 'UP2CrocCamouflageComponent::PreviousCamouflageType' has a wrong offset!");
static_assert(offsetof(UP2CrocCamouflageComponent, SamplingLocation) == 0x000128, "Member 'UP2CrocCamouflageComponent::SamplingLocation' has a wrong offset!");
static_assert(offsetof(UP2CrocCamouflageComponent, PreviousSamplingLocation) == 0x000140, "Member 'UP2CrocCamouflageComponent::PreviousSamplingLocation' has a wrong offset!");
static_assert(offsetof(UP2CrocCamouflageComponent, PhysMaterialName) == 0x000158, "Member 'UP2CrocCamouflageComponent::PhysMaterialName' has a wrong offset!");

// Class AICommon.P2CrocCheatExtension
// 0x0008 (0x0080 - 0x0078)
class UP2CrocCheatExtension final : public UP2CheatManagerExtension
{
public:
	TSubclassOf<class UP2Ability_CrocSnapAttackReaction> ReactionAbility;                            // 0x0078(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	void ServerToggleCrocSnapAttackReaction()	 // 0x474dcf8;
	void ToggleCrocSnapAttackReaction()	 // 0x474dd10;

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"P2CrocCheatExtension">();
	}
	static class UP2CrocCheatExtension* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UP2CrocCheatExtension>();
	}
};
static_assert(alignof(UP2CrocCheatExtension) == 0x000008, "Wrong alignment on UP2CrocCheatExtension");
static_assert(sizeof(UP2CrocCheatExtension) == 0x000080, "Wrong size on UP2CrocCheatExtension");
static_assert(offsetof(UP2CrocCheatExtension, ReactionAbility) == 0x000078, "Member 'UP2CrocCheatExtension::ReactionAbility' has a wrong offset!");

// Class AICommon.P2DisplayActorNameProvider_SmartObject
// 0x0010 (0x0040 - 0x0030)
class UP2DisplayActorNameProvider_SmartObject final : public UP2DisplayActorNameProviderBase
{
public:
	uint8                                         Pad_30[0x10];                                      // 0x0030(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"P2DisplayActorNameProvider_SmartObject">();
	}
	static class UP2DisplayActorNameProvider_SmartObject* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UP2DisplayActorNameProvider_SmartObject>();
	}
};
static_assert(alignof(UP2DisplayActorNameProvider_SmartObject) == 0x000008, "Wrong alignment on UP2DisplayActorNameProvider_SmartObject");
static_assert(sizeof(UP2DisplayActorNameProvider_SmartObject) == 0x000040, "Wrong size on UP2DisplayActorNameProvider_SmartObject");

// Class AICommon.P2PlayerBotSettings
// 0x0020 (0x0058 - 0x0038)
class UP2PlayerBotSettings final : public UDeveloperSettings
{
public:
	float                                         AttemptDistance;                                   // 0x0038(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PassDistance;                                      // 0x003C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MaxAttemptCount;                                   // 0x0040(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         EngageDistance;                                    // 0x0044(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RetreatDistance;                                   // 0x0048(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ReconDistance;                                     // 0x004C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RenewTimeHasAttackedByPlayer;                      // 0x0050(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_54[0x4];                                       // 0x0054(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"P2PlayerBotSettings">();
	}
	static class UP2PlayerBotSettings* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UP2PlayerBotSettings>();
	}
};
static_assert(alignof(UP2PlayerBotSettings) == 0x000008, "Wrong alignment on UP2PlayerBotSettings");
static_assert(sizeof(UP2PlayerBotSettings) == 0x000058, "Wrong size on UP2PlayerBotSettings");
static_assert(offsetof(UP2PlayerBotSettings, AttemptDistance) == 0x000038, "Member 'UP2PlayerBotSettings::AttemptDistance' has a wrong offset!");
static_assert(offsetof(UP2PlayerBotSettings, PassDistance) == 0x00003C, "Member 'UP2PlayerBotSettings::PassDistance' has a wrong offset!");
static_assert(offsetof(UP2PlayerBotSettings, MaxAttemptCount) == 0x000040, "Member 'UP2PlayerBotSettings::MaxAttemptCount' has a wrong offset!");
static_assert(offsetof(UP2PlayerBotSettings, EngageDistance) == 0x000044, "Member 'UP2PlayerBotSettings::EngageDistance' has a wrong offset!");
static_assert(offsetof(UP2PlayerBotSettings, RetreatDistance) == 0x000048, "Member 'UP2PlayerBotSettings::RetreatDistance' has a wrong offset!");
static_assert(offsetof(UP2PlayerBotSettings, ReconDistance) == 0x00004C, "Member 'UP2PlayerBotSettings::ReconDistance' has a wrong offset!");
static_assert(offsetof(UP2PlayerBotSettings, RenewTimeHasAttackedByPlayer) == 0x000050, "Member 'UP2PlayerBotSettings::RenewTimeHasAttackedByPlayer' has a wrong offset!");

// Class AICommon.P2JumpLinkConfig
// 0x01A0 (0x01C8 - 0x0028)
class UP2JumpLinkConfig final : public UObject
{
public:
	class UAnimMontage*                           Montage;                                           // 0x0028(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRuntimeVectorCurve                    TraceCheckCurve;                                   // 0x0030(0x0188)(Edit, BlueprintVisible, BlueprintReadOnly, EditConst, NativeAccessSpecifierPublic)
	TArray<class FName>                           WarpTargetNames;                                   // 0x01B8(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"P2JumpLinkConfig">();
	}
	static class UP2JumpLinkConfig* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UP2JumpLinkConfig>();
	}
};
static_assert(alignof(UP2JumpLinkConfig) == 0x000008, "Wrong alignment on UP2JumpLinkConfig");
static_assert(sizeof(UP2JumpLinkConfig) == 0x0001C8, "Wrong size on UP2JumpLinkConfig");
static_assert(offsetof(UP2JumpLinkConfig, Montage) == 0x000028, "Member 'UP2JumpLinkConfig::Montage' has a wrong offset!");
static_assert(offsetof(UP2JumpLinkConfig, TraceCheckCurve) == 0x000030, "Member 'UP2JumpLinkConfig::TraceCheckCurve' has a wrong offset!");
static_assert(offsetof(UP2JumpLinkConfig, WarpTargetNames) == 0x0001B8, "Member 'UP2JumpLinkConfig::WarpTargetNames' has a wrong offset!");

// Class AICommon.P2DoorNavLink
// 0x0050 (0x0630 - 0x05E0)
class AP2DoorNavLink final : public AP2BreakableNavLink
{
public:
	TArray<struct FComponentReference>            HandledDoorComponents;                             // 0x05E0(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(EDoorLinkState NewState)> OnDoorLinkStateChanged;                  // 0x05F0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	bool                                          bAllowInteraction;                                 // 0x0600(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_601[0x3];                                      // 0x0601(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ClosedDoorCost;                                    // 0x0604(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         OpenedDoorCost;                                    // 0x0608(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_60C[0x4];                                      // 0x060C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<TWeakObjectPtr<class UP2DoorComponent>> DoorComponentsCache;                              // 0x0610(0x0010)(ExportObject, ZeroConstructor, ContainsInstancedReference, UObjectWrapper, NativeAccessSpecifierPrivate)
	EDoorLinkState                                DoorLinkState;                                     // 0x0620(0x0001)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bLocked;                                           // 0x0621(0x0001)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_622[0xE];                                      // 0x0622(0x000E)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnDoorFinishedMoving(EDoorState InState, class UP2DoorComponent* InDoorComponent)	 // 0x474d920;
	void OnDoorLockStateChanged(EP2LockState InLockState, class UP2LockComponent* LockComponent)	 // 0x474da5c;

	struct FVector GetDoorLocation() const	 // 0x474d8c4;
	EDoorLinkState GetDoorState() const	 // 0x46a881c;
	bool TryToInteract(const struct FP2InteractionParameters& InParameters) const	 // 0x474dd5c;

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"P2DoorNavLink">();
	}
	static class AP2DoorNavLink* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<AP2DoorNavLink>();
	}
};
static_assert(alignof(AP2DoorNavLink) == 0x000010, "Wrong alignment on AP2DoorNavLink");
static_assert(sizeof(AP2DoorNavLink) == 0x000630, "Wrong size on AP2DoorNavLink");
static_assert(offsetof(AP2DoorNavLink, HandledDoorComponents) == 0x0005E0, "Member 'AP2DoorNavLink::HandledDoorComponents' has a wrong offset!");
static_assert(offsetof(AP2DoorNavLink, OnDoorLinkStateChanged) == 0x0005F0, "Member 'AP2DoorNavLink::OnDoorLinkStateChanged' has a wrong offset!");
static_assert(offsetof(AP2DoorNavLink, bAllowInteraction) == 0x000600, "Member 'AP2DoorNavLink::bAllowInteraction' has a wrong offset!");
static_assert(offsetof(AP2DoorNavLink, ClosedDoorCost) == 0x000604, "Member 'AP2DoorNavLink::ClosedDoorCost' has a wrong offset!");
static_assert(offsetof(AP2DoorNavLink, OpenedDoorCost) == 0x000608, "Member 'AP2DoorNavLink::OpenedDoorCost' has a wrong offset!");
static_assert(offsetof(AP2DoorNavLink, DoorComponentsCache) == 0x000610, "Member 'AP2DoorNavLink::DoorComponentsCache' has a wrong offset!");
static_assert(offsetof(AP2DoorNavLink, DoorLinkState) == 0x000620, "Member 'AP2DoorNavLink::DoorLinkState' has a wrong offset!");
static_assert(offsetof(AP2DoorNavLink, bLocked) == 0x000621, "Member 'AP2DoorNavLink::bLocked' has a wrong offset!");

// Class AICommon.P2DoorNavLinkGenerator
// 0x0010 (0x0038 - 0x0028)
class UP2DoorNavLinkGenerator final : public UP2NavLinkGenerator
{
public:
	TArray<struct FDoorNavlinkConfigs>            DoorNavlinkConfigs;                                // 0x0028(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"P2DoorNavLinkGenerator">();
	}
	static class UP2DoorNavLinkGenerator* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UP2DoorNavLinkGenerator>();
	}
};
static_assert(alignof(UP2DoorNavLinkGenerator) == 0x000008, "Wrong alignment on UP2DoorNavLinkGenerator");
static_assert(sizeof(UP2DoorNavLinkGenerator) == 0x000038, "Wrong size on UP2DoorNavLinkGenerator");
static_assert(offsetof(UP2DoorNavLinkGenerator, DoorNavlinkConfigs) == 0x000028, "Member 'UP2DoorNavLinkGenerator::DoorNavlinkConfigs' has a wrong offset!");

// Class AICommon.P2EnvQueryContext_Cover
// 0x0000 (0x0028 - 0x0028)
class UP2EnvQueryContext_Cover final : public UEnvQueryContext
{
public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"P2EnvQueryContext_Cover">();
	}
	static class UP2EnvQueryContext_Cover* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UP2EnvQueryContext_Cover>();
	}
};
static_assert(alignof(UP2EnvQueryContext_Cover) == 0x000008, "Wrong alignment on UP2EnvQueryContext_Cover");
static_assert(sizeof(UP2EnvQueryContext_Cover) == 0x000028, "Wrong size on UP2EnvQueryContext_Cover");

// Class AICommon.P2MeleeSlot
// 0x0030 (0x0058 - 0x0028)
class UP2MeleeSlot final : public UObject
{
public:
	TWeakObjectPtr<class UP2MeleeComponent>       OwnerComp;                                         // 0x0028(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TWeakObjectPtr<class AActor>                  Occupant;                                          // 0x0030(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FVector                                Direction;                                         // 0x0038(0x0018)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         MaxDistance;                                       // 0x0050(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         Angle;                                             // 0x0054(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"P2MeleeSlot">();
	}
	static class UP2MeleeSlot* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UP2MeleeSlot>();
	}
};
static_assert(alignof(UP2MeleeSlot) == 0x000008, "Wrong alignment on UP2MeleeSlot");
static_assert(sizeof(UP2MeleeSlot) == 0x000058, "Wrong size on UP2MeleeSlot");
static_assert(offsetof(UP2MeleeSlot, OwnerComp) == 0x000028, "Member 'UP2MeleeSlot::OwnerComp' has a wrong offset!");
static_assert(offsetof(UP2MeleeSlot, Occupant) == 0x000030, "Member 'UP2MeleeSlot::Occupant' has a wrong offset!");
static_assert(offsetof(UP2MeleeSlot, Direction) == 0x000038, "Member 'UP2MeleeSlot::Direction' has a wrong offset!");
static_assert(offsetof(UP2MeleeSlot, MaxDistance) == 0x000050, "Member 'UP2MeleeSlot::MaxDistance' has a wrong offset!");
static_assert(offsetof(UP2MeleeSlot, Angle) == 0x000054, "Member 'UP2MeleeSlot::Angle' has a wrong offset!");

// Class AICommon.P2EnvQueryContext_DangerLocation
// 0x0000 (0x0028 - 0x0028)
class UP2EnvQueryContext_DangerLocation final : public UEnvQueryContext
{
public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"P2EnvQueryContext_DangerLocation">();
	}
	static class UP2EnvQueryContext_DangerLocation* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UP2EnvQueryContext_DangerLocation>();
	}
};
static_assert(alignof(UP2EnvQueryContext_DangerLocation) == 0x000008, "Wrong alignment on UP2EnvQueryContext_DangerLocation");
static_assert(sizeof(UP2EnvQueryContext_DangerLocation) == 0x000028, "Wrong size on UP2EnvQueryContext_DangerLocation");

// Class AICommon.P2EnvQueryContext_GroupDangers
// 0x0000 (0x0028 - 0x0028)
class UP2EnvQueryContext_GroupDangers final : public UEnvQueryContext
{
public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"P2EnvQueryContext_GroupDangers">();
	}
	static class UP2EnvQueryContext_GroupDangers* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UP2EnvQueryContext_GroupDangers>();
	}
};
static_assert(alignof(UP2EnvQueryContext_GroupDangers) == 0x000008, "Wrong alignment on UP2EnvQueryContext_GroupDangers");
static_assert(sizeof(UP2EnvQueryContext_GroupDangers) == 0x000028, "Wrong size on UP2EnvQueryContext_GroupDangers");

// Class AICommon.P2EnvQueryContext_OffensiveGroupDangers
// 0x0000 (0x0028 - 0x0028)
class UP2EnvQueryContext_OffensiveGroupDangers final : public UEnvQueryContext
{
public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"P2EnvQueryContext_OffensiveGroupDangers">();
	}
	static class UP2EnvQueryContext_OffensiveGroupDangers* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UP2EnvQueryContext_OffensiveGroupDangers>();
	}
};
static_assert(alignof(UP2EnvQueryContext_OffensiveGroupDangers) == 0x000008, "Wrong alignment on UP2EnvQueryContext_OffensiveGroupDangers");
static_assert(sizeof(UP2EnvQueryContext_OffensiveGroupDangers) == 0x000028, "Wrong size on UP2EnvQueryContext_OffensiveGroupDangers");

// Class AICommon.P2EnvQueryTest_Teammate
// 0x0000 (0x0208 - 0x0208)
class UP2EnvQueryTest_Teammate final : public UEnvQueryTest
{
public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"P2EnvQueryTest_Teammate">();
	}
	static class UP2EnvQueryTest_Teammate* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UP2EnvQueryTest_Teammate>();
	}
};
static_assert(alignof(UP2EnvQueryTest_Teammate) == 0x000008, "Wrong alignment on UP2EnvQueryTest_Teammate");
static_assert(sizeof(UP2EnvQueryTest_Teammate) == 0x000208, "Wrong size on UP2EnvQueryTest_Teammate");

// Class AICommon.P2EnvQueryContext_NeutralGroupDangers
// 0x0000 (0x0028 - 0x0028)
class UP2EnvQueryContext_NeutralGroupDangers final : public UEnvQueryContext
{
public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"P2EnvQueryContext_NeutralGroupDangers">();
	}
	static class UP2EnvQueryContext_NeutralGroupDangers* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UP2EnvQueryContext_NeutralGroupDangers>();
	}
};
static_assert(alignof(UP2EnvQueryContext_NeutralGroupDangers) == 0x000008, "Wrong alignment on UP2EnvQueryContext_NeutralGroupDangers");
static_assert(sizeof(UP2EnvQueryContext_NeutralGroupDangers) == 0x000028, "Wrong size on UP2EnvQueryContext_NeutralGroupDangers");

// Class AICommon.P2EnvQueryContext_DefensiveGroupDangers
// 0x0000 (0x0028 - 0x0028)
class UP2EnvQueryContext_DefensiveGroupDangers final : public UEnvQueryContext
{
public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"P2EnvQueryContext_DefensiveGroupDangers">();
	}
	static class UP2EnvQueryContext_DefensiveGroupDangers* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UP2EnvQueryContext_DefensiveGroupDangers>();
	}
};
static_assert(alignof(UP2EnvQueryContext_DefensiveGroupDangers) == 0x000008, "Wrong alignment on UP2EnvQueryContext_DefensiveGroupDangers");
static_assert(sizeof(UP2EnvQueryContext_DefensiveGroupDangers) == 0x000028, "Wrong size on UP2EnvQueryContext_DefensiveGroupDangers");

// Class AICommon.P2EnvQueryContext_GroupDirection
// 0x0000 (0x0028 - 0x0028)
class UP2EnvQueryContext_GroupDirection final : public UEnvQueryContext
{
public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"P2EnvQueryContext_GroupDirection">();
	}
	static class UP2EnvQueryContext_GroupDirection* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UP2EnvQueryContext_GroupDirection>();
	}
};
static_assert(alignof(UP2EnvQueryContext_GroupDirection) == 0x000008, "Wrong alignment on UP2EnvQueryContext_GroupDirection");
static_assert(sizeof(UP2EnvQueryContext_GroupDirection) == 0x000028, "Wrong size on UP2EnvQueryContext_GroupDirection");

// Class AICommon.P2EnvQueryContext_GroupFormationDirection
// 0x0000 (0x0028 - 0x0028)
class UP2EnvQueryContext_GroupFormationDirection final : public UEnvQueryContext
{
public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"P2EnvQueryContext_GroupFormationDirection">();
	}
	static class UP2EnvQueryContext_GroupFormationDirection* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UP2EnvQueryContext_GroupFormationDirection>();
	}
};
static_assert(alignof(UP2EnvQueryContext_GroupFormationDirection) == 0x000008, "Wrong alignment on UP2EnvQueryContext_GroupFormationDirection");
static_assert(sizeof(UP2EnvQueryContext_GroupFormationDirection) == 0x000028, "Wrong size on UP2EnvQueryContext_GroupFormationDirection");

// Class AICommon.P2EnvQueryContext_GroupFormationLocation
// 0x0000 (0x0028 - 0x0028)
class UP2EnvQueryContext_GroupFormationLocation final : public UEnvQueryContext
{
public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"P2EnvQueryContext_GroupFormationLocation">();
	}
	static class UP2EnvQueryContext_GroupFormationLocation* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UP2EnvQueryContext_GroupFormationLocation>();
	}
};
static_assert(alignof(UP2EnvQueryContext_GroupFormationLocation) == 0x000008, "Wrong alignment on UP2EnvQueryContext_GroupFormationLocation");
static_assert(sizeof(UP2EnvQueryContext_GroupFormationLocation) == 0x000028, "Wrong size on UP2EnvQueryContext_GroupFormationLocation");

// Class AICommon.P2EnvQueryContext_GroupLocation
// 0x0000 (0x0028 - 0x0028)
class UP2EnvQueryContext_GroupLocation final : public UEnvQueryContext
{
public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"P2EnvQueryContext_GroupLocation">();
	}
	static class UP2EnvQueryContext_GroupLocation* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UP2EnvQueryContext_GroupLocation>();
	}
};
static_assert(alignof(UP2EnvQueryContext_GroupLocation) == 0x000008, "Wrong alignment on UP2EnvQueryContext_GroupLocation");
static_assert(sizeof(UP2EnvQueryContext_GroupLocation) == 0x000028, "Wrong size on UP2EnvQueryContext_GroupLocation");

// Class AICommon.P2EnvQueryContext_GroupMembers
// 0x0000 (0x0028 - 0x0028)
class UP2EnvQueryContext_GroupMembers final : public UEnvQueryContext
{
public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"P2EnvQueryContext_GroupMembers">();
	}
	static class UP2EnvQueryContext_GroupMembers* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UP2EnvQueryContext_GroupMembers>();
	}
};
static_assert(alignof(UP2EnvQueryContext_GroupMembers) == 0x000008, "Wrong alignment on UP2EnvQueryContext_GroupMembers");
static_assert(sizeof(UP2EnvQueryContext_GroupMembers) == 0x000028, "Wrong size on UP2EnvQueryContext_GroupMembers");

// Class AICommon.P2EnvQueryContext_GroupTargets
// 0x0000 (0x0028 - 0x0028)
class UP2EnvQueryContext_GroupTargets final : public UEnvQueryContext
{
public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"P2EnvQueryContext_GroupTargets">();
	}
	static class UP2EnvQueryContext_GroupTargets* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UP2EnvQueryContext_GroupTargets>();
	}
};
static_assert(alignof(UP2EnvQueryContext_GroupTargets) == 0x000008, "Wrong alignment on UP2EnvQueryContext_GroupTargets");
static_assert(sizeof(UP2EnvQueryContext_GroupTargets) == 0x000028, "Wrong size on UP2EnvQueryContext_GroupTargets");

// Class AICommon.P2ExtractionDroneDamageCalculation
// 0x0000 (0x0098 - 0x0098)
class UP2ExtractionDroneDamageCalculation : public UP2DamageCalculation
{
public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"P2ExtractionDroneDamageCalculation">();
	}
	static class UP2ExtractionDroneDamageCalculation* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UP2ExtractionDroneDamageCalculation>();
	}
};
static_assert(alignof(UP2ExtractionDroneDamageCalculation) == 0x000008, "Wrong alignment on UP2ExtractionDroneDamageCalculation");
static_assert(sizeof(UP2ExtractionDroneDamageCalculation) == 0x000098, "Wrong size on UP2ExtractionDroneDamageCalculation");

// Class AICommon.P2EnvQueryContext_GroupSpottedTargets
// 0x0000 (0x0028 - 0x0028)
class UP2EnvQueryContext_GroupSpottedTargets final : public UEnvQueryContext
{
public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"P2EnvQueryContext_GroupSpottedTargets">();
	}
	static class UP2EnvQueryContext_GroupSpottedTargets* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UP2EnvQueryContext_GroupSpottedTargets>();
	}
};
static_assert(alignof(UP2EnvQueryContext_GroupSpottedTargets) == 0x000008, "Wrong alignment on UP2EnvQueryContext_GroupSpottedTargets");
static_assert(sizeof(UP2EnvQueryContext_GroupSpottedTargets) == 0x000028, "Wrong size on UP2EnvQueryContext_GroupSpottedTargets");

// Class AICommon.P2MeleeCondition_Composite
// 0x0018 (0x0048 - 0x0030)
class UP2MeleeCondition_Composite final : public UP2MeleeCondition
{
public:
	TArray<class UP2MeleeCondition*>              Conditions;                                        // 0x0030(0x0010)(Edit, ExportObject, ZeroConstructor, ContainsInstancedReference, UObjectWrapper, NativeAccessSpecifierPublic)
	EP2CondCompositionType                        Type;                                              // 0x0040(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_41[0x7];                                       // 0x0041(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"P2MeleeCondition_Composite">();
	}
	static class UP2MeleeCondition_Composite* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UP2MeleeCondition_Composite>();
	}
};
static_assert(alignof(UP2MeleeCondition_Composite) == 0x000008, "Wrong alignment on UP2MeleeCondition_Composite");
static_assert(sizeof(UP2MeleeCondition_Composite) == 0x000048, "Wrong size on UP2MeleeCondition_Composite");
static_assert(offsetof(UP2MeleeCondition_Composite, Conditions) == 0x000030, "Member 'UP2MeleeCondition_Composite::Conditions' has a wrong offset!");
static_assert(offsetof(UP2MeleeCondition_Composite, Type) == 0x000040, "Member 'UP2MeleeCondition_Composite::Type' has a wrong offset!");

// Class AICommon.P2EnvQueryContext_GroupVisibleTargets
// 0x0000 (0x0028 - 0x0028)
class UP2EnvQueryContext_GroupVisibleTargets final : public UEnvQueryContext
{
public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"P2EnvQueryContext_GroupVisibleTargets">();
	}
	static class UP2EnvQueryContext_GroupVisibleTargets* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UP2EnvQueryContext_GroupVisibleTargets>();
	}
};
static_assert(alignof(UP2EnvQueryContext_GroupVisibleTargets) == 0x000008, "Wrong alignment on UP2EnvQueryContext_GroupVisibleTargets");
static_assert(sizeof(UP2EnvQueryContext_GroupVisibleTargets) == 0x000028, "Wrong size on UP2EnvQueryContext_GroupVisibleTargets");

// Class AICommon.P2EnvQueryContext_GroupInterestingTargets
// 0x0000 (0x0028 - 0x0028)
class UP2EnvQueryContext_GroupInterestingTargets final : public UEnvQueryContext
{
public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"P2EnvQueryContext_GroupInterestingTargets">();
	}
	static class UP2EnvQueryContext_GroupInterestingTargets* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UP2EnvQueryContext_GroupInterestingTargets>();
	}
};
static_assert(alignof(UP2EnvQueryContext_GroupInterestingTargets) == 0x000008, "Wrong alignment on UP2EnvQueryContext_GroupInterestingTargets");
static_assert(sizeof(UP2EnvQueryContext_GroupInterestingTargets) == 0x000028, "Wrong size on UP2EnvQueryContext_GroupInterestingTargets");

// Class AICommon.P2EnvQueryContext_Members
// 0x0000 (0x0028 - 0x0028)
class UP2EnvQueryContext_Members final : public UEnvQueryContext
{
public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"P2EnvQueryContext_Members">();
	}
	static class UP2EnvQueryContext_Members* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UP2EnvQueryContext_Members>();
	}
};
static_assert(alignof(UP2EnvQueryContext_Members) == 0x000008, "Wrong alignment on UP2EnvQueryContext_Members");
static_assert(sizeof(UP2EnvQueryContext_Members) == 0x000028, "Wrong size on UP2EnvQueryContext_Members");

// Class AICommon.P2EnvQueryContext_ObjectiveLocation
// 0x0000 (0x0028 - 0x0028)
class UP2EnvQueryContext_ObjectiveLocation final : public UEnvQueryContext
{
public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"P2EnvQueryContext_ObjectiveLocation">();
	}
	static class UP2EnvQueryContext_ObjectiveLocation* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UP2EnvQueryContext_ObjectiveLocation>();
	}
};
static_assert(alignof(UP2EnvQueryContext_ObjectiveLocation) == 0x000008, "Wrong alignment on UP2EnvQueryContext_ObjectiveLocation");
static_assert(sizeof(UP2EnvQueryContext_ObjectiveLocation) == 0x000028, "Wrong size on UP2EnvQueryContext_ObjectiveLocation");

// Class AICommon.P2EnvQueryContext_PlayerBot_ExtractionTunnelLocation
// 0x0000 (0x0028 - 0x0028)
class UP2EnvQueryContext_PlayerBot_ExtractionTunnelLocation final : public UEnvQueryContext
{
public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"P2EnvQueryContext_PlayerBot_ExtractionTunnelLocation">();
	}
	static class UP2EnvQueryContext_PlayerBot_ExtractionTunnelLocation* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UP2EnvQueryContext_PlayerBot_ExtractionTunnelLocation>();
	}
};
static_assert(alignof(UP2EnvQueryContext_PlayerBot_ExtractionTunnelLocation) == 0x000008, "Wrong alignment on UP2EnvQueryContext_PlayerBot_ExtractionTunnelLocation");
static_assert(sizeof(UP2EnvQueryContext_PlayerBot_ExtractionTunnelLocation) == 0x000028, "Wrong size on UP2EnvQueryContext_PlayerBot_ExtractionTunnelLocation");

// Class AICommon.P2EnvQueryContext_PlayerBot_WayPointLocation
// 0x0000 (0x0028 - 0x0028)
class UP2EnvQueryContext_PlayerBot_WayPointLocation final : public UEnvQueryContext
{
public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"P2EnvQueryContext_PlayerBot_WayPointLocation">();
	}
	static class UP2EnvQueryContext_PlayerBot_WayPointLocation* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UP2EnvQueryContext_PlayerBot_WayPointLocation>();
	}
};
static_assert(alignof(UP2EnvQueryContext_PlayerBot_WayPointLocation) == 0x000008, "Wrong alignment on UP2EnvQueryContext_PlayerBot_WayPointLocation");
static_assert(sizeof(UP2EnvQueryContext_PlayerBot_WayPointLocation) == 0x000028, "Wrong size on UP2EnvQueryContext_PlayerBot_WayPointLocation");

// Class AICommon.P2EnvQueryContext_Rotator
// 0x0000 (0x0028 - 0x0028)
class UP2EnvQueryContext_Rotator final : public UEnvQueryContext
{
public:
	void ProvideRotation(class AActor* QuerierActor, struct FRotator* ResultingRotator, bool* bValidResult) const	 // 0x474db98;

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"P2EnvQueryContext_Rotator">();
	}
	static class UP2EnvQueryContext_Rotator* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UP2EnvQueryContext_Rotator>();
	}
};
static_assert(alignof(UP2EnvQueryContext_Rotator) == 0x000008, "Wrong alignment on UP2EnvQueryContext_Rotator");
static_assert(sizeof(UP2EnvQueryContext_Rotator) == 0x000028, "Wrong size on UP2EnvQueryContext_Rotator");

// Class AICommon.P2NpcAbility_UseNavLink
// 0x0038 (0x04D0 - 0x0498)
class UP2NpcAbility_UseNavLink : public UP2NpcAbility
{
public:
	uint8                                         Pad_498[0x38];                                     // 0x0498(0x0038)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"P2NpcAbility_UseNavLink">();
	}
	static class UP2NpcAbility_UseNavLink* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UP2NpcAbility_UseNavLink>();
	}
};
static_assert(alignof(UP2NpcAbility_UseNavLink) == 0x000008, "Wrong alignment on UP2NpcAbility_UseNavLink");
static_assert(sizeof(UP2NpcAbility_UseNavLink) == 0x0004D0, "Wrong size on UP2NpcAbility_UseNavLink");

// Class AICommon.P2NpcAbility_Climb
// 0x0038 (0x0508 - 0x04D0)
class UP2NpcAbility_Climb final : public UP2NpcAbility_UseNavLink
{
public:
	float                                         SnapToStartDuration;                               // 0x04D0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MoveUpSpeed;                                       // 0x04D4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MoveToEndSpeed;                                    // 0x04D8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4DC[0x2C];                                     // 0x04DC(0x002C)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnEndReached()	 // 0x47613b4;
	void OnMidLocationReached()	 // 0x47614f8;
	void OnMoveFailed()	 // 0x4761238;
	void OnStartReached()	 // 0x4761520;

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"P2NpcAbility_Climb">();
	}
	static class UP2NpcAbility_Climb* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UP2NpcAbility_Climb>();
	}
};
static_assert(alignof(UP2NpcAbility_Climb) == 0x000008, "Wrong alignment on UP2NpcAbility_Climb");
static_assert(sizeof(UP2NpcAbility_Climb) == 0x000508, "Wrong size on UP2NpcAbility_Climb");
static_assert(offsetof(UP2NpcAbility_Climb, SnapToStartDuration) == 0x0004D0, "Member 'UP2NpcAbility_Climb::SnapToStartDuration' has a wrong offset!");
static_assert(offsetof(UP2NpcAbility_Climb, MoveUpSpeed) == 0x0004D4, "Member 'UP2NpcAbility_Climb::MoveUpSpeed' has a wrong offset!");
static_assert(offsetof(UP2NpcAbility_Climb, MoveToEndSpeed) == 0x0004D8, "Member 'UP2NpcAbility_Climb::MoveToEndSpeed' has a wrong offset!");

// Class AICommon.P2EnvQueryContext_TargetKnownLocation
// 0x0000 (0x0028 - 0x0028)
class UP2EnvQueryContext_TargetKnownLocation final : public UEnvQueryContext
{
public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"P2EnvQueryContext_TargetKnownLocation">();
	}
	static class UP2EnvQueryContext_TargetKnownLocation* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UP2EnvQueryContext_TargetKnownLocation>();
	}
};
static_assert(alignof(UP2EnvQueryContext_TargetKnownLocation) == 0x000008, "Wrong alignment on UP2EnvQueryContext_TargetKnownLocation");
static_assert(sizeof(UP2EnvQueryContext_TargetKnownLocation) == 0x000028, "Wrong size on UP2EnvQueryContext_TargetKnownLocation");

// Class AICommon.P2EnvQueryContext_Targets
// 0x0000 (0x0028 - 0x0028)
class UP2EnvQueryContext_Targets final : public UEnvQueryContext
{
public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"P2EnvQueryContext_Targets">();
	}
	static class UP2EnvQueryContext_Targets* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UP2EnvQueryContext_Targets>();
	}
};
static_assert(alignof(UP2EnvQueryContext_Targets) == 0x000008, "Wrong alignment on UP2EnvQueryContext_Targets");
static_assert(sizeof(UP2EnvQueryContext_Targets) == 0x000028, "Wrong size on UP2EnvQueryContext_Targets");

// Class AICommon.P2EnvQueryContext_SpottedTargets
// 0x0000 (0x0028 - 0x0028)
class UP2EnvQueryContext_SpottedTargets final : public UEnvQueryContext
{
public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"P2EnvQueryContext_SpottedTargets">();
	}
	static class UP2EnvQueryContext_SpottedTargets* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UP2EnvQueryContext_SpottedTargets>();
	}
};
static_assert(alignof(UP2EnvQueryContext_SpottedTargets) == 0x000008, "Wrong alignment on UP2EnvQueryContext_SpottedTargets");
static_assert(sizeof(UP2EnvQueryContext_SpottedTargets) == 0x000028, "Wrong size on UP2EnvQueryContext_SpottedTargets");

// Class AICommon.P2NavLinkRenderingComponent
// 0x0000 (0x05B0 - 0x05B0)
class UP2NavLinkRenderingComponent final : public UNavLinkRenderingComponent
{
public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"P2NavLinkRenderingComponent">();
	}
	static class UP2NavLinkRenderingComponent* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UP2NavLinkRenderingComponent>();
	}
};
static_assert(alignof(UP2NavLinkRenderingComponent) == 0x000010, "Wrong alignment on UP2NavLinkRenderingComponent");
static_assert(sizeof(UP2NavLinkRenderingComponent) == 0x0005B0, "Wrong size on UP2NavLinkRenderingComponent");

// Class AICommon.P2EnvQueryContext_InterestingTargets
// 0x0000 (0x0028 - 0x0028)
class UP2EnvQueryContext_InterestingTargets final : public UEnvQueryContext
{
public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"P2EnvQueryContext_InterestingTargets">();
	}
	static class UP2EnvQueryContext_InterestingTargets* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UP2EnvQueryContext_InterestingTargets>();
	}
};
static_assert(alignof(UP2EnvQueryContext_InterestingTargets) == 0x000008, "Wrong alignment on UP2EnvQueryContext_InterestingTargets");
static_assert(sizeof(UP2EnvQueryContext_InterestingTargets) == 0x000028, "Wrong size on UP2EnvQueryContext_InterestingTargets");

// Class AICommon.P2EnvQueryContext_TargetsKnownLocations
// 0x0000 (0x0028 - 0x0028)
class UP2EnvQueryContext_TargetsKnownLocations final : public UEnvQueryContext
{
public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"P2EnvQueryContext_TargetsKnownLocations">();
	}
	static class UP2EnvQueryContext_TargetsKnownLocations* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UP2EnvQueryContext_TargetsKnownLocations>();
	}
};
static_assert(alignof(UP2EnvQueryContext_TargetsKnownLocations) == 0x000008, "Wrong alignment on UP2EnvQueryContext_TargetsKnownLocations");
static_assert(sizeof(UP2EnvQueryContext_TargetsKnownLocations) == 0x000028, "Wrong size on UP2EnvQueryContext_TargetsKnownLocations");

// Class AICommon.P2EnvQueryGenerator_AttackingCreatures
// 0x0000 (0x0050 - 0x0050)
class UP2EnvQueryGenerator_AttackingCreatures final : public UEnvQueryGenerator
{
public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"P2EnvQueryGenerator_AttackingCreatures">();
	}
	static class UP2EnvQueryGenerator_AttackingCreatures* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UP2EnvQueryGenerator_AttackingCreatures>();
	}
};
static_assert(alignof(UP2EnvQueryGenerator_AttackingCreatures) == 0x000008, "Wrong alignment on UP2EnvQueryGenerator_AttackingCreatures");
static_assert(sizeof(UP2EnvQueryGenerator_AttackingCreatures) == 0x000050, "Wrong size on UP2EnvQueryGenerator_AttackingCreatures");

// Class AICommon.P2EnvQueryGenerator_Cover
// 0x0078 (0x00C8 - 0x0050)
class UP2EnvQueryGenerator_Cover final : public UEnvQueryGenerator
{
public:
	struct FAIDataProviderFloatValue              SquareExtent;                                      // 0x0050(0x0038)(Edit, DisableEditOnInstance, ContainsInstancedReference, NativeAccessSpecifierPublic)
	struct FAIDataProviderFloatValue              BoxHeight;                                         // 0x0088(0x0038)(Edit, DisableEditOnInstance, ContainsInstancedReference, NativeAccessSpecifierPublic)
	TSubclassOf<class UEnvQueryContext>           GenerateAround;                                    // 0x00C0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"P2EnvQueryGenerator_Cover">();
	}
	static class UP2EnvQueryGenerator_Cover* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UP2EnvQueryGenerator_Cover>();
	}
};
static_assert(alignof(UP2EnvQueryGenerator_Cover) == 0x000008, "Wrong alignment on UP2EnvQueryGenerator_Cover");
static_assert(sizeof(UP2EnvQueryGenerator_Cover) == 0x0000C8, "Wrong size on UP2EnvQueryGenerator_Cover");
static_assert(offsetof(UP2EnvQueryGenerator_Cover, SquareExtent) == 0x000050, "Member 'UP2EnvQueryGenerator_Cover::SquareExtent' has a wrong offset!");
static_assert(offsetof(UP2EnvQueryGenerator_Cover, BoxHeight) == 0x000088, "Member 'UP2EnvQueryGenerator_Cover::BoxHeight' has a wrong offset!");
static_assert(offsetof(UP2EnvQueryGenerator_Cover, GenerateAround) == 0x0000C0, "Member 'UP2EnvQueryGenerator_Cover::GenerateAround' has a wrong offset!");

// Class AICommon.P2EnvQueryGenerator_CurrentCover
// 0x0008 (0x0058 - 0x0050)
class UP2EnvQueryGenerator_CurrentCover final : public UEnvQueryGenerator
{
public:
	class FName                                   CoverBlackboardKeyName;                            // 0x0050(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"P2EnvQueryGenerator_CurrentCover">();
	}
	static class UP2EnvQueryGenerator_CurrentCover* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UP2EnvQueryGenerator_CurrentCover>();
	}
};
static_assert(alignof(UP2EnvQueryGenerator_CurrentCover) == 0x000008, "Wrong alignment on UP2EnvQueryGenerator_CurrentCover");
static_assert(sizeof(UP2EnvQueryGenerator_CurrentCover) == 0x000058, "Wrong size on UP2EnvQueryGenerator_CurrentCover");
static_assert(offsetof(UP2EnvQueryGenerator_CurrentCover, CoverBlackboardKeyName) == 0x000050, "Member 'UP2EnvQueryGenerator_CurrentCover::CoverBlackboardKeyName' has a wrong offset!");

// Class AICommon.P2EnvQueryGenerator_GroupTargets
// 0x0020 (0x0070 - 0x0050)
class UP2EnvQueryGenerator_GroupTargets final : public UEnvQueryGenerator
{
public:
	uint8                                         bSpottedOnly : 1;                                  // 0x0050(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bVisibleOnly : 1;                                  // 0x0050(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         Pad_51[0x7];                                       // 0x0051(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector2D                              InterestLevelLimits;                               // 0x0058(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MinSpottedTime;                                    // 0x0068(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MinVisibleTime;                                    // 0x006C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"P2EnvQueryGenerator_GroupTargets">();
	}
	static class UP2EnvQueryGenerator_GroupTargets* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UP2EnvQueryGenerator_GroupTargets>();
	}
};
static_assert(alignof(UP2EnvQueryGenerator_GroupTargets) == 0x000008, "Wrong alignment on UP2EnvQueryGenerator_GroupTargets");
static_assert(sizeof(UP2EnvQueryGenerator_GroupTargets) == 0x000070, "Wrong size on UP2EnvQueryGenerator_GroupTargets");
static_assert(offsetof(UP2EnvQueryGenerator_GroupTargets, InterestLevelLimits) == 0x000058, "Member 'UP2EnvQueryGenerator_GroupTargets::InterestLevelLimits' has a wrong offset!");
static_assert(offsetof(UP2EnvQueryGenerator_GroupTargets, MinSpottedTime) == 0x000068, "Member 'UP2EnvQueryGenerator_GroupTargets::MinSpottedTime' has a wrong offset!");
static_assert(offsetof(UP2EnvQueryGenerator_GroupTargets, MinVisibleTime) == 0x00006C, "Member 'UP2EnvQueryGenerator_GroupTargets::MinVisibleTime' has a wrong offset!");

// Class AICommon.P2EnvQueryGenerator_MeleeTargetSlots
// 0x0010 (0x0060 - 0x0050)
class UP2EnvQueryGenerator_MeleeTargetSlots final : public UEnvQueryGenerator
{
public:
	TSubclassOf<class UEnvQueryContext>           TargetContext;                                     // 0x0050(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Distance;                                          // 0x0058(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5C[0x4];                                       // 0x005C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"P2EnvQueryGenerator_MeleeTargetSlots">();
	}
	static class UP2EnvQueryGenerator_MeleeTargetSlots* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UP2EnvQueryGenerator_MeleeTargetSlots>();
	}
};
static_assert(alignof(UP2EnvQueryGenerator_MeleeTargetSlots) == 0x000008, "Wrong alignment on UP2EnvQueryGenerator_MeleeTargetSlots");
static_assert(sizeof(UP2EnvQueryGenerator_MeleeTargetSlots) == 0x000060, "Wrong size on UP2EnvQueryGenerator_MeleeTargetSlots");
static_assert(offsetof(UP2EnvQueryGenerator_MeleeTargetSlots, TargetContext) == 0x000050, "Member 'UP2EnvQueryGenerator_MeleeTargetSlots::TargetContext' has a wrong offset!");
static_assert(offsetof(UP2EnvQueryGenerator_MeleeTargetSlots, Distance) == 0x000058, "Member 'UP2EnvQueryGenerator_MeleeTargetSlots::Distance' has a wrong offset!");

// Class AICommon.P2NavLinkMontageData
// 0x0010 (0x0040 - 0x0030)
class UP2NavLinkMontageData final : public UDataAsset
{
public:
	TArray<struct FP2_NavLinkMontageData>         Montages;                                          // 0x0030(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"P2NavLinkMontageData">();
	}
	static class UP2NavLinkMontageData* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UP2NavLinkMontageData>();
	}
};
static_assert(alignof(UP2NavLinkMontageData) == 0x000008, "Wrong alignment on UP2NavLinkMontageData");
static_assert(sizeof(UP2NavLinkMontageData) == 0x000040, "Wrong size on UP2NavLinkMontageData");
static_assert(offsetof(UP2NavLinkMontageData, Montages) == 0x000030, "Member 'UP2NavLinkMontageData::Montages' has a wrong offset!");

// Class AICommon.P2EnvQueryGenerator_MercunaSimpleGrid
// 0x0000 (0x0108 - 0x0108)
class UP2EnvQueryGenerator_MercunaSimpleGrid final : public UEnvQueryGenerator_SimpleGrid
{
public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"P2EnvQueryGenerator_MercunaSimpleGrid">();
	}
	static class UP2EnvQueryGenerator_MercunaSimpleGrid* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UP2EnvQueryGenerator_MercunaSimpleGrid>();
	}
};
static_assert(alignof(UP2EnvQueryGenerator_MercunaSimpleGrid) == 0x000008, "Wrong alignment on UP2EnvQueryGenerator_MercunaSimpleGrid");
static_assert(sizeof(UP2EnvQueryGenerator_MercunaSimpleGrid) == 0x000108, "Wrong size on UP2EnvQueryGenerator_MercunaSimpleGrid");

// Class AICommon.P2EnvQueryGenerator_Objectives
// 0x0000 (0x0050 - 0x0050)
class UP2EnvQueryGenerator_Objectives final : public UEnvQueryGenerator
{
public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"P2EnvQueryGenerator_Objectives">();
	}
	static class UP2EnvQueryGenerator_Objectives* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UP2EnvQueryGenerator_Objectives>();
	}
};
static_assert(alignof(UP2EnvQueryGenerator_Objectives) == 0x000008, "Wrong alignment on UP2EnvQueryGenerator_Objectives");
static_assert(sizeof(UP2EnvQueryGenerator_Objectives) == 0x000050, "Wrong size on UP2EnvQueryGenerator_Objectives");

// Class AICommon.P2EnvQueryGenerator_SmartObjects
// 0x0088 (0x00D8 - 0x0050)
class UP2EnvQueryGenerator_SmartObjects final : public UEnvQueryGenerator
{
public:
	struct FAIDataProviderFloatValue              SearchRadius;                                      // 0x0050(0x0038)(Edit, DisableEditOnInstance, ContainsInstancedReference, NativeAccessSpecifierPublic)
	TSubclassOf<class UEnvQueryContext>           SearchCenter;                                      // 0x0088(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTagQuery                      SmartObjectTagsFilter;                             // 0x0090(0x0048)(Edit, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"P2EnvQueryGenerator_SmartObjects">();
	}
	static class UP2EnvQueryGenerator_SmartObjects* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UP2EnvQueryGenerator_SmartObjects>();
	}
};
static_assert(alignof(UP2EnvQueryGenerator_SmartObjects) == 0x000008, "Wrong alignment on UP2EnvQueryGenerator_SmartObjects");
static_assert(sizeof(UP2EnvQueryGenerator_SmartObjects) == 0x0000D8, "Wrong size on UP2EnvQueryGenerator_SmartObjects");
static_assert(offsetof(UP2EnvQueryGenerator_SmartObjects, SearchRadius) == 0x000050, "Member 'UP2EnvQueryGenerator_SmartObjects::SearchRadius' has a wrong offset!");
static_assert(offsetof(UP2EnvQueryGenerator_SmartObjects, SearchCenter) == 0x000088, "Member 'UP2EnvQueryGenerator_SmartObjects::SearchCenter' has a wrong offset!");
static_assert(offsetof(UP2EnvQueryGenerator_SmartObjects, SmartObjectTagsFilter) == 0x000090, "Member 'UP2EnvQueryGenerator_SmartObjects::SmartObjectTagsFilter' has a wrong offset!");

// Class AICommon.P2NpcAudioDataAsset
// 0x0000 (0x0100 - 0x0100)
class UP2NpcAudioDataAsset : public UP2AudioDataAsset
{
public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"P2NpcAudioDataAsset">();
	}
	static class UP2NpcAudioDataAsset* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UP2NpcAudioDataAsset>();
	}
};
static_assert(alignof(UP2NpcAudioDataAsset) == 0x000008, "Wrong alignment on UP2NpcAudioDataAsset");
static_assert(sizeof(UP2NpcAudioDataAsset) == 0x000100, "Wrong size on UP2NpcAudioDataAsset");

// Class AICommon.P2EnvQueryGenerator_Targets
// 0x0018 (0x0068 - 0x0050)
class UP2EnvQueryGenerator_Targets final : public UEnvQueryGenerator
{
public:
	uint8                                         bSpottedOnly : 1;                                  // 0x0050(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bVisibleOnly : 1;                                  // 0x0050(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         Pad_51[0x7];                                       // 0x0051(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector2D                              InterestLevelLimits;                               // 0x0058(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"P2EnvQueryGenerator_Targets">();
	}
	static class UP2EnvQueryGenerator_Targets* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UP2EnvQueryGenerator_Targets>();
	}
};
static_assert(alignof(UP2EnvQueryGenerator_Targets) == 0x000008, "Wrong alignment on UP2EnvQueryGenerator_Targets");
static_assert(sizeof(UP2EnvQueryGenerator_Targets) == 0x000068, "Wrong size on UP2EnvQueryGenerator_Targets");
static_assert(offsetof(UP2EnvQueryGenerator_Targets, InterestLevelLimits) == 0x000058, "Member 'UP2EnvQueryGenerator_Targets::InterestLevelLimits' has a wrong offset!");

// Class AICommon.P2MontageMatchingSubsystem
// 0x0050 (0x0080 - 0x0030)
class UP2MontageMatchingSubsystem final : public UWorldSubsystem
{
public:
	uint8                                         Pad_30[0x50];                                      // 0x0030(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"P2MontageMatchingSubsystem">();
	}
	static class UP2MontageMatchingSubsystem* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UP2MontageMatchingSubsystem>();
	}
};
static_assert(alignof(UP2MontageMatchingSubsystem) == 0x000008, "Wrong alignment on UP2MontageMatchingSubsystem");
static_assert(sizeof(UP2MontageMatchingSubsystem) == 0x000080, "Wrong size on UP2MontageMatchingSubsystem");

// Class AICommon.P2EnvQueryGenerator_Water
// 0x0010 (0x0060 - 0x0050)
class UP2EnvQueryGenerator_Water final : public UEnvQueryGenerator
{
public:
	TSubclassOf<class UEnvQueryContext>           ContextToFindClosestWaterPoints;                   // 0x0050(0x0008)(Edit, ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bFindLakes;                                        // 0x0058(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bFindRivers;                                       // 0x0059(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bFindOceans;                                       // 0x005A(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_5B[0x5];                                       // 0x005B(0x0005)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"P2EnvQueryGenerator_Water">();
	}
	static class UP2EnvQueryGenerator_Water* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UP2EnvQueryGenerator_Water>();
	}
};
static_assert(alignof(UP2EnvQueryGenerator_Water) == 0x000008, "Wrong alignment on UP2EnvQueryGenerator_Water");
static_assert(sizeof(UP2EnvQueryGenerator_Water) == 0x000060, "Wrong size on UP2EnvQueryGenerator_Water");
static_assert(offsetof(UP2EnvQueryGenerator_Water, ContextToFindClosestWaterPoints) == 0x000050, "Member 'UP2EnvQueryGenerator_Water::ContextToFindClosestWaterPoints' has a wrong offset!");
static_assert(offsetof(UP2EnvQueryGenerator_Water, bFindLakes) == 0x000058, "Member 'UP2EnvQueryGenerator_Water::bFindLakes' has a wrong offset!");
static_assert(offsetof(UP2EnvQueryGenerator_Water, bFindRivers) == 0x000059, "Member 'UP2EnvQueryGenerator_Water::bFindRivers' has a wrong offset!");
static_assert(offsetof(UP2EnvQueryGenerator_Water, bFindOceans) == 0x00005A, "Member 'UP2EnvQueryGenerator_Water::bFindOceans' has a wrong offset!");

// Class AICommon.P2EnvQueryItemType_Cover
// 0x0000 (0x0030 - 0x0030)
class UP2EnvQueryItemType_Cover final : public UEnvQueryItemType_VectorBase
{
public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"P2EnvQueryItemType_Cover">();
	}
	static class UP2EnvQueryItemType_Cover* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UP2EnvQueryItemType_Cover>();
	}
};
static_assert(alignof(UP2EnvQueryItemType_Cover) == 0x000008, "Wrong alignment on UP2EnvQueryItemType_Cover");
static_assert(sizeof(UP2EnvQueryItemType_Cover) == 0x000030, "Wrong size on UP2EnvQueryItemType_Cover");

// Class AICommon.P2NpcAbilitySystemComponent
// 0x0000 (0x1970 - 0x1970)
class UP2NpcAbilitySystemComponent final : public UP2AbilitySystemComponent
{
public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"P2NpcAbilitySystemComponent">();
	}
	static class UP2NpcAbilitySystemComponent* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UP2NpcAbilitySystemComponent>();
	}
};
static_assert(alignof(UP2NpcAbilitySystemComponent) == 0x000010, "Wrong alignment on UP2NpcAbilitySystemComponent");
static_assert(sizeof(UP2NpcAbilitySystemComponent) == 0x001970, "Wrong size on UP2NpcAbilitySystemComponent");

// Class AICommon.P2EnvQueryItemType_MeleeSlot
// 0x0000 (0x0030 - 0x0030)
class UP2EnvQueryItemType_MeleeSlot final : public UEnvQueryItemType_VectorBase
{
public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"P2EnvQueryItemType_MeleeSlot">();
	}
	static class UP2EnvQueryItemType_MeleeSlot* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UP2EnvQueryItemType_MeleeSlot>();
	}
};
static_assert(alignof(UP2EnvQueryItemType_MeleeSlot) == 0x000008, "Wrong alignment on UP2EnvQueryItemType_MeleeSlot");
static_assert(sizeof(UP2EnvQueryItemType_MeleeSlot) == 0x000030, "Wrong size on UP2EnvQueryItemType_MeleeSlot");

// Class AICommon.P2EnvQueryItemType_SmartObject
// 0x0000 (0x0030 - 0x0030)
class UP2EnvQueryItemType_SmartObject final : public UEnvQueryItemType_VectorBase
{
public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"P2EnvQueryItemType_SmartObject">();
	}
	static class UP2EnvQueryItemType_SmartObject* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UP2EnvQueryItemType_SmartObject>();
	}
};
static_assert(alignof(UP2EnvQueryItemType_SmartObject) == 0x000008, "Wrong alignment on UP2EnvQueryItemType_SmartObject");
static_assert(sizeof(UP2EnvQueryItemType_SmartObject) == 0x000030, "Wrong size on UP2EnvQueryItemType_SmartObject");

// Class AICommon.P2DynamicNavLinkGenerationSettings
// 0x00D8 (0x0110 - 0x0038)
class UP2DynamicNavLinkGenerationSettings final : public UDeveloperSettings
{
public:
	double                                        WorldSize;                                         // 0x0038(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	double                                        MinDistanceBetweenPoints;                          // 0x0040(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FMercunaAgentType                      AgentType;                                         // 0x0048(0x000C)(Edit, Config, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_54[0x4];                                       // 0x0054(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FMercunaSupportedAgentTypes            AgentTypes;                                        // 0x0058(0x00A8)(Edit, Config, NativeAccessSpecifierPublic)
	TSubclassOf<class AP2JumpNavLink>             JumpNavLinkClass;                                  // 0x0100(0x0008)(Edit, ZeroConstructor, Config, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class AP2VaultNavLink>            VaultNavLinkClass;                                 // 0x0108(0x0008)(Edit, ZeroConstructor, Config, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"P2DynamicNavLinkGenerationSettings">();
	}
	static class UP2DynamicNavLinkGenerationSettings* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UP2DynamicNavLinkGenerationSettings>();
	}
};
static_assert(alignof(UP2DynamicNavLinkGenerationSettings) == 0x000008, "Wrong alignment on UP2DynamicNavLinkGenerationSettings");
static_assert(sizeof(UP2DynamicNavLinkGenerationSettings) == 0x000110, "Wrong size on UP2DynamicNavLinkGenerationSettings");
static_assert(offsetof(UP2DynamicNavLinkGenerationSettings, WorldSize) == 0x000038, "Member 'UP2DynamicNavLinkGenerationSettings::WorldSize' has a wrong offset!");
static_assert(offsetof(UP2DynamicNavLinkGenerationSettings, MinDistanceBetweenPoints) == 0x000040, "Member 'UP2DynamicNavLinkGenerationSettings::MinDistanceBetweenPoints' has a wrong offset!");
static_assert(offsetof(UP2DynamicNavLinkGenerationSettings, AgentType) == 0x000048, "Member 'UP2DynamicNavLinkGenerationSettings::AgentType' has a wrong offset!");
static_assert(offsetof(UP2DynamicNavLinkGenerationSettings, AgentTypes) == 0x000058, "Member 'UP2DynamicNavLinkGenerationSettings::AgentTypes' has a wrong offset!");
static_assert(offsetof(UP2DynamicNavLinkGenerationSettings, JumpNavLinkClass) == 0x000100, "Member 'UP2DynamicNavLinkGenerationSettings::JumpNavLinkClass' has a wrong offset!");
static_assert(offsetof(UP2DynamicNavLinkGenerationSettings, VaultNavLinkClass) == 0x000108, "Member 'UP2DynamicNavLinkGenerationSettings::VaultNavLinkClass' has a wrong offset!");

// Class AICommon.P2EnvQueryItemType_Target
// 0x0000 (0x0030 - 0x0030)
class UP2EnvQueryItemType_Target final : public UEnvQueryItemType_Actor
{
public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"P2EnvQueryItemType_Target">();
	}
	static class UP2EnvQueryItemType_Target* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UP2EnvQueryItemType_Target>();
	}
};
static_assert(alignof(UP2EnvQueryItemType_Target) == 0x000008, "Wrong alignment on UP2EnvQueryItemType_Target");
static_assert(sizeof(UP2EnvQueryItemType_Target) == 0x000030, "Wrong size on UP2EnvQueryItemType_Target");

// Class AICommon.P2EnvQueryTest_AlertedLevel
// 0x0008 (0x0210 - 0x0208)
class UP2EnvQueryTest_AlertedLevel final : public UEnvQueryTest
{
public:
	EP2PerceptionAlertedLevelType                 RequiredLevel;                                     // 0x0208(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_209[0x7];                                      // 0x0209(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"P2EnvQueryTest_AlertedLevel">();
	}
	static class UP2EnvQueryTest_AlertedLevel* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UP2EnvQueryTest_AlertedLevel>();
	}
};
static_assert(alignof(UP2EnvQueryTest_AlertedLevel) == 0x000008, "Wrong alignment on UP2EnvQueryTest_AlertedLevel");
static_assert(sizeof(UP2EnvQueryTest_AlertedLevel) == 0x000210, "Wrong size on UP2EnvQueryTest_AlertedLevel");
static_assert(offsetof(UP2EnvQueryTest_AlertedLevel, RequiredLevel) == 0x000208, "Member 'UP2EnvQueryTest_AlertedLevel::RequiredLevel' has a wrong offset!");

// Class AICommon.P2EnvQueryTest_Alive
// 0x0000 (0x0208 - 0x0208)
class UP2EnvQueryTest_Alive final : public UEnvQueryTest
{
public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"P2EnvQueryTest_Alive">();
	}
	static class UP2EnvQueryTest_Alive* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UP2EnvQueryTest_Alive>();
	}
};
static_assert(alignof(UP2EnvQueryTest_Alive) == 0x000008, "Wrong alignment on UP2EnvQueryTest_Alive");
static_assert(sizeof(UP2EnvQueryTest_Alive) == 0x000208, "Wrong size on UP2EnvQueryTest_Alive");

// Class AICommon.P2NpcAbility_BruteRoar
// 0x0040 (0x0500 - 0x04C0)
class UP2NpcAbility_BruteRoar final : public UP2NpcAbility_MontageBasedAttack
{
public:
	float                                         DpsThreshold;                                      // 0x04C0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DpsMaxTime;                                        // 0x04C4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCurveFloat*                            StunTypeCurve;                                     // 0x04C8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         StunDistanceRange;                                 // 0x04D0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4D4[0x4];                                      // 0x04D4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class UCameraShakeBase>           RoarCameraShakeClass;                              // 0x04D8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ScreenShakeDistanceRange;                          // 0x04E0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4E4[0x4];                                      // 0x04E4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FP2BruteRoarStatusEffectConfig> StatusEffectConfigs;                               // 0x04E8(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	float                                         ScreenShakeFalloff;                                // 0x04F8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         NpcCallDistanceRange;                              // 0x04FC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"P2NpcAbility_BruteRoar">();
	}
	static class UP2NpcAbility_BruteRoar* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UP2NpcAbility_BruteRoar>();
	}
};
static_assert(alignof(UP2NpcAbility_BruteRoar) == 0x000008, "Wrong alignment on UP2NpcAbility_BruteRoar");
static_assert(sizeof(UP2NpcAbility_BruteRoar) == 0x000500, "Wrong size on UP2NpcAbility_BruteRoar");
static_assert(offsetof(UP2NpcAbility_BruteRoar, DpsThreshold) == 0x0004C0, "Member 'UP2NpcAbility_BruteRoar::DpsThreshold' has a wrong offset!");
static_assert(offsetof(UP2NpcAbility_BruteRoar, DpsMaxTime) == 0x0004C4, "Member 'UP2NpcAbility_BruteRoar::DpsMaxTime' has a wrong offset!");
static_assert(offsetof(UP2NpcAbility_BruteRoar, StunTypeCurve) == 0x0004C8, "Member 'UP2NpcAbility_BruteRoar::StunTypeCurve' has a wrong offset!");
static_assert(offsetof(UP2NpcAbility_BruteRoar, StunDistanceRange) == 0x0004D0, "Member 'UP2NpcAbility_BruteRoar::StunDistanceRange' has a wrong offset!");
static_assert(offsetof(UP2NpcAbility_BruteRoar, RoarCameraShakeClass) == 0x0004D8, "Member 'UP2NpcAbility_BruteRoar::RoarCameraShakeClass' has a wrong offset!");
static_assert(offsetof(UP2NpcAbility_BruteRoar, ScreenShakeDistanceRange) == 0x0004E0, "Member 'UP2NpcAbility_BruteRoar::ScreenShakeDistanceRange' has a wrong offset!");
static_assert(offsetof(UP2NpcAbility_BruteRoar, StatusEffectConfigs) == 0x0004E8, "Member 'UP2NpcAbility_BruteRoar::StatusEffectConfigs' has a wrong offset!");
static_assert(offsetof(UP2NpcAbility_BruteRoar, ScreenShakeFalloff) == 0x0004F8, "Member 'UP2NpcAbility_BruteRoar::ScreenShakeFalloff' has a wrong offset!");
static_assert(offsetof(UP2NpcAbility_BruteRoar, NpcCallDistanceRange) == 0x0004FC, "Member 'UP2NpcAbility_BruteRoar::NpcCallDistanceRange' has a wrong offset!");

// Class AICommon.P2EnvQueryTest_AvoidWhilePathing
// 0x00B8 (0x02C0 - 0x0208)
class UP2EnvQueryTest_AvoidWhilePathing final : public UEnvQueryTest
{
public:
	TSubclassOf<class UEnvQueryContext>           ContextToAvoid;                                    // 0x0208(0x0008)(Edit, ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FAIDataProviderBoolValue               SkipUnreachable;                                   // 0x0210(0x0038)(Edit, DisableEditOnInstance, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	struct FAIDataProviderFloatValue              LateralDistanceWeight;                             // 0x0248(0x0038)(Edit, DisableEditOnInstance, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	struct FAIDataProviderFloatValue              CurvilinearDistanceWeight;                         // 0x0280(0x0038)(Edit, DisableEditOnInstance, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	TSubclassOf<class UNavigationQueryFilter>     FilterClass;                                       // 0x02B8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"P2EnvQueryTest_AvoidWhilePathing">();
	}
	static class UP2EnvQueryTest_AvoidWhilePathing* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UP2EnvQueryTest_AvoidWhilePathing>();
	}
};
static_assert(alignof(UP2EnvQueryTest_AvoidWhilePathing) == 0x000008, "Wrong alignment on UP2EnvQueryTest_AvoidWhilePathing");
static_assert(sizeof(UP2EnvQueryTest_AvoidWhilePathing) == 0x0002C0, "Wrong size on UP2EnvQueryTest_AvoidWhilePathing");
static_assert(offsetof(UP2EnvQueryTest_AvoidWhilePathing, ContextToAvoid) == 0x000208, "Member 'UP2EnvQueryTest_AvoidWhilePathing::ContextToAvoid' has a wrong offset!");
static_assert(offsetof(UP2EnvQueryTest_AvoidWhilePathing, SkipUnreachable) == 0x000210, "Member 'UP2EnvQueryTest_AvoidWhilePathing::SkipUnreachable' has a wrong offset!");
static_assert(offsetof(UP2EnvQueryTest_AvoidWhilePathing, LateralDistanceWeight) == 0x000248, "Member 'UP2EnvQueryTest_AvoidWhilePathing::LateralDistanceWeight' has a wrong offset!");
static_assert(offsetof(UP2EnvQueryTest_AvoidWhilePathing, CurvilinearDistanceWeight) == 0x000280, "Member 'UP2EnvQueryTest_AvoidWhilePathing::CurvilinearDistanceWeight' has a wrong offset!");
static_assert(offsetof(UP2EnvQueryTest_AvoidWhilePathing, FilterClass) == 0x0002B8, "Member 'UP2EnvQueryTest_AvoidWhilePathing::FilterClass' has a wrong offset!");

// Class AICommon.P2NpcAbility_BombugMeleeDive
// 0x00D8 (0x0570 - 0x0498)
class UP2NpcAbility_BombugMeleeDive final : public UP2NpcAbility
{
public:
	uint8                                         Pad_498[0x8];                                      // 0x0498(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class UP2GameplayEffect_Damage>   DamageEffectClass;                                 // 0x04A0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         StunChance;                                        // 0x04A8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           StunTag;                                           // 0x04AC(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Speed;                                             // 0x04B4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AngularSpeed;                                      // 0x04B8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxAngleToStart;                                   // 0x04BC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxAngleToHit;                                     // 0x04C0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   TargetBoneName;                                    // 0x04C4(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4CC[0x4];                                      // 0x04CC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                TargetOffset;                                      // 0x04D0(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                DiveVertexOffset;                                  // 0x04E8(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UAnimInstance>              AnimLayer;                                         // 0x0500(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PreparationTime;                                   // 0x0508(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DelayAfterHit;                                     // 0x050C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BoxHitCheckHalfSize;                               // 0x0510(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_514[0x4];                                      // 0x0514(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                HitOffset;                                         // 0x0518(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                HitRandomOffsetAdditionBounds;                     // 0x0530(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                MissOffset;                                        // 0x0548(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxTargetDistanceChange;                           // 0x0560(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SweepRadius;                                       // 0x0564(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         OverrideHandle;                                    // 0x0568(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_56C[0x4];                                      // 0x056C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"P2NpcAbility_BombugMeleeDive">();
	}
	static class UP2NpcAbility_BombugMeleeDive* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UP2NpcAbility_BombugMeleeDive>();
	}
};
static_assert(alignof(UP2NpcAbility_BombugMeleeDive) == 0x000008, "Wrong alignment on UP2NpcAbility_BombugMeleeDive");
static_assert(sizeof(UP2NpcAbility_BombugMeleeDive) == 0x000570, "Wrong size on UP2NpcAbility_BombugMeleeDive");
static_assert(offsetof(UP2NpcAbility_BombugMeleeDive, DamageEffectClass) == 0x0004A0, "Member 'UP2NpcAbility_BombugMeleeDive::DamageEffectClass' has a wrong offset!");
static_assert(offsetof(UP2NpcAbility_BombugMeleeDive, StunChance) == 0x0004A8, "Member 'UP2NpcAbility_BombugMeleeDive::StunChance' has a wrong offset!");
static_assert(offsetof(UP2NpcAbility_BombugMeleeDive, StunTag) == 0x0004AC, "Member 'UP2NpcAbility_BombugMeleeDive::StunTag' has a wrong offset!");
static_assert(offsetof(UP2NpcAbility_BombugMeleeDive, Speed) == 0x0004B4, "Member 'UP2NpcAbility_BombugMeleeDive::Speed' has a wrong offset!");
static_assert(offsetof(UP2NpcAbility_BombugMeleeDive, AngularSpeed) == 0x0004B8, "Member 'UP2NpcAbility_BombugMeleeDive::AngularSpeed' has a wrong offset!");
static_assert(offsetof(UP2NpcAbility_BombugMeleeDive, MaxAngleToStart) == 0x0004BC, "Member 'UP2NpcAbility_BombugMeleeDive::MaxAngleToStart' has a wrong offset!");
static_assert(offsetof(UP2NpcAbility_BombugMeleeDive, MaxAngleToHit) == 0x0004C0, "Member 'UP2NpcAbility_BombugMeleeDive::MaxAngleToHit' has a wrong offset!");
static_assert(offsetof(UP2NpcAbility_BombugMeleeDive, TargetBoneName) == 0x0004C4, "Member 'UP2NpcAbility_BombugMeleeDive::TargetBoneName' has a wrong offset!");
static_assert(offsetof(UP2NpcAbility_BombugMeleeDive, TargetOffset) == 0x0004D0, "Member 'UP2NpcAbility_BombugMeleeDive::TargetOffset' has a wrong offset!");
static_assert(offsetof(UP2NpcAbility_BombugMeleeDive, DiveVertexOffset) == 0x0004E8, "Member 'UP2NpcAbility_BombugMeleeDive::DiveVertexOffset' has a wrong offset!");
static_assert(offsetof(UP2NpcAbility_BombugMeleeDive, AnimLayer) == 0x000500, "Member 'UP2NpcAbility_BombugMeleeDive::AnimLayer' has a wrong offset!");
static_assert(offsetof(UP2NpcAbility_BombugMeleeDive, PreparationTime) == 0x000508, "Member 'UP2NpcAbility_BombugMeleeDive::PreparationTime' has a wrong offset!");
static_assert(offsetof(UP2NpcAbility_BombugMeleeDive, DelayAfterHit) == 0x00050C, "Member 'UP2NpcAbility_BombugMeleeDive::DelayAfterHit' has a wrong offset!");
static_assert(offsetof(UP2NpcAbility_BombugMeleeDive, BoxHitCheckHalfSize) == 0x000510, "Member 'UP2NpcAbility_BombugMeleeDive::BoxHitCheckHalfSize' has a wrong offset!");
static_assert(offsetof(UP2NpcAbility_BombugMeleeDive, HitOffset) == 0x000518, "Member 'UP2NpcAbility_BombugMeleeDive::HitOffset' has a wrong offset!");
static_assert(offsetof(UP2NpcAbility_BombugMeleeDive, HitRandomOffsetAdditionBounds) == 0x000530, "Member 'UP2NpcAbility_BombugMeleeDive::HitRandomOffsetAdditionBounds' has a wrong offset!");
static_assert(offsetof(UP2NpcAbility_BombugMeleeDive, MissOffset) == 0x000548, "Member 'UP2NpcAbility_BombugMeleeDive::MissOffset' has a wrong offset!");
static_assert(offsetof(UP2NpcAbility_BombugMeleeDive, MaxTargetDistanceChange) == 0x000560, "Member 'UP2NpcAbility_BombugMeleeDive::MaxTargetDistanceChange' has a wrong offset!");
static_assert(offsetof(UP2NpcAbility_BombugMeleeDive, SweepRadius) == 0x000564, "Member 'UP2NpcAbility_BombugMeleeDive::SweepRadius' has a wrong offset!");
static_assert(offsetof(UP2NpcAbility_BombugMeleeDive, OverrideHandle) == 0x000568, "Member 'UP2NpcAbility_BombugMeleeDive::OverrideHandle' has a wrong offset!");

// Class AICommon.P2EnvQueryTest_CurrentTarget
// 0x0008 (0x0210 - 0x0208)
class UP2EnvQueryTest_CurrentTarget final : public UEnvQueryTest
{
public:
	bool                                          bCheckReachability;                                // 0x0208(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_209[0x7];                                      // 0x0209(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"P2EnvQueryTest_CurrentTarget">();
	}
	static class UP2EnvQueryTest_CurrentTarget* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UP2EnvQueryTest_CurrentTarget>();
	}
};
static_assert(alignof(UP2EnvQueryTest_CurrentTarget) == 0x000008, "Wrong alignment on UP2EnvQueryTest_CurrentTarget");
static_assert(sizeof(UP2EnvQueryTest_CurrentTarget) == 0x000210, "Wrong size on UP2EnvQueryTest_CurrentTarget");
static_assert(offsetof(UP2EnvQueryTest_CurrentTarget, bCheckReachability) == 0x000208, "Member 'UP2EnvQueryTest_CurrentTarget::bCheckReachability' has a wrong offset!");

// Class AICommon.P2EnvQueryTest_Damage
// 0x00E0 (0x02E8 - 0x0208)
class UP2EnvQueryTest_Damage final : public UEnvQueryTest
{
public:
	struct FP2AIDataProvider_DamageQuery          DamageQuery;                                       // 0x0208(0x0038)(Edit, DisableEditOnInstance, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	struct FAIDataProviderFloatValue              DamagePerSecondWindow;                             // 0x0240(0x0038)(Edit, DisableEditOnInstance, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	struct FAIDataProviderFloatValue              DamageMin;                                         // 0x0278(0x0038)(Edit, DisableEditOnInstance, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	struct FAIDataProviderFloatValue              DamageMax;                                         // 0x02B0(0x0038)(Edit, DisableEditOnInstance, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"P2EnvQueryTest_Damage">();
	}
	static class UP2EnvQueryTest_Damage* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UP2EnvQueryTest_Damage>();
	}
};
static_assert(alignof(UP2EnvQueryTest_Damage) == 0x000008, "Wrong alignment on UP2EnvQueryTest_Damage");
static_assert(sizeof(UP2EnvQueryTest_Damage) == 0x0002E8, "Wrong size on UP2EnvQueryTest_Damage");
static_assert(offsetof(UP2EnvQueryTest_Damage, DamageQuery) == 0x000208, "Member 'UP2EnvQueryTest_Damage::DamageQuery' has a wrong offset!");
static_assert(offsetof(UP2EnvQueryTest_Damage, DamagePerSecondWindow) == 0x000240, "Member 'UP2EnvQueryTest_Damage::DamagePerSecondWindow' has a wrong offset!");
static_assert(offsetof(UP2EnvQueryTest_Damage, DamageMin) == 0x000278, "Member 'UP2EnvQueryTest_Damage::DamageMin' has a wrong offset!");
static_assert(offsetof(UP2EnvQueryTest_Damage, DamageMax) == 0x0002B0, "Member 'UP2EnvQueryTest_Damage::DamageMax' has a wrong offset!");

// Class AICommon.P2EnvQueryTest_Dbno
// 0x0038 (0x0240 - 0x0208)
class UP2EnvQueryTest_Dbno final : public UEnvQueryTest
{
public:
	struct FP2AIDataProvider_DbnoQuery            DbnoQuery;                                         // 0x0208(0x0038)(Edit, DisableEditOnInstance, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"P2EnvQueryTest_Dbno">();
	}
	static class UP2EnvQueryTest_Dbno* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UP2EnvQueryTest_Dbno>();
	}
};
static_assert(alignof(UP2EnvQueryTest_Dbno) == 0x000008, "Wrong alignment on UP2EnvQueryTest_Dbno");
static_assert(sizeof(UP2EnvQueryTest_Dbno) == 0x000240, "Wrong size on UP2EnvQueryTest_Dbno");
static_assert(offsetof(UP2EnvQueryTest_Dbno, DbnoQuery) == 0x000208, "Member 'UP2EnvQueryTest_Dbno::DbnoQuery' has a wrong offset!");

// Class AICommon.P2NpcAbility_BruteThrowActive
// 0x00C0 (0x0558 - 0x0498)
class UP2NpcAbility_BruteThrowActive final : public UP2NpcAbility
{
public:
	uint8                                         Pad_498[0xC0];                                     // 0x0498(0x00C0)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnAnimationEnded()	 // 0x4761238;

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"P2NpcAbility_BruteThrowActive">();
	}
	static class UP2NpcAbility_BruteThrowActive* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UP2NpcAbility_BruteThrowActive>();
	}
};
static_assert(alignof(UP2NpcAbility_BruteThrowActive) == 0x000008, "Wrong alignment on UP2NpcAbility_BruteThrowActive");
static_assert(sizeof(UP2NpcAbility_BruteThrowActive) == 0x000558, "Wrong size on UP2NpcAbility_BruteThrowActive");

// Class AICommon.P2EnvQueryTest_FreeAttackTickets
// 0x0000 (0x0208 - 0x0208)
class UP2EnvQueryTest_FreeAttackTickets final : public UEnvQueryTest
{
public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"P2EnvQueryTest_FreeAttackTickets">();
	}
	static class UP2EnvQueryTest_FreeAttackTickets* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UP2EnvQueryTest_FreeAttackTickets>();
	}
};
static_assert(alignof(UP2EnvQueryTest_FreeAttackTickets) == 0x000008, "Wrong alignment on UP2EnvQueryTest_FreeAttackTickets");
static_assert(sizeof(UP2EnvQueryTest_FreeAttackTickets) == 0x000208, "Wrong size on UP2EnvQueryTest_FreeAttackTickets");

// Class AICommon.P2NpcGroupMemberData
// 0x0028 (0x0058 - 0x0030)
class UP2NpcGroupMemberData : public UPrimaryDataAsset
{
public:
	TSubclassOf<class AP2AIController>            GroupMemberAIControllerClass;                      // 0x0030(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStateTree*                             StateTree;                                         // 0x0038(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<TSubclassOf<class UActorComponent>>    RuntimeComponentList;                              // 0x0040(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, UObjectWrapper, NativeAccessSpecifierPublic)
	class UP2NpcData*                             NpcData;                                           // 0x0050(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"P2NpcGroupMemberData">();
	}
	static class UP2NpcGroupMemberData* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UP2NpcGroupMemberData>();
	}
};
static_assert(alignof(UP2NpcGroupMemberData) == 0x000008, "Wrong alignment on UP2NpcGroupMemberData");
static_assert(sizeof(UP2NpcGroupMemberData) == 0x000058, "Wrong size on UP2NpcGroupMemberData");
static_assert(offsetof(UP2NpcGroupMemberData, GroupMemberAIControllerClass) == 0x000030, "Member 'UP2NpcGroupMemberData::GroupMemberAIControllerClass' has a wrong offset!");
static_assert(offsetof(UP2NpcGroupMemberData, StateTree) == 0x000038, "Member 'UP2NpcGroupMemberData::StateTree' has a wrong offset!");
static_assert(offsetof(UP2NpcGroupMemberData, RuntimeComponentList) == 0x000040, "Member 'UP2NpcGroupMemberData::RuntimeComponentList' has a wrong offset!");
static_assert(offsetof(UP2NpcGroupMemberData, NpcData) == 0x000050, "Member 'UP2NpcGroupMemberData::NpcData' has a wrong offset!");

// Class AICommon.P2GhostGroupMemberData
// 0x00B0 (0x0108 - 0x0058)
class UP2GhostGroupMemberData final : public UP2NpcGroupMemberData
{
public:
	struct FGameplayTag                           ThrowStartTag;                                     // 0x0058(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           ThrowEndTag;                                       // 0x0060(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bRefillUtility;                                    // 0x0068(0x0001)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_69[0x3];                                       // 0x0069(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTag                           FireStartTag;                                      // 0x006C(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           FireEndTag;                                        // 0x0074(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           FireCancelTag;                                     // 0x007C(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           ReloadEventTag;                                    // 0x0084(0x0008)(Edit, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bRefillMags;                                       // 0x008C(0x0001)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_8D[0x3];                                       // 0x008D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTag                           LaserTag;                                          // 0x0090(0x0008)(Edit, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UGameplayEffect>            AdsGameplayEffect;                                 // 0x0098(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           AdsStatusGameplayTag;                              // 0x00A0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UGameplayEffect>            SprintGameplayEffect;                              // 0x00A8(0x0008)(Edit, BlueprintReadOnly, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           SprintGameplayTag;                                 // 0x00B0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TMap<int32, struct FP2GhostDifficultyConfig>  DifficultyConfig;                                  // 0x00B8(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"P2GhostGroupMemberData">();
	}
	static class UP2GhostGroupMemberData* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UP2GhostGroupMemberData>();
	}
};
static_assert(alignof(UP2GhostGroupMemberData) == 0x000008, "Wrong alignment on UP2GhostGroupMemberData");
static_assert(sizeof(UP2GhostGroupMemberData) == 0x000108, "Wrong size on UP2GhostGroupMemberData");
static_assert(offsetof(UP2GhostGroupMemberData, ThrowStartTag) == 0x000058, "Member 'UP2GhostGroupMemberData::ThrowStartTag' has a wrong offset!");
static_assert(offsetof(UP2GhostGroupMemberData, ThrowEndTag) == 0x000060, "Member 'UP2GhostGroupMemberData::ThrowEndTag' has a wrong offset!");
static_assert(offsetof(UP2GhostGroupMemberData, bRefillUtility) == 0x000068, "Member 'UP2GhostGroupMemberData::bRefillUtility' has a wrong offset!");
static_assert(offsetof(UP2GhostGroupMemberData, FireStartTag) == 0x00006C, "Member 'UP2GhostGroupMemberData::FireStartTag' has a wrong offset!");
static_assert(offsetof(UP2GhostGroupMemberData, FireEndTag) == 0x000074, "Member 'UP2GhostGroupMemberData::FireEndTag' has a wrong offset!");
static_assert(offsetof(UP2GhostGroupMemberData, FireCancelTag) == 0x00007C, "Member 'UP2GhostGroupMemberData::FireCancelTag' has a wrong offset!");
static_assert(offsetof(UP2GhostGroupMemberData, ReloadEventTag) == 0x000084, "Member 'UP2GhostGroupMemberData::ReloadEventTag' has a wrong offset!");
static_assert(offsetof(UP2GhostGroupMemberData, bRefillMags) == 0x00008C, "Member 'UP2GhostGroupMemberData::bRefillMags' has a wrong offset!");
static_assert(offsetof(UP2GhostGroupMemberData, LaserTag) == 0x000090, "Member 'UP2GhostGroupMemberData::LaserTag' has a wrong offset!");
static_assert(offsetof(UP2GhostGroupMemberData, AdsGameplayEffect) == 0x000098, "Member 'UP2GhostGroupMemberData::AdsGameplayEffect' has a wrong offset!");
static_assert(offsetof(UP2GhostGroupMemberData, AdsStatusGameplayTag) == 0x0000A0, "Member 'UP2GhostGroupMemberData::AdsStatusGameplayTag' has a wrong offset!");
static_assert(offsetof(UP2GhostGroupMemberData, SprintGameplayEffect) == 0x0000A8, "Member 'UP2GhostGroupMemberData::SprintGameplayEffect' has a wrong offset!");
static_assert(offsetof(UP2GhostGroupMemberData, SprintGameplayTag) == 0x0000B0, "Member 'UP2GhostGroupMemberData::SprintGameplayTag' has a wrong offset!");
static_assert(offsetof(UP2GhostGroupMemberData, DifficultyConfig) == 0x0000B8, "Member 'UP2GhostGroupMemberData::DifficultyConfig' has a wrong offset!");

// Class AICommon.P2EnvQueryTest_GameplayTagScoring
// 0x0018 (0x0220 - 0x0208)
class UP2EnvQueryTest_GameplayTagScoring final : public UEnvQueryTest
{
public:
	TArray<struct FP2TagQueryScore>               TagQueryScorePairs;                                // 0x0208(0x0010)(Edit, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	bool                                          bSumScores;                                        // 0x0218(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_219[0x7];                                      // 0x0219(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"P2EnvQueryTest_GameplayTagScoring">();
	}
	static class UP2EnvQueryTest_GameplayTagScoring* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UP2EnvQueryTest_GameplayTagScoring>();
	}
};
static_assert(alignof(UP2EnvQueryTest_GameplayTagScoring) == 0x000008, "Wrong alignment on UP2EnvQueryTest_GameplayTagScoring");
static_assert(sizeof(UP2EnvQueryTest_GameplayTagScoring) == 0x000220, "Wrong size on UP2EnvQueryTest_GameplayTagScoring");
static_assert(offsetof(UP2EnvQueryTest_GameplayTagScoring, TagQueryScorePairs) == 0x000208, "Member 'UP2EnvQueryTest_GameplayTagScoring::TagQueryScorePairs' has a wrong offset!");
static_assert(offsetof(UP2EnvQueryTest_GameplayTagScoring, bSumScores) == 0x000218, "Member 'UP2EnvQueryTest_GameplayTagScoring::bSumScores' has a wrong offset!");

// Class AICommon.P2EnvQueryTest_GroupTargetAssigned
// 0x0008 (0x0210 - 0x0208)
class UP2EnvQueryTest_GroupTargetAssigned final : public UEnvQueryTest
{
public:
	class FName                                   TargetKeyName;                                     // 0x0208(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"P2EnvQueryTest_GroupTargetAssigned">();
	}
	static class UP2EnvQueryTest_GroupTargetAssigned* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UP2EnvQueryTest_GroupTargetAssigned>();
	}
};
static_assert(alignof(UP2EnvQueryTest_GroupTargetAssigned) == 0x000008, "Wrong alignment on UP2EnvQueryTest_GroupTargetAssigned");
static_assert(sizeof(UP2EnvQueryTest_GroupTargetAssigned) == 0x000210, "Wrong size on UP2EnvQueryTest_GroupTargetAssigned");
static_assert(offsetof(UP2EnvQueryTest_GroupTargetAssigned, TargetKeyName) == 0x000208, "Member 'UP2EnvQueryTest_GroupTargetAssigned::TargetKeyName' has a wrong offset!");

// Class AICommon.P2EnvQueryTest_GroupTargetHostile
// 0x0000 (0x0208 - 0x0208)
class UP2EnvQueryTest_GroupTargetHostile final : public UEnvQueryTest
{
public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"P2EnvQueryTest_GroupTargetHostile">();
	}
	static class UP2EnvQueryTest_GroupTargetHostile* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UP2EnvQueryTest_GroupTargetHostile>();
	}
};
static_assert(alignof(UP2EnvQueryTest_GroupTargetHostile) == 0x000008, "Wrong alignment on UP2EnvQueryTest_GroupTargetHostile");
static_assert(sizeof(UP2EnvQueryTest_GroupTargetHostile) == 0x000208, "Wrong size on UP2EnvQueryTest_GroupTargetHostile");

// Class AICommon.P2NpcAbility_ChargeAttack
// 0x00F0 (0x0588 - 0x0498)
class UP2NpcAbility_ChargeAttack final : public UP2NpcAbility_Attack
{
public:
	class UAnimMontage*                           ChargeMontage;                                     // 0x0498(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   RootMotionTargetName;                              // 0x04A0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   MontageWindUpSectionName;                          // 0x04A8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   MontageHitSectionName;                             // 0x04B0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   MontageMissSectionName;                            // 0x04B8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   MontageStopSectionName;                            // 0x04C0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   MontageAbortSectionName;                           // 0x04C8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MinTargetDistance;                                 // 0x04D0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MaxTargetDistance;                                 // 0x04D4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MinHeadingErrorInHalfAngleDegrees;                 // 0x04D8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bCheckHeadingErrorWhileCharging;                   // 0x04DC(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_4DD[0x3];                                      // 0x04DD(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         SlopeAllowanceFactor;                              // 0x04E0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MaxSpeedToWindUp;                                  // 0x04E4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bCancelImmediatelyOnAbort;                         // 0x04E8(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_4E9[0x3];                                      // 0x04E9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MaxChargeTime;                                     // 0x04EC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         TimeToReachMaxSpeed;                               // 0x04F0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MaxSteeringInHalfAngleDegrees;                     // 0x04F4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         TimeToImpact;                                      // 0x04F8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MinDistanceToImpact;                               // 0x04FC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MinLateralDistanceToImpact;                        // 0x0500(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MissLateralDistance;                               // 0x0504(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector                                HitBoxOffset;                                      // 0x0508(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector                                HitBoxExtents;                                     // 0x0520(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UP2GameplayEffect_Damage>   DamageEffectClass;                                 // 0x0538(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         bApplyStun : 1;                                    // 0x0540(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         Pad_541[0x3];                                      // 0x0541(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTag                           StunType;                                          // 0x0544(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_54C[0x24];                                     // 0x054C(0x0024)(Fixing Size After Last Property [ Dumper-7 ])
	class UAbilityTask_PlayMontageAndWait*        PlayMontageTask;                                   // 0x0570(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UP2AbilityTask_AimCharge*               AimChargeTask;                                     // 0x0578(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UP2AbilityTask_Charge*                  ChargeTask;                                        // 0x0580(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void OnAbilityFinished()	 // 0x47611f8;
	void OnChargeAbort()	 // 0x4761278;
	void OnChargeHit()	 // 0x476128c;
	void OnChargeMiss()	 // 0x47612a8;
	void OnChargeStop()	 // 0x47612c4;

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"P2NpcAbility_ChargeAttack">();
	}
	static class UP2NpcAbility_ChargeAttack* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UP2NpcAbility_ChargeAttack>();
	}
};
static_assert(alignof(UP2NpcAbility_ChargeAttack) == 0x000008, "Wrong alignment on UP2NpcAbility_ChargeAttack");
static_assert(sizeof(UP2NpcAbility_ChargeAttack) == 0x000588, "Wrong size on UP2NpcAbility_ChargeAttack");
static_assert(offsetof(UP2NpcAbility_ChargeAttack, ChargeMontage) == 0x000498, "Member 'UP2NpcAbility_ChargeAttack::ChargeMontage' has a wrong offset!");
static_assert(offsetof(UP2NpcAbility_ChargeAttack, RootMotionTargetName) == 0x0004A0, "Member 'UP2NpcAbility_ChargeAttack::RootMotionTargetName' has a wrong offset!");
static_assert(offsetof(UP2NpcAbility_ChargeAttack, MontageWindUpSectionName) == 0x0004A8, "Member 'UP2NpcAbility_ChargeAttack::MontageWindUpSectionName' has a wrong offset!");
static_assert(offsetof(UP2NpcAbility_ChargeAttack, MontageHitSectionName) == 0x0004B0, "Member 'UP2NpcAbility_ChargeAttack::MontageHitSectionName' has a wrong offset!");
static_assert(offsetof(UP2NpcAbility_ChargeAttack, MontageMissSectionName) == 0x0004B8, "Member 'UP2NpcAbility_ChargeAttack::MontageMissSectionName' has a wrong offset!");
static_assert(offsetof(UP2NpcAbility_ChargeAttack, MontageStopSectionName) == 0x0004C0, "Member 'UP2NpcAbility_ChargeAttack::MontageStopSectionName' has a wrong offset!");
static_assert(offsetof(UP2NpcAbility_ChargeAttack, MontageAbortSectionName) == 0x0004C8, "Member 'UP2NpcAbility_ChargeAttack::MontageAbortSectionName' has a wrong offset!");
static_assert(offsetof(UP2NpcAbility_ChargeAttack, MinTargetDistance) == 0x0004D0, "Member 'UP2NpcAbility_ChargeAttack::MinTargetDistance' has a wrong offset!");
static_assert(offsetof(UP2NpcAbility_ChargeAttack, MaxTargetDistance) == 0x0004D4, "Member 'UP2NpcAbility_ChargeAttack::MaxTargetDistance' has a wrong offset!");
static_assert(offsetof(UP2NpcAbility_ChargeAttack, MinHeadingErrorInHalfAngleDegrees) == 0x0004D8, "Member 'UP2NpcAbility_ChargeAttack::MinHeadingErrorInHalfAngleDegrees' has a wrong offset!");
static_assert(offsetof(UP2NpcAbility_ChargeAttack, bCheckHeadingErrorWhileCharging) == 0x0004DC, "Member 'UP2NpcAbility_ChargeAttack::bCheckHeadingErrorWhileCharging' has a wrong offset!");
static_assert(offsetof(UP2NpcAbility_ChargeAttack, SlopeAllowanceFactor) == 0x0004E0, "Member 'UP2NpcAbility_ChargeAttack::SlopeAllowanceFactor' has a wrong offset!");
static_assert(offsetof(UP2NpcAbility_ChargeAttack, MaxSpeedToWindUp) == 0x0004E4, "Member 'UP2NpcAbility_ChargeAttack::MaxSpeedToWindUp' has a wrong offset!");
static_assert(offsetof(UP2NpcAbility_ChargeAttack, bCancelImmediatelyOnAbort) == 0x0004E8, "Member 'UP2NpcAbility_ChargeAttack::bCancelImmediatelyOnAbort' has a wrong offset!");
static_assert(offsetof(UP2NpcAbility_ChargeAttack, MaxChargeTime) == 0x0004EC, "Member 'UP2NpcAbility_ChargeAttack::MaxChargeTime' has a wrong offset!");
static_assert(offsetof(UP2NpcAbility_ChargeAttack, TimeToReachMaxSpeed) == 0x0004F0, "Member 'UP2NpcAbility_ChargeAttack::TimeToReachMaxSpeed' has a wrong offset!");
static_assert(offsetof(UP2NpcAbility_ChargeAttack, MaxSteeringInHalfAngleDegrees) == 0x0004F4, "Member 'UP2NpcAbility_ChargeAttack::MaxSteeringInHalfAngleDegrees' has a wrong offset!");
static_assert(offsetof(UP2NpcAbility_ChargeAttack, TimeToImpact) == 0x0004F8, "Member 'UP2NpcAbility_ChargeAttack::TimeToImpact' has a wrong offset!");
static_assert(offsetof(UP2NpcAbility_ChargeAttack, MinDistanceToImpact) == 0x0004FC, "Member 'UP2NpcAbility_ChargeAttack::MinDistanceToImpact' has a wrong offset!");
static_assert(offsetof(UP2NpcAbility_ChargeAttack, MinLateralDistanceToImpact) == 0x000500, "Member 'UP2NpcAbility_ChargeAttack::MinLateralDistanceToImpact' has a wrong offset!");
static_assert(offsetof(UP2NpcAbility_ChargeAttack, MissLateralDistance) == 0x000504, "Member 'UP2NpcAbility_ChargeAttack::MissLateralDistance' has a wrong offset!");
static_assert(offsetof(UP2NpcAbility_ChargeAttack, HitBoxOffset) == 0x000508, "Member 'UP2NpcAbility_ChargeAttack::HitBoxOffset' has a wrong offset!");
static_assert(offsetof(UP2NpcAbility_ChargeAttack, HitBoxExtents) == 0x000520, "Member 'UP2NpcAbility_ChargeAttack::HitBoxExtents' has a wrong offset!");
static_assert(offsetof(UP2NpcAbility_ChargeAttack, DamageEffectClass) == 0x000538, "Member 'UP2NpcAbility_ChargeAttack::DamageEffectClass' has a wrong offset!");
static_assert(offsetof(UP2NpcAbility_ChargeAttack, StunType) == 0x000544, "Member 'UP2NpcAbility_ChargeAttack::StunType' has a wrong offset!");
static_assert(offsetof(UP2NpcAbility_ChargeAttack, PlayMontageTask) == 0x000570, "Member 'UP2NpcAbility_ChargeAttack::PlayMontageTask' has a wrong offset!");
static_assert(offsetof(UP2NpcAbility_ChargeAttack, AimChargeTask) == 0x000578, "Member 'UP2NpcAbility_ChargeAttack::AimChargeTask' has a wrong offset!");
static_assert(offsetof(UP2NpcAbility_ChargeAttack, ChargeTask) == 0x000580, "Member 'UP2NpcAbility_ChargeAttack::ChargeTask' has a wrong offset!");

// Class AICommon.P2EnvQueryTest_GroupTargetReserved
// 0x0000 (0x0208 - 0x0208)
class UP2EnvQueryTest_GroupTargetReserved final : public UEnvQueryTest
{
public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"P2EnvQueryTest_GroupTargetReserved">();
	}
	static class UP2EnvQueryTest_GroupTargetReserved* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UP2EnvQueryTest_GroupTargetReserved>();
	}
};
static_assert(alignof(UP2EnvQueryTest_GroupTargetReserved) == 0x000008, "Wrong alignment on UP2EnvQueryTest_GroupTargetReserved");
static_assert(sizeof(UP2EnvQueryTest_GroupTargetReserved) == 0x000208, "Wrong size on UP2EnvQueryTest_GroupTargetReserved");

// Class AICommon.P2NpcAbility_BruteThrowableBase
// 0x0010 (0x04A8 - 0x0498)
class UP2NpcAbility_BruteThrowableBase : public UP2NpcAbility
{
public:
	uint8                                         Pad_498[0x10];                                     // 0x0498(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnAnimationEnded()	 // 0x4761238;

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"P2NpcAbility_BruteThrowableBase">();
	}
	static class UP2NpcAbility_BruteThrowableBase* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UP2NpcAbility_BruteThrowableBase>();
	}
};
static_assert(alignof(UP2NpcAbility_BruteThrowableBase) == 0x000008, "Wrong alignment on UP2NpcAbility_BruteThrowableBase");
static_assert(sizeof(UP2NpcAbility_BruteThrowableBase) == 0x0004A8, "Wrong size on UP2NpcAbility_BruteThrowableBase");

// Class AICommon.P2EnvQueryTest_HasAttackTicket
// 0x0000 (0x0208 - 0x0208)
class UP2EnvQueryTest_HasAttackTicket final : public UEnvQueryTest
{
public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"P2EnvQueryTest_HasAttackTicket">();
	}
	static class UP2EnvQueryTest_HasAttackTicket* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UP2EnvQueryTest_HasAttackTicket>();
	}
};
static_assert(alignof(UP2EnvQueryTest_HasAttackTicket) == 0x000008, "Wrong alignment on UP2EnvQueryTest_HasAttackTicket");
static_assert(sizeof(UP2EnvQueryTest_HasAttackTicket) == 0x000208, "Wrong size on UP2EnvQueryTest_HasAttackTicket");

// Class AICommon.P2EnvQueryTest_HasLineOfMotion
// 0x0008 (0x0210 - 0x0208)
class UP2EnvQueryTest_HasLineOfMotion final : public UEnvQueryTest
{
public:
	TSubclassOf<class UEnvQueryContext>           Context;                                           // 0x0208(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"P2EnvQueryTest_HasLineOfMotion">();
	}
	static class UP2EnvQueryTest_HasLineOfMotion* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UP2EnvQueryTest_HasLineOfMotion>();
	}
};
static_assert(alignof(UP2EnvQueryTest_HasLineOfMotion) == 0x000008, "Wrong alignment on UP2EnvQueryTest_HasLineOfMotion");
static_assert(sizeof(UP2EnvQueryTest_HasLineOfMotion) == 0x000210, "Wrong size on UP2EnvQueryTest_HasLineOfMotion");
static_assert(offsetof(UP2EnvQueryTest_HasLineOfMotion, Context) == 0x000208, "Member 'UP2EnvQueryTest_HasLineOfMotion::Context' has a wrong offset!");

// Class AICommon.P2EnvQueryTest_Health
// 0x0000 (0x0208 - 0x0208)
class UP2EnvQueryTest_Health final : public UEnvQueryTest
{
public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"P2EnvQueryTest_Health">();
	}
	static class UP2EnvQueryTest_Health* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UP2EnvQueryTest_Health>();
	}
};
static_assert(alignof(UP2EnvQueryTest_Health) == 0x000008, "Wrong alignment on UP2EnvQueryTest_Health");
static_assert(sizeof(UP2EnvQueryTest_Health) == 0x000208, "Wrong size on UP2EnvQueryTest_Health");

// Class AICommon.P2AbilityTask_CrocSnap
// 0x0040 (0x00C0 - 0x0080)
class UP2AbilityTask_CrocSnap final : public UAbilityTask
{
public:
	uint8                                         Pad_80[0x8];                                       // 0x0080(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                Location;                                          // 0x0088(0x0018)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FQuat                                  Rotation;                                          // 0x00A0(0x0020)(Net, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"P2AbilityTask_CrocSnap">();
	}
	static class UP2AbilityTask_CrocSnap* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UP2AbilityTask_CrocSnap>();
	}
};
static_assert(alignof(UP2AbilityTask_CrocSnap) == 0x000010, "Wrong alignment on UP2AbilityTask_CrocSnap");
static_assert(sizeof(UP2AbilityTask_CrocSnap) == 0x0000C0, "Wrong size on UP2AbilityTask_CrocSnap");
static_assert(offsetof(UP2AbilityTask_CrocSnap, Location) == 0x000088, "Member 'UP2AbilityTask_CrocSnap::Location' has a wrong offset!");
static_assert(offsetof(UP2AbilityTask_CrocSnap, Rotation) == 0x0000A0, "Member 'UP2AbilityTask_CrocSnap::Rotation' has a wrong offset!");

// Class AICommon.P2EnvQueryTest_InsideSpawnVolume
// 0x0000 (0x0208 - 0x0208)
class UP2EnvQueryTest_InsideSpawnVolume final : public UEnvQueryTest
{
public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"P2EnvQueryTest_InsideSpawnVolume">();
	}
	static class UP2EnvQueryTest_InsideSpawnVolume* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UP2EnvQueryTest_InsideSpawnVolume>();
	}
};
static_assert(alignof(UP2EnvQueryTest_InsideSpawnVolume) == 0x000008, "Wrong alignment on UP2EnvQueryTest_InsideSpawnVolume");
static_assert(sizeof(UP2EnvQueryTest_InsideSpawnVolume) == 0x000208, "Wrong size on UP2EnvQueryTest_InsideSpawnVolume");

// Class AICommon.P2AbilityTask_AttackAim
// 0x0050 (0x00D0 - 0x0080)
class UP2AbilityTask_AttackAim final : public UAbilityTask
{
public:
	uint8                                         Pad_80[0x50];                                      // 0x0080(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"P2AbilityTask_AttackAim">();
	}
	static class UP2AbilityTask_AttackAim* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UP2AbilityTask_AttackAim>();
	}
};
static_assert(alignof(UP2AbilityTask_AttackAim) == 0x000008, "Wrong alignment on UP2AbilityTask_AttackAim");
static_assert(sizeof(UP2AbilityTask_AttackAim) == 0x0000D0, "Wrong size on UP2AbilityTask_AttackAim");

// Class AICommon.P2EnvQueryTest_InterestLevel
// 0x0000 (0x0208 - 0x0208)
class UP2EnvQueryTest_InterestLevel final : public UEnvQueryTest
{
public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"P2EnvQueryTest_InterestLevel">();
	}
	static class UP2EnvQueryTest_InterestLevel* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UP2EnvQueryTest_InterestLevel>();
	}
};
static_assert(alignof(UP2EnvQueryTest_InterestLevel) == 0x000008, "Wrong alignment on UP2EnvQueryTest_InterestLevel");
static_assert(sizeof(UP2EnvQueryTest_InterestLevel) == 0x000208, "Wrong size on UP2EnvQueryTest_InterestLevel");

// Class AICommon.P2EnvQueryTest_IsCoverPointFree
// 0x0038 (0x0240 - 0x0208)
class UP2EnvQueryTest_IsCoverPointFree final : public UEnvQueryTest
{
public:
	struct FAIDataProviderBoolValue               AllowSelf;                                         // 0x0208(0x0038)(Edit, DisableEditOnInstance, ContainsInstancedReference, AdvancedDisplay, Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"P2EnvQueryTest_IsCoverPointFree">();
	}
	static class UP2EnvQueryTest_IsCoverPointFree* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UP2EnvQueryTest_IsCoverPointFree>();
	}
};
static_assert(alignof(UP2EnvQueryTest_IsCoverPointFree) == 0x000008, "Wrong alignment on UP2EnvQueryTest_IsCoverPointFree");
static_assert(sizeof(UP2EnvQueryTest_IsCoverPointFree) == 0x000240, "Wrong size on UP2EnvQueryTest_IsCoverPointFree");
static_assert(offsetof(UP2EnvQueryTest_IsCoverPointFree, AllowSelf) == 0x000208, "Member 'UP2EnvQueryTest_IsCoverPointFree::AllowSelf' has a wrong offset!");

// Class AICommon.P2EnvQueryTest_IsCoverPointHideOnly
// 0x0000 (0x0208 - 0x0208)
class UP2EnvQueryTest_IsCoverPointHideOnly final : public UEnvQueryTest
{
public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"P2EnvQueryTest_IsCoverPointHideOnly">();
	}
	static class UP2EnvQueryTest_IsCoverPointHideOnly* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UP2EnvQueryTest_IsCoverPointHideOnly>();
	}
};
static_assert(alignof(UP2EnvQueryTest_IsCoverPointHideOnly) == 0x000008, "Wrong alignment on UP2EnvQueryTest_IsCoverPointHideOnly");
static_assert(sizeof(UP2EnvQueryTest_IsCoverPointHideOnly) == 0x000208, "Wrong size on UP2EnvQueryTest_IsCoverPointHideOnly");

// Class AICommon.P2Mercuna3DNavigationComponent
// 0x0008 (0x0208 - 0x0200)
class UP2Mercuna3DNavigationComponent final : public UMercuna3DNavigationComponent
{
public:
	uint8                                         Pad_200[0x8];                                      // 0x0200(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"P2Mercuna3DNavigationComponent">();
	}
	static class UP2Mercuna3DNavigationComponent* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UP2Mercuna3DNavigationComponent>();
	}
};
static_assert(alignof(UP2Mercuna3DNavigationComponent) == 0x000008, "Wrong alignment on UP2Mercuna3DNavigationComponent");
static_assert(sizeof(UP2Mercuna3DNavigationComponent) == 0x000208, "Wrong size on UP2Mercuna3DNavigationComponent");

// Class AICommon.P2EnvQueryTest_IsCoverPosition
// 0x0128 (0x0330 - 0x0208)
class UP2EnvQueryTest_IsCoverPosition final : public UEnvQueryTest
{
public:
	struct FEnvTraceData                          TraceData;                                         // 0x0208(0x0040)(Edit, DisableEditOnInstance, NoDestructor, Protected, NativeAccessSpecifierProtected)
	TSubclassOf<class UEnvQueryContext>           Context;                                           // 0x0248(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FAIDataProviderFloatValue              MinContextDist;                                    // 0x0250(0x0038)(Edit, DisableEditOnInstance, ContainsInstancedReference, AdvancedDisplay, Protected, NativeAccessSpecifierProtected)
	struct FAIDataProviderFloatValue              MaxContextDist;                                    // 0x0288(0x0038)(Edit, DisableEditOnInstance, ContainsInstancedReference, AdvancedDisplay, Protected, NativeAccessSpecifierProtected)
	struct FAIDataProviderFloatValue              MaxContextFrontDot;                                // 0x02C0(0x0038)(Edit, DisableEditOnInstance, ContainsInstancedReference, AdvancedDisplay, Protected, NativeAccessSpecifierProtected)
	struct FAIDataProviderFloatValue              MaxContextSideDot;                                 // 0x02F8(0x0038)(Edit, DisableEditOnInstance, ContainsInstancedReference, AdvancedDisplay, Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"P2EnvQueryTest_IsCoverPosition">();
	}
	static class UP2EnvQueryTest_IsCoverPosition* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UP2EnvQueryTest_IsCoverPosition>();
	}
};
static_assert(alignof(UP2EnvQueryTest_IsCoverPosition) == 0x000008, "Wrong alignment on UP2EnvQueryTest_IsCoverPosition");
static_assert(sizeof(UP2EnvQueryTest_IsCoverPosition) == 0x000330, "Wrong size on UP2EnvQueryTest_IsCoverPosition");
static_assert(offsetof(UP2EnvQueryTest_IsCoverPosition, TraceData) == 0x000208, "Member 'UP2EnvQueryTest_IsCoverPosition::TraceData' has a wrong offset!");
static_assert(offsetof(UP2EnvQueryTest_IsCoverPosition, Context) == 0x000248, "Member 'UP2EnvQueryTest_IsCoverPosition::Context' has a wrong offset!");
static_assert(offsetof(UP2EnvQueryTest_IsCoverPosition, MinContextDist) == 0x000250, "Member 'UP2EnvQueryTest_IsCoverPosition::MinContextDist' has a wrong offset!");
static_assert(offsetof(UP2EnvQueryTest_IsCoverPosition, MaxContextDist) == 0x000288, "Member 'UP2EnvQueryTest_IsCoverPosition::MaxContextDist' has a wrong offset!");
static_assert(offsetof(UP2EnvQueryTest_IsCoverPosition, MaxContextFrontDot) == 0x0002C0, "Member 'UP2EnvQueryTest_IsCoverPosition::MaxContextFrontDot' has a wrong offset!");
static_assert(offsetof(UP2EnvQueryTest_IsCoverPosition, MaxContextSideDot) == 0x0002F8, "Member 'UP2EnvQueryTest_IsCoverPosition::MaxContextSideDot' has a wrong offset!");

// Class AICommon.P2NpcAbility_Camouflage
// 0x0068 (0x0500 - 0x0498)
class UP2NpcAbility_Camouflage final : public UP2NpcAbility
{
public:
	struct FScalableFloat                         IntensityValueCurve;                               // 0x0498(0x0028)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FScalableFloat                         TransitionSpeedValueCurve;                         // 0x04C0(0x0028)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	float                                         EndAbilityTransitionSpeed;                         // 0x04E8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bFreezeOnDeath;                                    // 0x04EC(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bCancelByDamage;                                   // 0x04ED(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_4EE[0x2];                                      // 0x04EE(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         DamageThreshold;                                   // 0x04F0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         DamageTimeToConsider;                              // 0x04F4(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_4F8[0x8];                                      // 0x04F8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void HandleDamage(const struct FP2DamageData& ChangeData)	 // 0x4760e10;

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"P2NpcAbility_Camouflage">();
	}
	static class UP2NpcAbility_Camouflage* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UP2NpcAbility_Camouflage>();
	}
};
static_assert(alignof(UP2NpcAbility_Camouflage) == 0x000008, "Wrong alignment on UP2NpcAbility_Camouflage");
static_assert(sizeof(UP2NpcAbility_Camouflage) == 0x000500, "Wrong size on UP2NpcAbility_Camouflage");
static_assert(offsetof(UP2NpcAbility_Camouflage, IntensityValueCurve) == 0x000498, "Member 'UP2NpcAbility_Camouflage::IntensityValueCurve' has a wrong offset!");
static_assert(offsetof(UP2NpcAbility_Camouflage, TransitionSpeedValueCurve) == 0x0004C0, "Member 'UP2NpcAbility_Camouflage::TransitionSpeedValueCurve' has a wrong offset!");
static_assert(offsetof(UP2NpcAbility_Camouflage, EndAbilityTransitionSpeed) == 0x0004E8, "Member 'UP2NpcAbility_Camouflage::EndAbilityTransitionSpeed' has a wrong offset!");
static_assert(offsetof(UP2NpcAbility_Camouflage, bFreezeOnDeath) == 0x0004EC, "Member 'UP2NpcAbility_Camouflage::bFreezeOnDeath' has a wrong offset!");
static_assert(offsetof(UP2NpcAbility_Camouflage, bCancelByDamage) == 0x0004ED, "Member 'UP2NpcAbility_Camouflage::bCancelByDamage' has a wrong offset!");
static_assert(offsetof(UP2NpcAbility_Camouflage, DamageThreshold) == 0x0004F0, "Member 'UP2NpcAbility_Camouflage::DamageThreshold' has a wrong offset!");
static_assert(offsetof(UP2NpcAbility_Camouflage, DamageTimeToConsider) == 0x0004F4, "Member 'UP2NpcAbility_Camouflage::DamageTimeToConsider' has a wrong offset!");

// Class AICommon.P2EnvQueryTest_IsHidingSpotVisible
// 0x0040 (0x0248 - 0x0208)
class UP2EnvQueryTest_IsHidingSpotVisible final : public UEnvQueryTest
{
public:
	TSubclassOf<class UEnvQueryContext>           TargetContext;                                     // 0x0208(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FAIDataProviderBoolValue               ShouldBeVisible;                                   // 0x0210(0x0038)(Edit, DisableEditOnInstance, ContainsInstancedReference, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"P2EnvQueryTest_IsHidingSpotVisible">();
	}
	static class UP2EnvQueryTest_IsHidingSpotVisible* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UP2EnvQueryTest_IsHidingSpotVisible>();
	}
};
static_assert(alignof(UP2EnvQueryTest_IsHidingSpotVisible) == 0x000008, "Wrong alignment on UP2EnvQueryTest_IsHidingSpotVisible");
static_assert(sizeof(UP2EnvQueryTest_IsHidingSpotVisible) == 0x000248, "Wrong size on UP2EnvQueryTest_IsHidingSpotVisible");
static_assert(offsetof(UP2EnvQueryTest_IsHidingSpotVisible, TargetContext) == 0x000208, "Member 'UP2EnvQueryTest_IsHidingSpotVisible::TargetContext' has a wrong offset!");
static_assert(offsetof(UP2EnvQueryTest_IsHidingSpotVisible, ShouldBeVisible) == 0x000210, "Member 'UP2EnvQueryTest_IsHidingSpotVisible::ShouldBeVisible' has a wrong offset!");

// Class AICommon.P2EnvQueryTest_Isolated
// 0x0008 (0x0210 - 0x0208)
class UP2EnvQueryTest_Isolated final : public UEnvQueryTest
{
public:
	TSubclassOf<class UEnvQueryContext>           DistanceTo;                                        // 0x0208(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"P2EnvQueryTest_Isolated">();
	}
	static class UP2EnvQueryTest_Isolated* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UP2EnvQueryTest_Isolated>();
	}
};
static_assert(alignof(UP2EnvQueryTest_Isolated) == 0x000008, "Wrong alignment on UP2EnvQueryTest_Isolated");
static_assert(sizeof(UP2EnvQueryTest_Isolated) == 0x000210, "Wrong size on UP2EnvQueryTest_Isolated");
static_assert(offsetof(UP2EnvQueryTest_Isolated, DistanceTo) == 0x000208, "Member 'UP2EnvQueryTest_Isolated::DistanceTo' has a wrong offset!");

// Class AICommon.P2EnvQueryTest_IsParallelToCoverDirection
// 0x0010 (0x0218 - 0x0208)
class UP2EnvQueryTest_IsParallelToCoverDirection final : public UEnvQueryTest
{
public:
	TSubclassOf<class UEnvQueryContext>           Context;                                           // 0x0208(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UEnvQueryContext>           FallbackContext;                                   // 0x0210(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"P2EnvQueryTest_IsParallelToCoverDirection">();
	}
	static class UP2EnvQueryTest_IsParallelToCoverDirection* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UP2EnvQueryTest_IsParallelToCoverDirection>();
	}
};
static_assert(alignof(UP2EnvQueryTest_IsParallelToCoverDirection) == 0x000008, "Wrong alignment on UP2EnvQueryTest_IsParallelToCoverDirection");
static_assert(sizeof(UP2EnvQueryTest_IsParallelToCoverDirection) == 0x000218, "Wrong size on UP2EnvQueryTest_IsParallelToCoverDirection");
static_assert(offsetof(UP2EnvQueryTest_IsParallelToCoverDirection, Context) == 0x000208, "Member 'UP2EnvQueryTest_IsParallelToCoverDirection::Context' has a wrong offset!");
static_assert(offsetof(UP2EnvQueryTest_IsParallelToCoverDirection, FallbackContext) == 0x000210, "Member 'UP2EnvQueryTest_IsParallelToCoverDirection::FallbackContext' has a wrong offset!");

// Class AICommon.P2EnvQueryTest_IsWithinGroupBounds
// 0x0000 (0x0208 - 0x0208)
class UP2EnvQueryTest_IsWithinGroupBounds final : public UEnvQueryTest
{
public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"P2EnvQueryTest_IsWithinGroupBounds">();
	}
	static class UP2EnvQueryTest_IsWithinGroupBounds* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UP2EnvQueryTest_IsWithinGroupBounds>();
	}
};
static_assert(alignof(UP2EnvQueryTest_IsWithinGroupBounds) == 0x000008, "Wrong alignment on UP2EnvQueryTest_IsWithinGroupBounds");
static_assert(sizeof(UP2EnvQueryTest_IsWithinGroupBounds) == 0x000208, "Wrong size on UP2EnvQueryTest_IsWithinGroupBounds");

// Class AICommon.P2NpcAbility_BossMercunaNavLinkTraversal
// 0x00E0 (0x05C0 - 0x04E0)
class UP2NpcAbility_BossMercunaNavLinkTraversal final : public UP2NpcAbility_UseMercunaNavLink
{
public:
	class UP2NavLinkMontageData*                  NavLinkMontageData;                                // 0x04E0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EMovementMode                                 TraversalMovementMode;                             // 0x04E8(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_4E9[0x7];                                      // 0x04E9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             StartTransform;                                    // 0x04F0(0x0060)(BlueprintVisible, BlueprintReadOnly, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FTransform                             EndTransform;                                      // 0x0550(0x0060)(BlueprintVisible, BlueprintReadOnly, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAbilityTask_PlayMontageAndWait*        PlayMontageTask;                                   // 0x05B0(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_5B8[0x8];                                      // 0x05B8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnTraversalCanceled()	 // 0x475d2e8;
	void OnTraversalFinished()	 // 0x475d2e8;

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"P2NpcAbility_BossMercunaNavLinkTraversal">();
	}
	static class UP2NpcAbility_BossMercunaNavLinkTraversal* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UP2NpcAbility_BossMercunaNavLinkTraversal>();
	}
};
static_assert(alignof(UP2NpcAbility_BossMercunaNavLinkTraversal) == 0x000010, "Wrong alignment on UP2NpcAbility_BossMercunaNavLinkTraversal");
static_assert(sizeof(UP2NpcAbility_BossMercunaNavLinkTraversal) == 0x0005C0, "Wrong size on UP2NpcAbility_BossMercunaNavLinkTraversal");
static_assert(offsetof(UP2NpcAbility_BossMercunaNavLinkTraversal, NavLinkMontageData) == 0x0004E0, "Member 'UP2NpcAbility_BossMercunaNavLinkTraversal::NavLinkMontageData' has a wrong offset!");
static_assert(offsetof(UP2NpcAbility_BossMercunaNavLinkTraversal, TraversalMovementMode) == 0x0004E8, "Member 'UP2NpcAbility_BossMercunaNavLinkTraversal::TraversalMovementMode' has a wrong offset!");
static_assert(offsetof(UP2NpcAbility_BossMercunaNavLinkTraversal, StartTransform) == 0x0004F0, "Member 'UP2NpcAbility_BossMercunaNavLinkTraversal::StartTransform' has a wrong offset!");
static_assert(offsetof(UP2NpcAbility_BossMercunaNavLinkTraversal, EndTransform) == 0x000550, "Member 'UP2NpcAbility_BossMercunaNavLinkTraversal::EndTransform' has a wrong offset!");
static_assert(offsetof(UP2NpcAbility_BossMercunaNavLinkTraversal, PlayMontageTask) == 0x0005B0, "Member 'UP2NpcAbility_BossMercunaNavLinkTraversal::PlayMontageTask' has a wrong offset!");

// Class AICommon.P2EnvQueryTest_MercunaModifierVolume
// 0x0008 (0x0210 - 0x0208)
class UP2EnvQueryTest_MercunaModifierVolume final : public UEnvQueryTest
{
public:
	struct FMercunaUsageTypes                     UsageTypeFilter;                                   // 0x0208(0x0004)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_20C[0x4];                                      // 0x020C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"P2EnvQueryTest_MercunaModifierVolume">();
	}
	static class UP2EnvQueryTest_MercunaModifierVolume* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UP2EnvQueryTest_MercunaModifierVolume>();
	}
};
static_assert(alignof(UP2EnvQueryTest_MercunaModifierVolume) == 0x000008, "Wrong alignment on UP2EnvQueryTest_MercunaModifierVolume");
static_assert(sizeof(UP2EnvQueryTest_MercunaModifierVolume) == 0x000210, "Wrong size on UP2EnvQueryTest_MercunaModifierVolume");
static_assert(offsetof(UP2EnvQueryTest_MercunaModifierVolume, UsageTypeFilter) == 0x000208, "Member 'UP2EnvQueryTest_MercunaModifierVolume::UsageTypeFilter' has a wrong offset!");

// Class AICommon.P2EnvQueryTest_NavRaycast
// 0x0010 (0x0218 - 0x0208)
class UP2EnvQueryTest_NavRaycast final : public UEnvQueryTest
{
public:
	TSubclassOf<class UEnvQueryContext>           Context;                                           // 0x0208(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	EP2EnvQueryTest_NavRaycast_Direction          RaycastDirection;                                  // 0x0210(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_211[0x7];                                      // 0x0211(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"P2EnvQueryTest_NavRaycast">();
	}
	static class UP2EnvQueryTest_NavRaycast* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UP2EnvQueryTest_NavRaycast>();
	}
};
static_assert(alignof(UP2EnvQueryTest_NavRaycast) == 0x000008, "Wrong alignment on UP2EnvQueryTest_NavRaycast");
static_assert(sizeof(UP2EnvQueryTest_NavRaycast) == 0x000218, "Wrong size on UP2EnvQueryTest_NavRaycast");
static_assert(offsetof(UP2EnvQueryTest_NavRaycast, Context) == 0x000208, "Member 'UP2EnvQueryTest_NavRaycast::Context' has a wrong offset!");
static_assert(offsetof(UP2EnvQueryTest_NavRaycast, RaycastDirection) == 0x000210, "Member 'UP2EnvQueryTest_NavRaycast::RaycastDirection' has a wrong offset!");

// Class AICommon.P2EnvQueryTest_NotSelf
// 0x0000 (0x0208 - 0x0208)
class UP2EnvQueryTest_NotSelf final : public UEnvQueryTest
{
public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"P2EnvQueryTest_NotSelf">();
	}
	static class UP2EnvQueryTest_NotSelf* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UP2EnvQueryTest_NotSelf>();
	}
};
static_assert(alignof(UP2EnvQueryTest_NotSelf) == 0x000008, "Wrong alignment on UP2EnvQueryTest_NotSelf");
static_assert(sizeof(UP2EnvQueryTest_NotSelf) == 0x000208, "Wrong size on UP2EnvQueryTest_NotSelf");

// Class AICommon.P2EnvQueryTest_ObjectiveOccupied
// 0x0000 (0x0208 - 0x0208)
class UP2EnvQueryTest_ObjectiveOccupied final : public UEnvQueryTest
{
public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"P2EnvQueryTest_ObjectiveOccupied">();
	}
	static class UP2EnvQueryTest_ObjectiveOccupied* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UP2EnvQueryTest_ObjectiveOccupied>();
	}
};
static_assert(alignof(UP2EnvQueryTest_ObjectiveOccupied) == 0x000008, "Wrong alignment on UP2EnvQueryTest_ObjectiveOccupied");
static_assert(sizeof(UP2EnvQueryTest_ObjectiveOccupied) == 0x000208, "Wrong size on UP2EnvQueryTest_ObjectiveOccupied");

// Class AICommon.P2EnvQueryTest_ObjectiveUnlocked
// 0x0000 (0x0208 - 0x0208)
class UP2EnvQueryTest_ObjectiveUnlocked final : public UEnvQueryTest
{
public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"P2EnvQueryTest_ObjectiveUnlocked">();
	}
	static class UP2EnvQueryTest_ObjectiveUnlocked* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UP2EnvQueryTest_ObjectiveUnlocked>();
	}
};
static_assert(alignof(UP2EnvQueryTest_ObjectiveUnlocked) == 0x000008, "Wrong alignment on UP2EnvQueryTest_ObjectiveUnlocked");
static_assert(sizeof(UP2EnvQueryTest_ObjectiveUnlocked) == 0x000208, "Wrong size on UP2EnvQueryTest_ObjectiveUnlocked");

// Class AICommon.P2EnvQueryTest_ObjectiveVisited
// 0x0070 (0x0278 - 0x0208)
class UP2EnvQueryTest_ObjectiveVisited final : public UEnvQueryTest
{
public:
	struct FAIDataProviderIntValue                VisitsMin;                                         // 0x0208(0x0038)(Edit, DisableEditOnInstance, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	struct FAIDataProviderIntValue                VisitsMax;                                         // 0x0240(0x0038)(Edit, DisableEditOnInstance, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"P2EnvQueryTest_ObjectiveVisited">();
	}
	static class UP2EnvQueryTest_ObjectiveVisited* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UP2EnvQueryTest_ObjectiveVisited>();
	}
};
static_assert(alignof(UP2EnvQueryTest_ObjectiveVisited) == 0x000008, "Wrong alignment on UP2EnvQueryTest_ObjectiveVisited");
static_assert(sizeof(UP2EnvQueryTest_ObjectiveVisited) == 0x000278, "Wrong size on UP2EnvQueryTest_ObjectiveVisited");
static_assert(offsetof(UP2EnvQueryTest_ObjectiveVisited, VisitsMin) == 0x000208, "Member 'UP2EnvQueryTest_ObjectiveVisited::VisitsMin' has a wrong offset!");
static_assert(offsetof(UP2EnvQueryTest_ObjectiveVisited, VisitsMax) == 0x000240, "Member 'UP2EnvQueryTest_ObjectiveVisited::VisitsMax' has a wrong offset!");

// Class AICommon.P2EnvQueryTest_ObjectiveWorldLayer
// 0x0000 (0x0208 - 0x0208)
class UP2EnvQueryTest_ObjectiveWorldLayer final : public UEnvQueryTest
{
public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"P2EnvQueryTest_ObjectiveWorldLayer">();
	}
	static class UP2EnvQueryTest_ObjectiveWorldLayer* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UP2EnvQueryTest_ObjectiveWorldLayer>();
	}
};
static_assert(alignof(UP2EnvQueryTest_ObjectiveWorldLayer) == 0x000008, "Wrong alignment on UP2EnvQueryTest_ObjectiveWorldLayer");
static_assert(sizeof(UP2EnvQueryTest_ObjectiveWorldLayer) == 0x000208, "Wrong size on UP2EnvQueryTest_ObjectiveWorldLayer");

// Class AICommon.P2NavGridModiferHandler
// 0x0008 (0x0030 - 0x0028)
class UP2NavGridModiferHandler : public UObject
{
public:
	uint8                                         Pad_28[0x8];                                       // 0x0028(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"P2NavGridModiferHandler">();
	}
	static class UP2NavGridModiferHandler* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UP2NavGridModiferHandler>();
	}
};
static_assert(alignof(UP2NavGridModiferHandler) == 0x000008, "Wrong alignment on UP2NavGridModiferHandler");
static_assert(sizeof(UP2NavGridModiferHandler) == 0x000030, "Wrong size on UP2NavGridModiferHandler");

// Class AICommon.P2NavGridModiferHandler_Door
// 0x0010 (0x0040 - 0x0030)
class UP2NavGridModiferHandler_Door final : public UP2NavGridModiferHandler
{
public:
	uint8                                         Pad_30[0x10];                                      // 0x0030(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnDoorComponentFinishedMoving(EDoorState State, class UP2DoorComponent* DoorComponent)	 // 0x475d044;

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"P2NavGridModiferHandler_Door">();
	}
	static class UP2NavGridModiferHandler_Door* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UP2NavGridModiferHandler_Door>();
	}
};
static_assert(alignof(UP2NavGridModiferHandler_Door) == 0x000008, "Wrong alignment on UP2NavGridModiferHandler_Door");
static_assert(sizeof(UP2NavGridModiferHandler_Door) == 0x000040, "Wrong size on UP2NavGridModiferHandler_Door");

// Class AICommon.P2EnvQueryTest_ObjectiveZoneTag
// 0x0000 (0x0208 - 0x0208)
class UP2EnvQueryTest_ObjectiveZoneTag final : public UEnvQueryTest
{
public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"P2EnvQueryTest_ObjectiveZoneTag">();
	}
	static class UP2EnvQueryTest_ObjectiveZoneTag* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UP2EnvQueryTest_ObjectiveZoneTag>();
	}
};
static_assert(alignof(UP2EnvQueryTest_ObjectiveZoneTag) == 0x000008, "Wrong alignment on UP2EnvQueryTest_ObjectiveZoneTag");
static_assert(sizeof(UP2EnvQueryTest_ObjectiveZoneTag) == 0x000208, "Wrong size on UP2EnvQueryTest_ObjectiveZoneTag");

// Class AICommon.P2NpcAbility_SprayAttack
// 0x0060 (0x0520 - 0x04C0)
class UP2NpcAbility_SprayAttack : public UP2NpcAbility_MontageBasedAttack
{
public:
	float                                         SpawnFrequency;                                    // 0x04C0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EP2TargetingType                              TargetingType;                                     // 0x04C4(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4C5[0x3];                                      // 0x04C5(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ZoneSpacing;                                       // 0x04C8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUseLeading;                                       // 0x04CC(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUseGroundTrace;                                   // 0x04CD(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4CE[0x2];                                      // 0x04CE(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         TargetDirectionTraceDistance;                      // 0x04D0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TargetOffset;                                      // 0x04D4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HeadingErrorHalfAngleDegrees;                      // 0x04D8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4DC[0x44];                                     // 0x04DC(0x0044)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	float CalcTimeToLocation(const struct FVector& Loc)	 // 0x4764d74;
	void EndSpray()	 // 0x4764fcc;
	struct FVector GetCustomLocation()	 // 0x476505c;
	void OnEndSpray()	 // 0xae1e64;
	void OnStartSpray()	 // 0xae1e64;
	void OnTimer()	 // 0x47656d0;
	void SpawnSprayZone(const struct FVector& TargetLoc)	 // 0x47656fc;
	void StartSpray()	 // 0x4765788;

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"P2NpcAbility_SprayAttack">();
	}
	static class UP2NpcAbility_SprayAttack* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UP2NpcAbility_SprayAttack>();
	}
};
static_assert(alignof(UP2NpcAbility_SprayAttack) == 0x000008, "Wrong alignment on UP2NpcAbility_SprayAttack");
static_assert(sizeof(UP2NpcAbility_SprayAttack) == 0x000520, "Wrong size on UP2NpcAbility_SprayAttack");
static_assert(offsetof(UP2NpcAbility_SprayAttack, SpawnFrequency) == 0x0004C0, "Member 'UP2NpcAbility_SprayAttack::SpawnFrequency' has a wrong offset!");
static_assert(offsetof(UP2NpcAbility_SprayAttack, TargetingType) == 0x0004C4, "Member 'UP2NpcAbility_SprayAttack::TargetingType' has a wrong offset!");
static_assert(offsetof(UP2NpcAbility_SprayAttack, ZoneSpacing) == 0x0004C8, "Member 'UP2NpcAbility_SprayAttack::ZoneSpacing' has a wrong offset!");
static_assert(offsetof(UP2NpcAbility_SprayAttack, bUseLeading) == 0x0004CC, "Member 'UP2NpcAbility_SprayAttack::bUseLeading' has a wrong offset!");
static_assert(offsetof(UP2NpcAbility_SprayAttack, bUseGroundTrace) == 0x0004CD, "Member 'UP2NpcAbility_SprayAttack::bUseGroundTrace' has a wrong offset!");
static_assert(offsetof(UP2NpcAbility_SprayAttack, TargetDirectionTraceDistance) == 0x0004D0, "Member 'UP2NpcAbility_SprayAttack::TargetDirectionTraceDistance' has a wrong offset!");
static_assert(offsetof(UP2NpcAbility_SprayAttack, TargetOffset) == 0x0004D4, "Member 'UP2NpcAbility_SprayAttack::TargetOffset' has a wrong offset!");
static_assert(offsetof(UP2NpcAbility_SprayAttack, HeadingErrorHalfAngleDegrees) == 0x0004D8, "Member 'UP2NpcAbility_SprayAttack::HeadingErrorHalfAngleDegrees' has a wrong offset!");

// Class AICommon.P2EnvQueryTest_PlayerBot_IsInsideAnomaly
// 0x0000 (0x0208 - 0x0208)
class UP2EnvQueryTest_PlayerBot_IsInsideAnomaly final : public UEnvQueryTest
{
public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"P2EnvQueryTest_PlayerBot_IsInsideAnomaly">();
	}
	static class UP2EnvQueryTest_PlayerBot_IsInsideAnomaly* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UP2EnvQueryTest_PlayerBot_IsInsideAnomaly>();
	}
};
static_assert(alignof(UP2EnvQueryTest_PlayerBot_IsInsideAnomaly) == 0x000008, "Wrong alignment on UP2EnvQueryTest_PlayerBot_IsInsideAnomaly");
static_assert(sizeof(UP2EnvQueryTest_PlayerBot_IsInsideAnomaly) == 0x000208, "Wrong size on UP2EnvQueryTest_PlayerBot_IsInsideAnomaly");

// Class AICommon.P2EnvQueryTest_PlayerBot_IsPlayerControlled
// 0x0000 (0x0208 - 0x0208)
class UP2EnvQueryTest_PlayerBot_IsPlayerControlled final : public UEnvQueryTest
{
public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"P2EnvQueryTest_PlayerBot_IsPlayerControlled">();
	}
	static class UP2EnvQueryTest_PlayerBot_IsPlayerControlled* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UP2EnvQueryTest_PlayerBot_IsPlayerControlled>();
	}
};
static_assert(alignof(UP2EnvQueryTest_PlayerBot_IsPlayerControlled) == 0x000008, "Wrong alignment on UP2EnvQueryTest_PlayerBot_IsPlayerControlled");
static_assert(sizeof(UP2EnvQueryTest_PlayerBot_IsPlayerControlled) == 0x000208, "Wrong size on UP2EnvQueryTest_PlayerBot_IsPlayerControlled");

// Class AICommon.P2EnvQueryTest_SmartObjectIsFree
// 0x0000 (0x0208 - 0x0208)
class UP2EnvQueryTest_SmartObjectIsFree final : public UEnvQueryTest
{
public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"P2EnvQueryTest_SmartObjectIsFree">();
	}
	static class UP2EnvQueryTest_SmartObjectIsFree* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UP2EnvQueryTest_SmartObjectIsFree>();
	}
};
static_assert(alignof(UP2EnvQueryTest_SmartObjectIsFree) == 0x000008, "Wrong alignment on UP2EnvQueryTest_SmartObjectIsFree");
static_assert(sizeof(UP2EnvQueryTest_SmartObjectIsFree) == 0x000208, "Wrong size on UP2EnvQueryTest_SmartObjectIsFree");

// Class AICommon.P2EnvQueryTest_SmartObjectPriority
// 0x0000 (0x0208 - 0x0208)
class UP2EnvQueryTest_SmartObjectPriority final : public UEnvQueryTest
{
public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"P2EnvQueryTest_SmartObjectPriority">();
	}
	static class UP2EnvQueryTest_SmartObjectPriority* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UP2EnvQueryTest_SmartObjectPriority>();
	}
};
static_assert(alignof(UP2EnvQueryTest_SmartObjectPriority) == 0x000008, "Wrong alignment on UP2EnvQueryTest_SmartObjectPriority");
static_assert(sizeof(UP2EnvQueryTest_SmartObjectPriority) == 0x000208, "Wrong size on UP2EnvQueryTest_SmartObjectPriority");

// Class AICommon.P2EnvQueryTest_Spotted
// 0x0000 (0x0208 - 0x0208)
class UP2EnvQueryTest_Spotted final : public UEnvQueryTest
{
public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"P2EnvQueryTest_Spotted">();
	}
	static class UP2EnvQueryTest_Spotted* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UP2EnvQueryTest_Spotted>();
	}
};
static_assert(alignof(UP2EnvQueryTest_Spotted) == 0x000008, "Wrong alignment on UP2EnvQueryTest_Spotted");
static_assert(sizeof(UP2EnvQueryTest_Spotted) == 0x000208, "Wrong size on UP2EnvQueryTest_Spotted");

// Class AICommon.P2EnvQueryTest_TargetVisible
// 0x0000 (0x0208 - 0x0208)
class UP2EnvQueryTest_TargetVisible final : public UEnvQueryTest
{
public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"P2EnvQueryTest_TargetVisible">();
	}
	static class UP2EnvQueryTest_TargetVisible* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UP2EnvQueryTest_TargetVisible>();
	}
};
static_assert(alignof(UP2EnvQueryTest_TargetVisible) == 0x000008, "Wrong alignment on UP2EnvQueryTest_TargetVisible");
static_assert(sizeof(UP2EnvQueryTest_TargetVisible) == 0x000208, "Wrong size on UP2EnvQueryTest_TargetVisible");

// Class AICommon.P2EnvQueryTest_Volume
// 0x0078 (0x0280 - 0x0208)
class UP2EnvQueryTest_Volume final : public UEnvQueryTest
{
public:
	TSubclassOf<class UEnvQueryContext>           VolumeContext;                                     // 0x0208(0x0008)(Edit, ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FAIDataProviderFloatValue              PointInflation;                                    // 0x0210(0x0038)(Edit, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	struct FAIDataProviderFloatValue              VolumeInflation;                                   // 0x0248(0x0038)(Edit, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"P2EnvQueryTest_Volume">();
	}
	static class UP2EnvQueryTest_Volume* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UP2EnvQueryTest_Volume>();
	}
};
static_assert(alignof(UP2EnvQueryTest_Volume) == 0x000008, "Wrong alignment on UP2EnvQueryTest_Volume");
static_assert(sizeof(UP2EnvQueryTest_Volume) == 0x000280, "Wrong size on UP2EnvQueryTest_Volume");
static_assert(offsetof(UP2EnvQueryTest_Volume, VolumeContext) == 0x000208, "Member 'UP2EnvQueryTest_Volume::VolumeContext' has a wrong offset!");
static_assert(offsetof(UP2EnvQueryTest_Volume, PointInflation) == 0x000210, "Member 'UP2EnvQueryTest_Volume::PointInflation' has a wrong offset!");
static_assert(offsetof(UP2EnvQueryTest_Volume, VolumeInflation) == 0x000248, "Member 'UP2EnvQueryTest_Volume::VolumeInflation' has a wrong offset!");

// Class AICommon.P2ExtractionDroneActor
// 0x0190 (0x0D00 - 0x0B70)
class AP2ExtractionDroneActor : public AP2NpcFlyingCharacter
{
public:
	uint8                                         Pad_B70[0x20];                                     // 0x0B70(0x0020)(Fixing Size After Last Property [ Dumper-7 ])
	TMulticastInlineDelegate<void()>              OnTransferredToActor;                              // 0x0B90(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void()>              OnActivationTimerStarted;                          // 0x0BA0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void()>              OnActivationTimerFinished;                         // 0x0BB0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void()>              OnDeployableDestroyed;                             // 0x0BC0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void()>              OnTunnelStarted;                                   // 0x0BD0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void()>              OnGroundCollision;                                 // 0x0BE0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void()>              OnMapMarkerCreate;                                 // 0x0BF0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void()>              OnMapMarkerDestroy;                                // 0x0C00(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void()>              OnDroneEndHeight;                                  // 0x0C10(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void()>              OnDroneTakeDamageEvent;                            // 0x0C20(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	class UP2Deployable*                          Deployable;                                        // 0x0C30(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, DisableEditOnTemplate, EditConst, RepNotify, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class USkeletalMesh>           DestroyedMesh;                                     // 0x0C38(0x0030)(Edit, BlueprintVisible, BlueprintReadOnly, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UP2NpcData*                             NpcData;                                           // 0x0C68(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FPrimaryAssetId                        NpcDataId;                                         // 0x0C70(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C80[0x10];                                     // 0x0C80(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTimespan                              TimeToExpire;                                      // 0x0C90(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FVector                                OnDeathAngularVelocity;                            // 0x0C98(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         FlightHeight;                                      // 0x0CB0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         NavigationRadius;                                  // 0x0CB4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         SearchRadius;                                      // 0x0CB8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         ExtractionDelayTimer;                              // 0x0CBC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         TunnelDurationTimer;                               // 0x0CC0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bIsNavAvailable;                                   // 0x0CC4(0x0001)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bWasLaunched;                                      // 0x0CC5(0x0001)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bDoneFlying;                                       // 0x0CC6(0x0001)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bDeliveredItems;                                   // 0x0CC7(0x0001)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FGameplayTag                           TargetPlayerStartsTag;                             // 0x0CC8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<class UP2Item*>                        ModItems;                                          // 0x0CD0(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	TArray<class UP2Container*>                   ModContainers;                                     // 0x0CE0(0x0010)(Net, ZeroConstructor, NativeAccessSpecifierPrivate)
	uint8                                         Pad_CF0[0x8];                                      // 0x0CF0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         TeamId;                                            // 0x0CF8(0x0004)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_CFC[0x4];                                      // 0x0CFC(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void DoneFlying()	 // 0x47523f8;
	void ExtractDrone()	 // 0x475240c;
	float GetCurrentHealth()	 // 0x4752420;
	void MulticastStartTunnel()	 // 0x4752448;
	void OnCollide(class UPrimitiveComponent* HitComp, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, const struct FVector& NormalImpulse, const struct FHitResult& Hit)	 // 0x4752460;
	void OnRep_Deployable()	 // 0x4752734;
	void StartedFlying()	 // 0x475275c;
	void StartTunnel()	 // 0x4752748;
	void StoppedFlying()	 // 0x4752770;
	void TryDeliverItems(class UP2HealthComponent* InHealthComponent, const struct FP2FinalBlowImpulseData& InImpulse)	 // 0x4752784;

	int32 GetTeamId() const	 // 0x2da7d30;

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"P2ExtractionDroneActor">();
	}
	static class AP2ExtractionDroneActor* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<AP2ExtractionDroneActor>();
	}
};
static_assert(alignof(AP2ExtractionDroneActor) == 0x000010, "Wrong alignment on AP2ExtractionDroneActor");
static_assert(sizeof(AP2ExtractionDroneActor) == 0x000D00, "Wrong size on AP2ExtractionDroneActor");
static_assert(offsetof(AP2ExtractionDroneActor, OnTransferredToActor) == 0x000B90, "Member 'AP2ExtractionDroneActor::OnTransferredToActor' has a wrong offset!");
static_assert(offsetof(AP2ExtractionDroneActor, OnActivationTimerStarted) == 0x000BA0, "Member 'AP2ExtractionDroneActor::OnActivationTimerStarted' has a wrong offset!");
static_assert(offsetof(AP2ExtractionDroneActor, OnActivationTimerFinished) == 0x000BB0, "Member 'AP2ExtractionDroneActor::OnActivationTimerFinished' has a wrong offset!");
static_assert(offsetof(AP2ExtractionDroneActor, OnDeployableDestroyed) == 0x000BC0, "Member 'AP2ExtractionDroneActor::OnDeployableDestroyed' has a wrong offset!");
static_assert(offsetof(AP2ExtractionDroneActor, OnTunnelStarted) == 0x000BD0, "Member 'AP2ExtractionDroneActor::OnTunnelStarted' has a wrong offset!");
static_assert(offsetof(AP2ExtractionDroneActor, OnGroundCollision) == 0x000BE0, "Member 'AP2ExtractionDroneActor::OnGroundCollision' has a wrong offset!");
static_assert(offsetof(AP2ExtractionDroneActor, OnMapMarkerCreate) == 0x000BF0, "Member 'AP2ExtractionDroneActor::OnMapMarkerCreate' has a wrong offset!");
static_assert(offsetof(AP2ExtractionDroneActor, OnMapMarkerDestroy) == 0x000C00, "Member 'AP2ExtractionDroneActor::OnMapMarkerDestroy' has a wrong offset!");
static_assert(offsetof(AP2ExtractionDroneActor, OnDroneEndHeight) == 0x000C10, "Member 'AP2ExtractionDroneActor::OnDroneEndHeight' has a wrong offset!");
static_assert(offsetof(AP2ExtractionDroneActor, OnDroneTakeDamageEvent) == 0x000C20, "Member 'AP2ExtractionDroneActor::OnDroneTakeDamageEvent' has a wrong offset!");
static_assert(offsetof(AP2ExtractionDroneActor, Deployable) == 0x000C30, "Member 'AP2ExtractionDroneActor::Deployable' has a wrong offset!");
static_assert(offsetof(AP2ExtractionDroneActor, DestroyedMesh) == 0x000C38, "Member 'AP2ExtractionDroneActor::DestroyedMesh' has a wrong offset!");
static_assert(offsetof(AP2ExtractionDroneActor, NpcData) == 0x000C68, "Member 'AP2ExtractionDroneActor::NpcData' has a wrong offset!");
static_assert(offsetof(AP2ExtractionDroneActor, NpcDataId) == 0x000C70, "Member 'AP2ExtractionDroneActor::NpcDataId' has a wrong offset!");
static_assert(offsetof(AP2ExtractionDroneActor, TimeToExpire) == 0x000C90, "Member 'AP2ExtractionDroneActor::TimeToExpire' has a wrong offset!");
static_assert(offsetof(AP2ExtractionDroneActor, OnDeathAngularVelocity) == 0x000C98, "Member 'AP2ExtractionDroneActor::OnDeathAngularVelocity' has a wrong offset!");
static_assert(offsetof(AP2ExtractionDroneActor, FlightHeight) == 0x000CB0, "Member 'AP2ExtractionDroneActor::FlightHeight' has a wrong offset!");
static_assert(offsetof(AP2ExtractionDroneActor, NavigationRadius) == 0x000CB4, "Member 'AP2ExtractionDroneActor::NavigationRadius' has a wrong offset!");
static_assert(offsetof(AP2ExtractionDroneActor, SearchRadius) == 0x000CB8, "Member 'AP2ExtractionDroneActor::SearchRadius' has a wrong offset!");
static_assert(offsetof(AP2ExtractionDroneActor, ExtractionDelayTimer) == 0x000CBC, "Member 'AP2ExtractionDroneActor::ExtractionDelayTimer' has a wrong offset!");
static_assert(offsetof(AP2ExtractionDroneActor, TunnelDurationTimer) == 0x000CC0, "Member 'AP2ExtractionDroneActor::TunnelDurationTimer' has a wrong offset!");
static_assert(offsetof(AP2ExtractionDroneActor, bIsNavAvailable) == 0x000CC4, "Member 'AP2ExtractionDroneActor::bIsNavAvailable' has a wrong offset!");
static_assert(offsetof(AP2ExtractionDroneActor, bWasLaunched) == 0x000CC5, "Member 'AP2ExtractionDroneActor::bWasLaunched' has a wrong offset!");
static_assert(offsetof(AP2ExtractionDroneActor, bDoneFlying) == 0x000CC6, "Member 'AP2ExtractionDroneActor::bDoneFlying' has a wrong offset!");
static_assert(offsetof(AP2ExtractionDroneActor, bDeliveredItems) == 0x000CC7, "Member 'AP2ExtractionDroneActor::bDeliveredItems' has a wrong offset!");
static_assert(offsetof(AP2ExtractionDroneActor, TargetPlayerStartsTag) == 0x000CC8, "Member 'AP2ExtractionDroneActor::TargetPlayerStartsTag' has a wrong offset!");
static_assert(offsetof(AP2ExtractionDroneActor, ModItems) == 0x000CD0, "Member 'AP2ExtractionDroneActor::ModItems' has a wrong offset!");
static_assert(offsetof(AP2ExtractionDroneActor, ModContainers) == 0x000CE0, "Member 'AP2ExtractionDroneActor::ModContainers' has a wrong offset!");
static_assert(offsetof(AP2ExtractionDroneActor, TeamId) == 0x000CF8, "Member 'AP2ExtractionDroneActor::TeamId' has a wrong offset!");

// Class AICommon.P2GeneratableNavLink
// 0x0000 (0x0000 - 0x0000)
class IP2GeneratableNavLink final
{
public:
	struct FTransform GetTransformForOwner(const class AActor* InOwner) const	 // 0x4754a84;

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"P2GeneratableNavLink">();
	}
	static class IP2GeneratableNavLink* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<IP2GeneratableNavLink>();
	}

	class UObject* AsUObject()	 // 0x0
	{
		return reinterpret_cast<UObject*>(this);
	}
	const class UObject* AsUObject() const	 // 0x0
	{
		return reinterpret_cast<const UObject*>(this);
	}
};
static_assert(alignof(IP2GeneratableNavLink) == 0x000001, "Wrong alignment on IP2GeneratableNavLink");
static_assert(sizeof(IP2GeneratableNavLink) == 0x000001, "Wrong size on IP2GeneratableNavLink");

// Class AICommon.P2GhostAIController
// 0x0138 (0x0560 - 0x0428)
class AP2GhostAIController : public AP2AIController
{
public:
	uint8                                         Pad_428[0x18];                                     // 0x0428(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   TargetBlackboardKeyName;                           // 0x0440(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   TargetVisibleBlackboardKeyName;                    // 0x0448(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   TargetSpottedBlackboardKeyName;                    // 0x0450(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   TargetLocationBlackboardKeyName;                   // 0x0458(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         InitialAccuracyOnNewTarget;                        // 0x0460(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_464[0xC];                                      // 0x0464(0x000C)(Fixing Size After Last Property [ Dumper-7 ])
	class UP2NpcGroupMemberData*                  MemberData;                                        // 0x0470(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_478[0x18];                                     // 0x0478(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bUseFixedDistance;                                 // 0x0490(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_491[0x3];                                      // 0x0491(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         AimCalculationFixedDistance;                       // 0x0494(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         AimZTightRatio;                                    // 0x0498(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_49C[0x4];                                      // 0x049C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                TargetLocationOffset;                              // 0x04A0(0x0018)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bUsePrediction;                                    // 0x04B8(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bUseBoolAccuracy;                                  // 0x04B9(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bUseCapsuleSectionAiming;                          // 0x04BA(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bUseCQCCapsuleSections;                            // 0x04BB(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_4BC[0x4];                                      // 0x04BC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<EP2CapsuleSection, struct FP2CapsuleSectionConfig> CapsuleSectionConfigs;                   // 0x04C0(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_510[0x50];                                     // 0x0510(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"P2GhostAIController">();
	}
	static class AP2GhostAIController* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<AP2GhostAIController>();
	}
};
static_assert(alignof(AP2GhostAIController) == 0x000008, "Wrong alignment on AP2GhostAIController");
static_assert(sizeof(AP2GhostAIController) == 0x000560, "Wrong size on AP2GhostAIController");
static_assert(offsetof(AP2GhostAIController, TargetBlackboardKeyName) == 0x000440, "Member 'AP2GhostAIController::TargetBlackboardKeyName' has a wrong offset!");
static_assert(offsetof(AP2GhostAIController, TargetVisibleBlackboardKeyName) == 0x000448, "Member 'AP2GhostAIController::TargetVisibleBlackboardKeyName' has a wrong offset!");
static_assert(offsetof(AP2GhostAIController, TargetSpottedBlackboardKeyName) == 0x000450, "Member 'AP2GhostAIController::TargetSpottedBlackboardKeyName' has a wrong offset!");
static_assert(offsetof(AP2GhostAIController, TargetLocationBlackboardKeyName) == 0x000458, "Member 'AP2GhostAIController::TargetLocationBlackboardKeyName' has a wrong offset!");
static_assert(offsetof(AP2GhostAIController, InitialAccuracyOnNewTarget) == 0x000460, "Member 'AP2GhostAIController::InitialAccuracyOnNewTarget' has a wrong offset!");
static_assert(offsetof(AP2GhostAIController, MemberData) == 0x000470, "Member 'AP2GhostAIController::MemberData' has a wrong offset!");
static_assert(offsetof(AP2GhostAIController, bUseFixedDistance) == 0x000490, "Member 'AP2GhostAIController::bUseFixedDistance' has a wrong offset!");
static_assert(offsetof(AP2GhostAIController, AimCalculationFixedDistance) == 0x000494, "Member 'AP2GhostAIController::AimCalculationFixedDistance' has a wrong offset!");
static_assert(offsetof(AP2GhostAIController, AimZTightRatio) == 0x000498, "Member 'AP2GhostAIController::AimZTightRatio' has a wrong offset!");
static_assert(offsetof(AP2GhostAIController, TargetLocationOffset) == 0x0004A0, "Member 'AP2GhostAIController::TargetLocationOffset' has a wrong offset!");
static_assert(offsetof(AP2GhostAIController, bUsePrediction) == 0x0004B8, "Member 'AP2GhostAIController::bUsePrediction' has a wrong offset!");
static_assert(offsetof(AP2GhostAIController, bUseBoolAccuracy) == 0x0004B9, "Member 'AP2GhostAIController::bUseBoolAccuracy' has a wrong offset!");
static_assert(offsetof(AP2GhostAIController, bUseCapsuleSectionAiming) == 0x0004BA, "Member 'AP2GhostAIController::bUseCapsuleSectionAiming' has a wrong offset!");
static_assert(offsetof(AP2GhostAIController, bUseCQCCapsuleSections) == 0x0004BB, "Member 'AP2GhostAIController::bUseCQCCapsuleSections' has a wrong offset!");
static_assert(offsetof(AP2GhostAIController, CapsuleSectionConfigs) == 0x0004C0, "Member 'AP2GhostAIController::CapsuleSectionConfigs' has a wrong offset!");

// Class AICommon.P2GhostBurstConfigData
// 0x0050 (0x0080 - 0x0030)
class UP2GhostBurstConfigData final : public UPrimaryDataAsset
{
public:
	TMap<class FName, struct FP2BurstConfig>      Configs;                                           // 0x0030(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"P2GhostBurstConfigData">();
	}
	static class UP2GhostBurstConfigData* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UP2GhostBurstConfigData>();
	}
};
static_assert(alignof(UP2GhostBurstConfigData) == 0x000008, "Wrong alignment on UP2GhostBurstConfigData");
static_assert(sizeof(UP2GhostBurstConfigData) == 0x000080, "Wrong size on UP2GhostBurstConfigData");
static_assert(offsetof(UP2GhostBurstConfigData, Configs) == 0x000030, "Member 'UP2GhostBurstConfigData::Configs' has a wrong offset!");

// Class AICommon.P2GhostAttackData
// 0x0040 (0x0070 - 0x0030)
class UP2GhostAttackData final : public UPrimaryDataAsset
{
public:
	float                                         MaxTargetVisibilityTime;                           // 0x0030(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MinTargetVisibilityTimeToAttack;                   // 0x0034(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MinTargetDotToAttack;                              // 0x0038(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3C[0x4];                                       // 0x003C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FScalableFloat                         TimeToAimDelay;                                    // 0x0040(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	float                                         CQCDistanceThreshold;                              // 0x0068(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DisengageCQCDistanceThreshold;                     // 0x006C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"P2GhostAttackData">();
	}
	static class UP2GhostAttackData* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UP2GhostAttackData>();
	}
};
static_assert(alignof(UP2GhostAttackData) == 0x000008, "Wrong alignment on UP2GhostAttackData");
static_assert(sizeof(UP2GhostAttackData) == 0x000070, "Wrong size on UP2GhostAttackData");
static_assert(offsetof(UP2GhostAttackData, MaxTargetVisibilityTime) == 0x000030, "Member 'UP2GhostAttackData::MaxTargetVisibilityTime' has a wrong offset!");
static_assert(offsetof(UP2GhostAttackData, MinTargetVisibilityTimeToAttack) == 0x000034, "Member 'UP2GhostAttackData::MinTargetVisibilityTimeToAttack' has a wrong offset!");
static_assert(offsetof(UP2GhostAttackData, MinTargetDotToAttack) == 0x000038, "Member 'UP2GhostAttackData::MinTargetDotToAttack' has a wrong offset!");
static_assert(offsetof(UP2GhostAttackData, TimeToAimDelay) == 0x000040, "Member 'UP2GhostAttackData::TimeToAimDelay' has a wrong offset!");
static_assert(offsetof(UP2GhostAttackData, CQCDistanceThreshold) == 0x000068, "Member 'UP2GhostAttackData::CQCDistanceThreshold' has a wrong offset!");
static_assert(offsetof(UP2GhostAttackData, DisengageCQCDistanceThreshold) == 0x00006C, "Member 'UP2GhostAttackData::DisengageCQCDistanceThreshold' has a wrong offset!");

// Class AICommon.P2GhostGroupObjective
// 0x00A0 (0x0350 - 0x02B0)
class AP2GhostGroupObjective final : public AActor
{
public:
	float                                         AreaRadius;                                        // 0x02B0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2B4[0x4];                                      // 0x02B4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FP2GroupObjectiveZoneDefinition> ZoneDefinitions;                                  // 0x02B8(0x0010)(Edit, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	struct FGameplayTagContainer                  WorldLayers;                                       // 0x02C8(0x0020)(Protected, NativeAccessSpecifierProtected)
	struct FGameplayTag                           Zone;                                              // 0x02E8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2F0[0x60];                                     // 0x02F0(0x0060)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"P2GhostGroupObjective">();
	}
	static class AP2GhostGroupObjective* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<AP2GhostGroupObjective>();
	}
};
static_assert(alignof(AP2GhostGroupObjective) == 0x000008, "Wrong alignment on AP2GhostGroupObjective");
static_assert(sizeof(AP2GhostGroupObjective) == 0x000350, "Wrong size on AP2GhostGroupObjective");
static_assert(offsetof(AP2GhostGroupObjective, AreaRadius) == 0x0002B0, "Member 'AP2GhostGroupObjective::AreaRadius' has a wrong offset!");
static_assert(offsetof(AP2GhostGroupObjective, ZoneDefinitions) == 0x0002B8, "Member 'AP2GhostGroupObjective::ZoneDefinitions' has a wrong offset!");
static_assert(offsetof(AP2GhostGroupObjective, WorldLayers) == 0x0002C8, "Member 'AP2GhostGroupObjective::WorldLayers' has a wrong offset!");
static_assert(offsetof(AP2GhostGroupObjective, Zone) == 0x0002E8, "Member 'AP2GhostGroupObjective::Zone' has a wrong offset!");

// Class AICommon.P2HeroNoiseSourceConfig
// 0x0030 (0x0060 - 0x0030)
class UP2HeroNoiseSourceConfig final : public UDataAsset
{
public:
	class UCurveFloat*                            WalkSpeedToLoudness;                               // 0x0030(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCurveFloat*                            CrouchedWalkSpeedToLoudness;                       // 0x0038(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCurveFloat*                            SprintSpeedToLoudness;                             // 0x0040(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCurveFloat*                            FallSpeedToLoudness;                               // 0x0048(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCurveFloat*                            SwimSpeedToLoudness;                               // 0x0050(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         JumpLoudness;                                      // 0x0058(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ThrowableBounceLoudness;                           // 0x005C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"P2HeroNoiseSourceConfig">();
	}
	static class UP2HeroNoiseSourceConfig* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UP2HeroNoiseSourceConfig>();
	}
};
static_assert(alignof(UP2HeroNoiseSourceConfig) == 0x000008, "Wrong alignment on UP2HeroNoiseSourceConfig");
static_assert(sizeof(UP2HeroNoiseSourceConfig) == 0x000060, "Wrong size on UP2HeroNoiseSourceConfig");
static_assert(offsetof(UP2HeroNoiseSourceConfig, WalkSpeedToLoudness) == 0x000030, "Member 'UP2HeroNoiseSourceConfig::WalkSpeedToLoudness' has a wrong offset!");
static_assert(offsetof(UP2HeroNoiseSourceConfig, CrouchedWalkSpeedToLoudness) == 0x000038, "Member 'UP2HeroNoiseSourceConfig::CrouchedWalkSpeedToLoudness' has a wrong offset!");
static_assert(offsetof(UP2HeroNoiseSourceConfig, SprintSpeedToLoudness) == 0x000040, "Member 'UP2HeroNoiseSourceConfig::SprintSpeedToLoudness' has a wrong offset!");
static_assert(offsetof(UP2HeroNoiseSourceConfig, FallSpeedToLoudness) == 0x000048, "Member 'UP2HeroNoiseSourceConfig::FallSpeedToLoudness' has a wrong offset!");
static_assert(offsetof(UP2HeroNoiseSourceConfig, SwimSpeedToLoudness) == 0x000050, "Member 'UP2HeroNoiseSourceConfig::SwimSpeedToLoudness' has a wrong offset!");
static_assert(offsetof(UP2HeroNoiseSourceConfig, JumpLoudness) == 0x000058, "Member 'UP2HeroNoiseSourceConfig::JumpLoudness' has a wrong offset!");
static_assert(offsetof(UP2HeroNoiseSourceConfig, ThrowableBounceLoudness) == 0x00005C, "Member 'UP2HeroNoiseSourceConfig::ThrowableBounceLoudness' has a wrong offset!");

// Class AICommon.P2HeroPerceptionSourceComponent
// 0x0008 (0x00C8 - 0x00C0)
class UP2HeroPerceptionSourceComponent final : public UActorComponent
{
public:
	class UP2HealthComponent*                     OwnerHealthComponent;                              // 0x00C0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void OnOwnerExfiltrated(const struct FGameplayTag& ExfilTag)	 // 0x4758060;
	void OnOwnerUnconsciousEnded(class UP2HealthComponent* HealthComponent)	 // 0x4758120;
	void OnOwnerUnconsciousStarted(class UP2HealthComponent* HealthComponent)	 // 0x47581e0;

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"P2HeroPerceptionSourceComponent">();
	}
	static class UP2HeroPerceptionSourceComponent* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UP2HeroPerceptionSourceComponent>();
	}
};
static_assert(alignof(UP2HeroPerceptionSourceComponent) == 0x000008, "Wrong alignment on UP2HeroPerceptionSourceComponent");
static_assert(sizeof(UP2HeroPerceptionSourceComponent) == 0x0000C8, "Wrong size on UP2HeroPerceptionSourceComponent");
static_assert(offsetof(UP2HeroPerceptionSourceComponent, OwnerHealthComponent) == 0x0000C0, "Member 'UP2HeroPerceptionSourceComponent::OwnerHealthComponent' has a wrong offset!");

// Class AICommon.P2JumpLinkData
// 0x0018 (0x0048 - 0x0030)
class UP2JumpLinkData final : public UDataAsset
{
public:
	float                                         VerticalDisplacementErrorFactor;                   // 0x0030(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_34[0x4];                                       // 0x0034(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UP2JumpLinkConfig*>              JumpLinkConfigs;                                   // 0x0038(0x0010)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, ContainsInstancedReference, UObjectWrapper, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"P2JumpLinkData">();
	}
	static class UP2JumpLinkData* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UP2JumpLinkData>();
	}
};
static_assert(alignof(UP2JumpLinkData) == 0x000008, "Wrong alignment on UP2JumpLinkData");
static_assert(sizeof(UP2JumpLinkData) == 0x000048, "Wrong size on UP2JumpLinkData");
static_assert(offsetof(UP2JumpLinkData, VerticalDisplacementErrorFactor) == 0x000030, "Member 'UP2JumpLinkData::VerticalDisplacementErrorFactor' has a wrong offset!");
static_assert(offsetof(UP2JumpLinkData, JumpLinkConfigs) == 0x000038, "Member 'UP2JumpLinkData::JumpLinkConfigs' has a wrong offset!");

// Class AICommon.P2JumpNavLink
// 0x0010 (0x0590 - 0x0580)
class AP2JumpNavLink final : public AP2MercunaNavLink
{
public:
	TArray<struct FP2WarpTargetPoint>             IntermediatePoints;                                // 0x0580(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"P2JumpNavLink">();
	}
	static class AP2JumpNavLink* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<AP2JumpNavLink>();
	}
};
static_assert(alignof(AP2JumpNavLink) == 0x000010, "Wrong alignment on AP2JumpNavLink");
static_assert(sizeof(AP2JumpNavLink) == 0x000590, "Wrong size on AP2JumpNavLink");
static_assert(offsetof(AP2JumpNavLink, IntermediatePoints) == 0x000580, "Member 'AP2JumpNavLink::IntermediatePoints' has a wrong offset!");

// Class AICommon.P2LookedAtSenseData
// 0x0028 (0x0058 - 0x0030)
class UP2LookedAtSenseData final : public UDataAsset
{
public:
	float                                         TimeToBeDetectedSec;                               // 0x0030(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TimeToBeForgottenSec;                              // 0x0034(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ClearViewDistance;                                 // 0x0038(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxViewDistance;                                   // 0x003C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxDirectionErrorDeg;                              // 0x0040(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_44[0x4];                                       // 0x0044(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UCurveFloat*                            RateScaleWithDistance;                             // 0x0048(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCurveFloat*                            RateScaleWithDirectionError;                       // 0x0050(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"P2LookedAtSenseData">();
	}
	static class UP2LookedAtSenseData* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UP2LookedAtSenseData>();
	}
};
static_assert(alignof(UP2LookedAtSenseData) == 0x000008, "Wrong alignment on UP2LookedAtSenseData");
static_assert(sizeof(UP2LookedAtSenseData) == 0x000058, "Wrong size on UP2LookedAtSenseData");
static_assert(offsetof(UP2LookedAtSenseData, TimeToBeDetectedSec) == 0x000030, "Member 'UP2LookedAtSenseData::TimeToBeDetectedSec' has a wrong offset!");
static_assert(offsetof(UP2LookedAtSenseData, TimeToBeForgottenSec) == 0x000034, "Member 'UP2LookedAtSenseData::TimeToBeForgottenSec' has a wrong offset!");
static_assert(offsetof(UP2LookedAtSenseData, ClearViewDistance) == 0x000038, "Member 'UP2LookedAtSenseData::ClearViewDistance' has a wrong offset!");
static_assert(offsetof(UP2LookedAtSenseData, MaxViewDistance) == 0x00003C, "Member 'UP2LookedAtSenseData::MaxViewDistance' has a wrong offset!");
static_assert(offsetof(UP2LookedAtSenseData, MaxDirectionErrorDeg) == 0x000040, "Member 'UP2LookedAtSenseData::MaxDirectionErrorDeg' has a wrong offset!");
static_assert(offsetof(UP2LookedAtSenseData, RateScaleWithDistance) == 0x000048, "Member 'UP2LookedAtSenseData::RateScaleWithDistance' has a wrong offset!");
static_assert(offsetof(UP2LookedAtSenseData, RateScaleWithDirectionError) == 0x000050, "Member 'UP2LookedAtSenseData::RateScaleWithDirectionError' has a wrong offset!");

// Class AICommon.P2MeleeComponent
// 0x0010 (0x00D8 - 0x00C8)
class UP2MeleeComponent final : public UP2PawnComponent
{
public:
	TArray<class UP2MeleeSlot*>                   Slots;                                             // 0x00C8(0x0010)(ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"P2MeleeComponent">();
	}
	static class UP2MeleeComponent* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UP2MeleeComponent>();
	}
};
static_assert(alignof(UP2MeleeComponent) == 0x000008, "Wrong alignment on UP2MeleeComponent");
static_assert(sizeof(UP2MeleeComponent) == 0x0000D8, "Wrong size on UP2MeleeComponent");
static_assert(offsetof(UP2MeleeComponent, Slots) == 0x0000C8, "Member 'UP2MeleeComponent::Slots' has a wrong offset!");

// Class AICommon.MeleeConditionTestActor
// 0x0018 (0x02C8 - 0x02B0)
class AMeleeConditionTestActor final : public AActor
{
public:
	class UP2MeleeCondition*                      Condition;                                         // 0x02B0(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, PersistentInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TWeakObjectPtr<class AActor>                  Target;                                            // 0x02B8(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USphereComponent*                       Sphere;                                            // 0x02C0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"MeleeConditionTestActor">();
	}
	static class AMeleeConditionTestActor* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<AMeleeConditionTestActor>();
	}
};
static_assert(alignof(AMeleeConditionTestActor) == 0x000008, "Wrong alignment on AMeleeConditionTestActor");
static_assert(sizeof(AMeleeConditionTestActor) == 0x0002C8, "Wrong size on AMeleeConditionTestActor");
static_assert(offsetof(AMeleeConditionTestActor, Condition) == 0x0002B0, "Member 'AMeleeConditionTestActor::Condition' has a wrong offset!");
static_assert(offsetof(AMeleeConditionTestActor, Target) == 0x0002B8, "Member 'AMeleeConditionTestActor::Target' has a wrong offset!");
static_assert(offsetof(AMeleeConditionTestActor, Sphere) == 0x0002C0, "Member 'AMeleeConditionTestActor::Sphere' has a wrong offset!");

// Class AICommon.P2MeleeCondition_HasLineOfMotion
// 0x0008 (0x0038 - 0x0030)
class UP2MeleeCondition_HasLineOfMotion final : public UP2MeleeCondition
{
public:
	TSubclassOf<class UNavigationQueryFilter>     FilterClass;                                       // 0x0030(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"P2MeleeCondition_HasLineOfMotion">();
	}
	static class UP2MeleeCondition_HasLineOfMotion* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UP2MeleeCondition_HasLineOfMotion>();
	}
};
static_assert(alignof(UP2MeleeCondition_HasLineOfMotion) == 0x000008, "Wrong alignment on UP2MeleeCondition_HasLineOfMotion");
static_assert(sizeof(UP2MeleeCondition_HasLineOfMotion) == 0x000038, "Wrong size on UP2MeleeCondition_HasLineOfMotion");
static_assert(offsetof(UP2MeleeCondition_HasLineOfMotion, FilterClass) == 0x000030, "Member 'UP2MeleeCondition_HasLineOfMotion::FilterClass' has a wrong offset!");

// Class AICommon.P2MeleeCondition_IsFacing
// 0x0008 (0x0038 - 0x0030)
class UP2MeleeCondition_IsFacing final : public UP2MeleeCondition
{
public:
	float                                         HeadingToleranceDeg;                               // 0x0030(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CachedHeadingTolerance;                            // 0x0034(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"P2MeleeCondition_IsFacing">();
	}
	static class UP2MeleeCondition_IsFacing* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UP2MeleeCondition_IsFacing>();
	}
};
static_assert(alignof(UP2MeleeCondition_IsFacing) == 0x000008, "Wrong alignment on UP2MeleeCondition_IsFacing");
static_assert(sizeof(UP2MeleeCondition_IsFacing) == 0x000038, "Wrong size on UP2MeleeCondition_IsFacing");
static_assert(offsetof(UP2MeleeCondition_IsFacing, HeadingToleranceDeg) == 0x000030, "Member 'UP2MeleeCondition_IsFacing::HeadingToleranceDeg' has a wrong offset!");
static_assert(offsetof(UP2MeleeCondition_IsFacing, CachedHeadingTolerance) == 0x000034, "Member 'UP2MeleeCondition_IsFacing::CachedHeadingTolerance' has a wrong offset!");

// Class AICommon.P2MeleeTargetComponent
// 0x0028 (0x00E8 - 0x00C0)
class UP2MeleeTargetComponent : public UActorComponent
{
public:
	uint8                                         NumSlots;                                          // 0x00C0(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C1[0x3];                                       // 0x00C1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         AttackPeriod;                                      // 0x00C4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AttackPeriodVariation;                             // 0x00C8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_CC[0x4];                                       // 0x00CC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UP2MeleeTargetSlot*>             Slots;                                             // 0x00D0(0x0010)(ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPrivate)
	int32                                         NumCurrentAttackers;                               // 0x00E0(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_E4[0x4];                                       // 0x00E4(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UP2MeleeTargetComponent* GetMeleeTargetComponent(const class AActor* Actor)	 // 0x4757c80;

	int32 GetNumAttackers() const	 // 0x4757d4c;

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"P2MeleeTargetComponent">();
	}
	static class UP2MeleeTargetComponent* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UP2MeleeTargetComponent>();
	}
};
static_assert(alignof(UP2MeleeTargetComponent) == 0x000008, "Wrong alignment on UP2MeleeTargetComponent");
static_assert(sizeof(UP2MeleeTargetComponent) == 0x0000E8, "Wrong size on UP2MeleeTargetComponent");
static_assert(offsetof(UP2MeleeTargetComponent, NumSlots) == 0x0000C0, "Member 'UP2MeleeTargetComponent::NumSlots' has a wrong offset!");
static_assert(offsetof(UP2MeleeTargetComponent, AttackPeriod) == 0x0000C4, "Member 'UP2MeleeTargetComponent::AttackPeriod' has a wrong offset!");
static_assert(offsetof(UP2MeleeTargetComponent, AttackPeriodVariation) == 0x0000C8, "Member 'UP2MeleeTargetComponent::AttackPeriodVariation' has a wrong offset!");
static_assert(offsetof(UP2MeleeTargetComponent, Slots) == 0x0000D0, "Member 'UP2MeleeTargetComponent::Slots' has a wrong offset!");
static_assert(offsetof(UP2MeleeTargetComponent, NumCurrentAttackers) == 0x0000E0, "Member 'UP2MeleeTargetComponent::NumCurrentAttackers' has a wrong offset!");

// Class AICommon.P2MeleeTargetSlot
// 0x0028 (0x0050 - 0x0028)
class UP2MeleeTargetSlot final : public UObject
{
public:
	TWeakObjectPtr<class AActor>                  CurrentUser;                                       // 0x0028(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FVector                                Direction;                                         // 0x0030(0x0018)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         SectorHalfAngleCos;                                // 0x0048(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         HalfAngle;                                         // 0x004C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void OnUserDeath(class UP2HealthComponent* HealthComponent)	 // 0x475853c;
	void OnUserDestroyed(class AActor* DestroyedActor)	 // 0x475853c;

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"P2MeleeTargetSlot">();
	}
	static class UP2MeleeTargetSlot* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UP2MeleeTargetSlot>();
	}
};
static_assert(alignof(UP2MeleeTargetSlot) == 0x000008, "Wrong alignment on UP2MeleeTargetSlot");
static_assert(sizeof(UP2MeleeTargetSlot) == 0x000050, "Wrong size on UP2MeleeTargetSlot");
static_assert(offsetof(UP2MeleeTargetSlot, CurrentUser) == 0x000028, "Member 'UP2MeleeTargetSlot::CurrentUser' has a wrong offset!");
static_assert(offsetof(UP2MeleeTargetSlot, Direction) == 0x000030, "Member 'UP2MeleeTargetSlot::Direction' has a wrong offset!");
static_assert(offsetof(UP2MeleeTargetSlot, SectorHalfAngleCos) == 0x000048, "Member 'UP2MeleeTargetSlot::SectorHalfAngleCos' has a wrong offset!");
static_assert(offsetof(UP2MeleeTargetSlot, HalfAngle) == 0x00004C, "Member 'UP2MeleeTargetSlot::HalfAngle' has a wrong offset!");

// Class AICommon.P2Mercuna3DMovementComponent
// 0x0010 (0x0260 - 0x0250)
class UP2Mercuna3DMovementComponent final : public UMercuna3DMovementComponent
{
public:
	uint8                                         Pad_250[0x10];                                     // 0x0250(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"P2Mercuna3DMovementComponent">();
	}
	static class UP2Mercuna3DMovementComponent* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UP2Mercuna3DMovementComponent>();
	}
};
static_assert(alignof(UP2Mercuna3DMovementComponent) == 0x000010, "Wrong alignment on UP2Mercuna3DMovementComponent");
static_assert(sizeof(UP2Mercuna3DMovementComponent) == 0x000260, "Wrong size on UP2Mercuna3DMovementComponent");

// Class AICommon.P2MercunaGroundNavigationComponent
// 0x0008 (0x02D8 - 0x02D0)
class UP2MercunaGroundNavigationComponent : public UMercunaGroundNavigationComponent
{
public:
	uint8                                         Pad_2D0[0x8];                                      // 0x02D0(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void StartJump(const struct FVector& StartPosition, const struct FVector& EndPosition, const struct FVector& SuggestedLaunchVelocity)	 // 0x47585f8;

	bool StartTraversal(class AP2MercunaNavLink* NavLink, EMercunaNavigationLinkDirection InDirection, const struct FVector& InDestination) const	 // 0x47587f4;

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"P2MercunaGroundNavigationComponent">();
	}
	static class UP2MercunaGroundNavigationComponent* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UP2MercunaGroundNavigationComponent>();
	}
};
static_assert(alignof(UP2MercunaGroundNavigationComponent) == 0x000008, "Wrong alignment on UP2MercunaGroundNavigationComponent");
static_assert(sizeof(UP2MercunaGroundNavigationComponent) == 0x0002D8, "Wrong size on UP2MercunaGroundNavigationComponent");

// Class AICommon.P2MercunaNavGrid
// 0x0000 (0x0690 - 0x0690)
class AP2MercunaNavGrid final : public AMercunaNavGroundGrid
{
public:
	bool                                          bGenerateGridOnWaterSurface;                       // 0x0688(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_689[0x7];                                      // 0x0689(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnBuildCompleteCallback(bool bSuccess)	 // 0x4757ef0;

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"P2MercunaNavGrid">();
	}
	static class AP2MercunaNavGrid* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<AP2MercunaNavGrid>();
	}
};
static_assert(alignof(AP2MercunaNavGrid) == 0x000010, "Wrong alignment on AP2MercunaNavGrid");
static_assert(sizeof(AP2MercunaNavGrid) == 0x000690, "Wrong size on AP2MercunaNavGrid");
static_assert(offsetof(AP2MercunaNavGrid, bGenerateGridOnWaterSurface) == 0x000688, "Member 'AP2MercunaNavGrid::bGenerateGridOnWaterSurface' has a wrong offset!");

// Class AICommon.P2MercunaObstacleComponent
// 0x0010 (0x0320 - 0x0310)
class UP2MercunaObstacleComponent final : public UMercunaObstacleComponent
{
public:
	uint8                                         Pad_310[0x10];                                     // 0x0310(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnDeathStatusChanged(const struct FGameplayTag& Tag, int32 NewCount)	 // 0x475ced8;
	void OnKOStatusChanged(const struct FGameplayTag& Tag, int32 NewCount)	 // 0x475d1a0;

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"P2MercunaObstacleComponent">();
	}
	static class UP2MercunaObstacleComponent* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UP2MercunaObstacleComponent>();
	}
};
static_assert(alignof(UP2MercunaObstacleComponent) == 0x000010, "Wrong alignment on UP2MercunaObstacleComponent");
static_assert(sizeof(UP2MercunaObstacleComponent) == 0x000320, "Wrong size on UP2MercunaObstacleComponent");

// Class AICommon.P2NavGridModiferHandler_Destructible
// 0x0010 (0x0040 - 0x0030)
class UP2NavGridModiferHandler_Destructible final : public UP2NavGridModiferHandler
{
public:
	uint8                                         Pad_30[0x10];                                      // 0x0030(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnDestructibleComponentDestroyed()	 // 0x475d030;

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"P2NavGridModiferHandler_Destructible">();
	}
	static class UP2NavGridModiferHandler_Destructible* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UP2NavGridModiferHandler_Destructible>();
	}
};
static_assert(alignof(UP2NavGridModiferHandler_Destructible) == 0x000008, "Wrong alignment on UP2NavGridModiferHandler_Destructible");
static_assert(sizeof(UP2NavGridModiferHandler_Destructible) == 0x000040, "Wrong size on UP2NavGridModiferHandler_Destructible");

// Class AICommon.P2NavGridModifierComponent
// 0x0050 (0x06D0 - 0x0680)
class UP2NavGridModifierComponent final : public UMercunaNavGridModifierComponent
{
public:
	TSet<class UP2NavGridModiferHandler*>         Handlers;                                          // 0x0678(0x0050)(Transient, Protected, UObjectWrapper, NativeAccessSpecifierProtected)
	uint8                                         Pad_6C8[0x8];                                      // 0x06C8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"P2NavGridModifierComponent">();
	}
	static class UP2NavGridModifierComponent* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UP2NavGridModifierComponent>();
	}
};
static_assert(alignof(UP2NavGridModifierComponent) == 0x000010, "Wrong alignment on UP2NavGridModifierComponent");
static_assert(sizeof(UP2NavGridModifierComponent) == 0x0006D0, "Wrong size on UP2NavGridModifierComponent");
static_assert(offsetof(UP2NavGridModifierComponent, Handlers) == 0x000678, "Member 'UP2NavGridModifierComponent::Handlers' has a wrong offset!");

// Class AICommon.P2NavLinkHandleComponent
// 0x0010 (0x05E0 - 0x05D0)
class UP2NavLinkHandleComponent final : public UBillboardComponent
{
public:
	uint8                                         Pad_5D0[0x10];                                     // 0x05D0(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"P2NavLinkHandleComponent">();
	}
	static class UP2NavLinkHandleComponent* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UP2NavLinkHandleComponent>();
	}
};
static_assert(alignof(UP2NavLinkHandleComponent) == 0x000010, "Wrong alignment on UP2NavLinkHandleComponent");
static_assert(sizeof(UP2NavLinkHandleComponent) == 0x0005E0, "Wrong size on UP2NavLinkHandleComponent");

// Class AICommon.P2NavModifierCollection
// 0x0120 (0x03D0 - 0x02B0)
class AP2NavModifierCollection final : public AActor
{
public:
	TArray<struct FP2DoorNavModifierData>         DoorModifiers;                                     // 0x02B0(0x0010)(Edit, ZeroConstructor, DisableEditOnTemplate, EditConst, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	TArray<struct FP2DestructibleNavModifierData> DestructibleModifiers;                             // 0x02C0(0x0010)(Edit, ZeroConstructor, DisableEditOnTemplate, EditConst, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2D0[0xA0];                                     // 0x02D0(0x00A0)(Fixing Size After Last Property [ Dumper-7 ])
	TSet<TSubclassOf<class AActor>>               NavModOwnerClasses;                                // 0x0370(0x0050)(Edit, DisableEditOnTemplate, EditConst, UObjectWrapper, NativeAccessSpecifierPrivate)
	uint8                                         Pad_3C0[0x10];                                     // 0x03C0(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"P2NavModifierCollection">();
	}
	static class AP2NavModifierCollection* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<AP2NavModifierCollection>();
	}
};
static_assert(alignof(AP2NavModifierCollection) == 0x000008, "Wrong alignment on AP2NavModifierCollection");
static_assert(sizeof(AP2NavModifierCollection) == 0x0003D0, "Wrong size on AP2NavModifierCollection");
static_assert(offsetof(AP2NavModifierCollection, DoorModifiers) == 0x0002B0, "Member 'AP2NavModifierCollection::DoorModifiers' has a wrong offset!");
static_assert(offsetof(AP2NavModifierCollection, DestructibleModifiers) == 0x0002C0, "Member 'AP2NavModifierCollection::DestructibleModifiers' has a wrong offset!");
static_assert(offsetof(AP2NavModifierCollection, NavModOwnerClasses) == 0x000370, "Member 'AP2NavModifierCollection::NavModOwnerClasses' has a wrong offset!");

// Class AICommon.P2NavRegenerationSubsystem
// 0x0050 (0x0090 - 0x0040)
class UP2NavRegenerationSubsystem final : public UTickableWorldSubsystem
{
public:
	uint8                                         Pad_40[0x50];                                      // 0x0040(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"P2NavRegenerationSubsystem">();
	}
	static class UP2NavRegenerationSubsystem* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UP2NavRegenerationSubsystem>();
	}
};
static_assert(alignof(UP2NavRegenerationSubsystem) == 0x000008, "Wrong alignment on UP2NavRegenerationSubsystem");
static_assert(sizeof(UP2NavRegenerationSubsystem) == 0x000090, "Wrong size on UP2NavRegenerationSubsystem");

// Class AICommon.P2NpcAbilitySystemFunctionLibrary
// 0x0000 (0x0028 - 0x0028)
class UP2NpcAbilitySystemFunctionLibrary final : public UBlueprintFunctionLibrary
{
public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"P2NpcAbilitySystemFunctionLibrary">();
	}
	static class UP2NpcAbilitySystemFunctionLibrary* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UP2NpcAbilitySystemFunctionLibrary>();
	}
};
static_assert(alignof(UP2NpcAbilitySystemFunctionLibrary) == 0x000008, "Wrong alignment on UP2NpcAbilitySystemFunctionLibrary");
static_assert(sizeof(UP2NpcAbilitySystemFunctionLibrary) == 0x000028, "Wrong size on UP2NpcAbilitySystemFunctionLibrary");

// Class AICommon.P2NpcAbility_Aura
// 0x0010 (0x04A8 - 0x0498)
class UP2NpcAbility_Aura final : public UP2NpcAbility
{
public:
	float                                         Range;                                             // 0x0498(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_49C[0x4];                                      // 0x049C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UP2AbilityTask_ApplyStatusInRange*      ApplyStatusTask;                                   // 0x04A0(0x0008)(ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"P2NpcAbility_Aura">();
	}
	static class UP2NpcAbility_Aura* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UP2NpcAbility_Aura>();
	}
};
static_assert(alignof(UP2NpcAbility_Aura) == 0x000008, "Wrong alignment on UP2NpcAbility_Aura");
static_assert(sizeof(UP2NpcAbility_Aura) == 0x0004A8, "Wrong size on UP2NpcAbility_Aura");
static_assert(offsetof(UP2NpcAbility_Aura, Range) == 0x000498, "Member 'UP2NpcAbility_Aura::Range' has a wrong offset!");
static_assert(offsetof(UP2NpcAbility_Aura, ApplyStatusTask) == 0x0004A0, "Member 'UP2NpcAbility_Aura::ApplyStatusTask' has a wrong offset!");

// Class AICommon.P2AbilityTask_BombugMeleeDive
// 0x0118 (0x01A0 - 0x0088)
class UP2AbilityTask_BombugMeleeDive final : public UP2AbilityTask_AnimLayer
{
public:
	uint8                                         Pad_88[0x8];                                       // 0x0088(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FP2BombugDiveContext                   Context;                                           // 0x0090(0x00E0)(Net, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_170[0x28];                                     // 0x0170(0x0028)(Fixing Size After Last Property [ Dumper-7 ])
	TWeakObjectPtr<class AActor>                  TargetActor;                                       // 0x0198(0x0008)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"P2AbilityTask_BombugMeleeDive">();
	}
	static class UP2AbilityTask_BombugMeleeDive* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UP2AbilityTask_BombugMeleeDive>();
	}
};
static_assert(alignof(UP2AbilityTask_BombugMeleeDive) == 0x000010, "Wrong alignment on UP2AbilityTask_BombugMeleeDive");
static_assert(sizeof(UP2AbilityTask_BombugMeleeDive) == 0x0001A0, "Wrong size on UP2AbilityTask_BombugMeleeDive");
static_assert(offsetof(UP2AbilityTask_BombugMeleeDive, Context) == 0x000090, "Member 'UP2AbilityTask_BombugMeleeDive::Context' has a wrong offset!");
static_assert(offsetof(UP2AbilityTask_BombugMeleeDive, TargetActor) == 0x000198, "Member 'UP2AbilityTask_BombugMeleeDive::TargetActor' has a wrong offset!");

// Class AICommon.P2NpcAbility_BruteLungsClose
// 0x0000 (0x0498 - 0x0498)
class UP2NpcAbility_BruteLungsClose final : public UP2NpcAbility
{
public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"P2NpcAbility_BruteLungsClose">();
	}
	static class UP2NpcAbility_BruteLungsClose* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UP2NpcAbility_BruteLungsClose>();
	}
};
static_assert(alignof(UP2NpcAbility_BruteLungsClose) == 0x000008, "Wrong alignment on UP2NpcAbility_BruteLungsClose");
static_assert(sizeof(UP2NpcAbility_BruteLungsClose) == 0x000498, "Wrong size on UP2NpcAbility_BruteLungsClose");

// Class AICommon.P2NpcAbility_BruteLungsOpen
// 0x0000 (0x0498 - 0x0498)
class UP2NpcAbility_BruteLungsOpen final : public UP2NpcAbility
{
public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"P2NpcAbility_BruteLungsOpen">();
	}
	static class UP2NpcAbility_BruteLungsOpen* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UP2NpcAbility_BruteLungsOpen>();
	}
};
static_assert(alignof(UP2NpcAbility_BruteLungsOpen) == 0x000008, "Wrong alignment on UP2NpcAbility_BruteLungsOpen");
static_assert(sizeof(UP2NpcAbility_BruteLungsOpen) == 0x000498, "Wrong size on UP2NpcAbility_BruteLungsOpen");

// Class AICommon.P2NpcAbility_BrutePickupThrowable
// 0x0000 (0x04A8 - 0x04A8)
class UP2NpcAbility_BrutePickupThrowable final : public UP2NpcAbility_BruteThrowableBase
{
public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"P2NpcAbility_BrutePickupThrowable">();
	}
	static class UP2NpcAbility_BrutePickupThrowable* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UP2NpcAbility_BrutePickupThrowable>();
	}
};
static_assert(alignof(UP2NpcAbility_BrutePickupThrowable) == 0x000008, "Wrong alignment on UP2NpcAbility_BrutePickupThrowable");
static_assert(sizeof(UP2NpcAbility_BrutePickupThrowable) == 0x0004A8, "Wrong size on UP2NpcAbility_BrutePickupThrowable");

// Class AICommon.P2NpcAbility_BruteSpawnThrowable
// 0x0008 (0x04B0 - 0x04A8)
class UP2NpcAbility_BruteSpawnThrowable final : public UP2NpcAbility_BruteThrowableBase
{
public:
	class UP2SmartObjectDefinition_BruteThrowable* SpawnThrowableDefinition;                         // 0x04A8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"P2NpcAbility_BruteSpawnThrowable">();
	}
	static class UP2NpcAbility_BruteSpawnThrowable* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UP2NpcAbility_BruteSpawnThrowable>();
	}
};
static_assert(alignof(UP2NpcAbility_BruteSpawnThrowable) == 0x000008, "Wrong alignment on UP2NpcAbility_BruteSpawnThrowable");
static_assert(sizeof(UP2NpcAbility_BruteSpawnThrowable) == 0x0004B0, "Wrong size on UP2NpcAbility_BruteSpawnThrowable");
static_assert(offsetof(UP2NpcAbility_BruteSpawnThrowable, SpawnThrowableDefinition) == 0x0004A8, "Member 'UP2NpcAbility_BruteSpawnThrowable::SpawnThrowableDefinition' has a wrong offset!");

// Class AICommon.P2NpcAbility_BruteSpray
// 0x0000 (0x0520 - 0x0520)
class UP2NpcAbility_BruteSpray final : public UP2NpcAbility_SprayAttack
{
public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"P2NpcAbility_BruteSpray">();
	}
	static class UP2NpcAbility_BruteSpray* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UP2NpcAbility_BruteSpray>();
	}
};
static_assert(alignof(UP2NpcAbility_BruteSpray) == 0x000008, "Wrong alignment on UP2NpcAbility_BruteSpray");
static_assert(sizeof(UP2NpcAbility_BruteSpray) == 0x000520, "Wrong size on UP2NpcAbility_BruteSpray");

// Class AICommon.P2NpcAbility_BruteThrowPassive
// 0x0008 (0x04A0 - 0x0498)
class UP2NpcAbility_BruteThrowPassive final : public UP2NpcAbility
{
public:
	uint8                                         Pad_498[0x8];                                      // 0x0498(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"P2NpcAbility_BruteThrowPassive">();
	}
	static class UP2NpcAbility_BruteThrowPassive* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UP2NpcAbility_BruteThrowPassive>();
	}
};
static_assert(alignof(UP2NpcAbility_BruteThrowPassive) == 0x000008, "Wrong alignment on UP2NpcAbility_BruteThrowPassive");
static_assert(sizeof(UP2NpcAbility_BruteThrowPassive) == 0x0004A0, "Wrong size on UP2NpcAbility_BruteThrowPassive");

// Class AICommon.P2NpcAbility_ChangeFlyState
// 0x0028 (0x04C0 - 0x0498)
class UP2NpcAbility_ChangeFlyState final : public UP2NpcAbility
{
public:
	class UAnimMontage*                           Montage;                                           // 0x0498(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         Duration;                                          // 0x04A0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         Rate;                                              // 0x04A4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bChangeToFlying;                                   // 0x04A8(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_4A9[0x7];                                      // 0x04A9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UAbilityTask*                           AbilityTask;                                       // 0x04B0(0x0008)(ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAbilityTask*                           AuxiliaryMontageTask;                              // 0x04B8(0x0008)(ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void OnTaskFinished()	 // 0x4761534;

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"P2NpcAbility_ChangeFlyState">();
	}
	static class UP2NpcAbility_ChangeFlyState* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UP2NpcAbility_ChangeFlyState>();
	}
};
static_assert(alignof(UP2NpcAbility_ChangeFlyState) == 0x000008, "Wrong alignment on UP2NpcAbility_ChangeFlyState");
static_assert(sizeof(UP2NpcAbility_ChangeFlyState) == 0x0004C0, "Wrong size on UP2NpcAbility_ChangeFlyState");
static_assert(offsetof(UP2NpcAbility_ChangeFlyState, Montage) == 0x000498, "Member 'UP2NpcAbility_ChangeFlyState::Montage' has a wrong offset!");
static_assert(offsetof(UP2NpcAbility_ChangeFlyState, Duration) == 0x0004A0, "Member 'UP2NpcAbility_ChangeFlyState::Duration' has a wrong offset!");
static_assert(offsetof(UP2NpcAbility_ChangeFlyState, Rate) == 0x0004A4, "Member 'UP2NpcAbility_ChangeFlyState::Rate' has a wrong offset!");
static_assert(offsetof(UP2NpcAbility_ChangeFlyState, bChangeToFlying) == 0x0004A8, "Member 'UP2NpcAbility_ChangeFlyState::bChangeToFlying' has a wrong offset!");
static_assert(offsetof(UP2NpcAbility_ChangeFlyState, AbilityTask) == 0x0004B0, "Member 'UP2NpcAbility_ChangeFlyState::AbilityTask' has a wrong offset!");
static_assert(offsetof(UP2NpcAbility_ChangeFlyState, AuxiliaryMontageTask) == 0x0004B8, "Member 'UP2NpcAbility_ChangeFlyState::AuxiliaryMontageTask' has a wrong offset!");

// Class AICommon.P2NpcAbility_Concussed
// 0x0040 (0x04D8 - 0x0498)
class UP2NpcAbility_Concussed final : public UP2NpcAbility
{
public:
	struct FGameplayTag                           StatusEffectTag;                                   // 0x0498(0x0008)(Edit, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAnimMontage*                           Montage;                                           // 0x04A0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   EndMontageSection;                                 // 0x04A8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         EffectLevelToTriggerAnimation;                     // 0x04B0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_4B4[0x4];                                      // 0x04B4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<TSubclassOf<class UAISense>>           SensesToDisable;                                   // 0x04B8(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, Protected, UObjectWrapper, NativeAccessSpecifierProtected)
	class UAbilityTask_PlayMontageAndWait*        MontageTask;                                       // 0x04C8(0x0008)(ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_4D0[0x8];                                      // 0x04D0(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnAnimationEnded()	 // 0x47305ec;

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"P2NpcAbility_Concussed">();
	}
	static class UP2NpcAbility_Concussed* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UP2NpcAbility_Concussed>();
	}
};
static_assert(alignof(UP2NpcAbility_Concussed) == 0x000008, "Wrong alignment on UP2NpcAbility_Concussed");
static_assert(sizeof(UP2NpcAbility_Concussed) == 0x0004D8, "Wrong size on UP2NpcAbility_Concussed");
static_assert(offsetof(UP2NpcAbility_Concussed, StatusEffectTag) == 0x000498, "Member 'UP2NpcAbility_Concussed::StatusEffectTag' has a wrong offset!");
static_assert(offsetof(UP2NpcAbility_Concussed, Montage) == 0x0004A0, "Member 'UP2NpcAbility_Concussed::Montage' has a wrong offset!");
static_assert(offsetof(UP2NpcAbility_Concussed, EndMontageSection) == 0x0004A8, "Member 'UP2NpcAbility_Concussed::EndMontageSection' has a wrong offset!");
static_assert(offsetof(UP2NpcAbility_Concussed, EffectLevelToTriggerAnimation) == 0x0004B0, "Member 'UP2NpcAbility_Concussed::EffectLevelToTriggerAnimation' has a wrong offset!");
static_assert(offsetof(UP2NpcAbility_Concussed, SensesToDisable) == 0x0004B8, "Member 'UP2NpcAbility_Concussed::SensesToDisable' has a wrong offset!");
static_assert(offsetof(UP2NpcAbility_Concussed, MontageTask) == 0x0004C8, "Member 'UP2NpcAbility_Concussed::MontageTask' has a wrong offset!");

// Class AICommon.P2NpcAbility_CrocSnapAttack
// 0x0148 (0x05E0 - 0x0498)
class alignas(0x10) UP2NpcAbility_CrocSnapAttack final : public UP2NpcAbility_Attack
{
public:
	float                                         SnappingDuration;                                  // 0x0498(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SnappingBlendInDuration;                           // 0x049C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UP2TransformCurve*                      SnappingTransformCurve;                            // 0x04A0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                HitBoxOffset;                                      // 0x04A8(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                HitBoxExtents;                                     // 0x04C0(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UP2GameplayEffect_Damage>   InstantDamage;                                     // 0x04D8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UP2GameplayEffect_Damage>   PeriodicDamage;                                    // 0x04E0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PeriodicDamagePeriod;                              // 0x04E8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SnapDuration;                                      // 0x04EC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Distance;                                          // 0x04F0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4F4[0x4];                                      // 0x04F4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class UP2Ability_CrocSnapAttackReaction> ReactionAbility;                            // 0x04F8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimMontage*                           Montage;                                           // 0x0500(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           DamageCue;                                         // 0x0508(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDrawDebug;                                        // 0x0510(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_511[0x3];                                      // 0x0511(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	TWeakObjectPtr<class AP2HeroCharacter>        Target;                                            // 0x0514(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_51C[0x84];                                     // 0x051C(0x0084)(Fixing Size After Last Property [ Dumper-7 ])
	class UP2AbilityTask_CrocSnap*                SnapTask;                                          // 0x05A0(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UAbilityTask_PlayMontageAndWait*        MontageTask;                                       // 0x05A8(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UP2AbilityTask_MoveAlongTransformCurve* MoveTask;                                          // 0x05B0(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_5B8[0x28];                                     // 0x05B8(0x0028)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnDoneReaching()	 // 0x47612e0;

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"P2NpcAbility_CrocSnapAttack">();
	}
	static class UP2NpcAbility_CrocSnapAttack* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UP2NpcAbility_CrocSnapAttack>();
	}
};
static_assert(alignof(UP2NpcAbility_CrocSnapAttack) == 0x000010, "Wrong alignment on UP2NpcAbility_CrocSnapAttack");
static_assert(sizeof(UP2NpcAbility_CrocSnapAttack) == 0x0005E0, "Wrong size on UP2NpcAbility_CrocSnapAttack");
static_assert(offsetof(UP2NpcAbility_CrocSnapAttack, SnappingDuration) == 0x000498, "Member 'UP2NpcAbility_CrocSnapAttack::SnappingDuration' has a wrong offset!");
static_assert(offsetof(UP2NpcAbility_CrocSnapAttack, SnappingBlendInDuration) == 0x00049C, "Member 'UP2NpcAbility_CrocSnapAttack::SnappingBlendInDuration' has a wrong offset!");
static_assert(offsetof(UP2NpcAbility_CrocSnapAttack, SnappingTransformCurve) == 0x0004A0, "Member 'UP2NpcAbility_CrocSnapAttack::SnappingTransformCurve' has a wrong offset!");
static_assert(offsetof(UP2NpcAbility_CrocSnapAttack, HitBoxOffset) == 0x0004A8, "Member 'UP2NpcAbility_CrocSnapAttack::HitBoxOffset' has a wrong offset!");
static_assert(offsetof(UP2NpcAbility_CrocSnapAttack, HitBoxExtents) == 0x0004C0, "Member 'UP2NpcAbility_CrocSnapAttack::HitBoxExtents' has a wrong offset!");
static_assert(offsetof(UP2NpcAbility_CrocSnapAttack, InstantDamage) == 0x0004D8, "Member 'UP2NpcAbility_CrocSnapAttack::InstantDamage' has a wrong offset!");
static_assert(offsetof(UP2NpcAbility_CrocSnapAttack, PeriodicDamage) == 0x0004E0, "Member 'UP2NpcAbility_CrocSnapAttack::PeriodicDamage' has a wrong offset!");
static_assert(offsetof(UP2NpcAbility_CrocSnapAttack, PeriodicDamagePeriod) == 0x0004E8, "Member 'UP2NpcAbility_CrocSnapAttack::PeriodicDamagePeriod' has a wrong offset!");
static_assert(offsetof(UP2NpcAbility_CrocSnapAttack, SnapDuration) == 0x0004EC, "Member 'UP2NpcAbility_CrocSnapAttack::SnapDuration' has a wrong offset!");
static_assert(offsetof(UP2NpcAbility_CrocSnapAttack, Distance) == 0x0004F0, "Member 'UP2NpcAbility_CrocSnapAttack::Distance' has a wrong offset!");
static_assert(offsetof(UP2NpcAbility_CrocSnapAttack, ReactionAbility) == 0x0004F8, "Member 'UP2NpcAbility_CrocSnapAttack::ReactionAbility' has a wrong offset!");
static_assert(offsetof(UP2NpcAbility_CrocSnapAttack, Montage) == 0x000500, "Member 'UP2NpcAbility_CrocSnapAttack::Montage' has a wrong offset!");
static_assert(offsetof(UP2NpcAbility_CrocSnapAttack, DamageCue) == 0x000508, "Member 'UP2NpcAbility_CrocSnapAttack::DamageCue' has a wrong offset!");
static_assert(offsetof(UP2NpcAbility_CrocSnapAttack, bDrawDebug) == 0x000510, "Member 'UP2NpcAbility_CrocSnapAttack::bDrawDebug' has a wrong offset!");
static_assert(offsetof(UP2NpcAbility_CrocSnapAttack, Target) == 0x000514, "Member 'UP2NpcAbility_CrocSnapAttack::Target' has a wrong offset!");
static_assert(offsetof(UP2NpcAbility_CrocSnapAttack, SnapTask) == 0x0005A0, "Member 'UP2NpcAbility_CrocSnapAttack::SnapTask' has a wrong offset!");
static_assert(offsetof(UP2NpcAbility_CrocSnapAttack, MontageTask) == 0x0005A8, "Member 'UP2NpcAbility_CrocSnapAttack::MontageTask' has a wrong offset!");
static_assert(offsetof(UP2NpcAbility_CrocSnapAttack, MoveTask) == 0x0005B0, "Member 'UP2NpcAbility_CrocSnapAttack::MoveTask' has a wrong offset!");

// Class AICommon.P2NpcAbility_UseDoorLink
// 0x0000 (0x04E0 - 0x04E0)
class UP2NpcAbility_UseDoorLink : public UP2NpcAbility_UseMercunaNavLink
{
public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"P2NpcAbility_UseDoorLink">();
	}
	static class UP2NpcAbility_UseDoorLink* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UP2NpcAbility_UseDoorLink>();
	}
};
static_assert(alignof(UP2NpcAbility_UseDoorLink) == 0x000008, "Wrong alignment on UP2NpcAbility_UseDoorLink");
static_assert(sizeof(UP2NpcAbility_UseDoorLink) == 0x0004E0, "Wrong size on UP2NpcAbility_UseDoorLink");

// Class AICommon.P2NpcAbility_DoorLink_Break
// 0x0078 (0x0558 - 0x04E0)
class UP2NpcAbility_DoorLink_Break final : public UP2NpcAbility_UseDoorLink
{
public:
	int32                                         DoorDamagePerHit;                                  // 0x04E0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_4E4[0x4];                                      // 0x04E4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UAnimMontage*                           HitMontage;                                        // 0x04E8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   WarpTargetLinkStart;                               // 0x04F0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   WarpTargetDoor;                                    // 0x04F8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   WarpTargetLinkEnd;                                 // 0x0500(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EDoorsAttackSelectionType                     AttackSelectionType;                               // 0x0508(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_509[0x7];                                      // 0x0509(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class FName>                           AttackSectionNames;                                // 0x0510(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	class FName                                   BreakSectionName;                                  // 0x0520(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   CooldownSectionName;                               // 0x0528(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAbilityTask*                           AnimMontageTask;                                   // 0x0530(0x0008)(ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TWeakObjectPtr<class UP2MercunaGroundNavigationComponent> MercunaComponent;                      // 0x0538(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_540[0x8];                                      // 0x0540(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   CurrentMontageSection;                             // 0x0548(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         NextAttackMontageIndex;                            // 0x0550(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_554[0x4];                                      // 0x0554(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void HitDoor(class UP2PayloadObject_DoorHit* Payload)	 // 0x4761138;
	void OnMontageCompleted()	 // 0x476150c;
	void PlayNextSection()	 // 0x476155c;

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"P2NpcAbility_DoorLink_Break">();
	}
	static class UP2NpcAbility_DoorLink_Break* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UP2NpcAbility_DoorLink_Break>();
	}
};
static_assert(alignof(UP2NpcAbility_DoorLink_Break) == 0x000008, "Wrong alignment on UP2NpcAbility_DoorLink_Break");
static_assert(sizeof(UP2NpcAbility_DoorLink_Break) == 0x000558, "Wrong size on UP2NpcAbility_DoorLink_Break");
static_assert(offsetof(UP2NpcAbility_DoorLink_Break, DoorDamagePerHit) == 0x0004E0, "Member 'UP2NpcAbility_DoorLink_Break::DoorDamagePerHit' has a wrong offset!");
static_assert(offsetof(UP2NpcAbility_DoorLink_Break, HitMontage) == 0x0004E8, "Member 'UP2NpcAbility_DoorLink_Break::HitMontage' has a wrong offset!");
static_assert(offsetof(UP2NpcAbility_DoorLink_Break, WarpTargetLinkStart) == 0x0004F0, "Member 'UP2NpcAbility_DoorLink_Break::WarpTargetLinkStart' has a wrong offset!");
static_assert(offsetof(UP2NpcAbility_DoorLink_Break, WarpTargetDoor) == 0x0004F8, "Member 'UP2NpcAbility_DoorLink_Break::WarpTargetDoor' has a wrong offset!");
static_assert(offsetof(UP2NpcAbility_DoorLink_Break, WarpTargetLinkEnd) == 0x000500, "Member 'UP2NpcAbility_DoorLink_Break::WarpTargetLinkEnd' has a wrong offset!");
static_assert(offsetof(UP2NpcAbility_DoorLink_Break, AttackSelectionType) == 0x000508, "Member 'UP2NpcAbility_DoorLink_Break::AttackSelectionType' has a wrong offset!");
static_assert(offsetof(UP2NpcAbility_DoorLink_Break, AttackSectionNames) == 0x000510, "Member 'UP2NpcAbility_DoorLink_Break::AttackSectionNames' has a wrong offset!");
static_assert(offsetof(UP2NpcAbility_DoorLink_Break, BreakSectionName) == 0x000520, "Member 'UP2NpcAbility_DoorLink_Break::BreakSectionName' has a wrong offset!");
static_assert(offsetof(UP2NpcAbility_DoorLink_Break, CooldownSectionName) == 0x000528, "Member 'UP2NpcAbility_DoorLink_Break::CooldownSectionName' has a wrong offset!");
static_assert(offsetof(UP2NpcAbility_DoorLink_Break, AnimMontageTask) == 0x000530, "Member 'UP2NpcAbility_DoorLink_Break::AnimMontageTask' has a wrong offset!");
static_assert(offsetof(UP2NpcAbility_DoorLink_Break, MercunaComponent) == 0x000538, "Member 'UP2NpcAbility_DoorLink_Break::MercunaComponent' has a wrong offset!");
static_assert(offsetof(UP2NpcAbility_DoorLink_Break, CurrentMontageSection) == 0x000548, "Member 'UP2NpcAbility_DoorLink_Break::CurrentMontageSection' has a wrong offset!");
static_assert(offsetof(UP2NpcAbility_DoorLink_Break, NextAttackMontageIndex) == 0x000550, "Member 'UP2NpcAbility_DoorLink_Break::NextAttackMontageIndex' has a wrong offset!");

// Class AICommon.P2NpcAbility_DoorLink_Interact
// 0x0000 (0x04E0 - 0x04E0)
class UP2NpcAbility_DoorLink_Interact : public UP2NpcAbility_UseDoorLink
{
public:
	void OnDoorStateChanged(EDoorLinkState DoorLinkState)	 // 0x47612f4;

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"P2NpcAbility_DoorLink_Interact">();
	}
	static class UP2NpcAbility_DoorLink_Interact* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UP2NpcAbility_DoorLink_Interact>();
	}
};
static_assert(alignof(UP2NpcAbility_DoorLink_Interact) == 0x000008, "Wrong alignment on UP2NpcAbility_DoorLink_Interact");
static_assert(sizeof(UP2NpcAbility_DoorLink_Interact) == 0x0004E0, "Wrong size on UP2NpcAbility_DoorLink_Interact");

// Class AICommon.P2AbilityTask_WalkTask
// 0x0038 (0x00B8 - 0x0080)
class UP2AbilityTask_WalkTask final : public UAbilityTask
{
public:
	TMulticastInlineDelegate<void()>              OnCompleted;                                       // 0x0080(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	class ACharacter*                             Character;                                         // 0x0090(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_98[0x20];                                      // 0x0098(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UP2AbilityTask_WalkTask* CreateNew(class UGameplayAbility* OwningAbility, class FName TaskInstanceName, class ACharacter* InCharacter, const float InMinDistance, const struct FVector& InDestination)	 // 0x4760918;

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"P2AbilityTask_WalkTask">();
	}
	static class UP2AbilityTask_WalkTask* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UP2AbilityTask_WalkTask>();
	}
};
static_assert(alignof(UP2AbilityTask_WalkTask) == 0x000008, "Wrong alignment on UP2AbilityTask_WalkTask");
static_assert(sizeof(UP2AbilityTask_WalkTask) == 0x0000B8, "Wrong size on UP2AbilityTask_WalkTask");
static_assert(offsetof(UP2AbilityTask_WalkTask, OnCompleted) == 0x000080, "Member 'UP2AbilityTask_WalkTask::OnCompleted' has a wrong offset!");
static_assert(offsetof(UP2AbilityTask_WalkTask, Character) == 0x000090, "Member 'UP2AbilityTask_WalkTask::Character' has a wrong offset!");

// Class AICommon.P2PayloadObject_HitBox
// 0x0048 (0x0070 - 0x0028)
class UP2PayloadObject_HitBox final : public UP2PayloadObject
{
public:
	struct FVector                                Offset;                                            // 0x0028(0x0018)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Extent;                                            // 0x0040(0x0018)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               Rotation;                                          // 0x0058(0x0018)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"P2PayloadObject_HitBox">();
	}
	static class UP2PayloadObject_HitBox* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UP2PayloadObject_HitBox>();
	}
};
static_assert(alignof(UP2PayloadObject_HitBox) == 0x000008, "Wrong alignment on UP2PayloadObject_HitBox");
static_assert(sizeof(UP2PayloadObject_HitBox) == 0x000070, "Wrong size on UP2PayloadObject_HitBox");
static_assert(offsetof(UP2PayloadObject_HitBox, Offset) == 0x000028, "Member 'UP2PayloadObject_HitBox::Offset' has a wrong offset!");
static_assert(offsetof(UP2PayloadObject_HitBox, Extent) == 0x000040, "Member 'UP2PayloadObject_HitBox::Extent' has a wrong offset!");
static_assert(offsetof(UP2PayloadObject_HitBox, Rotation) == 0x000058, "Member 'UP2PayloadObject_HitBox::Rotation' has a wrong offset!");

// Class AICommon.P2PlayEmoteData
// 0x0030 (0x0058 - 0x0028)
class UP2PlayEmoteData final : public UObject
{
public:
	bool                                          bSucceedOnInterrupted;                             // 0x0028(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_29[0x7];                                       // 0x0029(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UAnimMontage*                           Montage;                                           // 0x0030(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   StartSection;                                      // 0x0038(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsInterruptible;                                  // 0x0040(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_41[0x7];                                       // 0x0041(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FP2RootMotionTarget>            RootMotionTargets;                                 // 0x0048(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"P2PlayEmoteData">();
	}
	static class UP2PlayEmoteData* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UP2PlayEmoteData>();
	}
};
static_assert(alignof(UP2PlayEmoteData) == 0x000008, "Wrong alignment on UP2PlayEmoteData");
static_assert(sizeof(UP2PlayEmoteData) == 0x000058, "Wrong size on UP2PlayEmoteData");
static_assert(offsetof(UP2PlayEmoteData, bSucceedOnInterrupted) == 0x000028, "Member 'UP2PlayEmoteData::bSucceedOnInterrupted' has a wrong offset!");
static_assert(offsetof(UP2PlayEmoteData, Montage) == 0x000030, "Member 'UP2PlayEmoteData::Montage' has a wrong offset!");
static_assert(offsetof(UP2PlayEmoteData, StartSection) == 0x000038, "Member 'UP2PlayEmoteData::StartSection' has a wrong offset!");
static_assert(offsetof(UP2PlayEmoteData, bIsInterruptible) == 0x000040, "Member 'UP2PlayEmoteData::bIsInterruptible' has a wrong offset!");
static_assert(offsetof(UP2PlayEmoteData, RootMotionTargets) == 0x000048, "Member 'UP2PlayEmoteData::RootMotionTargets' has a wrong offset!");

// Class AICommon.P2NpcAbility_ProjectileAttack
// 0x0020 (0x0550 - 0x0530)
class UP2NpcAbility_ProjectileAttack final : public UP2NpcAbility_BaseSpawningAttack
{
public:
	struct FVector                                SpawnOffset;                                       // 0x0530(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         ProjectileSpeed;                                   // 0x0548(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         GravityScale;                                      // 0x054C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"P2NpcAbility_ProjectileAttack">();
	}
	static class UP2NpcAbility_ProjectileAttack* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UP2NpcAbility_ProjectileAttack>();
	}
};
static_assert(alignof(UP2NpcAbility_ProjectileAttack) == 0x000008, "Wrong alignment on UP2NpcAbility_ProjectileAttack");
static_assert(sizeof(UP2NpcAbility_ProjectileAttack) == 0x000550, "Wrong size on UP2NpcAbility_ProjectileAttack");
static_assert(offsetof(UP2NpcAbility_ProjectileAttack, SpawnOffset) == 0x000530, "Member 'UP2NpcAbility_ProjectileAttack::SpawnOffset' has a wrong offset!");
static_assert(offsetof(UP2NpcAbility_ProjectileAttack, ProjectileSpeed) == 0x000548, "Member 'UP2NpcAbility_ProjectileAttack::ProjectileSpeed' has a wrong offset!");
static_assert(offsetof(UP2NpcAbility_ProjectileAttack, GravityScale) == 0x00054C, "Member 'UP2NpcAbility_ProjectileAttack::GravityScale' has a wrong offset!");

// Class AICommon.P2NpcAbility_PsycheAimEvasion
// 0x0098 (0x0530 - 0x0498)
class UP2NpcAbility_PsycheAimEvasion final : public UP2NpcAbility
{
public:
	float                                         EvasionDistance;                                   // 0x0498(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxPushDistance;                                   // 0x049C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRuntimeFloatCurve                     PushForceCurve;                                    // 0x04A0(0x0088)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	class UP2AbilityTask_PsycheAimEvasion*        Task;                                              // 0x0528(0x0008)(ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"P2NpcAbility_PsycheAimEvasion">();
	}
	static class UP2NpcAbility_PsycheAimEvasion* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UP2NpcAbility_PsycheAimEvasion>();
	}
};
static_assert(alignof(UP2NpcAbility_PsycheAimEvasion) == 0x000008, "Wrong alignment on UP2NpcAbility_PsycheAimEvasion");
static_assert(sizeof(UP2NpcAbility_PsycheAimEvasion) == 0x000530, "Wrong size on UP2NpcAbility_PsycheAimEvasion");
static_assert(offsetof(UP2NpcAbility_PsycheAimEvasion, EvasionDistance) == 0x000498, "Member 'UP2NpcAbility_PsycheAimEvasion::EvasionDistance' has a wrong offset!");
static_assert(offsetof(UP2NpcAbility_PsycheAimEvasion, MaxPushDistance) == 0x00049C, "Member 'UP2NpcAbility_PsycheAimEvasion::MaxPushDistance' has a wrong offset!");
static_assert(offsetof(UP2NpcAbility_PsycheAimEvasion, PushForceCurve) == 0x0004A0, "Member 'UP2NpcAbility_PsycheAimEvasion::PushForceCurve' has a wrong offset!");
static_assert(offsetof(UP2NpcAbility_PsycheAimEvasion, Task) == 0x000528, "Member 'UP2NpcAbility_PsycheAimEvasion::Task' has a wrong offset!");

// Class AICommon.P2NpcAbility_PsycheUseSmartObject
// 0x0018 (0x05F0 - 0x05D8)
class UP2NpcAbility_PsycheUseSmartObject final : public UP2NpcAbility_UseSmartObjectMontage
{
public:
	struct FGameplayTag                           AttackEventTag;                                    // 0x05D8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         HorizontalRange;                                   // 0x05E0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         VerticalRange;                                     // 0x05E4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_5E8[0x8];                                      // 0x05E8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ApplyEffectToActorOnAttack(class AActor* Actor)	 // 0xae1e64;

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"P2NpcAbility_PsycheUseSmartObject">();
	}
	static class UP2NpcAbility_PsycheUseSmartObject* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UP2NpcAbility_PsycheUseSmartObject>();
	}
};
static_assert(alignof(UP2NpcAbility_PsycheUseSmartObject) == 0x000008, "Wrong alignment on UP2NpcAbility_PsycheUseSmartObject");
static_assert(sizeof(UP2NpcAbility_PsycheUseSmartObject) == 0x0005F0, "Wrong size on UP2NpcAbility_PsycheUseSmartObject");
static_assert(offsetof(UP2NpcAbility_PsycheUseSmartObject, AttackEventTag) == 0x0005D8, "Member 'UP2NpcAbility_PsycheUseSmartObject::AttackEventTag' has a wrong offset!");
static_assert(offsetof(UP2NpcAbility_PsycheUseSmartObject, HorizontalRange) == 0x0005E0, "Member 'UP2NpcAbility_PsycheUseSmartObject::HorizontalRange' has a wrong offset!");
static_assert(offsetof(UP2NpcAbility_PsycheUseSmartObject, VerticalRange) == 0x0005E4, "Member 'UP2NpcAbility_PsycheUseSmartObject::VerticalRange' has a wrong offset!");

// Class AICommon.P2NpcAbility_RasslerStasis
// 0x0080 (0x0518 - 0x0498)
class UP2NpcAbility_RasslerStasis final : public UP2NpcAbility
{
public:
	float                                         IncreaseDetectionSpeed;                            // 0x0498(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         DecreaseDetectionSpeed;                            // 0x049C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         DecreaseDetectionDelay;                            // 0x04A0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_4A4[0x4];                                      // 0x04A4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	double                                        MaxStimulusAgeToLoopAnimation;                     // 0x04A8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<struct FStimuliImpactTime>             StimulusTagsToListen;                              // 0x04B0(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	TSubclassOf<class UP2AnimLayer_RasslerStasis> AnimLayer;                                         // 0x04C0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class UP2StasisAnimationsData*>        AnimationSets;                                     // 0x04C8(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Protected, UObjectWrapper, NativeAccessSpecifierProtected)
	struct FGameplayTagContainer                  RequiredTags;                                      // 0x04D8(0x0020)(Edit, BlueprintVisible, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_4F8[0x8];                                      // 0x04F8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UP2AbilityTask_AnimLayer_Rassler*       AnimLayerTask;                                     // 0x0500(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UP2AbilityTask_DetectionGauge*          DetectionGaugeTask;                                // 0x0508(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UP2AbilityTask_CheckGameplayTags*       CheckGameplayTagsTask;                             // 0x0510(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void OnCancellationRequired()	 // 0x47650fc;
	void OnExitingMontageFinished()	 // 0x4765124;
	void OnGaugeUpdated(const float GaugeValue, const float GaugeSpeed)	 // 0x4765138;
	void OnLastSensedLocationUpdated(const struct FVector& LastSensedLocation)	 // 0x4765278;
	void OnLookAroundMontageFinished()	 // 0x4765300;

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"P2NpcAbility_RasslerStasis">();
	}
	static class UP2NpcAbility_RasslerStasis* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UP2NpcAbility_RasslerStasis>();
	}
};
static_assert(alignof(UP2NpcAbility_RasslerStasis) == 0x000008, "Wrong alignment on UP2NpcAbility_RasslerStasis");
static_assert(sizeof(UP2NpcAbility_RasslerStasis) == 0x000518, "Wrong size on UP2NpcAbility_RasslerStasis");
static_assert(offsetof(UP2NpcAbility_RasslerStasis, IncreaseDetectionSpeed) == 0x000498, "Member 'UP2NpcAbility_RasslerStasis::IncreaseDetectionSpeed' has a wrong offset!");
static_assert(offsetof(UP2NpcAbility_RasslerStasis, DecreaseDetectionSpeed) == 0x00049C, "Member 'UP2NpcAbility_RasslerStasis::DecreaseDetectionSpeed' has a wrong offset!");
static_assert(offsetof(UP2NpcAbility_RasslerStasis, DecreaseDetectionDelay) == 0x0004A0, "Member 'UP2NpcAbility_RasslerStasis::DecreaseDetectionDelay' has a wrong offset!");
static_assert(offsetof(UP2NpcAbility_RasslerStasis, MaxStimulusAgeToLoopAnimation) == 0x0004A8, "Member 'UP2NpcAbility_RasslerStasis::MaxStimulusAgeToLoopAnimation' has a wrong offset!");
static_assert(offsetof(UP2NpcAbility_RasslerStasis, StimulusTagsToListen) == 0x0004B0, "Member 'UP2NpcAbility_RasslerStasis::StimulusTagsToListen' has a wrong offset!");
static_assert(offsetof(UP2NpcAbility_RasslerStasis, AnimLayer) == 0x0004C0, "Member 'UP2NpcAbility_RasslerStasis::AnimLayer' has a wrong offset!");
static_assert(offsetof(UP2NpcAbility_RasslerStasis, AnimationSets) == 0x0004C8, "Member 'UP2NpcAbility_RasslerStasis::AnimationSets' has a wrong offset!");
static_assert(offsetof(UP2NpcAbility_RasslerStasis, RequiredTags) == 0x0004D8, "Member 'UP2NpcAbility_RasslerStasis::RequiredTags' has a wrong offset!");
static_assert(offsetof(UP2NpcAbility_RasslerStasis, AnimLayerTask) == 0x000500, "Member 'UP2NpcAbility_RasslerStasis::AnimLayerTask' has a wrong offset!");
static_assert(offsetof(UP2NpcAbility_RasslerStasis, DetectionGaugeTask) == 0x000508, "Member 'UP2NpcAbility_RasslerStasis::DetectionGaugeTask' has a wrong offset!");
static_assert(offsetof(UP2NpcAbility_RasslerStasis, CheckGameplayTagsTask) == 0x000510, "Member 'UP2NpcAbility_RasslerStasis::CheckGameplayTagsTask' has a wrong offset!");

// Class AICommon.P2NpcAbility_Sentry_Activate
// 0x0008 (0x04A0 - 0x0498)
class UP2NpcAbility_Sentry_Activate : public UP2NpcAbility
{
public:
	class UP2AbilityTask_Sentry_Active*           SentryActiveTask;                                  // 0x0498(0x0008)(ZeroConstructor, Transient, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"P2NpcAbility_Sentry_Activate">();
	}
	static class UP2NpcAbility_Sentry_Activate* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UP2NpcAbility_Sentry_Activate>();
	}
};
static_assert(alignof(UP2NpcAbility_Sentry_Activate) == 0x000008, "Wrong alignment on UP2NpcAbility_Sentry_Activate");
static_assert(sizeof(UP2NpcAbility_Sentry_Activate) == 0x0004A0, "Wrong size on UP2NpcAbility_Sentry_Activate");
static_assert(offsetof(UP2NpcAbility_Sentry_Activate, SentryActiveTask) == 0x000498, "Member 'UP2NpcAbility_Sentry_Activate::SentryActiveTask' has a wrong offset!");

// Class AICommon.P2NpcAbility_Shortcut
// 0x0008 (0x04A0 - 0x0498)
class UP2NpcAbility_Shortcut final : public UP2NpcAbility
{
public:
	ECollisionEnabled                             SavedCollisionType;                                // 0x0498(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_499[0x7];                                      // 0x0499(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnAnimationEnded()	 // 0x17c7f2c;
	void OnAnimationInterrupted()	 // 0x17c7f2c;
	void StartShortcut(class UP2ShortcutDataAsset* ShortcutDataAsset, const struct FVector& StartLocation, const struct FVector& EndLocation, bool bUseStart)	 // 0xae1e64;
	void StartShortcut_MoveAction(const struct FMoveActionExecData& ExecData)	 // 0xae1e64;

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"P2NpcAbility_Shortcut">();
	}
	static class UP2NpcAbility_Shortcut* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UP2NpcAbility_Shortcut>();
	}
};
static_assert(alignof(UP2NpcAbility_Shortcut) == 0x000008, "Wrong alignment on UP2NpcAbility_Shortcut");
static_assert(sizeof(UP2NpcAbility_Shortcut) == 0x0004A0, "Wrong size on UP2NpcAbility_Shortcut");
static_assert(offsetof(UP2NpcAbility_Shortcut, SavedCollisionType) == 0x000498, "Member 'UP2NpcAbility_Shortcut::SavedCollisionType' has a wrong offset!");

// Class AICommon.P2AbilityTask_JumpMovementMode
// 0x0010 (0x0090 - 0x0080)
class UP2AbilityTask_JumpMovementMode final : public UAbilityTask
{
public:
	class AP2NPCharacter*                         Character;                                         // 0x0080(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_88[0x8];                                       // 0x0088(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UP2AbilityTask_JumpMovementMode* CreateNew(class UGameplayAbility* OwningAbility, class FName TaskInstanceName, class AP2NPCharacter* InCharacter)	 // 0x4764e10;

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"P2AbilityTask_JumpMovementMode">();
	}
	static class UP2AbilityTask_JumpMovementMode* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UP2AbilityTask_JumpMovementMode>();
	}
};
static_assert(alignof(UP2AbilityTask_JumpMovementMode) == 0x000008, "Wrong alignment on UP2AbilityTask_JumpMovementMode");
static_assert(sizeof(UP2AbilityTask_JumpMovementMode) == 0x000090, "Wrong size on UP2AbilityTask_JumpMovementMode");
static_assert(offsetof(UP2AbilityTask_JumpMovementMode, Character) == 0x000080, "Member 'UP2AbilityTask_JumpMovementMode::Character' has a wrong offset!");

// Class AICommon.P2NpcAbility_UsePassageLink_Walking
// 0x0018 (0x04F8 - 0x04E0)
class UP2NpcAbility_UsePassageLink_Walking final : public UP2NpcAbility_UsePassageLink
{
public:
	float                                         Speed;                                             // 0x04E0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4E4[0x4];                                      // 0x04E4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UAbilityTask_ApplyRootMotionMoveToForce* RootMotionMoveTask;                               // 0x04E8(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UP2AbilityTask_SetCollisionResponse*    CollisionResponseTask;                             // 0x04F0(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void OnMovementFinished()	 // 0x4761238;

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"P2NpcAbility_UsePassageLink_Walking">();
	}
	static class UP2NpcAbility_UsePassageLink_Walking* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UP2NpcAbility_UsePassageLink_Walking>();
	}
};
static_assert(alignof(UP2NpcAbility_UsePassageLink_Walking) == 0x000008, "Wrong alignment on UP2NpcAbility_UsePassageLink_Walking");
static_assert(sizeof(UP2NpcAbility_UsePassageLink_Walking) == 0x0004F8, "Wrong size on UP2NpcAbility_UsePassageLink_Walking");
static_assert(offsetof(UP2NpcAbility_UsePassageLink_Walking, Speed) == 0x0004E0, "Member 'UP2NpcAbility_UsePassageLink_Walking::Speed' has a wrong offset!");
static_assert(offsetof(UP2NpcAbility_UsePassageLink_Walking, RootMotionMoveTask) == 0x0004E8, "Member 'UP2NpcAbility_UsePassageLink_Walking::RootMotionMoveTask' has a wrong offset!");
static_assert(offsetof(UP2NpcAbility_UsePassageLink_Walking, CollisionResponseTask) == 0x0004F0, "Member 'UP2NpcAbility_UsePassageLink_Walking::CollisionResponseTask' has a wrong offset!");

// Class AICommon.P2NpcAbility_UseVaultLink
// 0x0018 (0x04F8 - 0x04E0)
class UP2NpcAbility_UseVaultLink : public UP2NpcAbility_UseMercunaNavLink
{
public:
	class FName                                   FocalPointOverrideBlackboardKeyName;               // 0x04E0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4E8[0x10];                                     // 0x04E8(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnTagChanged(const struct FGameplayTag& InGameplayTag, int32 InCount)	 // 0x4765594;

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"P2NpcAbility_UseVaultLink">();
	}
	static class UP2NpcAbility_UseVaultLink* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UP2NpcAbility_UseVaultLink>();
	}
};
static_assert(alignof(UP2NpcAbility_UseVaultLink) == 0x000008, "Wrong alignment on UP2NpcAbility_UseVaultLink");
static_assert(sizeof(UP2NpcAbility_UseVaultLink) == 0x0004F8, "Wrong size on UP2NpcAbility_UseVaultLink");
static_assert(offsetof(UP2NpcAbility_UseVaultLink, FocalPointOverrideBlackboardKeyName) == 0x0004E0, "Member 'UP2NpcAbility_UseVaultLink::FocalPointOverrideBlackboardKeyName' has a wrong offset!");

// Class AICommon.P2NpcAbility_UseWindowLink
// 0x0050 (0x0530 - 0x04E0)
class UP2NpcAbility_UseWindowLink final : public UP2NpcAbility_UseMercunaNavLink
{
public:
	class UAnimMontage*                           TraversalMontage;                                  // 0x04E0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   MontageGroundEntrySectionName;                     // 0x04E8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   MontageGroundExitSectionName;                      // 0x04F0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   MontageVaultEntrySectionName;                      // 0x04F8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   MontageVaultExitSectionName;                       // 0x0500(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   MontageHighVaultEntrySectionName;                  // 0x0508(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   MontageHighVaultExitSectionName;                   // 0x0510(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UP2AbilityTask_PlayMontageAndWait*      PlayMontageTask;                                   // 0x0518(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UP2AbilityTask_MovementModeOverride*    MovementModeOverrideTask;                          // 0x0520(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_528[0x8];                                      // 0x0528(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnExitFinished()	 // 0x4765110;
	void OnTraversalCanceled()	 // 0x47656e8;

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"P2NpcAbility_UseWindowLink">();
	}
	static class UP2NpcAbility_UseWindowLink* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UP2NpcAbility_UseWindowLink>();
	}
};
static_assert(alignof(UP2NpcAbility_UseWindowLink) == 0x000008, "Wrong alignment on UP2NpcAbility_UseWindowLink");
static_assert(sizeof(UP2NpcAbility_UseWindowLink) == 0x000530, "Wrong size on UP2NpcAbility_UseWindowLink");
static_assert(offsetof(UP2NpcAbility_UseWindowLink, TraversalMontage) == 0x0004E0, "Member 'UP2NpcAbility_UseWindowLink::TraversalMontage' has a wrong offset!");
static_assert(offsetof(UP2NpcAbility_UseWindowLink, MontageGroundEntrySectionName) == 0x0004E8, "Member 'UP2NpcAbility_UseWindowLink::MontageGroundEntrySectionName' has a wrong offset!");
static_assert(offsetof(UP2NpcAbility_UseWindowLink, MontageGroundExitSectionName) == 0x0004F0, "Member 'UP2NpcAbility_UseWindowLink::MontageGroundExitSectionName' has a wrong offset!");
static_assert(offsetof(UP2NpcAbility_UseWindowLink, MontageVaultEntrySectionName) == 0x0004F8, "Member 'UP2NpcAbility_UseWindowLink::MontageVaultEntrySectionName' has a wrong offset!");
static_assert(offsetof(UP2NpcAbility_UseWindowLink, MontageVaultExitSectionName) == 0x000500, "Member 'UP2NpcAbility_UseWindowLink::MontageVaultExitSectionName' has a wrong offset!");
static_assert(offsetof(UP2NpcAbility_UseWindowLink, MontageHighVaultEntrySectionName) == 0x000508, "Member 'UP2NpcAbility_UseWindowLink::MontageHighVaultEntrySectionName' has a wrong offset!");
static_assert(offsetof(UP2NpcAbility_UseWindowLink, MontageHighVaultExitSectionName) == 0x000510, "Member 'UP2NpcAbility_UseWindowLink::MontageHighVaultExitSectionName' has a wrong offset!");
static_assert(offsetof(UP2NpcAbility_UseWindowLink, PlayMontageTask) == 0x000518, "Member 'UP2NpcAbility_UseWindowLink::PlayMontageTask' has a wrong offset!");
static_assert(offsetof(UP2NpcAbility_UseWindowLink, MovementModeOverrideTask) == 0x000520, "Member 'UP2NpcAbility_UseWindowLink::MovementModeOverrideTask' has a wrong offset!");

// Class AICommon.P2NpcAbility_WildCatUseTree
// 0x00A8 (0x0540 - 0x0498)
class UP2NpcAbility_WildCatUseTree final : public UP2NpcAbility
{
public:
	TSubclassOf<class UP2GameplayEffect_Damage>   DamageEffect;                                      // 0x0498(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCurveFloat*                            StunSeverityCurve;                                 // 0x04A0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         StunImpactRadius;                                  // 0x04A8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         ImpactRadius;                                      // 0x04AC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         AttackTargetOffset;                                // 0x04B0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         JumpSpeed;                                         // 0x04B4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UAnimInstance>              AnimLayer;                                         // 0x04B8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAnimSequence*                          AttackLandedAnimation;                             // 0x04C0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAbilityTask_PlayMontageAndWait*        MontageTask;                                       // 0x04C8(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UP2AbilityTask_MoveAlongTransformCurve* ClimbTask;                                         // 0x04D0(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UP2AbilityTask_WildcatJumpFromTree*     JumpTask;                                          // 0x04D8(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UP2AbilityTask_AnimLayer_Wildcat*       AnimLayerTask;                                     // 0x04E0(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UP2AbilityTask_MovementModeOverride*    MovementModeOverrideTask;                          // 0x04E8(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UP2AbilityTask_WildCatIdleOnTree*       IdleOnTreeTask;                                    // 0x04F0(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_4F8[0x48];                                     // 0x04F8(0x0048)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnLeftTree()	 // 0x4761238;

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"P2NpcAbility_WildCatUseTree">();
	}
	static class UP2NpcAbility_WildCatUseTree* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UP2NpcAbility_WildCatUseTree>();
	}
};
static_assert(alignof(UP2NpcAbility_WildCatUseTree) == 0x000008, "Wrong alignment on UP2NpcAbility_WildCatUseTree");
static_assert(sizeof(UP2NpcAbility_WildCatUseTree) == 0x000540, "Wrong size on UP2NpcAbility_WildCatUseTree");
static_assert(offsetof(UP2NpcAbility_WildCatUseTree, DamageEffect) == 0x000498, "Member 'UP2NpcAbility_WildCatUseTree::DamageEffect' has a wrong offset!");
static_assert(offsetof(UP2NpcAbility_WildCatUseTree, StunSeverityCurve) == 0x0004A0, "Member 'UP2NpcAbility_WildCatUseTree::StunSeverityCurve' has a wrong offset!");
static_assert(offsetof(UP2NpcAbility_WildCatUseTree, StunImpactRadius) == 0x0004A8, "Member 'UP2NpcAbility_WildCatUseTree::StunImpactRadius' has a wrong offset!");
static_assert(offsetof(UP2NpcAbility_WildCatUseTree, ImpactRadius) == 0x0004AC, "Member 'UP2NpcAbility_WildCatUseTree::ImpactRadius' has a wrong offset!");
static_assert(offsetof(UP2NpcAbility_WildCatUseTree, AttackTargetOffset) == 0x0004B0, "Member 'UP2NpcAbility_WildCatUseTree::AttackTargetOffset' has a wrong offset!");
static_assert(offsetof(UP2NpcAbility_WildCatUseTree, JumpSpeed) == 0x0004B4, "Member 'UP2NpcAbility_WildCatUseTree::JumpSpeed' has a wrong offset!");
static_assert(offsetof(UP2NpcAbility_WildCatUseTree, AnimLayer) == 0x0004B8, "Member 'UP2NpcAbility_WildCatUseTree::AnimLayer' has a wrong offset!");
static_assert(offsetof(UP2NpcAbility_WildCatUseTree, AttackLandedAnimation) == 0x0004C0, "Member 'UP2NpcAbility_WildCatUseTree::AttackLandedAnimation' has a wrong offset!");
static_assert(offsetof(UP2NpcAbility_WildCatUseTree, MontageTask) == 0x0004C8, "Member 'UP2NpcAbility_WildCatUseTree::MontageTask' has a wrong offset!");
static_assert(offsetof(UP2NpcAbility_WildCatUseTree, ClimbTask) == 0x0004D0, "Member 'UP2NpcAbility_WildCatUseTree::ClimbTask' has a wrong offset!");
static_assert(offsetof(UP2NpcAbility_WildCatUseTree, JumpTask) == 0x0004D8, "Member 'UP2NpcAbility_WildCatUseTree::JumpTask' has a wrong offset!");
static_assert(offsetof(UP2NpcAbility_WildCatUseTree, AnimLayerTask) == 0x0004E0, "Member 'UP2NpcAbility_WildCatUseTree::AnimLayerTask' has a wrong offset!");
static_assert(offsetof(UP2NpcAbility_WildCatUseTree, MovementModeOverrideTask) == 0x0004E8, "Member 'UP2NpcAbility_WildCatUseTree::MovementModeOverrideTask' has a wrong offset!");
static_assert(offsetof(UP2NpcAbility_WildCatUseTree, IdleOnTreeTask) == 0x0004F0, "Member 'UP2NpcAbility_WildCatUseTree::IdleOnTreeTask' has a wrong offset!");

// Class AICommon.P2NpcAnimFunctionLibrary
// 0x0000 (0x0028 - 0x0028)
class UP2NpcAnimFunctionLibrary final : public UBlueprintFunctionLibrary
{
public:
	static void ForcePoseSearch(struct FTrajectory& InTrajectory)	 // 0x4764fe4;

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"P2NpcAnimFunctionLibrary">();
	}
	static class UP2NpcAnimFunctionLibrary* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UP2NpcAnimFunctionLibrary>();
	}
};
static_assert(alignof(UP2NpcAnimFunctionLibrary) == 0x000008, "Wrong alignment on UP2NpcAnimFunctionLibrary");
static_assert(sizeof(UP2NpcAnimFunctionLibrary) == 0x000028, "Wrong size on UP2NpcAnimFunctionLibrary");

// Class AICommon.P2NpcAnimInstance_Rassler
// 0x0070 (0x05D0 - 0x0560)
class UP2NpcAnimInstance_Rassler final : public UP2NpcAnimInstance
{
public:
	struct FRotator                               HeadRot1;                                          // 0x0560(0x0018)(Edit, BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FRotator                               HeadRot2;                                          // 0x0578(0x0018)(Edit, BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FRotator                               HeadRot3;                                          // 0x0590(0x0018)(Edit, BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          bActiveLayerAndStopped;                            // 0x05A8(0x0001)(Edit, BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5A9[0x7];                                      // 0x05A9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FMotionMatchingInputData               MM_InputData;                                      // 0x05B0(0x0010)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	class UMotionMatchConfig*                     MM_Config;                                         // 0x05C0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5C8[0x8];                                      // 0x05C8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"P2NpcAnimInstance_Rassler">();
	}
	static class UP2NpcAnimInstance_Rassler* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UP2NpcAnimInstance_Rassler>();
	}
};
static_assert(alignof(UP2NpcAnimInstance_Rassler) == 0x000010, "Wrong alignment on UP2NpcAnimInstance_Rassler");
static_assert(sizeof(UP2NpcAnimInstance_Rassler) == 0x0005D0, "Wrong size on UP2NpcAnimInstance_Rassler");
static_assert(offsetof(UP2NpcAnimInstance_Rassler, HeadRot1) == 0x000560, "Member 'UP2NpcAnimInstance_Rassler::HeadRot1' has a wrong offset!");
static_assert(offsetof(UP2NpcAnimInstance_Rassler, HeadRot2) == 0x000578, "Member 'UP2NpcAnimInstance_Rassler::HeadRot2' has a wrong offset!");
static_assert(offsetof(UP2NpcAnimInstance_Rassler, HeadRot3) == 0x000590, "Member 'UP2NpcAnimInstance_Rassler::HeadRot3' has a wrong offset!");
static_assert(offsetof(UP2NpcAnimInstance_Rassler, bActiveLayerAndStopped) == 0x0005A8, "Member 'UP2NpcAnimInstance_Rassler::bActiveLayerAndStopped' has a wrong offset!");
static_assert(offsetof(UP2NpcAnimInstance_Rassler, MM_InputData) == 0x0005B0, "Member 'UP2NpcAnimInstance_Rassler::MM_InputData' has a wrong offset!");
static_assert(offsetof(UP2NpcAnimInstance_Rassler, MM_Config) == 0x0005C0, "Member 'UP2NpcAnimInstance_Rassler::MM_Config' has a wrong offset!");

// Class AICommon.P2NpcAttributeSet
// 0x0040 (0x0080 - 0x0040)
class UP2NpcAttributeSet : public UP2AttributeSet
{
public:
	struct FGameplayAttributeData                 MaxSpeedLimit;                                     // 0x0040(0x0010)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 ToxinLevel;                                        // 0x0050(0x0010)(BlueprintVisible, BlueprintReadOnly, Net, RepNotify, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 MaxToxinLevel;                                     // 0x0060(0x0010)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 MutationStage;                                     // 0x0070(0x0010)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)

public:
	void OnRep_ToxinLevel(const struct FGameplayAttributeData& OldValue)	 // 0x12e2ac8;

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"P2NpcAttributeSet">();
	}
	static class UP2NpcAttributeSet* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UP2NpcAttributeSet>();
	}
};
static_assert(alignof(UP2NpcAttributeSet) == 0x000008, "Wrong alignment on UP2NpcAttributeSet");
static_assert(sizeof(UP2NpcAttributeSet) == 0x000080, "Wrong size on UP2NpcAttributeSet");
static_assert(offsetof(UP2NpcAttributeSet, MaxSpeedLimit) == 0x000040, "Member 'UP2NpcAttributeSet::MaxSpeedLimit' has a wrong offset!");
static_assert(offsetof(UP2NpcAttributeSet, ToxinLevel) == 0x000050, "Member 'UP2NpcAttributeSet::ToxinLevel' has a wrong offset!");
static_assert(offsetof(UP2NpcAttributeSet, MaxToxinLevel) == 0x000060, "Member 'UP2NpcAttributeSet::MaxToxinLevel' has a wrong offset!");
static_assert(offsetof(UP2NpcAttributeSet, MutationStage) == 0x000070, "Member 'UP2NpcAttributeSet::MutationStage' has a wrong offset!");

// Class AICommon.P2FlyingNpcAudioDataAsset
// 0x0050 (0x0150 - 0x0100)
class UP2FlyingNpcAudioDataAsset final : public UP2NpcAudioDataAsset
{
public:
	TMap<EP2PerceptionAlertedLevelType, class UAkAudioEvent*> AlertedStateFlyingEvents;              // 0x0100(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, UObjectWrapper, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"P2FlyingNpcAudioDataAsset">();
	}
	static class UP2FlyingNpcAudioDataAsset* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UP2FlyingNpcAudioDataAsset>();
	}
};
static_assert(alignof(UP2FlyingNpcAudioDataAsset) == 0x000008, "Wrong alignment on UP2FlyingNpcAudioDataAsset");
static_assert(sizeof(UP2FlyingNpcAudioDataAsset) == 0x000150, "Wrong size on UP2FlyingNpcAudioDataAsset");
static_assert(offsetof(UP2FlyingNpcAudioDataAsset, AlertedStateFlyingEvents) == 0x000100, "Member 'UP2FlyingNpcAudioDataAsset::AlertedStateFlyingEvents' has a wrong offset!");

// Class AICommon.P2NpcComponent
// 0x0028 (0x00F0 - 0x00C8)
class UP2NpcComponent final : public UP2PawnComponent
{
public:
	uint8                                         Pad_C8[0x28];                                      // 0x00C8(0x0028)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnNpcDeath(class UP2HealthComponent* InHealthComponent)	 // 0x11df1d0;

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"P2NpcComponent">();
	}
	static class UP2NpcComponent* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UP2NpcComponent>();
	}
};
static_assert(alignof(UP2NpcComponent) == 0x000008, "Wrong alignment on UP2NpcComponent");
static_assert(sizeof(UP2NpcComponent) == 0x0000F0, "Wrong size on UP2NpcComponent");

// Class AICommon.P2NpcContainerData
// 0x0000 (0x0058 - 0x0058)
class UP2NpcContainerData final : public UP2LootSpawnContainerData
{
public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"P2NpcContainerData">();
	}
	static class UP2NpcContainerData* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UP2NpcContainerData>();
	}
};
static_assert(alignof(UP2NpcContainerData) == 0x000008, "Wrong alignment on UP2NpcContainerData");
static_assert(sizeof(UP2NpcContainerData) == 0x000058, "Wrong size on UP2NpcContainerData");

// Class AICommon.P2NpcDebugControlComponent
// 0x0040 (0x0100 - 0x00C0)
class UP2NpcDebugControlComponent final : public UActorComponent
{
public:
	TArray<struct FVector>                        Waypoints;                                         // 0x00C0(0x0010)(Edit, ZeroConstructor, EditConst, Protected, NativeAccessSpecifierProtected)
	bool                                          bControlActive;                                    // 0x00D0(0x0001)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	ENpcDebugMovementType                         MovementType;                                      // 0x00D1(0x0001)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_D2[0x2];                                       // 0x00D2(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         WaypointReachedThreshold;                          // 0x00D4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_D8[0x28];                                      // 0x00D8(0x0028)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"P2NpcDebugControlComponent">();
	}
	static class UP2NpcDebugControlComponent* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UP2NpcDebugControlComponent>();
	}
};
static_assert(alignof(UP2NpcDebugControlComponent) == 0x000008, "Wrong alignment on UP2NpcDebugControlComponent");
static_assert(sizeof(UP2NpcDebugControlComponent) == 0x000100, "Wrong size on UP2NpcDebugControlComponent");
static_assert(offsetof(UP2NpcDebugControlComponent, Waypoints) == 0x0000C0, "Member 'UP2NpcDebugControlComponent::Waypoints' has a wrong offset!");
static_assert(offsetof(UP2NpcDebugControlComponent, bControlActive) == 0x0000D0, "Member 'UP2NpcDebugControlComponent::bControlActive' has a wrong offset!");
static_assert(offsetof(UP2NpcDebugControlComponent, MovementType) == 0x0000D1, "Member 'UP2NpcDebugControlComponent::MovementType' has a wrong offset!");
static_assert(offsetof(UP2NpcDebugControlComponent, WaypointReachedThreshold) == 0x0000D4, "Member 'UP2NpcDebugControlComponent::WaypointReachedThreshold' has a wrong offset!");

// Class AICommon.P2NpcGroupMemberInterface
// 0x0000 (0x0000 - 0x0000)
class IP2NpcGroupMemberInterface final
{
public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"P2NpcGroupMemberInterface">();
	}
	static class IP2NpcGroupMemberInterface* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<IP2NpcGroupMemberInterface>();
	}

	class UObject* AsUObject()	 // 0x0
	{
		return reinterpret_cast<UObject*>(this);
	}
	const class UObject* AsUObject() const	 // 0x0
	{
		return reinterpret_cast<const UObject*>(this);
	}
};
static_assert(alignof(IP2NpcGroupMemberInterface) == 0x000001, "Wrong alignment on IP2NpcGroupMemberInterface");
static_assert(sizeof(IP2NpcGroupMemberInterface) == 0x000001, "Wrong size on IP2NpcGroupMemberInterface");

// Class AICommon.P2NpcHitReactionData
// 0x0010 (0x0048 - 0x0038)
class UP2NpcHitReactionData final : public UP2HitReactionDataBase
{
public:
	TArray<struct FP2NpcReactionData>             Reactions;                                         // 0x0038(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"P2NpcHitReactionData">();
	}
	static class UP2NpcHitReactionData* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UP2NpcHitReactionData>();
	}
};
static_assert(alignof(UP2NpcHitReactionData) == 0x000008, "Wrong alignment on UP2NpcHitReactionData");
static_assert(sizeof(UP2NpcHitReactionData) == 0x000048, "Wrong size on UP2NpcHitReactionData");
static_assert(offsetof(UP2NpcHitReactionData, Reactions) == 0x000038, "Member 'UP2NpcHitReactionData::Reactions' has a wrong offset!");

// Class AICommon.P2NpcMovementComponent
// 0x01C0 (0x1540 - 0x1380)
class UP2NpcMovementComponent final : public UP2CharacterMovementComponent
{
public:
	class UP2MovementData*                        MovementData;                                      // 0x1378(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TMap<struct FGameplayTag, class UP2MovementData*> MovementModeDataOverrides;                     // 0x1380(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, UObjectWrapper, NativeAccessSpecifierProtected)
	float                                         NavMeshHorizontalClampingRadius;                   // 0x13D0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         NavMeshVerticalClampingRadius;                     // 0x13D4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bUseRemoteUpdateRateOptimizations;                 // 0x13D8(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_13D9[0x7];                                     // 0x13D9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<int32, int32>                            RemoteLodToSkippedFramesMap;                       // 0x13E0(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	int32                                         RemoteNonRenderedSkippedFrames;                    // 0x1430(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1434[0x4];                                     // 0x1434(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UP2MovementConfig*                      CurrentConfig;                                     // 0x1438(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FVector                                PrevLocation;                                      // 0x1440(0x0018)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FRotator                               PrevRotation;                                      // 0x1458(0x0018)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, NativeAccessSpecifierPrivate)
	struct FVector                                PrevNavigableLocation;                             // 0x1470(0x0018)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UMoveInputTranslationDataAsset*         MoveInputTranslationDataAssetRef;                  // 0x1488(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_1490[0xB0];                                    // 0x1490(0x00B0)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"P2NpcMovementComponent">();
	}
	static class UP2NpcMovementComponent* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UP2NpcMovementComponent>();
	}
};
static_assert(alignof(UP2NpcMovementComponent) == 0x000010, "Wrong alignment on UP2NpcMovementComponent");
static_assert(sizeof(UP2NpcMovementComponent) == 0x001540, "Wrong size on UP2NpcMovementComponent");
static_assert(offsetof(UP2NpcMovementComponent, MovementData) == 0x001378, "Member 'UP2NpcMovementComponent::MovementData' has a wrong offset!");
static_assert(offsetof(UP2NpcMovementComponent, MovementModeDataOverrides) == 0x001380, "Member 'UP2NpcMovementComponent::MovementModeDataOverrides' has a wrong offset!");
static_assert(offsetof(UP2NpcMovementComponent, NavMeshHorizontalClampingRadius) == 0x0013D0, "Member 'UP2NpcMovementComponent::NavMeshHorizontalClampingRadius' has a wrong offset!");
static_assert(offsetof(UP2NpcMovementComponent, NavMeshVerticalClampingRadius) == 0x0013D4, "Member 'UP2NpcMovementComponent::NavMeshVerticalClampingRadius' has a wrong offset!");
static_assert(offsetof(UP2NpcMovementComponent, bUseRemoteUpdateRateOptimizations) == 0x0013D8, "Member 'UP2NpcMovementComponent::bUseRemoteUpdateRateOptimizations' has a wrong offset!");
static_assert(offsetof(UP2NpcMovementComponent, RemoteLodToSkippedFramesMap) == 0x0013E0, "Member 'UP2NpcMovementComponent::RemoteLodToSkippedFramesMap' has a wrong offset!");
static_assert(offsetof(UP2NpcMovementComponent, RemoteNonRenderedSkippedFrames) == 0x001430, "Member 'UP2NpcMovementComponent::RemoteNonRenderedSkippedFrames' has a wrong offset!");
static_assert(offsetof(UP2NpcMovementComponent, CurrentConfig) == 0x001438, "Member 'UP2NpcMovementComponent::CurrentConfig' has a wrong offset!");
static_assert(offsetof(UP2NpcMovementComponent, PrevLocation) == 0x001440, "Member 'UP2NpcMovementComponent::PrevLocation' has a wrong offset!");
static_assert(offsetof(UP2NpcMovementComponent, PrevRotation) == 0x001458, "Member 'UP2NpcMovementComponent::PrevRotation' has a wrong offset!");
static_assert(offsetof(UP2NpcMovementComponent, PrevNavigableLocation) == 0x001470, "Member 'UP2NpcMovementComponent::PrevNavigableLocation' has a wrong offset!");
static_assert(offsetof(UP2NpcMovementComponent, MoveInputTranslationDataAssetRef) == 0x001488, "Member 'UP2NpcMovementComponent::MoveInputTranslationDataAssetRef' has a wrong offset!");

// Class AICommon.P2MovementConfig
// 0x0030 (0x0058 - 0x0028)
class UP2MovementConfig final : public UObject
{
public:
	float                                         MaxSpeed;                                          // 0x0028(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bOverrideAcceleration;                             // 0x002C(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2D[0x3];                                       // 0x002D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MaxAcceleration;                                   // 0x0030(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bOverrideBrakingDeceleration;                      // 0x0034(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_35[0x3];                                       // 0x0035(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MaxBrakingDeceleration;                            // 0x0038(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bOverrideYawRate;                                  // 0x003C(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3D[0x3];                                       // 0x003D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         YawRate;                                           // 0x0040(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bOverrideAcceleration3D;                           // 0x0044(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_45[0x3];                                       // 0x0045(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ForwardAcceleration3D;                             // 0x0048(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SidewaysAcceleration3D;                            // 0x004C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BackwardAcceleration3D;                            // 0x0050(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_54[0x4];                                       // 0x0054(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"P2MovementConfig">();
	}
	static class UP2MovementConfig* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UP2MovementConfig>();
	}
};
static_assert(alignof(UP2MovementConfig) == 0x000008, "Wrong alignment on UP2MovementConfig");
static_assert(sizeof(UP2MovementConfig) == 0x000058, "Wrong size on UP2MovementConfig");
static_assert(offsetof(UP2MovementConfig, MaxSpeed) == 0x000028, "Member 'UP2MovementConfig::MaxSpeed' has a wrong offset!");
static_assert(offsetof(UP2MovementConfig, bOverrideAcceleration) == 0x00002C, "Member 'UP2MovementConfig::bOverrideAcceleration' has a wrong offset!");
static_assert(offsetof(UP2MovementConfig, MaxAcceleration) == 0x000030, "Member 'UP2MovementConfig::MaxAcceleration' has a wrong offset!");
static_assert(offsetof(UP2MovementConfig, bOverrideBrakingDeceleration) == 0x000034, "Member 'UP2MovementConfig::bOverrideBrakingDeceleration' has a wrong offset!");
static_assert(offsetof(UP2MovementConfig, MaxBrakingDeceleration) == 0x000038, "Member 'UP2MovementConfig::MaxBrakingDeceleration' has a wrong offset!");
static_assert(offsetof(UP2MovementConfig, bOverrideYawRate) == 0x00003C, "Member 'UP2MovementConfig::bOverrideYawRate' has a wrong offset!");
static_assert(offsetof(UP2MovementConfig, YawRate) == 0x000040, "Member 'UP2MovementConfig::YawRate' has a wrong offset!");
static_assert(offsetof(UP2MovementConfig, bOverrideAcceleration3D) == 0x000044, "Member 'UP2MovementConfig::bOverrideAcceleration3D' has a wrong offset!");
static_assert(offsetof(UP2MovementConfig, ForwardAcceleration3D) == 0x000048, "Member 'UP2MovementConfig::ForwardAcceleration3D' has a wrong offset!");
static_assert(offsetof(UP2MovementConfig, SidewaysAcceleration3D) == 0x00004C, "Member 'UP2MovementConfig::SidewaysAcceleration3D' has a wrong offset!");
static_assert(offsetof(UP2MovementConfig, BackwardAcceleration3D) == 0x000050, "Member 'UP2MovementConfig::BackwardAcceleration3D' has a wrong offset!");

// Class AICommon.P2MovementData
// 0x0058 (0x0088 - 0x0030)
class UP2MovementData final : public UDataAsset
{
public:
	TMap<struct FGameplayTag, class UP2MovementConfig*> MovementConfigMap;                           // 0x0030(0x0050)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, DisableEditOnInstance, ContainsInstancedReference, UObjectWrapper, NativeAccessSpecifierPublic)
	class UCurveFloat*                            AccelerationCurve;                                 // 0x0080(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"P2MovementData">();
	}
	static class UP2MovementData* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UP2MovementData>();
	}
};
static_assert(alignof(UP2MovementData) == 0x000008, "Wrong alignment on UP2MovementData");
static_assert(sizeof(UP2MovementData) == 0x000088, "Wrong size on UP2MovementData");
static_assert(offsetof(UP2MovementData, MovementConfigMap) == 0x000030, "Member 'UP2MovementData::MovementConfigMap' has a wrong offset!");
static_assert(offsetof(UP2MovementData, AccelerationCurve) == 0x000080, "Member 'UP2MovementData::AccelerationCurve' has a wrong offset!");

// Class AICommon.P2NPCNoiseSourceComponent
// 0x0000 (0x00C8 - 0x00C8)
class UP2NPCNoiseSourceComponent : public UP2PawnComponent
{
public:
	void HandleReceivedDamage(const struct FP2DamageData& DamageData)	 // 0x1691fd8;

	void MakeAttackNoise(class AP2HeroCharacter* AttackTarget, float Loudness) const	 // 0x476bbb8;

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"P2NPCNoiseSourceComponent">();
	}
	static class UP2NPCNoiseSourceComponent* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UP2NPCNoiseSourceComponent>();
	}
};
static_assert(alignof(UP2NPCNoiseSourceComponent) == 0x000008, "Wrong alignment on UP2NPCNoiseSourceComponent");
static_assert(sizeof(UP2NPCNoiseSourceComponent) == 0x0000C8, "Wrong size on UP2NPCNoiseSourceComponent");

// Class AICommon.P2NpcSpawningCheatExtension
// 0x0050 (0x00C8 - 0x0078)
class UP2NpcSpawningCheatExtension final : public UP2CheatManagerExtension
{
public:
	TSubclassOf<class UP2NpcSpawningDebugWidget>  ToolWidgetClass;                                   // 0x0078(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_80[0x48];                                      // 0x0080(0x0048)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ClientReceiveDebugData(const struct FNPCSpawningCheatDebugData& InDebugData)	 // 0xcab7c4;
	void ClientReceiveToolWidgetData(const struct FP2RepNpcSpawningToolWidgetData& InRepWidgetData)	 // 0x4769fe8;
	void RequestDebugData()	 // 0x1769068;
	void ServerOnFinishSpawning(int32 InSeed, const TArray<struct FP2NpcSpawningCell>& InCells, const TArray<struct FP2NpcSpawningGeneratedPoint>& InPoints, const TArray<struct FP2NpcSpawningSpawnedCreature>& InTextureCreatures, const TArray<struct FP2NpcSpawningSpawnedCreature>& InVolumeCreatures, float InTimeSpent)	 // 0x476c044;
	void ServerSpawningRegen(bool bInInitializeSeed, int32 InCustomSeed)	 // 0x476c418;
	void ServerSpawningReset(bool bInResetFlags)	 // 0x476c56c;
	void ServerSpawningSetDebugDrawEnabled(bool bInEnable)	 // 0x476c634;
	void ServerSpawningToggleToolWidget(bool bInEnable)	 // 0x476c6fc;
	void ServerSpawningTriggerAndUnqueWave(int32 InWaveIndex)	 // 0x476c7c4;

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"P2NpcSpawningCheatExtension">();
	}
	static class UP2NpcSpawningCheatExtension* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UP2NpcSpawningCheatExtension>();
	}
};
static_assert(alignof(UP2NpcSpawningCheatExtension) == 0x000008, "Wrong alignment on UP2NpcSpawningCheatExtension");
static_assert(sizeof(UP2NpcSpawningCheatExtension) == 0x0000C8, "Wrong size on UP2NpcSpawningCheatExtension");
static_assert(offsetof(UP2NpcSpawningCheatExtension, ToolWidgetClass) == 0x000078, "Member 'UP2NpcSpawningCheatExtension::ToolWidgetClass' has a wrong offset!");

// Class AICommon.P2NpcSpawningFunctionLibrary
// 0x0000 (0x0028 - 0x0028)
class UP2NpcSpawningFunctionLibrary final : public UBlueprintFunctionLibrary
{
public:
	static void BuildDynamicLayerData(const struct FP2NpcSpawningLayerData& InLayerData, const struct FRandomStream& InRandomStream, struct FP2NpcSpawningGrid& OutGrid)	 // 0x4769d6c;
	static void BuildLayerData(const struct FP2NpcSpawningLayerData& InLayerData, struct FP2NpcSpawningGrid& OutGrid)	 // 0x4769ee8;
	static class AP2NpcSpawningLevelConfig* FindSpawningLevelConfigActor(class UObject* InWorldContextObject)	 // 0x476a0e4;
	static class UTexture2D* GenerateTexture(int32 InSizeX, int32 InSizeY, const TArray<struct FColor>& InSurfaceData)	 // 0x476a1a4;
	static class UP2AIDirectorTask_Spawning* GetAIDirectorTaskSpawning(class UObject* InWorldContextObject)	 // 0x476a328;
	static bool GetCellAtTextureCoordinate(const struct FIntPoint& InTextureCoordinate, const struct FP2NpcSpawningGrid& InGrid, struct FP2NpcSpawningCell* OutCell)	 // 0x476a490;
	static bool GetCellAtWorldCoordinate(const struct FVector& InWorldLocation, const struct FVector2D& InWorldSize, const struct FP2NpcSpawningGrid& InGrid, struct FP2NpcSpawningCell* OutCell)	 // 0x476a630;
	static bool GetDensityAtTextureCoordinate(const struct FIntPoint& InTextureCoordinate, const struct FP2NpcSpawningGrid& InGrid, float* OutDensity)	 // 0x476a87c;
	static bool GetDensityAtWorldCoordinate(const struct FVector& InWorldLocation, const struct FVector2D& InWorldSize, const struct FP2NpcSpawningGrid& InGrid, float* OutDensity)	 // 0x476aa68;
	static bool GetDistributionAtTextureCoordinate(const struct FIntPoint& InTextureCoordinate, const struct FP2NpcSpawningGrid& InGrid, TMap<struct FGameplayTag, struct FColor>* OutDistribution)	 // 0x476ace8;
	static bool GetDistributionAtWorldCoordinate(const struct FVector& InWorldLocation, const struct FVector2D& InWorldSize, const struct FP2NpcSpawningGrid& InGrid, TMap<struct FGameplayTag, struct FColor>* OutDistribution)	 // 0x476aebc;
	static int32 GetRandomStreamInitialSeed(const struct FRandomStream& InRandomStream)	 // 0x437afd4;
	static bool GetSelectedDistributionAtTextureCoordinate(const struct FIntPoint& InTextureCoordinate, const struct FP2NpcSpawningGrid& InGrid, struct FGameplayTag* OutSelectedDistribution)	 // 0x476b2a8;
	static bool GetSelectedDistributionAtWorldCoordinate(const struct FVector& InWorldLocation, const struct FVector2D& InWorldSize, const struct FP2NpcSpawningGrid& InGrid, struct FGameplayTag* OutSelectedDistribution)	 // 0x476b494;
	static bool GetZoneAtTextureCoordinate(const struct FIntPoint& InTextureCoordinate, const struct FP2NpcSpawningGrid& InGrid, struct FGameplayTag* OutZone)	 // 0x476b714;
	static bool GetZoneAtWorldCoordinate(const struct FVector& InWorldLocation, const struct FVector2D& InWorldSize, const struct FP2NpcSpawningGrid& InGrid, struct FGameplayTag* OutZone)	 // 0x476b900;

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"P2NpcSpawningFunctionLibrary">();
	}
	static class UP2NpcSpawningFunctionLibrary* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UP2NpcSpawningFunctionLibrary>();
	}
};
static_assert(alignof(UP2NpcSpawningFunctionLibrary) == 0x000008, "Wrong alignment on UP2NpcSpawningFunctionLibrary");
static_assert(sizeof(UP2NpcSpawningFunctionLibrary) == 0x000028, "Wrong size on UP2NpcSpawningFunctionLibrary");

// Class AICommon.P2NpcSpawningLevelConfig
// 0x0028 (0x02D8 - 0x02B0)
class AP2NpcSpawningLevelConfig final : public AActor
{
public:
	class UP2NpcSpawningLayerDataAsset*           LayerDataAsset;                                    // 0x02B0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bSpawningEnabled : 1;                              // 0x02B8(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bDrawDebug : 1;                                    // 0x02B8(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_2B9[0x7];                                      // 0x02B9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	double                                        PlayerMinRelevancyDistance;                        // 0x02C0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	double                                        PlayerMaxRelevancyDistance;                        // 0x02C8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	double                                        PlayerMinDotDirection;                             // 0x02D0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	void UpdateCells(const int32 InSeed)	 // 0x4770cbc;

	bool GetCellAtTextureCoordinate(class UObject* InWorldContextObject, const struct FIntPoint& InTextureCoordinate, struct FP2NpcSpawningCell* OutCell) const	 // 0x4770450;

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"P2NpcSpawningLevelConfig">();
	}
	static class AP2NpcSpawningLevelConfig* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<AP2NpcSpawningLevelConfig>();
	}
};
static_assert(alignof(AP2NpcSpawningLevelConfig) == 0x000008, "Wrong alignment on AP2NpcSpawningLevelConfig");
static_assert(sizeof(AP2NpcSpawningLevelConfig) == 0x0002D8, "Wrong size on AP2NpcSpawningLevelConfig");
static_assert(offsetof(AP2NpcSpawningLevelConfig, LayerDataAsset) == 0x0002B0, "Member 'AP2NpcSpawningLevelConfig::LayerDataAsset' has a wrong offset!");
static_assert(offsetof(AP2NpcSpawningLevelConfig, PlayerMinRelevancyDistance) == 0x0002C0, "Member 'AP2NpcSpawningLevelConfig::PlayerMinRelevancyDistance' has a wrong offset!");
static_assert(offsetof(AP2NpcSpawningLevelConfig, PlayerMaxRelevancyDistance) == 0x0002C8, "Member 'AP2NpcSpawningLevelConfig::PlayerMaxRelevancyDistance' has a wrong offset!");
static_assert(offsetof(AP2NpcSpawningLevelConfig, PlayerMinDotDirection) == 0x0002D0, "Member 'AP2NpcSpawningLevelConfig::PlayerMinDotDirection' has a wrong offset!");

// Class AICommon.P2NpcSpawningVolumeData
// 0x0010 (0x0040 - 0x0030)
class UP2NpcSpawningVolumeData final : public UPrimaryDataAsset
{
public:
	struct FP2NpcSpawningVolumeSettings           Settings;                                          // 0x0030(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"P2NpcSpawningVolumeData">();
	}
	static class UP2NpcSpawningVolumeData* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UP2NpcSpawningVolumeData>();
	}
};
static_assert(alignof(UP2NpcSpawningVolumeData) == 0x000008, "Wrong alignment on UP2NpcSpawningVolumeData");
static_assert(sizeof(UP2NpcSpawningVolumeData) == 0x000040, "Wrong size on UP2NpcSpawningVolumeData");
static_assert(offsetof(UP2NpcSpawningVolumeData, Settings) == 0x000030, "Member 'UP2NpcSpawningVolumeData::Settings' has a wrong offset!");

// Class AICommon.P2NpcSpawningVolume
// 0x0020 (0x0310 - 0x02F0)
class AP2NpcSpawningVolume final : public AP2NpcSpawningVolumeBase
{
public:
	class UP2NpcSpawningVolumeData*               Data;                                              // 0x02F0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FP2NpcSpawningVolumeSettings           Settings;                                          // 0x02F8(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, Protected, NativeAccessSpecifierProtected)
	int32                                         Priority;                                          // 0x0308(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bRequireLandscape;                                 // 0x030C(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_30D[0x3];                                      // 0x030D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"P2NpcSpawningVolume">();
	}
	static class AP2NpcSpawningVolume* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<AP2NpcSpawningVolume>();
	}
};
static_assert(alignof(AP2NpcSpawningVolume) == 0x000008, "Wrong alignment on AP2NpcSpawningVolume");
static_assert(sizeof(AP2NpcSpawningVolume) == 0x000310, "Wrong size on AP2NpcSpawningVolume");
static_assert(offsetof(AP2NpcSpawningVolume, Data) == 0x0002F0, "Member 'AP2NpcSpawningVolume::Data' has a wrong offset!");
static_assert(offsetof(AP2NpcSpawningVolume, Settings) == 0x0002F8, "Member 'AP2NpcSpawningVolume::Settings' has a wrong offset!");
static_assert(offsetof(AP2NpcSpawningVolume, Priority) == 0x000308, "Member 'AP2NpcSpawningVolume::Priority' has a wrong offset!");
static_assert(offsetof(AP2NpcSpawningVolume, bRequireLandscape) == 0x00030C, "Member 'AP2NpcSpawningVolume::bRequireLandscape' has a wrong offset!");

// Class AICommon.P2NpcStaggerComponent
// 0x0018 (0x00E0 - 0x00C8)
class UP2NpcStaggerComponent final : public UP2PawnComponent
{
public:
	class UP2BattleTrackingComponent*             TrackingComponent;                                 // 0x00C8(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_D0[0x10];                                      // 0x00D0(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void HandleDamage(const struct FP2DamageData& ChangeData)	 // 0x477061c;

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"P2NpcStaggerComponent">();
	}
	static class UP2NpcStaggerComponent* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UP2NpcStaggerComponent>();
	}
};
static_assert(alignof(UP2NpcStaggerComponent) == 0x000008, "Wrong alignment on UP2NpcStaggerComponent");
static_assert(sizeof(UP2NpcStaggerComponent) == 0x0000E0, "Wrong size on UP2NpcStaggerComponent");
static_assert(offsetof(UP2NpcStaggerComponent, TrackingComponent) == 0x0000C8, "Member 'UP2NpcStaggerComponent::TrackingComponent' has a wrong offset!");

// Class AICommon.P2NpcSuppressionSourceComponent
// 0x0068 (0x0130 - 0x00C8)
class UP2NpcSuppressionSourceComponent final : public UP2PawnComponent
{
public:
	float                                         MaxAge;                                            // 0x00C8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_CC[0x64];                                      // 0x00CC(0x0064)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ServerReportBulletPassEvent(class AActor* Target, const struct FVector& EventLocation, const struct FVector& ReceiverLocation)	 // 0x4770750;

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"P2NpcSuppressionSourceComponent">();
	}
	static class UP2NpcSuppressionSourceComponent* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UP2NpcSuppressionSourceComponent>();
	}
};
static_assert(alignof(UP2NpcSuppressionSourceComponent) == 0x000008, "Wrong alignment on UP2NpcSuppressionSourceComponent");
static_assert(sizeof(UP2NpcSuppressionSourceComponent) == 0x000130, "Wrong size on UP2NpcSuppressionSourceComponent");
static_assert(offsetof(UP2NpcSuppressionSourceComponent, MaxAge) == 0x0000C8, "Member 'UP2NpcSuppressionSourceComponent::MaxAge' has a wrong offset!");

// Class AICommon.P2NpcSuppressionTargetComponent
// 0x0000 (0x05D0 - 0x05D0)
class UP2NpcSuppressionTargetComponent final : public USphereComponent
{
public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"P2NpcSuppressionTargetComponent">();
	}
	static class UP2NpcSuppressionTargetComponent* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UP2NpcSuppressionTargetComponent>();
	}
};
static_assert(alignof(UP2NpcSuppressionTargetComponent) == 0x000010, "Wrong alignment on UP2NpcSuppressionTargetComponent");
static_assert(sizeof(UP2NpcSuppressionTargetComponent) == 0x0005D0, "Wrong size on UP2NpcSuppressionTargetComponent");

// Class AICommon.P2NpcSwimmingComponent
// 0x0020 (0x00E0 - 0x00C0)
class UP2NpcSwimmingComponent final : public UPawnComponent
{
public:
	float                                         AboveWaterFraction;                                // 0x00C0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         SwimmingStepHeightOverride;                        // 0x00C4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         SwimmingStartDepth;                                // 0x00C8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         SwimmingEndDepth;                                  // 0x00CC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UP2MercunaGroundNavigationComponent*    NavComponentCache;                                 // 0x00D0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_D8[0x8];                                       // 0x00D8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void MercunaSwimmingStarted()	 // 0x477070c;
	void MercunaSwimmingStopped()	 // 0x4770724;

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"P2NpcSwimmingComponent">();
	}
	static class UP2NpcSwimmingComponent* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UP2NpcSwimmingComponent>();
	}
};
static_assert(alignof(UP2NpcSwimmingComponent) == 0x000008, "Wrong alignment on UP2NpcSwimmingComponent");
static_assert(sizeof(UP2NpcSwimmingComponent) == 0x0000E0, "Wrong size on UP2NpcSwimmingComponent");
static_assert(offsetof(UP2NpcSwimmingComponent, AboveWaterFraction) == 0x0000C0, "Member 'UP2NpcSwimmingComponent::AboveWaterFraction' has a wrong offset!");
static_assert(offsetof(UP2NpcSwimmingComponent, SwimmingStepHeightOverride) == 0x0000C4, "Member 'UP2NpcSwimmingComponent::SwimmingStepHeightOverride' has a wrong offset!");
static_assert(offsetof(UP2NpcSwimmingComponent, SwimmingStartDepth) == 0x0000C8, "Member 'UP2NpcSwimmingComponent::SwimmingStartDepth' has a wrong offset!");
static_assert(offsetof(UP2NpcSwimmingComponent, SwimmingEndDepth) == 0x0000CC, "Member 'UP2NpcSwimmingComponent::SwimmingEndDepth' has a wrong offset!");
static_assert(offsetof(UP2NpcSwimmingComponent, NavComponentCache) == 0x0000D0, "Member 'UP2NpcSwimmingComponent::NavComponentCache' has a wrong offset!");

// Class AICommon.P2NpcTestScenarioCheatExtension
// 0x0058 (0x00D0 - 0x0078)
class UP2NpcTestScenarioCheatExtension final : public UP2CheatManagerExtension
{
public:
	TWeakObjectPtr<class AP2NPCharacter>          SelectedNPC;                                       // 0x0078(0x0008)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class UP2NpcTestScenario*>             AvailableScenarios;                                // 0x0080(0x0010)(Net, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	class UP2NpcTestScenario*                     SelectedScenario;                                  // 0x0090(0x0008)(Net, ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class UP2TestKeySelector*>             InstancedKeySelectors;                             // 0x0098(0x0010)(Net, ZeroConstructor, Protected, UObjectWrapper, NativeAccessSpecifierProtected)
	uint8                                         Pad_A8[0x8];                                       // 0x00A8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<TWeakObjectPtr<class AP2NPCharacter>>  CachedNPCsSortedByDistance;                        // 0x00B0(0x0010)(Net, ZeroConstructor, Protected, UObjectWrapper, NativeAccessSpecifierProtected)
	bool                                          bIsScenarioRunning;                                // 0x00C0(0x0001)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_C1[0x7];                                       // 0x00C1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UP2NpcTestScenarioImGui*                GUIManager;                                        // 0x00C8(0x0008)(ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void ServerExecuteScenario()	 // 0x4770738;
	void ServerResetNPCBehavior()	 // 0x4770914;
	void ServerSelectKeySelectorClass(int32 KeyIndex, TSubclassOf<class UP2TestKeySelector> SelectorClass)	 // 0x477092c;
	void ServerSelectNPC(class AP2NPCharacter* InNPC)	 // 0x4770a70;
	void ServerSelectScenario(class UP2NpcTestScenario* TestScenario)	 // 0x4770b34;
	void ServerSendGameplayEventToNPC(const struct FGameplayTag& EventTag)	 // 0x4770bf8;

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"P2NpcTestScenarioCheatExtension">();
	}
	static class UP2NpcTestScenarioCheatExtension* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UP2NpcTestScenarioCheatExtension>();
	}
};
static_assert(alignof(UP2NpcTestScenarioCheatExtension) == 0x000008, "Wrong alignment on UP2NpcTestScenarioCheatExtension");
static_assert(sizeof(UP2NpcTestScenarioCheatExtension) == 0x0000D0, "Wrong size on UP2NpcTestScenarioCheatExtension");
static_assert(offsetof(UP2NpcTestScenarioCheatExtension, SelectedNPC) == 0x000078, "Member 'UP2NpcTestScenarioCheatExtension::SelectedNPC' has a wrong offset!");
static_assert(offsetof(UP2NpcTestScenarioCheatExtension, AvailableScenarios) == 0x000080, "Member 'UP2NpcTestScenarioCheatExtension::AvailableScenarios' has a wrong offset!");
static_assert(offsetof(UP2NpcTestScenarioCheatExtension, SelectedScenario) == 0x000090, "Member 'UP2NpcTestScenarioCheatExtension::SelectedScenario' has a wrong offset!");
static_assert(offsetof(UP2NpcTestScenarioCheatExtension, InstancedKeySelectors) == 0x000098, "Member 'UP2NpcTestScenarioCheatExtension::InstancedKeySelectors' has a wrong offset!");
static_assert(offsetof(UP2NpcTestScenarioCheatExtension, CachedNPCsSortedByDistance) == 0x0000B0, "Member 'UP2NpcTestScenarioCheatExtension::CachedNPCsSortedByDistance' has a wrong offset!");
static_assert(offsetof(UP2NpcTestScenarioCheatExtension, bIsScenarioRunning) == 0x0000C0, "Member 'UP2NpcTestScenarioCheatExtension::bIsScenarioRunning' has a wrong offset!");
static_assert(offsetof(UP2NpcTestScenarioCheatExtension, GUIManager) == 0x0000C8, "Member 'UP2NpcTestScenarioCheatExtension::GUIManager' has a wrong offset!");

// Class AICommon.P2NpcThreatProjectionComponent
// 0x00A8 (0x0170 - 0x00C8)
class UP2NpcThreatProjectionComponent final : public UP2PawnComponent
{
public:
	float                                         TargetResetTimeout;                                // 0x00C8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxPathLength;                                     // 0x00CC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HorizontalSearchRange;                             // 0x00D0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         VerticalSearchRange;                               // 0x00D4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SearchHeightOffset;                                // 0x00D8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCheckLineTrace;                                   // 0x00DC(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_DD[0x3];                                       // 0x00DD(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ProjectedLocationTraceHeightOffset;                // 0x00E0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TargetTraceHeightOffset;                           // 0x00E4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECollisionChannel                             TraceChannel;                                      // 0x00E8(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_E9[0x3];                                       // 0x00E9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         NumSecondaryPoints;                                // 0x00EC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_F0[0x80];                                      // 0x00F0(0x0080)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"P2NpcThreatProjectionComponent">();
	}
	static class UP2NpcThreatProjectionComponent* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UP2NpcThreatProjectionComponent>();
	}
};
static_assert(alignof(UP2NpcThreatProjectionComponent) == 0x000008, "Wrong alignment on UP2NpcThreatProjectionComponent");
static_assert(sizeof(UP2NpcThreatProjectionComponent) == 0x000170, "Wrong size on UP2NpcThreatProjectionComponent");
static_assert(offsetof(UP2NpcThreatProjectionComponent, TargetResetTimeout) == 0x0000C8, "Member 'UP2NpcThreatProjectionComponent::TargetResetTimeout' has a wrong offset!");
static_assert(offsetof(UP2NpcThreatProjectionComponent, MaxPathLength) == 0x0000CC, "Member 'UP2NpcThreatProjectionComponent::MaxPathLength' has a wrong offset!");
static_assert(offsetof(UP2NpcThreatProjectionComponent, HorizontalSearchRange) == 0x0000D0, "Member 'UP2NpcThreatProjectionComponent::HorizontalSearchRange' has a wrong offset!");
static_assert(offsetof(UP2NpcThreatProjectionComponent, VerticalSearchRange) == 0x0000D4, "Member 'UP2NpcThreatProjectionComponent::VerticalSearchRange' has a wrong offset!");
static_assert(offsetof(UP2NpcThreatProjectionComponent, SearchHeightOffset) == 0x0000D8, "Member 'UP2NpcThreatProjectionComponent::SearchHeightOffset' has a wrong offset!");
static_assert(offsetof(UP2NpcThreatProjectionComponent, bCheckLineTrace) == 0x0000DC, "Member 'UP2NpcThreatProjectionComponent::bCheckLineTrace' has a wrong offset!");
static_assert(offsetof(UP2NpcThreatProjectionComponent, ProjectedLocationTraceHeightOffset) == 0x0000E0, "Member 'UP2NpcThreatProjectionComponent::ProjectedLocationTraceHeightOffset' has a wrong offset!");
static_assert(offsetof(UP2NpcThreatProjectionComponent, TargetTraceHeightOffset) == 0x0000E4, "Member 'UP2NpcThreatProjectionComponent::TargetTraceHeightOffset' has a wrong offset!");
static_assert(offsetof(UP2NpcThreatProjectionComponent, TraceChannel) == 0x0000E8, "Member 'UP2NpcThreatProjectionComponent::TraceChannel' has a wrong offset!");
static_assert(offsetof(UP2NpcThreatProjectionComponent, NumSecondaryPoints) == 0x0000EC, "Member 'UP2NpcThreatProjectionComponent::NumSecondaryPoints' has a wrong offset!");

// Class AICommon.P2PlayerBotAIController
// 0x0020 (0x0580 - 0x0560)
class AP2PlayerBotAIController final : public AP2GhostAIController
{
public:
	class FString                                 PlayerBotId;                                       // 0x0560(0x0010)(ZeroConstructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FString                                 PlayerBotNickname;                                 // 0x0570(0x0010)(ZeroConstructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"P2PlayerBotAIController">();
	}
	static class AP2PlayerBotAIController* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<AP2PlayerBotAIController>();
	}
};
static_assert(alignof(AP2PlayerBotAIController) == 0x000008, "Wrong alignment on AP2PlayerBotAIController");
static_assert(sizeof(AP2PlayerBotAIController) == 0x000580, "Wrong size on AP2PlayerBotAIController");
static_assert(offsetof(AP2PlayerBotAIController, PlayerBotId) == 0x000560, "Member 'AP2PlayerBotAIController::PlayerBotId' has a wrong offset!");
static_assert(offsetof(AP2PlayerBotAIController, PlayerBotNickname) == 0x000570, "Member 'AP2PlayerBotAIController::PlayerBotNickname' has a wrong offset!");

// Class AICommon.P2PlayerBotGroupAIController
// 0x0048 (0x05E0 - 0x0598)
class AP2PlayerBotGroupAIController final : public AP2GhostGroupAIController
{
public:
	uint8                                         Pad_598[0x10];                                     // 0x0598(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         EngageDistance;                                    // 0x05A8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RetreatDistance;                                   // 0x05AC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ReconDistance;                                     // 0x05B0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RenewTimeHasAttackedByPlayer;                      // 0x05B4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 PlayerBotTeamId;                                   // 0x05B8(0x0010)(ZeroConstructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_5C8[0x18];                                     // 0x05C8(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	bool IsWayPointPassed(const int32& InCurrentWayPointIndex)	 // 0x47730c8;

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"P2PlayerBotGroupAIController">();
	}
	static class AP2PlayerBotGroupAIController* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<AP2PlayerBotGroupAIController>();
	}
};
static_assert(alignof(AP2PlayerBotGroupAIController) == 0x000008, "Wrong alignment on AP2PlayerBotGroupAIController");
static_assert(sizeof(AP2PlayerBotGroupAIController) == 0x0005E0, "Wrong size on AP2PlayerBotGroupAIController");
static_assert(offsetof(AP2PlayerBotGroupAIController, EngageDistance) == 0x0005A8, "Member 'AP2PlayerBotGroupAIController::EngageDistance' has a wrong offset!");
static_assert(offsetof(AP2PlayerBotGroupAIController, RetreatDistance) == 0x0005AC, "Member 'AP2PlayerBotGroupAIController::RetreatDistance' has a wrong offset!");
static_assert(offsetof(AP2PlayerBotGroupAIController, ReconDistance) == 0x0005B0, "Member 'AP2PlayerBotGroupAIController::ReconDistance' has a wrong offset!");
static_assert(offsetof(AP2PlayerBotGroupAIController, RenewTimeHasAttackedByPlayer) == 0x0005B4, "Member 'AP2PlayerBotGroupAIController::RenewTimeHasAttackedByPlayer' has a wrong offset!");
static_assert(offsetof(AP2PlayerBotGroupAIController, PlayerBotTeamId) == 0x0005B8, "Member 'AP2PlayerBotGroupAIController::PlayerBotTeamId' has a wrong offset!");

// Class AICommon.P2PlayerBotRaidSpawnManager
// 0x0050 (0x0300 - 0x02B0)
class AP2PlayerBotRaidSpawnManager final : public AActor
{
public:
	uint8                                         Pad_2B0[0x50];                                     // 0x02B0(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"P2PlayerBotRaidSpawnManager">();
	}
	static class AP2PlayerBotRaidSpawnManager* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<AP2PlayerBotRaidSpawnManager>();
	}
};
static_assert(alignof(AP2PlayerBotRaidSpawnManager) == 0x000008, "Wrong alignment on AP2PlayerBotRaidSpawnManager");
static_assert(sizeof(AP2PlayerBotRaidSpawnManager) == 0x000300, "Wrong size on AP2PlayerBotRaidSpawnManager");

// Class AICommon.P2PlayerNavLinkGenerationComponent
// 0x0060 (0x0128 - 0x00C8)
class UP2PlayerNavLinkGenerationComponent : public UP2PawnComponent
{
public:
	uint8                                         Pad_C8[0x60];                                      // 0x00C8(0x0060)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnMovementModeChanged(class ACharacter* Character, EMovementMode PrevMovementMode, uint8 PreviousCustomMode)	 // 0x1155fb8;

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"P2PlayerNavLinkGenerationComponent">();
	}
	static class UP2PlayerNavLinkGenerationComponent* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UP2PlayerNavLinkGenerationComponent>();
	}
};
static_assert(alignof(UP2PlayerNavLinkGenerationComponent) == 0x000008, "Wrong alignment on UP2PlayerNavLinkGenerationComponent");
static_assert(sizeof(UP2PlayerNavLinkGenerationComponent) == 0x000128, "Wrong size on UP2PlayerNavLinkGenerationComponent");

// Class AICommon.P2PvPStateComponent
// 0x0060 (0x0120 - 0x00C0)
class UP2PvPStateComponent : public UActorComponent
{
public:
	float                                         MaxTensionValue;                                   // 0x00C0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_C4[0x4];                                       // 0x00C4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FP2ScalableFloat                       TensionFromDistance;                               // 0x00C8(0x0030)(Edit, Protected, NativeAccessSpecifierProtected)
	float                                         MaxDistanceForTension;                             // 0x00F8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         TensionDecayRate;                                  // 0x00FC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         TensionDecayCooldownOnHit;                         // 0x0100(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         TeammateTensionSharingDistance;                    // 0x0104(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_108[0x10];                                     // 0x0108(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class UP2HealthComponent*                     OwnerHealthComponent;                              // 0x0118(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void OnDamageReceived(class UP2HealthComponent* HealthComponent, class AActor* Instigator, float Damage)	 // 0x16b8b08;

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"P2PvPStateComponent">();
	}
	static class UP2PvPStateComponent* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UP2PvPStateComponent>();
	}
};
static_assert(alignof(UP2PvPStateComponent) == 0x000008, "Wrong alignment on UP2PvPStateComponent");
static_assert(sizeof(UP2PvPStateComponent) == 0x000120, "Wrong size on UP2PvPStateComponent");
static_assert(offsetof(UP2PvPStateComponent, MaxTensionValue) == 0x0000C0, "Member 'UP2PvPStateComponent::MaxTensionValue' has a wrong offset!");
static_assert(offsetof(UP2PvPStateComponent, TensionFromDistance) == 0x0000C8, "Member 'UP2PvPStateComponent::TensionFromDistance' has a wrong offset!");
static_assert(offsetof(UP2PvPStateComponent, MaxDistanceForTension) == 0x0000F8, "Member 'UP2PvPStateComponent::MaxDistanceForTension' has a wrong offset!");
static_assert(offsetof(UP2PvPStateComponent, TensionDecayRate) == 0x0000FC, "Member 'UP2PvPStateComponent::TensionDecayRate' has a wrong offset!");
static_assert(offsetof(UP2PvPStateComponent, TensionDecayCooldownOnHit) == 0x000100, "Member 'UP2PvPStateComponent::TensionDecayCooldownOnHit' has a wrong offset!");
static_assert(offsetof(UP2PvPStateComponent, TeammateTensionSharingDistance) == 0x000104, "Member 'UP2PvPStateComponent::TeammateTensionSharingDistance' has a wrong offset!");
static_assert(offsetof(UP2PvPStateComponent, OwnerHealthComponent) == 0x000118, "Member 'UP2PvPStateComponent::OwnerHealthComponent' has a wrong offset!");

// Class AICommon.P2RootMotionModiferWarpToTarget
// 0x0010 (0x0050 - 0x0040)
class UP2RootMotionModiferWarpToTarget final : public UP2RootMotionModifier
{
public:
	float                                         MaxSpeedPerSecond;                                 // 0x0040(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxRotationPerSecond;                              // 0x0044(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TargetOffset;                                      // 0x0048(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAlwaysFaceTarget;                                 // 0x004C(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EP2RootMotionWarpingType                      WarpingType;                                       // 0x004D(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EP2RootMotionTargetOffsetType                 TargetType;                                        // 0x004E(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4F[0x1];                                       // 0x004F(0x0001)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"P2RootMotionModiferWarpToTarget">();
	}
	static class UP2RootMotionModiferWarpToTarget* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UP2RootMotionModiferWarpToTarget>();
	}
};
static_assert(alignof(UP2RootMotionModiferWarpToTarget) == 0x000008, "Wrong alignment on UP2RootMotionModiferWarpToTarget");
static_assert(sizeof(UP2RootMotionModiferWarpToTarget) == 0x000050, "Wrong size on UP2RootMotionModiferWarpToTarget");
static_assert(offsetof(UP2RootMotionModiferWarpToTarget, MaxSpeedPerSecond) == 0x000040, "Member 'UP2RootMotionModiferWarpToTarget::MaxSpeedPerSecond' has a wrong offset!");
static_assert(offsetof(UP2RootMotionModiferWarpToTarget, MaxRotationPerSecond) == 0x000044, "Member 'UP2RootMotionModiferWarpToTarget::MaxRotationPerSecond' has a wrong offset!");
static_assert(offsetof(UP2RootMotionModiferWarpToTarget, TargetOffset) == 0x000048, "Member 'UP2RootMotionModiferWarpToTarget::TargetOffset' has a wrong offset!");
static_assert(offsetof(UP2RootMotionModiferWarpToTarget, bAlwaysFaceTarget) == 0x00004C, "Member 'UP2RootMotionModiferWarpToTarget::bAlwaysFaceTarget' has a wrong offset!");
static_assert(offsetof(UP2RootMotionModiferWarpToTarget, WarpingType) == 0x00004D, "Member 'UP2RootMotionModiferWarpToTarget::WarpingType' has a wrong offset!");
static_assert(offsetof(UP2RootMotionModiferWarpToTarget, TargetType) == 0x00004E, "Member 'UP2RootMotionModiferWarpToTarget::TargetType' has a wrong offset!");

// Class AICommon.P2RootMotionModifierComponent
// 0x0028 (0x00F0 - 0x00C8)
class UP2RootMotionModifierComponent final : public UP2PawnComponent
{
public:
	struct FP2RootMotionTargetData                TargetData;                                        // 0x00C8(0x0028)(Net, NoDestructor, Protected, NativeAccessSpecifierProtected)

public:
	void ClearTarget()	 // 0x4773094;
	void SetTarget(class AActor* NewTarget)	 // 0x4773744;
	void SetTargetLocation(const struct FVector& NewTarget)	 // 0x4773804;

	bool HasTarget() const	 // 0x47730ac;

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"P2RootMotionModifierComponent">();
	}
	static class UP2RootMotionModifierComponent* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UP2RootMotionModifierComponent>();
	}
};
static_assert(alignof(UP2RootMotionModifierComponent) == 0x000008, "Wrong alignment on UP2RootMotionModifierComponent");
static_assert(sizeof(UP2RootMotionModifierComponent) == 0x0000F0, "Wrong size on UP2RootMotionModifierComponent");
static_assert(offsetof(UP2RootMotionModifierComponent, TargetData) == 0x0000C8, "Member 'UP2RootMotionModifierComponent::TargetData' has a wrong offset!");

// Class AICommon.P2RootMotionModifierWarp
// 0x0010 (0x0100 - 0x00F0)
class UP2RootMotionModifierWarp final : public URootMotionModifier
{
public:
	class FName                                   WarpTargetName;                                    // 0x00E8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxSpeedPerSecond;                                 // 0x00F0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxRotationPerSecond;                              // 0x00F4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TargetOffset;                                      // 0x00F8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAlwaysFaceTarget;                                 // 0x00FC(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EP2RootMotionWarpingType                      WarpingType;                                       // 0x00FD(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EP2RootMotionTargetOffsetType                 TargetType;                                        // 0x00FE(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_FF[0x1];                                       // 0x00FF(0x0001)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"P2RootMotionModifierWarp">();
	}
	static class UP2RootMotionModifierWarp* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UP2RootMotionModifierWarp>();
	}
};
static_assert(alignof(UP2RootMotionModifierWarp) == 0x000010, "Wrong alignment on UP2RootMotionModifierWarp");
static_assert(sizeof(UP2RootMotionModifierWarp) == 0x000100, "Wrong size on UP2RootMotionModifierWarp");
static_assert(offsetof(UP2RootMotionModifierWarp, WarpTargetName) == 0x0000E8, "Member 'UP2RootMotionModifierWarp::WarpTargetName' has a wrong offset!");
static_assert(offsetof(UP2RootMotionModifierWarp, MaxSpeedPerSecond) == 0x0000F0, "Member 'UP2RootMotionModifierWarp::MaxSpeedPerSecond' has a wrong offset!");
static_assert(offsetof(UP2RootMotionModifierWarp, MaxRotationPerSecond) == 0x0000F4, "Member 'UP2RootMotionModifierWarp::MaxRotationPerSecond' has a wrong offset!");
static_assert(offsetof(UP2RootMotionModifierWarp, TargetOffset) == 0x0000F8, "Member 'UP2RootMotionModifierWarp::TargetOffset' has a wrong offset!");
static_assert(offsetof(UP2RootMotionModifierWarp, bAlwaysFaceTarget) == 0x0000FC, "Member 'UP2RootMotionModifierWarp::bAlwaysFaceTarget' has a wrong offset!");
static_assert(offsetof(UP2RootMotionModifierWarp, WarpingType) == 0x0000FD, "Member 'UP2RootMotionModifierWarp::WarpingType' has a wrong offset!");
static_assert(offsetof(UP2RootMotionModifierWarp, TargetType) == 0x0000FE, "Member 'UP2RootMotionModifierWarp::TargetType' has a wrong offset!");

// Class AICommon.P2SentryData
// 0x0000 (0x0538 - 0x0538)
class UP2SentryData final : public UP2DeployableData
{
public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"P2SentryData">();
	}
	static class UP2SentryData* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UP2SentryData>();
	}
};
static_assert(alignof(UP2SentryData) == 0x000008, "Wrong alignment on UP2SentryData");
static_assert(sizeof(UP2SentryData) == 0x000538, "Wrong size on UP2SentryData");

// Class AICommon.P2SentryProjectile
// 0x0020 (0x02D0 - 0x02B0)
class AP2SentryProjectile : public AActor
{
public:
	class USphereComponent*                       CollisionSphere;                                   // 0x02B0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UProjectileMovementComponent*           ProjectileMovement;                                // 0x02B8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UP2FireData*                            OnStopFireData;                                    // 0x02C0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         FireRadius;                                        // 0x02C8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2CC[0x4];                                      // 0x02CC(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnBeginOverlap(class AActor* OverlappedActor, class AActor* OtherActor)	 // 0x4776e10;
	void OnProjectileStop(const struct FHitResult& ImpactResult)	 // 0x47770f0;

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"P2SentryProjectile">();
	}
	static class AP2SentryProjectile* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<AP2SentryProjectile>();
	}
};
static_assert(alignof(AP2SentryProjectile) == 0x000008, "Wrong alignment on AP2SentryProjectile");
static_assert(sizeof(AP2SentryProjectile) == 0x0002D0, "Wrong size on AP2SentryProjectile");
static_assert(offsetof(AP2SentryProjectile, CollisionSphere) == 0x0002B0, "Member 'AP2SentryProjectile::CollisionSphere' has a wrong offset!");
static_assert(offsetof(AP2SentryProjectile, ProjectileMovement) == 0x0002B8, "Member 'AP2SentryProjectile::ProjectileMovement' has a wrong offset!");
static_assert(offsetof(AP2SentryProjectile, OnStopFireData) == 0x0002C0, "Member 'AP2SentryProjectile::OnStopFireData' has a wrong offset!");
static_assert(offsetof(AP2SentryProjectile, FireRadius) == 0x0002C8, "Member 'AP2SentryProjectile::FireRadius' has a wrong offset!");

// Class AICommon.P2ShortcutDataAsset
// 0x0070 (0x00A0 - 0x0030)
class UP2ShortcutDataAsset final : public UDataAsset
{
public:
	struct FShortcutRequirements                  Requirements;                                      // 0x0030(0x0020)(Edit, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
	struct FShortcutConfig                        Config;                                            // 0x0050(0x0048)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
	class UMoveActionDataAsset*                   MoveActionDataAsset;                               // 0x0098(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	float GetPlayRateByDistance(const float InDistance) const	 // 0x4776a54;

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"P2ShortcutDataAsset">();
	}
	static class UP2ShortcutDataAsset* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UP2ShortcutDataAsset>();
	}
};
static_assert(alignof(UP2ShortcutDataAsset) == 0x000008, "Wrong alignment on UP2ShortcutDataAsset");
static_assert(sizeof(UP2ShortcutDataAsset) == 0x0000A0, "Wrong size on UP2ShortcutDataAsset");
static_assert(offsetof(UP2ShortcutDataAsset, Requirements) == 0x000030, "Member 'UP2ShortcutDataAsset::Requirements' has a wrong offset!");
static_assert(offsetof(UP2ShortcutDataAsset, Config) == 0x000050, "Member 'UP2ShortcutDataAsset::Config' has a wrong offset!");
static_assert(offsetof(UP2ShortcutDataAsset, MoveActionDataAsset) == 0x000098, "Member 'UP2ShortcutDataAsset::MoveActionDataAsset' has a wrong offset!");

// Class AICommon.P2ShortcutDataSet
// 0x0010 (0x0040 - 0x0030)
class UP2ShortcutDataSet final : public UDataAsset
{
public:
	TArray<class UP2ShortcutDataAsset*>           ShortcutDataArray;                                 // 0x0030(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"P2ShortcutDataSet">();
	}
	static class UP2ShortcutDataSet* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UP2ShortcutDataSet>();
	}
};
static_assert(alignof(UP2ShortcutDataSet) == 0x000008, "Wrong alignment on UP2ShortcutDataSet");
static_assert(sizeof(UP2ShortcutDataSet) == 0x000040, "Wrong size on UP2ShortcutDataSet");
static_assert(offsetof(UP2ShortcutDataSet, ShortcutDataArray) == 0x000030, "Member 'UP2ShortcutDataSet::ShortcutDataArray' has a wrong offset!");

// Class AICommon.P2SightSenseData
// 0x0010 (0x0040 - 0x0030)
class UP2SightSenseData final : public UPrimaryDataAsset
{
public:
	TArray<struct FP2SightSenseDataPerTag>        SenseSettingPerTag;                                // 0x0030(0x0010)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"P2SightSenseData">();
	}
	static class UP2SightSenseData* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UP2SightSenseData>();
	}
};
static_assert(alignof(UP2SightSenseData) == 0x000008, "Wrong alignment on UP2SightSenseData");
static_assert(sizeof(UP2SightSenseData) == 0x000040, "Wrong size on UP2SightSenseData");
static_assert(offsetof(UP2SightSenseData, SenseSettingPerTag) == 0x000030, "Member 'UP2SightSenseData::SenseSettingPerTag' has a wrong offset!");

// Class AICommon.P2SmartObjectDefinition_BruteThrowable
// 0x0150 (0x0230 - 0x00E0)
class UP2SmartObjectDefinition_BruteThrowable final : public UP2SmartObjectDefinition
{
public:
	class UAnimMontage*                           Montage;                                           // 0x00E0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   PickupSectionName;                                 // 0x00E8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   ThrowSectionName;                                  // 0x00F0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UStaticMesh>             Mesh;                                              // 0x00F8(0x0030)(Edit, BlueprintVisible, BlueprintReadOnly, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UMaterial>               MeshMaterial;                                      // 0x0128(0x0030)(Edit, BlueprintVisible, BlueprintReadOnly, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_158[0x8];                                      // 0x0158(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             MeshLocalTransform;                                // 0x0160(0x0060)(Edit, BlueprintVisible, BlueprintReadOnly, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   SocketName;                                        // 0x01C0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FMercunaGroundAgentType                MercunaAgentType;                                  // 0x01C8(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         InitialLifeSpan;                                   // 0x01D4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TargetVelocityVariabilityFactor;                   // 0x01D8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MinThrowAngle;                                     // 0x01DC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxThrowAngle;                                     // 0x01E0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxThrowSpeed;                                     // 0x01E4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CollisionRadius;                                   // 0x01E8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1EC[0x4];                                      // 0x01EC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class UP2GameplayEffect_Damage>   DamageEffect;                                      // 0x01F0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCurveFloat*                            StunCurve;                                         // 0x01F8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         StunRadius;                                        // 0x0200(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DamageAoeRadius;                                   // 0x0204(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TargetSelectionOffsetRadius;                       // 0x0208(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_20C[0x4];                                      // 0x020C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class AP2BruteProjectile>         ProjectileClass;                                   // 0x0210(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         NoCollisionTrajectoryFraction;                     // 0x0218(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TargetToEyesAlpha;                                 // 0x021C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          DrawDebug;                                         // 0x0220(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_221[0x3];                                      // 0x0221(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         DrawDebugDuration;                                 // 0x0224(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_228[0x8];                                      // 0x0228(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"P2SmartObjectDefinition_BruteThrowable">();
	}
	static class UP2SmartObjectDefinition_BruteThrowable* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UP2SmartObjectDefinition_BruteThrowable>();
	}
};
static_assert(alignof(UP2SmartObjectDefinition_BruteThrowable) == 0x000010, "Wrong alignment on UP2SmartObjectDefinition_BruteThrowable");
static_assert(sizeof(UP2SmartObjectDefinition_BruteThrowable) == 0x000230, "Wrong size on UP2SmartObjectDefinition_BruteThrowable");
static_assert(offsetof(UP2SmartObjectDefinition_BruteThrowable, Montage) == 0x0000E0, "Member 'UP2SmartObjectDefinition_BruteThrowable::Montage' has a wrong offset!");
static_assert(offsetof(UP2SmartObjectDefinition_BruteThrowable, PickupSectionName) == 0x0000E8, "Member 'UP2SmartObjectDefinition_BruteThrowable::PickupSectionName' has a wrong offset!");
static_assert(offsetof(UP2SmartObjectDefinition_BruteThrowable, ThrowSectionName) == 0x0000F0, "Member 'UP2SmartObjectDefinition_BruteThrowable::ThrowSectionName' has a wrong offset!");
static_assert(offsetof(UP2SmartObjectDefinition_BruteThrowable, Mesh) == 0x0000F8, "Member 'UP2SmartObjectDefinition_BruteThrowable::Mesh' has a wrong offset!");
static_assert(offsetof(UP2SmartObjectDefinition_BruteThrowable, MeshMaterial) == 0x000128, "Member 'UP2SmartObjectDefinition_BruteThrowable::MeshMaterial' has a wrong offset!");
static_assert(offsetof(UP2SmartObjectDefinition_BruteThrowable, MeshLocalTransform) == 0x000160, "Member 'UP2SmartObjectDefinition_BruteThrowable::MeshLocalTransform' has a wrong offset!");
static_assert(offsetof(UP2SmartObjectDefinition_BruteThrowable, SocketName) == 0x0001C0, "Member 'UP2SmartObjectDefinition_BruteThrowable::SocketName' has a wrong offset!");
static_assert(offsetof(UP2SmartObjectDefinition_BruteThrowable, MercunaAgentType) == 0x0001C8, "Member 'UP2SmartObjectDefinition_BruteThrowable::MercunaAgentType' has a wrong offset!");
static_assert(offsetof(UP2SmartObjectDefinition_BruteThrowable, InitialLifeSpan) == 0x0001D4, "Member 'UP2SmartObjectDefinition_BruteThrowable::InitialLifeSpan' has a wrong offset!");
static_assert(offsetof(UP2SmartObjectDefinition_BruteThrowable, TargetVelocityVariabilityFactor) == 0x0001D8, "Member 'UP2SmartObjectDefinition_BruteThrowable::TargetVelocityVariabilityFactor' has a wrong offset!");
static_assert(offsetof(UP2SmartObjectDefinition_BruteThrowable, MinThrowAngle) == 0x0001DC, "Member 'UP2SmartObjectDefinition_BruteThrowable::MinThrowAngle' has a wrong offset!");
static_assert(offsetof(UP2SmartObjectDefinition_BruteThrowable, MaxThrowAngle) == 0x0001E0, "Member 'UP2SmartObjectDefinition_BruteThrowable::MaxThrowAngle' has a wrong offset!");
static_assert(offsetof(UP2SmartObjectDefinition_BruteThrowable, MaxThrowSpeed) == 0x0001E4, "Member 'UP2SmartObjectDefinition_BruteThrowable::MaxThrowSpeed' has a wrong offset!");
static_assert(offsetof(UP2SmartObjectDefinition_BruteThrowable, CollisionRadius) == 0x0001E8, "Member 'UP2SmartObjectDefinition_BruteThrowable::CollisionRadius' has a wrong offset!");
static_assert(offsetof(UP2SmartObjectDefinition_BruteThrowable, DamageEffect) == 0x0001F0, "Member 'UP2SmartObjectDefinition_BruteThrowable::DamageEffect' has a wrong offset!");
static_assert(offsetof(UP2SmartObjectDefinition_BruteThrowable, StunCurve) == 0x0001F8, "Member 'UP2SmartObjectDefinition_BruteThrowable::StunCurve' has a wrong offset!");
static_assert(offsetof(UP2SmartObjectDefinition_BruteThrowable, StunRadius) == 0x000200, "Member 'UP2SmartObjectDefinition_BruteThrowable::StunRadius' has a wrong offset!");
static_assert(offsetof(UP2SmartObjectDefinition_BruteThrowable, DamageAoeRadius) == 0x000204, "Member 'UP2SmartObjectDefinition_BruteThrowable::DamageAoeRadius' has a wrong offset!");
static_assert(offsetof(UP2SmartObjectDefinition_BruteThrowable, TargetSelectionOffsetRadius) == 0x000208, "Member 'UP2SmartObjectDefinition_BruteThrowable::TargetSelectionOffsetRadius' has a wrong offset!");
static_assert(offsetof(UP2SmartObjectDefinition_BruteThrowable, ProjectileClass) == 0x000210, "Member 'UP2SmartObjectDefinition_BruteThrowable::ProjectileClass' has a wrong offset!");
static_assert(offsetof(UP2SmartObjectDefinition_BruteThrowable, NoCollisionTrajectoryFraction) == 0x000218, "Member 'UP2SmartObjectDefinition_BruteThrowable::NoCollisionTrajectoryFraction' has a wrong offset!");
static_assert(offsetof(UP2SmartObjectDefinition_BruteThrowable, TargetToEyesAlpha) == 0x00021C, "Member 'UP2SmartObjectDefinition_BruteThrowable::TargetToEyesAlpha' has a wrong offset!");
static_assert(offsetof(UP2SmartObjectDefinition_BruteThrowable, DrawDebug) == 0x000220, "Member 'UP2SmartObjectDefinition_BruteThrowable::DrawDebug' has a wrong offset!");
static_assert(offsetof(UP2SmartObjectDefinition_BruteThrowable, DrawDebugDuration) == 0x000224, "Member 'UP2SmartObjectDefinition_BruteThrowable::DrawDebugDuration' has a wrong offset!");

// Class AICommon.P2SmartObjectDefinition_MontageBased
// 0x00F0 (0x01D0 - 0x00E0)
class UP2SmartObjectDefinition_MontageBased final : public UP2SmartObjectDefinition
{
public:
	TSubclassOf<class UP2NpcAbility_UseSmartObjectMontage> AbilityClass;                             // 0x00E0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimMontage*                           Montage;                                           // 0x00E8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMesh*                            PreviewMesh;                                       // 0x00F0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FMercunaGroundAgentType                NavAgentType;                                      // 0x00F8(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   IdleSectionName;                                   // 0x0104(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   EnterSectionName;                                  // 0x010C(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   LeaveSectionName;                                  // 0x0114(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         EnterBlendInTime;                                  // 0x011C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         EnterBlendOutTime;                                 // 0x0120(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ExitBlendInTime;                                   // 0x0124(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ExitBlendOutTime;                                  // 0x0128(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_12C[0x4];                                      // 0x012C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             OffsetTransform;                                   // 0x0130(0x0060)(Edit, BlueprintVisible, BlueprintReadOnly, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FP2SmartObjectEventResponse>    EventResponses;                                    // 0x0190(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	float                                         MaxDistanceToEnter;                                // 0x01A0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1A4[0x4];                                      // 0x01A4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                IdleWatchDirection;                                // 0x01A8(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UP2TransformCurve*                      EnterTransformCurve;                               // 0x01C0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UP2TransformCurve*                      ExitTransformCurve;                                // 0x01C8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"P2SmartObjectDefinition_MontageBased">();
	}
	static class UP2SmartObjectDefinition_MontageBased* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UP2SmartObjectDefinition_MontageBased>();
	}
};
static_assert(alignof(UP2SmartObjectDefinition_MontageBased) == 0x000010, "Wrong alignment on UP2SmartObjectDefinition_MontageBased");
static_assert(sizeof(UP2SmartObjectDefinition_MontageBased) == 0x0001D0, "Wrong size on UP2SmartObjectDefinition_MontageBased");
static_assert(offsetof(UP2SmartObjectDefinition_MontageBased, AbilityClass) == 0x0000E0, "Member 'UP2SmartObjectDefinition_MontageBased::AbilityClass' has a wrong offset!");
static_assert(offsetof(UP2SmartObjectDefinition_MontageBased, Montage) == 0x0000E8, "Member 'UP2SmartObjectDefinition_MontageBased::Montage' has a wrong offset!");
static_assert(offsetof(UP2SmartObjectDefinition_MontageBased, PreviewMesh) == 0x0000F0, "Member 'UP2SmartObjectDefinition_MontageBased::PreviewMesh' has a wrong offset!");
static_assert(offsetof(UP2SmartObjectDefinition_MontageBased, NavAgentType) == 0x0000F8, "Member 'UP2SmartObjectDefinition_MontageBased::NavAgentType' has a wrong offset!");
static_assert(offsetof(UP2SmartObjectDefinition_MontageBased, IdleSectionName) == 0x000104, "Member 'UP2SmartObjectDefinition_MontageBased::IdleSectionName' has a wrong offset!");
static_assert(offsetof(UP2SmartObjectDefinition_MontageBased, EnterSectionName) == 0x00010C, "Member 'UP2SmartObjectDefinition_MontageBased::EnterSectionName' has a wrong offset!");
static_assert(offsetof(UP2SmartObjectDefinition_MontageBased, LeaveSectionName) == 0x000114, "Member 'UP2SmartObjectDefinition_MontageBased::LeaveSectionName' has a wrong offset!");
static_assert(offsetof(UP2SmartObjectDefinition_MontageBased, EnterBlendInTime) == 0x00011C, "Member 'UP2SmartObjectDefinition_MontageBased::EnterBlendInTime' has a wrong offset!");
static_assert(offsetof(UP2SmartObjectDefinition_MontageBased, EnterBlendOutTime) == 0x000120, "Member 'UP2SmartObjectDefinition_MontageBased::EnterBlendOutTime' has a wrong offset!");
static_assert(offsetof(UP2SmartObjectDefinition_MontageBased, ExitBlendInTime) == 0x000124, "Member 'UP2SmartObjectDefinition_MontageBased::ExitBlendInTime' has a wrong offset!");
static_assert(offsetof(UP2SmartObjectDefinition_MontageBased, ExitBlendOutTime) == 0x000128, "Member 'UP2SmartObjectDefinition_MontageBased::ExitBlendOutTime' has a wrong offset!");
static_assert(offsetof(UP2SmartObjectDefinition_MontageBased, OffsetTransform) == 0x000130, "Member 'UP2SmartObjectDefinition_MontageBased::OffsetTransform' has a wrong offset!");
static_assert(offsetof(UP2SmartObjectDefinition_MontageBased, EventResponses) == 0x000190, "Member 'UP2SmartObjectDefinition_MontageBased::EventResponses' has a wrong offset!");
static_assert(offsetof(UP2SmartObjectDefinition_MontageBased, MaxDistanceToEnter) == 0x0001A0, "Member 'UP2SmartObjectDefinition_MontageBased::MaxDistanceToEnter' has a wrong offset!");
static_assert(offsetof(UP2SmartObjectDefinition_MontageBased, IdleWatchDirection) == 0x0001A8, "Member 'UP2SmartObjectDefinition_MontageBased::IdleWatchDirection' has a wrong offset!");
static_assert(offsetof(UP2SmartObjectDefinition_MontageBased, EnterTransformCurve) == 0x0001C0, "Member 'UP2SmartObjectDefinition_MontageBased::EnterTransformCurve' has a wrong offset!");
static_assert(offsetof(UP2SmartObjectDefinition_MontageBased, ExitTransformCurve) == 0x0001C8, "Member 'UP2SmartObjectDefinition_MontageBased::ExitTransformCurve' has a wrong offset!");

// Class AICommon.P2SmartObjectDefinition_StalkerHidingSpot
// 0x0018 (0x00F8 - 0x00E0)
class UP2SmartObjectDefinition_StalkerHidingSpot final : public UP2SmartObjectDefinition
{
public:
	class UAnimMontage*                           Montage;                                           // 0x00E0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsInstant;                                        // 0x00E8(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCanFall;                                          // 0x00E9(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_EA[0x6];                                       // 0x00EA(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class UGameplayEffect>            HealEffect;                                        // 0x00F0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"P2SmartObjectDefinition_StalkerHidingSpot">();
	}
	static class UP2SmartObjectDefinition_StalkerHidingSpot* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UP2SmartObjectDefinition_StalkerHidingSpot>();
	}
};
static_assert(alignof(UP2SmartObjectDefinition_StalkerHidingSpot) == 0x000008, "Wrong alignment on UP2SmartObjectDefinition_StalkerHidingSpot");
static_assert(sizeof(UP2SmartObjectDefinition_StalkerHidingSpot) == 0x0000F8, "Wrong size on UP2SmartObjectDefinition_StalkerHidingSpot");
static_assert(offsetof(UP2SmartObjectDefinition_StalkerHidingSpot, Montage) == 0x0000E0, "Member 'UP2SmartObjectDefinition_StalkerHidingSpot::Montage' has a wrong offset!");
static_assert(offsetof(UP2SmartObjectDefinition_StalkerHidingSpot, bIsInstant) == 0x0000E8, "Member 'UP2SmartObjectDefinition_StalkerHidingSpot::bIsInstant' has a wrong offset!");
static_assert(offsetof(UP2SmartObjectDefinition_StalkerHidingSpot, bCanFall) == 0x0000E9, "Member 'UP2SmartObjectDefinition_StalkerHidingSpot::bCanFall' has a wrong offset!");
static_assert(offsetof(UP2SmartObjectDefinition_StalkerHidingSpot, HealEffect) == 0x0000F0, "Member 'UP2SmartObjectDefinition_StalkerHidingSpot::HealEffect' has a wrong offset!");

// Class AICommon.P2SmartObjectProxyComponent
// 0x0000 (0x0670 - 0x0670)
class UP2SmartObjectProxyComponent final : public UStaticMeshComponent
{
public:
	class UP2SmartObjectDefinition_MontageBased*  PreviewSmartObjectDefinition;                      // 0x0668(0x0008)(Edit, ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"P2SmartObjectProxyComponent">();
	}
	static class UP2SmartObjectProxyComponent* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UP2SmartObjectProxyComponent>();
	}
};
static_assert(alignof(UP2SmartObjectProxyComponent) == 0x000010, "Wrong alignment on UP2SmartObjectProxyComponent");
static_assert(sizeof(UP2SmartObjectProxyComponent) == 0x000670, "Wrong size on UP2SmartObjectProxyComponent");
static_assert(offsetof(UP2SmartObjectProxyComponent, PreviewSmartObjectDefinition) == 0x000668, "Member 'UP2SmartObjectProxyComponent::PreviewSmartObjectDefinition' has a wrong offset!");

// Class AICommon.P2BruteThrowable
// 0x00A0 (0x0350 - 0x02B0)
class AP2BruteThrowable final : public AP2SmartObjectProxy
{
public:
	struct FTransform                             AttachmentTransform;                               // 0x02B0(0x0060)(Edit, BlueprintVisible, BlueprintReadOnly, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FAkEventSlotConfig                     ImpactAudioEvent;                                  // 0x0310(0x0030)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   Mesh;                                              // 0x0340(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_348[0x8];                                      // 0x0348(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"P2BruteThrowable">();
	}
	static class AP2BruteThrowable* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<AP2BruteThrowable>();
	}
};
static_assert(alignof(AP2BruteThrowable) == 0x000010, "Wrong alignment on AP2BruteThrowable");
static_assert(sizeof(AP2BruteThrowable) == 0x000350, "Wrong size on AP2BruteThrowable");
static_assert(offsetof(AP2BruteThrowable, AttachmentTransform) == 0x0002B0, "Member 'AP2BruteThrowable::AttachmentTransform' has a wrong offset!");
static_assert(offsetof(AP2BruteThrowable, ImpactAudioEvent) == 0x000310, "Member 'AP2BruteThrowable::ImpactAudioEvent' has a wrong offset!");
static_assert(offsetof(AP2BruteThrowable, Mesh) == 0x000340, "Member 'AP2BruteThrowable::Mesh' has a wrong offset!");

// Class AICommon.P2StalkerHidingSpot
// 0x0000 (0x02B0 - 0x02B0)
class AP2StalkerHidingSpot final : public AP2SmartObjectProxy
{
public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"P2StalkerHidingSpot">();
	}
	static class AP2StalkerHidingSpot* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<AP2StalkerHidingSpot>();
	}
};
static_assert(alignof(AP2StalkerHidingSpot) == 0x000008, "Wrong alignment on AP2StalkerHidingSpot");
static_assert(sizeof(AP2StalkerHidingSpot) == 0x0002B0, "Wrong size on AP2StalkerHidingSpot");

// Class AICommon.P2SmartObjectsCollection
// 0x00C0 (0x0370 - 0x02B0)
class alignas(0x10) AP2SmartObjectsCollection final : public AInfo
{
public:
	TArray<class UP2SmartObject*>                 SmartObjects;                                      // 0x02B0(0x0010)(ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2C0[0xB0];                                     // 0x02C0(0x00B0)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"P2SmartObjectsCollection">();
	}
	static class AP2SmartObjectsCollection* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<AP2SmartObjectsCollection>();
	}
};
static_assert(alignof(AP2SmartObjectsCollection) == 0x000010, "Wrong alignment on AP2SmartObjectsCollection");
static_assert(sizeof(AP2SmartObjectsCollection) == 0x000370, "Wrong size on AP2SmartObjectsCollection");
static_assert(offsetof(AP2SmartObjectsCollection, SmartObjects) == 0x0002B0, "Member 'AP2SmartObjectsCollection::SmartObjects' has a wrong offset!");

// Class AICommon.P2SmartObjectSystem
// 0x0008 (0x0038 - 0x0030)
class UP2SmartObjectSystem final : public UWorldSubsystem
{
public:
	class AP2SmartObjectsCollection*              Collection;                                        // 0x0030(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"P2SmartObjectSystem">();
	}
	static class UP2SmartObjectSystem* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UP2SmartObjectSystem>();
	}
};
static_assert(alignof(UP2SmartObjectSystem) == 0x000008, "Wrong alignment on UP2SmartObjectSystem");
static_assert(sizeof(UP2SmartObjectSystem) == 0x000038, "Wrong size on UP2SmartObjectSystem");
static_assert(offsetof(UP2SmartObjectSystem, Collection) == 0x000030, "Member 'UP2SmartObjectSystem::Collection' has a wrong offset!");

// Class AICommon.P2SmartObjectUserComponent
// 0x0038 (0x00F8 - 0x00C0)
class UP2SmartObjectUserComponent final : public UActorComponent
{
public:
	uint8                                         Pad_C0[0x30];                                      // 0x00C0(0x0030)(Fixing Size After Last Property [ Dumper-7 ])
	TWeakObjectPtr<class UP2SmartObject>          CurrentlyUsedSmartObject;                          // 0x00F0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"P2SmartObjectUserComponent">();
	}
	static class UP2SmartObjectUserComponent* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UP2SmartObjectUserComponent>();
	}
};
static_assert(alignof(UP2SmartObjectUserComponent) == 0x000008, "Wrong alignment on UP2SmartObjectUserComponent");
static_assert(sizeof(UP2SmartObjectUserComponent) == 0x0000F8, "Wrong size on UP2SmartObjectUserComponent");
static_assert(offsetof(UP2SmartObjectUserComponent, CurrentlyUsedSmartObject) == 0x0000F0, "Member 'UP2SmartObjectUserComponent::CurrentlyUsedSmartObject' has a wrong offset!");

// Class AICommon.P2SmartObject_MontageBased
// 0x0168 (0x01E0 - 0x0078)
class UP2SmartObject_MontageBased final : public UP2SmartObject_AbilityDriven
{
public:
	uint8                                         Pad_78[0x8];                                       // 0x0078(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             ObjectTransform;                                   // 0x0080(0x0060)(IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FTransform                             IdleTransform;                                     // 0x00E0(0x0060)(IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FTransform                             EntryTransform;                                    // 0x0140(0x0060)(IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FBoxSphereBounds                       Bounds;                                            // 0x01A0(0x0038)(ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPrivate)
	uint8                                         Pad_1D8[0x8];                                      // 0x01D8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	struct FVector GetEnterLocation() const	 // 0x477a748;
	const struct FTransform GetEnterTransform() const	 // 0x477a784;
	const struct FTransform GetIdleTransform() const	 // 0x477a84c;
	const struct FTransform GetObjectTransform() const	 // 0x477a7f4;

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"P2SmartObject_MontageBased">();
	}
	static class UP2SmartObject_MontageBased* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UP2SmartObject_MontageBased>();
	}
};
static_assert(alignof(UP2SmartObject_MontageBased) == 0x000010, "Wrong alignment on UP2SmartObject_MontageBased");
static_assert(sizeof(UP2SmartObject_MontageBased) == 0x0001E0, "Wrong size on UP2SmartObject_MontageBased");
static_assert(offsetof(UP2SmartObject_MontageBased, ObjectTransform) == 0x000080, "Member 'UP2SmartObject_MontageBased::ObjectTransform' has a wrong offset!");
static_assert(offsetof(UP2SmartObject_MontageBased, IdleTransform) == 0x0000E0, "Member 'UP2SmartObject_MontageBased::IdleTransform' has a wrong offset!");
static_assert(offsetof(UP2SmartObject_MontageBased, EntryTransform) == 0x000140, "Member 'UP2SmartObject_MontageBased::EntryTransform' has a wrong offset!");
static_assert(offsetof(UP2SmartObject_MontageBased, Bounds) == 0x0001A0, "Member 'UP2SmartObject_MontageBased::Bounds' has a wrong offset!");

// Class AICommon.P2SmartObject_Simple
// 0x0050 (0x00A8 - 0x0058)
class UP2SmartObject_Simple final : public UP2SmartObject
{
public:
	struct FVector                                Location;                                          // 0x0058(0x0018)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FBoxSphereBounds                       Bounds;                                            // 0x0070(0x0038)(ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"P2SmartObject_Simple">();
	}
	static class UP2SmartObject_Simple* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UP2SmartObject_Simple>();
	}
};
static_assert(alignof(UP2SmartObject_Simple) == 0x000008, "Wrong alignment on UP2SmartObject_Simple");
static_assert(sizeof(UP2SmartObject_Simple) == 0x0000A8, "Wrong size on UP2SmartObject_Simple");
static_assert(offsetof(UP2SmartObject_Simple, Location) == 0x000058, "Member 'UP2SmartObject_Simple::Location' has a wrong offset!");
static_assert(offsetof(UP2SmartObject_Simple, Bounds) == 0x000070, "Member 'UP2SmartObject_Simple::Bounds' has a wrong offset!");

// Class AICommon.P2SmartObject_StalkerHidingSpot
// 0x00B8 (0x0130 - 0x0078)
class UP2SmartObject_StalkerHidingSpot final : public UP2SmartObject_AbilityDriven
{
public:
	uint8                                         Pad_78[0x8];                                       // 0x0078(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             HidingSpotTransform;                               // 0x0080(0x0060)(IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FVector                                EntryLocation;                                     // 0x00E0(0x0018)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FBoxSphereBounds                       Bounds;                                            // 0x00F8(0x0038)(ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPrivate)

public:
	struct FVector GetEnterLocation() const	 // 0x477a748;
	const struct FTransform GetHidingSportTransform() const	 // 0x477a7f4;

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"P2SmartObject_StalkerHidingSpot">();
	}
	static class UP2SmartObject_StalkerHidingSpot* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UP2SmartObject_StalkerHidingSpot>();
	}
};
static_assert(alignof(UP2SmartObject_StalkerHidingSpot) == 0x000010, "Wrong alignment on UP2SmartObject_StalkerHidingSpot");
static_assert(sizeof(UP2SmartObject_StalkerHidingSpot) == 0x000130, "Wrong size on UP2SmartObject_StalkerHidingSpot");
static_assert(offsetof(UP2SmartObject_StalkerHidingSpot, HidingSpotTransform) == 0x000080, "Member 'UP2SmartObject_StalkerHidingSpot::HidingSpotTransform' has a wrong offset!");
static_assert(offsetof(UP2SmartObject_StalkerHidingSpot, EntryLocation) == 0x0000E0, "Member 'UP2SmartObject_StalkerHidingSpot::EntryLocation' has a wrong offset!");
static_assert(offsetof(UP2SmartObject_StalkerHidingSpot, Bounds) == 0x0000F8, "Member 'UP2SmartObject_StalkerHidingSpot::Bounds' has a wrong offset!");

// Class AICommon.P2StalkerComponent
// 0x0020 (0x00E8 - 0x00C8)
class UP2StalkerComponent final : public UP2PawnComponent
{
public:
	TMulticastInlineDelegate<void(EP2_Stalker_State PrevState, EP2_Stalker_State NewState)> OnStateChanged; // 0x00C8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	float                                         Bloodlust;                                         // 0x00D8(0x0004)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         Fear;                                              // 0x00DC(0x0004)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	EP2_Stalker_State                             State;                                             // 0x00E0(0x0001)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_E1[0x7];                                       // 0x00E1(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UP2StalkerComponent* FindStalkerComponent(class AActor* Actor)	 // 0x477a664;

	void OnRep_State(const EP2_Stalker_State& PrevState)	 // 0x477ac88;

	float GetBloodLust() const	 // 0x477a730;
	float GetFearLevel() const	 // 0x477a7dc;
	EP2_Stalker_State GetState() const	 // 0x46dde34;

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"P2StalkerComponent">();
	}
	static class UP2StalkerComponent* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UP2StalkerComponent>();
	}
};
static_assert(alignof(UP2StalkerComponent) == 0x000008, "Wrong alignment on UP2StalkerComponent");
static_assert(sizeof(UP2StalkerComponent) == 0x0000E8, "Wrong size on UP2StalkerComponent");
static_assert(offsetof(UP2StalkerComponent, OnStateChanged) == 0x0000C8, "Member 'UP2StalkerComponent::OnStateChanged' has a wrong offset!");
static_assert(offsetof(UP2StalkerComponent, Bloodlust) == 0x0000D8, "Member 'UP2StalkerComponent::Bloodlust' has a wrong offset!");
static_assert(offsetof(UP2StalkerComponent, Fear) == 0x0000DC, "Member 'UP2StalkerComponent::Fear' has a wrong offset!");
static_assert(offsetof(UP2StalkerComponent, State) == 0x0000E0, "Member 'UP2StalkerComponent::State' has a wrong offset!");

// Class AICommon.P2StateTreeComponent
// 0x0020 (0x0198 - 0x0178)
class UP2StateTreeComponent final : public UStateTreeComponent
{
public:
	uint8                                         Pad_178[0x20];                                     // 0x0178(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"P2StateTreeComponent">();
	}
	static class UP2StateTreeComponent* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UP2StateTreeComponent>();
	}
};
static_assert(alignof(UP2StateTreeComponent) == 0x000008, "Wrong alignment on UP2StateTreeComponent");
static_assert(sizeof(UP2StateTreeComponent) == 0x000198, "Wrong size on UP2StateTreeComponent");

// Class AICommon.P2StimuliTrackingComponent
// 0x0078 (0x0140 - 0x00C8)
class UP2StimuliTrackingComponent final : public UP2PawnComponent
{
public:
	struct FGameplayTagContainer                  TagsToTrack;                                       // 0x00C8(0x0020)(Edit, NativeAccessSpecifierPublic)
	uint8                                         Pad_E8[0x58];                                      // 0x00E8(0x0058)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void HandleNewStimulus(const class AActor* Actor, const struct FAIStimulus& Stimulus)	 // 0x477aabc;

	float GetTotalStimuliStrengthReceived(const struct FGameplayTagContainer& StimuliTags, const class AActor* FromActor, float TimeWindow) const	 // 0x477a8a4;

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"P2StimuliTrackingComponent">();
	}
	static class UP2StimuliTrackingComponent* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UP2StimuliTrackingComponent>();
	}
};
static_assert(alignof(UP2StimuliTrackingComponent) == 0x000008, "Wrong alignment on UP2StimuliTrackingComponent");
static_assert(sizeof(UP2StimuliTrackingComponent) == 0x000140, "Wrong size on UP2StimuliTrackingComponent");
static_assert(offsetof(UP2StimuliTrackingComponent, TagsToTrack) == 0x0000C8, "Member 'UP2StimuliTrackingComponent::TagsToTrack' has a wrong offset!");

// Class AICommon.P2TestCrocAlignmentActor
// 0x00A0 (0x0350 - 0x02B0)
class AP2TestCrocAlignmentActor final : public AActor
{
public:
	float                                         Distance;                                          // 0x02B0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EP2CrocSnapAttackAlignementAnchor             Anchor;                                            // 0x02B4(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2B5[0x3];                                      // 0x02B5(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class UCapsuleComponent*                      CapsuleA;                                          // 0x02B8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class USkeletalMeshComponent*                 MeshA;                                             // 0x02C0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UCapsuleComponent*                      CapsuleB;                                          // 0x02C8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class USkeletalMeshComponent*                 MeshB;                                             // 0x02D0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FVector                                LocationA;                                         // 0x02D8(0x0018)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FVector                                LocationB;                                         // 0x02F0(0x0018)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FVector                                NormalA;                                           // 0x0308(0x0018)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FVector                                NormalB;                                           // 0x0320(0x0018)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FVector                                Tangent;                                           // 0x0338(0x0018)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"P2TestCrocAlignmentActor">();
	}
	static class AP2TestCrocAlignmentActor* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<AP2TestCrocAlignmentActor>();
	}
};
static_assert(alignof(AP2TestCrocAlignmentActor) == 0x000008, "Wrong alignment on AP2TestCrocAlignmentActor");
static_assert(sizeof(AP2TestCrocAlignmentActor) == 0x000350, "Wrong size on AP2TestCrocAlignmentActor");
static_assert(offsetof(AP2TestCrocAlignmentActor, Distance) == 0x0002B0, "Member 'AP2TestCrocAlignmentActor::Distance' has a wrong offset!");
static_assert(offsetof(AP2TestCrocAlignmentActor, Anchor) == 0x0002B4, "Member 'AP2TestCrocAlignmentActor::Anchor' has a wrong offset!");
static_assert(offsetof(AP2TestCrocAlignmentActor, CapsuleA) == 0x0002B8, "Member 'AP2TestCrocAlignmentActor::CapsuleA' has a wrong offset!");
static_assert(offsetof(AP2TestCrocAlignmentActor, MeshA) == 0x0002C0, "Member 'AP2TestCrocAlignmentActor::MeshA' has a wrong offset!");
static_assert(offsetof(AP2TestCrocAlignmentActor, CapsuleB) == 0x0002C8, "Member 'AP2TestCrocAlignmentActor::CapsuleB' has a wrong offset!");
static_assert(offsetof(AP2TestCrocAlignmentActor, MeshB) == 0x0002D0, "Member 'AP2TestCrocAlignmentActor::MeshB' has a wrong offset!");
static_assert(offsetof(AP2TestCrocAlignmentActor, LocationA) == 0x0002D8, "Member 'AP2TestCrocAlignmentActor::LocationA' has a wrong offset!");
static_assert(offsetof(AP2TestCrocAlignmentActor, LocationB) == 0x0002F0, "Member 'AP2TestCrocAlignmentActor::LocationB' has a wrong offset!");
static_assert(offsetof(AP2TestCrocAlignmentActor, NormalA) == 0x000308, "Member 'AP2TestCrocAlignmentActor::NormalA' has a wrong offset!");
static_assert(offsetof(AP2TestCrocAlignmentActor, NormalB) == 0x000320, "Member 'AP2TestCrocAlignmentActor::NormalB' has a wrong offset!");
static_assert(offsetof(AP2TestCrocAlignmentActor, Tangent) == 0x000338, "Member 'AP2TestCrocAlignmentActor::Tangent' has a wrong offset!");

// Class AICommon.P2TestKeySelector_Ability
// 0x0018 (0x0048 - 0x0030)
class UP2TestKeySelector_Ability final : public UP2TestKeySelector
{
public:
	TArray<TSubclassOf<class UGameplayAbility>>   AvailableAbilities;                                // 0x0030(0x0010)(Net, ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
	TSubclassOf<class UGameplayAbility>           SelectedAbilityClass;                              // 0x0040(0x0008)(Net, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	void ServerSetAbilityClass(TSubclassOf<class UGameplayAbility> NewAbilityClass)	 // 0x477aef8;

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"P2TestKeySelector_Ability">();
	}
	static class UP2TestKeySelector_Ability* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UP2TestKeySelector_Ability>();
	}
};
static_assert(alignof(UP2TestKeySelector_Ability) == 0x000008, "Wrong alignment on UP2TestKeySelector_Ability");
static_assert(sizeof(UP2TestKeySelector_Ability) == 0x000048, "Wrong size on UP2TestKeySelector_Ability");
static_assert(offsetof(UP2TestKeySelector_Ability, AvailableAbilities) == 0x000030, "Member 'UP2TestKeySelector_Ability::AvailableAbilities' has a wrong offset!");
static_assert(offsetof(UP2TestKeySelector_Ability, SelectedAbilityClass) == 0x000040, "Member 'UP2TestKeySelector_Ability::SelectedAbilityClass' has a wrong offset!");

// Class AICommon.P2TestKeySelector_CurrentPlayer
// 0x0008 (0x0038 - 0x0030)
class UP2TestKeySelector_CurrentPlayer final : public UP2TestKeySelector
{
public:
	class AActor*                                 CurrentPlayer;                                     // 0x0030(0x0008)(Net, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"P2TestKeySelector_CurrentPlayer">();
	}
	static class UP2TestKeySelector_CurrentPlayer* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UP2TestKeySelector_CurrentPlayer>();
	}
};
static_assert(alignof(UP2TestKeySelector_CurrentPlayer) == 0x000008, "Wrong alignment on UP2TestKeySelector_CurrentPlayer");
static_assert(sizeof(UP2TestKeySelector_CurrentPlayer) == 0x000038, "Wrong size on UP2TestKeySelector_CurrentPlayer");
static_assert(offsetof(UP2TestKeySelector_CurrentPlayer, CurrentPlayer) == 0x000030, "Member 'UP2TestKeySelector_CurrentPlayer::CurrentPlayer' has a wrong offset!");

// Class AICommon.P2TestKeySelector_Float
// 0x0008 (0x0038 - 0x0030)
class UP2TestKeySelector_Float final : public UP2TestKeySelector
{
public:
	float                                         CurrentValue;                                      // 0x0030(0x0004)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_34[0x4];                                       // 0x0034(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ServerSetFloatValue(float NewValue)	 // 0x477afbc;

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"P2TestKeySelector_Float">();
	}
	static class UP2TestKeySelector_Float* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UP2TestKeySelector_Float>();
	}
};
static_assert(alignof(UP2TestKeySelector_Float) == 0x000008, "Wrong alignment on UP2TestKeySelector_Float");
static_assert(sizeof(UP2TestKeySelector_Float) == 0x000038, "Wrong size on UP2TestKeySelector_Float");
static_assert(offsetof(UP2TestKeySelector_Float, CurrentValue) == 0x000030, "Member 'UP2TestKeySelector_Float::CurrentValue' has a wrong offset!");

// Class AICommon.P2TestKeySelector_SmartObject
// 0x0050 (0x0080 - 0x0030)
class UP2TestKeySelector_SmartObject final : public UP2TestKeySelector
{
public:
	float                                         Radius;                                            // 0x0030(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ConeAngle;                                         // 0x0034(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UP2SmartObject*                         SelectedSmartObject;                               // 0x0038(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 SelectedSmartObjectName;                           // 0x0040(0x0010)(Net, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                SelectedSmartObjectOrigin;                         // 0x0050(0x0018)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                SelectedSmartObjectExtent;                         // 0x0068(0x0018)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	void ServerSelectSmartObject(const struct FVector& ViewLocation, const struct FVector& ViewDirection, const class AP2NPCharacter* InSelectedNpc)	 // 0x477ad34;

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"P2TestKeySelector_SmartObject">();
	}
	static class UP2TestKeySelector_SmartObject* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UP2TestKeySelector_SmartObject>();
	}
};
static_assert(alignof(UP2TestKeySelector_SmartObject) == 0x000008, "Wrong alignment on UP2TestKeySelector_SmartObject");
static_assert(sizeof(UP2TestKeySelector_SmartObject) == 0x000080, "Wrong size on UP2TestKeySelector_SmartObject");
static_assert(offsetof(UP2TestKeySelector_SmartObject, Radius) == 0x000030, "Member 'UP2TestKeySelector_SmartObject::Radius' has a wrong offset!");
static_assert(offsetof(UP2TestKeySelector_SmartObject, ConeAngle) == 0x000034, "Member 'UP2TestKeySelector_SmartObject::ConeAngle' has a wrong offset!");
static_assert(offsetof(UP2TestKeySelector_SmartObject, SelectedSmartObject) == 0x000038, "Member 'UP2TestKeySelector_SmartObject::SelectedSmartObject' has a wrong offset!");
static_assert(offsetof(UP2TestKeySelector_SmartObject, SelectedSmartObjectName) == 0x000040, "Member 'UP2TestKeySelector_SmartObject::SelectedSmartObjectName' has a wrong offset!");
static_assert(offsetof(UP2TestKeySelector_SmartObject, SelectedSmartObjectOrigin) == 0x000050, "Member 'UP2TestKeySelector_SmartObject::SelectedSmartObjectOrigin' has a wrong offset!");
static_assert(offsetof(UP2TestKeySelector_SmartObject, SelectedSmartObjectExtent) == 0x000068, "Member 'UP2TestKeySelector_SmartObject::SelectedSmartObjectExtent' has a wrong offset!");

// Class AICommon.P2LureData
// 0x0038 (0x0068 - 0x0030)
class UP2LureData : public UDataAsset
{
public:
	float                                         StartRadius;                                       // 0x0030(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         EndRadius;                                         // 0x0034(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ZoneExpandTime;                                    // 0x0038(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Duration;                                          // 0x003C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTagContainer                  AffectedPawnTags;                                  // 0x0040(0x0020)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TSubclassOf<class UGameplayEffect>            GameplayEffect;                                    // 0x0060(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"P2LureData">();
	}
	static class UP2LureData* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UP2LureData>();
	}
};
static_assert(alignof(UP2LureData) == 0x000008, "Wrong alignment on UP2LureData");
static_assert(sizeof(UP2LureData) == 0x000068, "Wrong size on UP2LureData");
static_assert(offsetof(UP2LureData, StartRadius) == 0x000030, "Member 'UP2LureData::StartRadius' has a wrong offset!");
static_assert(offsetof(UP2LureData, EndRadius) == 0x000034, "Member 'UP2LureData::EndRadius' has a wrong offset!");
static_assert(offsetof(UP2LureData, ZoneExpandTime) == 0x000038, "Member 'UP2LureData::ZoneExpandTime' has a wrong offset!");
static_assert(offsetof(UP2LureData, Duration) == 0x00003C, "Member 'UP2LureData::Duration' has a wrong offset!");
static_assert(offsetof(UP2LureData, AffectedPawnTags) == 0x000040, "Member 'UP2LureData::AffectedPawnTags' has a wrong offset!");
static_assert(offsetof(UP2LureData, GameplayEffect) == 0x000060, "Member 'UP2LureData::GameplayEffect' has a wrong offset!");

// Class AICommon.P2LureData_Attract
// 0x0018 (0x0080 - 0x0068)
class UP2LureData_Attract final : public UP2LureData
{
public:
	struct FVector2D                              RandomRadiusRange;                                 // 0x0068(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MinDistanceBetweenPoints;                          // 0x0078(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_7C[0x4];                                       // 0x007C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"P2LureData_Attract">();
	}
	static class UP2LureData_Attract* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UP2LureData_Attract>();
	}
};
static_assert(alignof(UP2LureData_Attract) == 0x000008, "Wrong alignment on UP2LureData_Attract");
static_assert(sizeof(UP2LureData_Attract) == 0x000080, "Wrong size on UP2LureData_Attract");
static_assert(offsetof(UP2LureData_Attract, RandomRadiusRange) == 0x000068, "Member 'UP2LureData_Attract::RandomRadiusRange' has a wrong offset!");
static_assert(offsetof(UP2LureData_Attract, MinDistanceBetweenPoints) == 0x000078, "Member 'UP2LureData_Attract::MinDistanceBetweenPoints' has a wrong offset!");

// Class AICommon.P2LureData_Repel
// 0x0000 (0x0068 - 0x0068)
class UP2LureData_Repel final : public UP2LureData
{
public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"P2LureData_Repel">();
	}
	static class UP2LureData_Repel* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UP2LureData_Repel>();
	}
};
static_assert(alignof(UP2LureData_Repel) == 0x000008, "Wrong alignment on UP2LureData_Repel");
static_assert(sizeof(UP2LureData_Repel) == 0x000068, "Wrong size on UP2LureData_Repel");

// Class AICommon.P2ThrowableActor_Lure
// 0x00B0 (0x0450 - 0x03A0)
class AP2ThrowableActor_Lure final : public AP2ThrowableActor
{
public:
	uint8                                         Pad_3A0[0xA0];                                     // 0x03A0(0x00A0)(Fixing Size After Last Property [ Dumper-7 ])
	class UP2LureData_Attract*                    AttractData;                                       // 0x0440(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UP2LureData_Repel*                      RepelData;                                         // 0x0448(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	void OnGameplayEffectRemoved(const struct FGameplayEffectRemovalInfo& InGameplayEffectRemovalInfo)	 // 0x4788668;

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"P2ThrowableActor_Lure">();
	}
	static class AP2ThrowableActor_Lure* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<AP2ThrowableActor_Lure>();
	}
};
static_assert(alignof(AP2ThrowableActor_Lure) == 0x000008, "Wrong alignment on AP2ThrowableActor_Lure");
static_assert(sizeof(AP2ThrowableActor_Lure) == 0x000450, "Wrong size on AP2ThrowableActor_Lure");
static_assert(offsetof(AP2ThrowableActor_Lure, AttractData) == 0x000440, "Member 'AP2ThrowableActor_Lure::AttractData' has a wrong offset!");
static_assert(offsetof(AP2ThrowableActor_Lure, RepelData) == 0x000448, "Member 'AP2ThrowableActor_Lure::RepelData' has a wrong offset!");

// Class AICommon.P2ToxinStackBuildupMagnitudeCalculation
// 0x0078 (0x00B8 - 0x0040)
class UP2ToxinStackBuildupMagnitudeCalculation final : public UGameplayModMagnitudeCalculation
{
public:
	struct FScalableFloat                         RelaxedStackSF;                                    // 0x0040(0x0028)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FScalableFloat                         InvestigatingStackSF;                              // 0x0068(0x0028)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FScalableFloat                         EngagingStackSF;                                   // 0x0090(0x0028)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"P2ToxinStackBuildupMagnitudeCalculation">();
	}
	static class UP2ToxinStackBuildupMagnitudeCalculation* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UP2ToxinStackBuildupMagnitudeCalculation>();
	}
};
static_assert(alignof(UP2ToxinStackBuildupMagnitudeCalculation) == 0x000008, "Wrong alignment on UP2ToxinStackBuildupMagnitudeCalculation");
static_assert(sizeof(UP2ToxinStackBuildupMagnitudeCalculation) == 0x0000B8, "Wrong size on UP2ToxinStackBuildupMagnitudeCalculation");
static_assert(offsetof(UP2ToxinStackBuildupMagnitudeCalculation, RelaxedStackSF) == 0x000040, "Member 'UP2ToxinStackBuildupMagnitudeCalculation::RelaxedStackSF' has a wrong offset!");
static_assert(offsetof(UP2ToxinStackBuildupMagnitudeCalculation, InvestigatingStackSF) == 0x000068, "Member 'UP2ToxinStackBuildupMagnitudeCalculation::InvestigatingStackSF' has a wrong offset!");
static_assert(offsetof(UP2ToxinStackBuildupMagnitudeCalculation, EngagingStackSF) == 0x000090, "Member 'UP2ToxinStackBuildupMagnitudeCalculation::EngagingStackSF' has a wrong offset!");

// Class AICommon.P2TrajectoryGenerator
// 0x0150 (0x0390 - 0x0240)
class UP2TrajectoryGenerator final : public UTrajectoryGenerator_Base
{
public:
	uint8                                         Pad_238[0x118];                                    // 0x0238(0x0118)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         RepPathRemain;                                     // 0x0350(0x0004)(Net, ZeroConstructor, Transient, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_354[0x4];                                      // 0x0354(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTrajectorySampleRange                 ReplicatedTrajectory;                              // 0x0358(0x0010)(Net, Transient, RepNotify, Protected, NativeAccessSpecifierProtected)
	struct FP2TrajMovementParams                  RepMovementParams;                                 // 0x0368(0x0010)(Net, Transient, RepNotify, NoDestructor, Protected, NativeAccessSpecifierProtected)
	class UP2NpcMovementComponent*                NpcMovementCache;                                  // 0x0378(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UMercunaGroundNavigationComponent*      GroundNavCache;                                    // 0x0380(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USkeletalMeshComponent*                 SkComp;                                            // 0x0388(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void OnMoveCompleted(const struct FAIRequestID& RequestID, const EMercunaMoveResult Result)	 // 0x478880c;
	void OnRep_MovementParams()	 // 0x478893c;
	void OnRep_PathRemaining()	 // 0x166aba4;
	void OnRep_Trajectory()	 // 0x47889ac;

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"P2TrajectoryGenerator">();
	}
	static class UP2TrajectoryGenerator* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UP2TrajectoryGenerator>();
	}
};
static_assert(alignof(UP2TrajectoryGenerator) == 0x000010, "Wrong alignment on UP2TrajectoryGenerator");
static_assert(sizeof(UP2TrajectoryGenerator) == 0x000390, "Wrong size on UP2TrajectoryGenerator");
static_assert(offsetof(UP2TrajectoryGenerator, RepPathRemain) == 0x000350, "Member 'UP2TrajectoryGenerator::RepPathRemain' has a wrong offset!");
static_assert(offsetof(UP2TrajectoryGenerator, ReplicatedTrajectory) == 0x000358, "Member 'UP2TrajectoryGenerator::ReplicatedTrajectory' has a wrong offset!");
static_assert(offsetof(UP2TrajectoryGenerator, RepMovementParams) == 0x000368, "Member 'UP2TrajectoryGenerator::RepMovementParams' has a wrong offset!");
static_assert(offsetof(UP2TrajectoryGenerator, NpcMovementCache) == 0x000378, "Member 'UP2TrajectoryGenerator::NpcMovementCache' has a wrong offset!");
static_assert(offsetof(UP2TrajectoryGenerator, GroundNavCache) == 0x000380, "Member 'UP2TrajectoryGenerator::GroundNavCache' has a wrong offset!");
static_assert(offsetof(UP2TrajectoryGenerator, SkComp) == 0x000388, "Member 'UP2TrajectoryGenerator::SkComp' has a wrong offset!");

// Class AICommon.P2TrajectoryGeneratorTickSubsystem
// 0x0010 (0x0050 - 0x0040)
class UP2TrajectoryGeneratorTickSubsystem final : public UTickableWorldSubsystem
{
public:
	uint8                                         Pad_40[0x10];                                      // 0x0040(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"P2TrajectoryGeneratorTickSubsystem">();
	}
	static class UP2TrajectoryGeneratorTickSubsystem* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UP2TrajectoryGeneratorTickSubsystem>();
	}
};
static_assert(alignof(UP2TrajectoryGeneratorTickSubsystem) == 0x000008, "Wrong alignment on UP2TrajectoryGeneratorTickSubsystem");
static_assert(sizeof(UP2TrajectoryGeneratorTickSubsystem) == 0x000050, "Wrong size on UP2TrajectoryGeneratorTickSubsystem");

// Class AICommon.P2VaultNavLink
// 0x0020 (0x05A0 - 0x0580)
class AP2VaultNavLink final : public AP2MercunaNavLink
{
public:
	uint8                                         Pad_580[0x20];                                     // 0x0580(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"P2VaultNavLink">();
	}
	static class AP2VaultNavLink* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<AP2VaultNavLink>();
	}
};
static_assert(alignof(AP2VaultNavLink) == 0x000010, "Wrong alignment on AP2VaultNavLink");
static_assert(sizeof(AP2VaultNavLink) == 0x0005A0, "Wrong size on AP2VaultNavLink");

// Class AICommon.P2WeakSpotComponent
// 0x0018 (0x00D8 - 0x00C0)
class UP2WeakSpotComponent final : public UActorComponent
{
public:
	struct FGameplayTag                           DestroyedZoneEventTag;                             // 0x00C0(0x0008)(Edit, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<struct FP2WeakSpotState>               WeakSpotStates;                                    // 0x00C8(0x0010)(Net, ZeroConstructor, Protected, NativeAccessSpecifierProtected)

public:
	void HandleDamage(const struct FP2DamageData& DamageData)	 // 0x4788554;

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"P2WeakSpotComponent">();
	}
	static class UP2WeakSpotComponent* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UP2WeakSpotComponent>();
	}
};
static_assert(alignof(UP2WeakSpotComponent) == 0x000008, "Wrong alignment on UP2WeakSpotComponent");
static_assert(sizeof(UP2WeakSpotComponent) == 0x0000D8, "Wrong size on UP2WeakSpotComponent");
static_assert(offsetof(UP2WeakSpotComponent, DestroyedZoneEventTag) == 0x0000C0, "Member 'UP2WeakSpotComponent::DestroyedZoneEventTag' has a wrong offset!");
static_assert(offsetof(UP2WeakSpotComponent, WeakSpotStates) == 0x0000C8, "Member 'UP2WeakSpotComponent::WeakSpotStates' has a wrong offset!");

// Class AICommon.P2WeakSpotDamageCalculation
// 0x0010 (0x00A8 - 0x0098)
class UP2WeakSpotDamageCalculation final : public UP2DamageCalculation
{
public:
	TArray<struct FP2WeakSpotConfig>              WeakSpotConfigs;                                   // 0x0098(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"P2WeakSpotDamageCalculation">();
	}
	static class UP2WeakSpotDamageCalculation* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UP2WeakSpotDamageCalculation>();
	}
};
static_assert(alignof(UP2WeakSpotDamageCalculation) == 0x000008, "Wrong alignment on UP2WeakSpotDamageCalculation");
static_assert(sizeof(UP2WeakSpotDamageCalculation) == 0x0000A8, "Wrong size on UP2WeakSpotDamageCalculation");
static_assert(offsetof(UP2WeakSpotDamageCalculation, WeakSpotConfigs) == 0x000098, "Member 'UP2WeakSpotDamageCalculation::WeakSpotConfigs' has a wrong offset!");

// Class AICommon.P2WildCatImpatienceConfig
// 0x0060 (0x0090 - 0x0030)
class UP2WildCatImpatienceConfig final : public UDataAsset
{
public:
	float                                         FastIncreaseRateValue;                             // 0x0030(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         IncreaseRateValue;                                 // 0x0034(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DecreaseRateValue;                                 // 0x0038(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FarDistanceValue;                                  // 0x003C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MovingAwaySpeedThreshold;                          // 0x0040(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MovingInSpeedThreshold;                            // 0x0044(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FovAngleDeg;                                       // 0x0048(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FarViewDistance;                                   // 0x004C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MiddleViewDistance;                                // 0x0050(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CloseViewDistance;                                 // 0x0054(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_58[0x38];                                      // 0x0058(0x0038)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"P2WildCatImpatienceConfig">();
	}
	static class UP2WildCatImpatienceConfig* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UP2WildCatImpatienceConfig>();
	}
};
static_assert(alignof(UP2WildCatImpatienceConfig) == 0x000008, "Wrong alignment on UP2WildCatImpatienceConfig");
static_assert(sizeof(UP2WildCatImpatienceConfig) == 0x000090, "Wrong size on UP2WildCatImpatienceConfig");
static_assert(offsetof(UP2WildCatImpatienceConfig, FastIncreaseRateValue) == 0x000030, "Member 'UP2WildCatImpatienceConfig::FastIncreaseRateValue' has a wrong offset!");
static_assert(offsetof(UP2WildCatImpatienceConfig, IncreaseRateValue) == 0x000034, "Member 'UP2WildCatImpatienceConfig::IncreaseRateValue' has a wrong offset!");
static_assert(offsetof(UP2WildCatImpatienceConfig, DecreaseRateValue) == 0x000038, "Member 'UP2WildCatImpatienceConfig::DecreaseRateValue' has a wrong offset!");
static_assert(offsetof(UP2WildCatImpatienceConfig, FarDistanceValue) == 0x00003C, "Member 'UP2WildCatImpatienceConfig::FarDistanceValue' has a wrong offset!");
static_assert(offsetof(UP2WildCatImpatienceConfig, MovingAwaySpeedThreshold) == 0x000040, "Member 'UP2WildCatImpatienceConfig::MovingAwaySpeedThreshold' has a wrong offset!");
static_assert(offsetof(UP2WildCatImpatienceConfig, MovingInSpeedThreshold) == 0x000044, "Member 'UP2WildCatImpatienceConfig::MovingInSpeedThreshold' has a wrong offset!");
static_assert(offsetof(UP2WildCatImpatienceConfig, FovAngleDeg) == 0x000048, "Member 'UP2WildCatImpatienceConfig::FovAngleDeg' has a wrong offset!");
static_assert(offsetof(UP2WildCatImpatienceConfig, FarViewDistance) == 0x00004C, "Member 'UP2WildCatImpatienceConfig::FarViewDistance' has a wrong offset!");
static_assert(offsetof(UP2WildCatImpatienceConfig, MiddleViewDistance) == 0x000050, "Member 'UP2WildCatImpatienceConfig::MiddleViewDistance' has a wrong offset!");
static_assert(offsetof(UP2WildCatImpatienceConfig, CloseViewDistance) == 0x000054, "Member 'UP2WildCatImpatienceConfig::CloseViewDistance' has a wrong offset!");

// Class AICommon.P2WildCatImpatienceComponent
// 0x0020 (0x00E0 - 0x00C0)
class UP2WildCatImpatienceComponent final : public UActorComponent
{
public:
	uint8                                         Pad_C0[0x8];                                       // 0x00C0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UP2WildCatImpatienceConfig*             Config;                                            // 0x00C8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D0[0x10];                                      // 0x00D0(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ReportDamaged(class UP2HealthComponent* HealthComponent, class AActor* Instigator, float Damage)	 // 0x47889c0;
	void ReportTargetChanged(const class AActor* Actor, class AActor* InNewTarget, class AActor* InOldTarget)	 // 0x4788b6c;
	void Reset()	 // 0x4788d9c;

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"P2WildCatImpatienceComponent">();
	}
	static class UP2WildCatImpatienceComponent* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UP2WildCatImpatienceComponent>();
	}
};
static_assert(alignof(UP2WildCatImpatienceComponent) == 0x000008, "Wrong alignment on UP2WildCatImpatienceComponent");
static_assert(sizeof(UP2WildCatImpatienceComponent) == 0x0000E0, "Wrong size on UP2WildCatImpatienceComponent");
static_assert(offsetof(UP2WildCatImpatienceComponent, Config) == 0x0000C8, "Member 'UP2WildCatImpatienceComponent::Config' has a wrong offset!");

// Class AICommon.P2WildCatTraversalTestActor
// 0x00C8 (0x0378 - 0x02B0)
class AP2WildCatTraversalTestActor final : public AActor
{
public:
	double                                        MaxLaunchVelocity;                                 // 0x02B0(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MinimumApexHeight;                                 // 0x02B8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Timeout;                                           // 0x02BC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDrawDebugTrajectory;                              // 0x02C0(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C1[0x7];                                      // 0x02C1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class USkeletalMeshComponent*                 SkeletalMeshComponent;                             // 0x02C8(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class AActor*                                 TargetActor;                                       // 0x02D0(0x0008)(Edit, ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2D8[0xA0];                                     // 0x02D8(0x00A0)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	double GetApexToImpactAngleDeg() const	 // 0x4788204;
	struct FVector GetCurrentLocation() const	 // 0x478822c;
	float GetCurrentPhaseProgress() const	 // 0x4788260;
	struct FVector GetCurrentVelocity() const	 // 0x4788280;
	struct FVector GetDirectionFromApexToImpact() const	 // 0x47882b4;
	float GetJumpProgress() const	 // 0x47882ec;
	double GetLaunchPitchAngleDeg() const	 // 0x478830c;
	struct FVector GetLaunchVelocity() const	 // 0x4788364;
	struct FVector GetLocationAtTime(float Time) const	 // 0x478838c;
	struct FVector GetVelocityAtTime(float Time) const	 // 0x4788470;
	bool IsBeforeApex() const	 // 0x4788644;

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"P2WildCatTraversalTestActor">();
	}
	static class AP2WildCatTraversalTestActor* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<AP2WildCatTraversalTestActor>();
	}
};
static_assert(alignof(AP2WildCatTraversalTestActor) == 0x000008, "Wrong alignment on AP2WildCatTraversalTestActor");
static_assert(sizeof(AP2WildCatTraversalTestActor) == 0x000378, "Wrong size on AP2WildCatTraversalTestActor");
static_assert(offsetof(AP2WildCatTraversalTestActor, MaxLaunchVelocity) == 0x0002B0, "Member 'AP2WildCatTraversalTestActor::MaxLaunchVelocity' has a wrong offset!");
static_assert(offsetof(AP2WildCatTraversalTestActor, MinimumApexHeight) == 0x0002B8, "Member 'AP2WildCatTraversalTestActor::MinimumApexHeight' has a wrong offset!");
static_assert(offsetof(AP2WildCatTraversalTestActor, Timeout) == 0x0002BC, "Member 'AP2WildCatTraversalTestActor::Timeout' has a wrong offset!");
static_assert(offsetof(AP2WildCatTraversalTestActor, bDrawDebugTrajectory) == 0x0002C0, "Member 'AP2WildCatTraversalTestActor::bDrawDebugTrajectory' has a wrong offset!");
static_assert(offsetof(AP2WildCatTraversalTestActor, SkeletalMeshComponent) == 0x0002C8, "Member 'AP2WildCatTraversalTestActor::SkeletalMeshComponent' has a wrong offset!");
static_assert(offsetof(AP2WildCatTraversalTestActor, TargetActor) == 0x0002D0, "Member 'AP2WildCatTraversalTestActor::TargetActor' has a wrong offset!");

// Class AICommon.P2WindowNavLink
// 0x0010 (0x05F0 - 0x05E0)
class AP2WindowNavLink final : public AP2BreakableNavLink
{
public:
	EP2MercunaNavLinkTraversalType                LowestAllowedNavLinkTraversalType;                 // 0x05E0(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5E1[0x3];                                      // 0x05E1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         VaultHeight;                                       // 0x05E4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         HighVaultHeight;                                   // 0x05E8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_5EC[0x4];                                      // 0x05EC(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnGlassDestroyed(class AP2Window* InWindow)	 // 0x4788750;

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"P2WindowNavLink">();
	}
	static class AP2WindowNavLink* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<AP2WindowNavLink>();
	}
};
static_assert(alignof(AP2WindowNavLink) == 0x000010, "Wrong alignment on AP2WindowNavLink");
static_assert(sizeof(AP2WindowNavLink) == 0x0005F0, "Wrong size on AP2WindowNavLink");
static_assert(offsetof(AP2WindowNavLink, LowestAllowedNavLinkTraversalType) == 0x0005E0, "Member 'AP2WindowNavLink::LowestAllowedNavLinkTraversalType' has a wrong offset!");
static_assert(offsetof(AP2WindowNavLink, VaultHeight) == 0x0005E4, "Member 'AP2WindowNavLink::VaultHeight' has a wrong offset!");
static_assert(offsetof(AP2WindowNavLink, HighVaultHeight) == 0x0005E8, "Member 'AP2WindowNavLink::HighVaultHeight' has a wrong offset!");

// Class AICommon.UP2BTDecorator_HasRecentSharedStimuli
// 0x0008 (0x0070 - 0x0068)
class UUP2BTDecorator_HasRecentSharedStimuli final : public UBTDecorator
{
public:
	float                                         AgeThreshold;                                      // 0x0068(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_6C[0x4];                                       // 0x006C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"UP2BTDecorator_HasRecentSharedStimuli">();
	}
	static class UUP2BTDecorator_HasRecentSharedStimuli* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UUP2BTDecorator_HasRecentSharedStimuli>();
	}
};
static_assert(alignof(UUP2BTDecorator_HasRecentSharedStimuli) == 0x000008, "Wrong alignment on UUP2BTDecorator_HasRecentSharedStimuli");
static_assert(sizeof(UUP2BTDecorator_HasRecentSharedStimuli) == 0x000070, "Wrong size on UUP2BTDecorator_HasRecentSharedStimuli");
static_assert(offsetof(UUP2BTDecorator_HasRecentSharedStimuli, AgeThreshold) == 0x000068, "Member 'UUP2BTDecorator_HasRecentSharedStimuli::AgeThreshold' has a wrong offset!");

// Class AICommon.P2BTService_MuntjacSprayService
// 0x0008 (0x00C0 - 0x00B8)
class UP2BTService_MuntjacSprayService final : public UP2BTService_TryActivateAbility
{
public:
	ECollisionChannel                             CollisionChannel;                                  // 0x00B8(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_B9[0x3];                                       // 0x00B9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MaxDistance;                                       // 0x00BC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"P2BTService_MuntjacSprayService">();
	}
	static class UP2BTService_MuntjacSprayService* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UP2BTService_MuntjacSprayService>();
	}
};
static_assert(alignof(UP2BTService_MuntjacSprayService) == 0x000008, "Wrong alignment on UP2BTService_MuntjacSprayService");
static_assert(sizeof(UP2BTService_MuntjacSprayService) == 0x0000C0, "Wrong size on UP2BTService_MuntjacSprayService");
static_assert(offsetof(UP2BTService_MuntjacSprayService, CollisionChannel) == 0x0000B8, "Member 'UP2BTService_MuntjacSprayService::CollisionChannel' has a wrong offset!");
static_assert(offsetof(UP2BTService_MuntjacSprayService, MaxDistance) == 0x0000BC, "Member 'UP2BTService_MuntjacSprayService::MaxDistance' has a wrong offset!");

// Class AICommon.P2AIDataProvider_CoverMinDot
// 0x0008 (0x0048 - 0x0040)
class UP2AIDataProvider_CoverMinDot final : public UAIDataProvider_QueryParams
{
public:
	uint8                                         bFront : 1;                                        // 0x0040(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         Pad_41[0x7];                                       // 0x0041(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"P2AIDataProvider_CoverMinDot">();
	}
	static class UP2AIDataProvider_CoverMinDot* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UP2AIDataProvider_CoverMinDot>();
	}
};
static_assert(alignof(UP2AIDataProvider_CoverMinDot) == 0x000008, "Wrong alignment on UP2AIDataProvider_CoverMinDot");
static_assert(sizeof(UP2AIDataProvider_CoverMinDot) == 0x000048, "Wrong size on UP2AIDataProvider_CoverMinDot");

// Class AICommon.P2AIDataProvider_EngagementRange
// 0x0008 (0x0048 - 0x0040)
class UP2AIDataProvider_EngagementRange final : public UAIDataProvider_QueryParams
{
public:
	uint8                                         bIdealRange : 1;                                   // 0x0040(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bMinRange : 1;                                     // 0x0040(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         Pad_41[0x3];                                       // 0x0041(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Factor;                                            // 0x0044(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"P2AIDataProvider_EngagementRange">();
	}
	static class UP2AIDataProvider_EngagementRange* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UP2AIDataProvider_EngagementRange>();
	}
};
static_assert(alignof(UP2AIDataProvider_EngagementRange) == 0x000008, "Wrong alignment on UP2AIDataProvider_EngagementRange");
static_assert(sizeof(UP2AIDataProvider_EngagementRange) == 0x000048, "Wrong size on UP2AIDataProvider_EngagementRange");
static_assert(offsetof(UP2AIDataProvider_EngagementRange, Factor) == 0x000044, "Member 'UP2AIDataProvider_EngagementRange::Factor' has a wrong offset!");

// Class AICommon.P2AIDataProvider_ObjectiveAreaRadius
// 0x0008 (0x0048 - 0x0040)
class UP2AIDataProvider_ObjectiveAreaRadius final : public UAIDataProvider_QueryParams
{
public:
	float                                         Factor;                                            // 0x0040(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_44[0x4];                                       // 0x0044(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()	 // 0x0
	{
		return StaticClassImpl<"P2AIDataProvider_ObjectiveAreaRadius">();
	}
	static class UP2AIDataProvider_ObjectiveAreaRadius* GetDefaultObj()	 // 0x0
	{
		return GetDefaultObjImpl<UP2AIDataProvider_ObjectiveAreaRadius>();
	}
};
static_assert(alignof(UP2AIDataProvider_ObjectiveAreaRadius) == 0x000008, "Wrong alignment on UP2AIDataProvider_ObjectiveAreaRadius");
static_assert(sizeof(UP2AIDataProvider_ObjectiveAreaRadius) == 0x000048, "Wrong size on UP2AIDataProvider_ObjectiveAreaRadius");
static_assert(offsetof(UP2AIDataProvider_ObjectiveAreaRadius, Factor) == 0x000040, "Member 'UP2AIDataProvider_ObjectiveAreaRadius::Factor' has a wrong offset!");

}

