#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: MotionSymphony

#include "Basic.hpp"

#include "CoreUObject_structs.hpp"
#include "MotionSymphony_structs.hpp"


namespace SDK::Params
{

// Function MotionSymphony.DistanceMatching.DetectTransitions
// 0x0004 (0x0004 - 0x0000)
struct DistanceMatching_DetectTransitions final
{
public:
	float                                         DeltaTime;                                         // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DistanceMatching_DetectTransitions) == 0x000004, "Wrong alignment on DistanceMatching_DetectTransitions");
static_assert(sizeof(DistanceMatching_DetectTransitions) == 0x000004, "Wrong size on DistanceMatching_DetectTransitions");
static_assert(offsetof(DistanceMatching_DetectTransitions, DeltaTime) == 0x000000, "Member 'DistanceMatching_DetectTransitions::DeltaTime' has a wrong offset!");

// Function MotionSymphony.DistanceMatching.GetAndConsumeTriggeredTransition
// 0x0001 (0x0001 - 0x0000)
struct DistanceMatching_GetAndConsumeTriggeredTransition final
{
public:
	EDistanceMatchTrigger                         ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DistanceMatching_GetAndConsumeTriggeredTransition) == 0x000001, "Wrong alignment on DistanceMatching_GetAndConsumeTriggeredTransition");
static_assert(sizeof(DistanceMatching_GetAndConsumeTriggeredTransition) == 0x000001, "Wrong size on DistanceMatching_GetAndConsumeTriggeredTransition");
static_assert(offsetof(DistanceMatching_GetAndConsumeTriggeredTransition, ReturnValue) == 0x000000, "Member 'DistanceMatching_GetAndConsumeTriggeredTransition::ReturnValue' has a wrong offset!");

// Function MotionSymphony.DistanceMatching.GetMarkerDistance
// 0x0004 (0x0004 - 0x0000)
struct DistanceMatching_GetMarkerDistance final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DistanceMatching_GetMarkerDistance) == 0x000004, "Wrong alignment on DistanceMatching_GetMarkerDistance");
static_assert(sizeof(DistanceMatching_GetMarkerDistance) == 0x000004, "Wrong size on DistanceMatching_GetMarkerDistance");
static_assert(offsetof(DistanceMatching_GetMarkerDistance, ReturnValue) == 0x000000, "Member 'DistanceMatching_GetMarkerDistance::ReturnValue' has a wrong offset!");

// Function MotionSymphony.DistanceMatching.TriggerJump
// 0x0004 (0x0004 - 0x0000)
struct DistanceMatching_TriggerJump final
{
public:
	float                                         DeltaTime;                                         // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DistanceMatching_TriggerJump) == 0x000004, "Wrong alignment on DistanceMatching_TriggerJump");
static_assert(sizeof(DistanceMatching_TriggerJump) == 0x000004, "Wrong size on DistanceMatching_TriggerJump");
static_assert(offsetof(DistanceMatching_TriggerJump, DeltaTime) == 0x000000, "Member 'DistanceMatching_TriggerJump::DeltaTime' has a wrong offset!");

// Function MotionSymphony.DistanceMatching.TriggerPlant
// 0x0004 (0x0004 - 0x0000)
struct DistanceMatching_TriggerPlant final
{
public:
	float                                         DeltaTime;                                         // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DistanceMatching_TriggerPlant) == 0x000004, "Wrong alignment on DistanceMatching_TriggerPlant");
static_assert(sizeof(DistanceMatching_TriggerPlant) == 0x000004, "Wrong size on DistanceMatching_TriggerPlant");
static_assert(offsetof(DistanceMatching_TriggerPlant, DeltaTime) == 0x000000, "Member 'DistanceMatching_TriggerPlant::DeltaTime' has a wrong offset!");

// Function MotionSymphony.DistanceMatching.TriggerStart
// 0x0004 (0x0004 - 0x0000)
struct DistanceMatching_TriggerStart final
{
public:
	float                                         DeltaTime;                                         // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DistanceMatching_TriggerStart) == 0x000004, "Wrong alignment on DistanceMatching_TriggerStart");
static_assert(sizeof(DistanceMatching_TriggerStart) == 0x000004, "Wrong size on DistanceMatching_TriggerStart");
static_assert(offsetof(DistanceMatching_TriggerStart, DeltaTime) == 0x000000, "Member 'DistanceMatching_TriggerStart::DeltaTime' has a wrong offset!");

// Function MotionSymphony.DistanceMatching.TriggerStop
// 0x0004 (0x0004 - 0x0000)
struct DistanceMatching_TriggerStop final
{
public:
	float                                         DeltaTime;                                         // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DistanceMatching_TriggerStop) == 0x000004, "Wrong alignment on DistanceMatching_TriggerStop");
static_assert(sizeof(DistanceMatching_TriggerStop) == 0x000004, "Wrong size on DistanceMatching_TriggerStop");
static_assert(offsetof(DistanceMatching_TriggerStop, DeltaTime) == 0x000000, "Member 'DistanceMatching_TriggerStop::DeltaTime' has a wrong offset!");

// Function MotionSymphony.DistanceMatching.TriggerTurnInPlaceTo
// 0x0018 (0x0018 - 0x0000)
struct DistanceMatching_TriggerTurnInPlaceTo final
{
public:
	struct FVector                                DesiredDirection;                                  // 0x0000(0x0018)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DistanceMatching_TriggerTurnInPlaceTo) == 0x000008, "Wrong alignment on DistanceMatching_TriggerTurnInPlaceTo");
static_assert(sizeof(DistanceMatching_TriggerTurnInPlaceTo) == 0x000018, "Wrong size on DistanceMatching_TriggerTurnInPlaceTo");
static_assert(offsetof(DistanceMatching_TriggerTurnInPlaceTo, DesiredDirection) == 0x000000, "Member 'DistanceMatching_TriggerTurnInPlaceTo::DesiredDirection' has a wrong offset!");

// Function MotionSymphony.MMBlueprintFunctionLibrary.ConstructMotionInputFeatureArray
// 0x0020 (0x0020 - 0x0000)
struct MMBlueprintFunctionLibrary_ConstructMotionInputFeatureArray final
{
public:
	struct FMotionMatchingInputData               InputData;                                         // 0x0000(0x0010)(Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	class AActor*                                 Actor;                                             // 0x0010(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMotionMatchConfig*                     MotionConfig;                                      // 0x0018(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MMBlueprintFunctionLibrary_ConstructMotionInputFeatureArray) == 0x000008, "Wrong alignment on MMBlueprintFunctionLibrary_ConstructMotionInputFeatureArray");
static_assert(sizeof(MMBlueprintFunctionLibrary_ConstructMotionInputFeatureArray) == 0x000020, "Wrong size on MMBlueprintFunctionLibrary_ConstructMotionInputFeatureArray");
static_assert(offsetof(MMBlueprintFunctionLibrary_ConstructMotionInputFeatureArray, InputData) == 0x000000, "Member 'MMBlueprintFunctionLibrary_ConstructMotionInputFeatureArray::InputData' has a wrong offset!");
static_assert(offsetof(MMBlueprintFunctionLibrary_ConstructMotionInputFeatureArray, Actor) == 0x000010, "Member 'MMBlueprintFunctionLibrary_ConstructMotionInputFeatureArray::Actor' has a wrong offset!");
static_assert(offsetof(MMBlueprintFunctionLibrary_ConstructMotionInputFeatureArray, MotionConfig) == 0x000018, "Member 'MMBlueprintFunctionLibrary_ConstructMotionInputFeatureArray::MotionConfig' has a wrong offset!");

// Function MotionSymphony.MMBlueprintFunctionLibrary.CreateInputDataFromTrajectory
// 0x0020 (0x0020 - 0x0000)
struct MMBlueprintFunctionLibrary_CreateInputDataFromTrajectory final
{
public:
	struct FTrajectory                            Trajectory;                                        // 0x0000(0x0010)(Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	struct FMotionMatchingInputData               InputData;                                         // 0x0010(0x0010)(Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(MMBlueprintFunctionLibrary_CreateInputDataFromTrajectory) == 0x000008, "Wrong alignment on MMBlueprintFunctionLibrary_CreateInputDataFromTrajectory");
static_assert(sizeof(MMBlueprintFunctionLibrary_CreateInputDataFromTrajectory) == 0x000020, "Wrong size on MMBlueprintFunctionLibrary_CreateInputDataFromTrajectory");
static_assert(offsetof(MMBlueprintFunctionLibrary_CreateInputDataFromTrajectory, Trajectory) == 0x000000, "Member 'MMBlueprintFunctionLibrary_CreateInputDataFromTrajectory::Trajectory' has a wrong offset!");
static_assert(offsetof(MMBlueprintFunctionLibrary_CreateInputDataFromTrajectory, InputData) == 0x000010, "Member 'MMBlueprintFunctionLibrary_CreateInputDataFromTrajectory::InputData' has a wrong offset!");

// Function MotionSymphony.MMBlueprintFunctionLibrary.GetInputVectorRelativeToCamera
// 0x0038 (0x0038 - 0x0000)
struct MMBlueprintFunctionLibrary_GetInputVectorRelativeToCamera final
{
public:
	struct FVector                                InputVector;                                       // 0x0000(0x0018)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCameraComponent*                       CameraComponent;                                   // 0x0018(0x0008)(Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                ReturnValue;                                       // 0x0020(0x0018)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MMBlueprintFunctionLibrary_GetInputVectorRelativeToCamera) == 0x000008, "Wrong alignment on MMBlueprintFunctionLibrary_GetInputVectorRelativeToCamera");
static_assert(sizeof(MMBlueprintFunctionLibrary_GetInputVectorRelativeToCamera) == 0x000038, "Wrong size on MMBlueprintFunctionLibrary_GetInputVectorRelativeToCamera");
static_assert(offsetof(MMBlueprintFunctionLibrary_GetInputVectorRelativeToCamera, InputVector) == 0x000000, "Member 'MMBlueprintFunctionLibrary_GetInputVectorRelativeToCamera::InputVector' has a wrong offset!");
static_assert(offsetof(MMBlueprintFunctionLibrary_GetInputVectorRelativeToCamera, CameraComponent) == 0x000018, "Member 'MMBlueprintFunctionLibrary_GetInputVectorRelativeToCamera::CameraComponent' has a wrong offset!");
static_assert(offsetof(MMBlueprintFunctionLibrary_GetInputVectorRelativeToCamera, ReturnValue) == 0x000020, "Member 'MMBlueprintFunctionLibrary_GetInputVectorRelativeToCamera::ReturnValue' has a wrong offset!");

// Function MotionSymphony.MMBlueprintFunctionLibrary.GetVectorRelativeToCamera
// 0x0028 (0x0028 - 0x0000)
struct MMBlueprintFunctionLibrary_GetVectorRelativeToCamera final
{
public:
	float                                         InputX;                                            // 0x0000(0x0004)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         InputY;                                            // 0x0004(0x0004)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCameraComponent*                       CameraComponent;                                   // 0x0008(0x0008)(Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                ReturnValue;                                       // 0x0010(0x0018)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MMBlueprintFunctionLibrary_GetVectorRelativeToCamera) == 0x000008, "Wrong alignment on MMBlueprintFunctionLibrary_GetVectorRelativeToCamera");
static_assert(sizeof(MMBlueprintFunctionLibrary_GetVectorRelativeToCamera) == 0x000028, "Wrong size on MMBlueprintFunctionLibrary_GetVectorRelativeToCamera");
static_assert(offsetof(MMBlueprintFunctionLibrary_GetVectorRelativeToCamera, InputX) == 0x000000, "Member 'MMBlueprintFunctionLibrary_GetVectorRelativeToCamera::InputX' has a wrong offset!");
static_assert(offsetof(MMBlueprintFunctionLibrary_GetVectorRelativeToCamera, InputY) == 0x000004, "Member 'MMBlueprintFunctionLibrary_GetVectorRelativeToCamera::InputY' has a wrong offset!");
static_assert(offsetof(MMBlueprintFunctionLibrary_GetVectorRelativeToCamera, CameraComponent) == 0x000008, "Member 'MMBlueprintFunctionLibrary_GetVectorRelativeToCamera::CameraComponent' has a wrong offset!");
static_assert(offsetof(MMBlueprintFunctionLibrary_GetVectorRelativeToCamera, ReturnValue) == 0x000010, "Member 'MMBlueprintFunctionLibrary_GetVectorRelativeToCamera::ReturnValue' has a wrong offset!");

// Function MotionSymphony.MMBlueprintFunctionLibrary.InitializeTrajectory
// 0x0018 (0x0018 - 0x0000)
struct MMBlueprintFunctionLibrary_InitializeTrajectory final
{
public:
	struct FTrajectory                            OutTrajectory;                                     // 0x0000(0x0010)(Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	int32                                         TrajectoryCount;                                   // 0x0010(0x0004)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(MMBlueprintFunctionLibrary_InitializeTrajectory) == 0x000008, "Wrong alignment on MMBlueprintFunctionLibrary_InitializeTrajectory");
static_assert(sizeof(MMBlueprintFunctionLibrary_InitializeTrajectory) == 0x000018, "Wrong size on MMBlueprintFunctionLibrary_InitializeTrajectory");
static_assert(offsetof(MMBlueprintFunctionLibrary_InitializeTrajectory, OutTrajectory) == 0x000000, "Member 'MMBlueprintFunctionLibrary_InitializeTrajectory::OutTrajectory' has a wrong offset!");
static_assert(offsetof(MMBlueprintFunctionLibrary_InitializeTrajectory, TrajectoryCount) == 0x000010, "Member 'MMBlueprintFunctionLibrary_InitializeTrajectory::TrajectoryCount' has a wrong offset!");

// Function MotionSymphony.MMBlueprintFunctionLibrary.SetTrajectoryPoint
// 0x0038 (0x0038 - 0x0000)
struct MMBlueprintFunctionLibrary_SetTrajectoryPoint final
{
public:
	struct FTrajectory                            OutTrajectory;                                     // 0x0000(0x0010)(Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	int32                                         Index_0;                                           // 0x0010(0x0004)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                Position;                                          // 0x0018(0x0018)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RotationZ;                                         // 0x0030(0x0004)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_34[0x4];                                       // 0x0034(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(MMBlueprintFunctionLibrary_SetTrajectoryPoint) == 0x000008, "Wrong alignment on MMBlueprintFunctionLibrary_SetTrajectoryPoint");
static_assert(sizeof(MMBlueprintFunctionLibrary_SetTrajectoryPoint) == 0x000038, "Wrong size on MMBlueprintFunctionLibrary_SetTrajectoryPoint");
static_assert(offsetof(MMBlueprintFunctionLibrary_SetTrajectoryPoint, OutTrajectory) == 0x000000, "Member 'MMBlueprintFunctionLibrary_SetTrajectoryPoint::OutTrajectory' has a wrong offset!");
static_assert(offsetof(MMBlueprintFunctionLibrary_SetTrajectoryPoint, Index_0) == 0x000010, "Member 'MMBlueprintFunctionLibrary_SetTrajectoryPoint::Index_0' has a wrong offset!");
static_assert(offsetof(MMBlueprintFunctionLibrary_SetTrajectoryPoint, Position) == 0x000018, "Member 'MMBlueprintFunctionLibrary_SetTrajectoryPoint::Position' has a wrong offset!");
static_assert(offsetof(MMBlueprintFunctionLibrary_SetTrajectoryPoint, RotationZ) == 0x000030, "Member 'MMBlueprintFunctionLibrary_SetTrajectoryPoint::RotationZ' has a wrong offset!");

// Function MotionSymphony.MMBlueprintFunctionLibrary.TransformFromUpForwardAxis
// 0x0070 (0x0070 - 0x0000)
struct MMBlueprintFunctionLibrary_TransformFromUpForwardAxis final
{
public:
	struct FTransform                             OutTransform;                                      // 0x0000(0x0060)(Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EAllAxis                                      UpAxis;                                            // 0x0060(0x0001)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EAllAxis                                      ForwardAxis;                                       // 0x0061(0x0001)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_62[0xE];                                       // 0x0062(0x000E)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(MMBlueprintFunctionLibrary_TransformFromUpForwardAxis) == 0x000010, "Wrong alignment on MMBlueprintFunctionLibrary_TransformFromUpForwardAxis");
static_assert(sizeof(MMBlueprintFunctionLibrary_TransformFromUpForwardAxis) == 0x000070, "Wrong size on MMBlueprintFunctionLibrary_TransformFromUpForwardAxis");
static_assert(offsetof(MMBlueprintFunctionLibrary_TransformFromUpForwardAxis, OutTransform) == 0x000000, "Member 'MMBlueprintFunctionLibrary_TransformFromUpForwardAxis::OutTransform' has a wrong offset!");
static_assert(offsetof(MMBlueprintFunctionLibrary_TransformFromUpForwardAxis, UpAxis) == 0x000060, "Member 'MMBlueprintFunctionLibrary_TransformFromUpForwardAxis::UpAxis' has a wrong offset!");
static_assert(offsetof(MMBlueprintFunctionLibrary_TransformFromUpForwardAxis, ForwardAxis) == 0x000061, "Member 'MMBlueprintFunctionLibrary_TransformFromUpForwardAxis::ForwardAxis' has a wrong offset!");

// Function MotionSymphony.MotionTag.GetTagName
// 0x0010 (0x0010 - 0x0000)
struct MotionTag_GetTagName final
{
public:
	class FString                                 ReturnValue;                                       // 0x0000(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MotionTag_GetTagName) == 0x000008, "Wrong alignment on MotionTag_GetTagName");
static_assert(sizeof(MotionTag_GetTagName) == 0x000010, "Wrong size on MotionTag_GetTagName");
static_assert(offsetof(MotionTag_GetTagName, ReturnValue) == 0x000000, "Member 'MotionTag_GetTagName::ReturnValue' has a wrong offset!");

// Function MotionSymphony.MotionTag.Received_RunPreProcessForTag
// 0x0004 (0x0004 - 0x0000)
struct MotionTag_Received_RunPreProcessForTag final
{
public:
	float                                         PoseInterval;                                      // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MotionTag_Received_RunPreProcessForTag) == 0x000004, "Wrong alignment on MotionTag_Received_RunPreProcessForTag");
static_assert(sizeof(MotionTag_Received_RunPreProcessForTag) == 0x000004, "Wrong size on MotionTag_Received_RunPreProcessForTag");
static_assert(offsetof(MotionTag_Received_RunPreProcessForTag, PoseInterval) == 0x000000, "Member 'MotionTag_Received_RunPreProcessForTag::PoseInterval' has a wrong offset!");

// Function MotionSymphony.MSFootLockerMath.AngleBetween
// 0x0038 (0x0038 - 0x0000)
struct MSFootLockerMath_AngleBetween final
{
public:
	struct FVector                                A;                                                 // 0x0000(0x0018)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                B;                                                 // 0x0018(0x0018)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ReturnValue;                                       // 0x0030(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_34[0x4];                                       // 0x0034(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(MSFootLockerMath_AngleBetween) == 0x000008, "Wrong alignment on MSFootLockerMath_AngleBetween");
static_assert(sizeof(MSFootLockerMath_AngleBetween) == 0x000038, "Wrong size on MSFootLockerMath_AngleBetween");
static_assert(offsetof(MSFootLockerMath_AngleBetween, A) == 0x000000, "Member 'MSFootLockerMath_AngleBetween::A' has a wrong offset!");
static_assert(offsetof(MSFootLockerMath_AngleBetween, B) == 0x000018, "Member 'MSFootLockerMath_AngleBetween::B' has a wrong offset!");
static_assert(offsetof(MSFootLockerMath_AngleBetween, ReturnValue) == 0x000030, "Member 'MSFootLockerMath_AngleBetween::ReturnValue' has a wrong offset!");

// Function MotionSymphony.MSFootLockManager.LockFoot
// 0x0008 (0x0008 - 0x0000)
struct MSFootLockManager_LockFoot final
{
public:
	EMSFootLockId                                 FootId;                                            // 0x0000(0x0001)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Duration;                                          // 0x0004(0x0004)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MSFootLockManager_LockFoot) == 0x000004, "Wrong alignment on MSFootLockManager_LockFoot");
static_assert(sizeof(MSFootLockManager_LockFoot) == 0x000008, "Wrong size on MSFootLockManager_LockFoot");
static_assert(offsetof(MSFootLockManager_LockFoot, FootId) == 0x000000, "Member 'MSFootLockManager_LockFoot::FootId' has a wrong offset!");
static_assert(offsetof(MSFootLockManager_LockFoot, Duration) == 0x000004, "Member 'MSFootLockManager_LockFoot::Duration' has a wrong offset!");

// Function MotionSymphony.MSFootLockManager.UnlockFoot
// 0x0001 (0x0001 - 0x0000)
struct MSFootLockManager_UnlockFoot final
{
public:
	EMSFootLockId                                 FootId;                                            // 0x0000(0x0001)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MSFootLockManager_UnlockFoot) == 0x000001, "Wrong alignment on MSFootLockManager_UnlockFoot");
static_assert(sizeof(MSFootLockManager_UnlockFoot) == 0x000001, "Wrong size on MSFootLockManager_UnlockFoot");
static_assert(offsetof(MSFootLockManager_UnlockFoot, FootId) == 0x000000, "Member 'MSFootLockManager_UnlockFoot::FootId' has a wrong offset!");

// Function MotionSymphony.MSFootLockManager.IsFootLocked
// 0x0002 (0x0002 - 0x0000)
struct MSFootLockManager_IsFootLocked final
{
public:
	EMSFootLockId                                 FootId;                                            // 0x0000(0x0001)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0001(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MSFootLockManager_IsFootLocked) == 0x000001, "Wrong alignment on MSFootLockManager_IsFootLocked");
static_assert(sizeof(MSFootLockManager_IsFootLocked) == 0x000002, "Wrong size on MSFootLockManager_IsFootLocked");
static_assert(offsetof(MSFootLockManager_IsFootLocked, FootId) == 0x000000, "Member 'MSFootLockManager_IsFootLocked::FootId' has a wrong offset!");
static_assert(offsetof(MSFootLockManager_IsFootLocked, ReturnValue) == 0x000001, "Member 'MSFootLockManager_IsFootLocked::ReturnValue' has a wrong offset!");

// Function MotionSymphony.TagPoint.Received_PreProcessTag
// 0x0068 (0x0068 - 0x0000)
struct TagPoint_Received_PreProcessTag final
{
public:
	struct FPoseMotionData                        PointPose;                                         // 0x0000(0x0050)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	class UMotionAnimObject*                      OutMotionAnim;                                     // 0x0050(0x0008)(Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMotionDataAsset*                       OutMotionData;                                     // 0x0058(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Time;                                              // 0x0060(0x0004)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0064(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_65[0x3];                                       // 0x0065(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(TagPoint_Received_PreProcessTag) == 0x000008, "Wrong alignment on TagPoint_Received_PreProcessTag");
static_assert(sizeof(TagPoint_Received_PreProcessTag) == 0x000068, "Wrong size on TagPoint_Received_PreProcessTag");
static_assert(offsetof(TagPoint_Received_PreProcessTag, PointPose) == 0x000000, "Member 'TagPoint_Received_PreProcessTag::PointPose' has a wrong offset!");
static_assert(offsetof(TagPoint_Received_PreProcessTag, OutMotionAnim) == 0x000050, "Member 'TagPoint_Received_PreProcessTag::OutMotionAnim' has a wrong offset!");
static_assert(offsetof(TagPoint_Received_PreProcessTag, OutMotionData) == 0x000058, "Member 'TagPoint_Received_PreProcessTag::OutMotionData' has a wrong offset!");
static_assert(offsetof(TagPoint_Received_PreProcessTag, Time) == 0x000060, "Member 'TagPoint_Received_PreProcessTag::Time' has a wrong offset!");
static_assert(offsetof(TagPoint_Received_PreProcessTag, ReturnValue) == 0x000064, "Member 'TagPoint_Received_PreProcessTag::ReturnValue' has a wrong offset!");

// Function MotionSymphony.TagSection.Received_PreProcessPose
// 0x0070 (0x0070 - 0x0000)
struct TagSection_Received_PreProcessPose final
{
public:
	struct FPoseMotionData                        OutPose;                                           // 0x0000(0x0050)(Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	class UMotionAnimObject*                      OutMotionAnim;                                     // 0x0050(0x0008)(Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMotionDataAsset*                       OutMotionData;                                     // 0x0058(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         StartTime;                                         // 0x0060(0x0004)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         EndTime;                                           // 0x0064(0x0004)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0068(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_69[0x7];                                       // 0x0069(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(TagSection_Received_PreProcessPose) == 0x000008, "Wrong alignment on TagSection_Received_PreProcessPose");
static_assert(sizeof(TagSection_Received_PreProcessPose) == 0x000070, "Wrong size on TagSection_Received_PreProcessPose");
static_assert(offsetof(TagSection_Received_PreProcessPose, OutPose) == 0x000000, "Member 'TagSection_Received_PreProcessPose::OutPose' has a wrong offset!");
static_assert(offsetof(TagSection_Received_PreProcessPose, OutMotionAnim) == 0x000050, "Member 'TagSection_Received_PreProcessPose::OutMotionAnim' has a wrong offset!");
static_assert(offsetof(TagSection_Received_PreProcessPose, OutMotionData) == 0x000058, "Member 'TagSection_Received_PreProcessPose::OutMotionData' has a wrong offset!");
static_assert(offsetof(TagSection_Received_PreProcessPose, StartTime) == 0x000060, "Member 'TagSection_Received_PreProcessPose::StartTime' has a wrong offset!");
static_assert(offsetof(TagSection_Received_PreProcessPose, EndTime) == 0x000064, "Member 'TagSection_Received_PreProcessPose::EndTime' has a wrong offset!");
static_assert(offsetof(TagSection_Received_PreProcessPose, ReturnValue) == 0x000068, "Member 'TagSection_Received_PreProcessPose::ReturnValue' has a wrong offset!");

// Function MotionSymphony.TagSection.Received_PreProcessTag
// 0x0020 (0x0020 - 0x0000)
struct TagSection_Received_PreProcessTag final
{
public:
	class UMotionAnimObject*                      OutMotionAnim;                                     // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMotionDataAsset*                       OutMotionData;                                     // 0x0008(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         StartTime;                                         // 0x0010(0x0004)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         EndTime;                                           // 0x0014(0x0004)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0018(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19[0x7];                                       // 0x0019(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(TagSection_Received_PreProcessTag) == 0x000008, "Wrong alignment on TagSection_Received_PreProcessTag");
static_assert(sizeof(TagSection_Received_PreProcessTag) == 0x000020, "Wrong size on TagSection_Received_PreProcessTag");
static_assert(offsetof(TagSection_Received_PreProcessTag, OutMotionAnim) == 0x000000, "Member 'TagSection_Received_PreProcessTag::OutMotionAnim' has a wrong offset!");
static_assert(offsetof(TagSection_Received_PreProcessTag, OutMotionData) == 0x000008, "Member 'TagSection_Received_PreProcessTag::OutMotionData' has a wrong offset!");
static_assert(offsetof(TagSection_Received_PreProcessTag, StartTime) == 0x000010, "Member 'TagSection_Received_PreProcessTag::StartTime' has a wrong offset!");
static_assert(offsetof(TagSection_Received_PreProcessTag, EndTime) == 0x000014, "Member 'TagSection_Received_PreProcessTag::EndTime' has a wrong offset!");
static_assert(offsetof(TagSection_Received_PreProcessTag, ReturnValue) == 0x000018, "Member 'TagSection_Received_PreProcessTag::ReturnValue' has a wrong offset!");

// Function MotionSymphony.TrajectoryErrorWarping.ApplyTrajectoryErrorWarping
// 0x0008 (0x0008 - 0x0000)
struct TrajectoryErrorWarping_ApplyTrajectoryErrorWarping final
{
public:
	float                                         DeltaTime;                                         // 0x0000(0x0004)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PlaybackSpeed;                                     // 0x0004(0x0004)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(TrajectoryErrorWarping_ApplyTrajectoryErrorWarping) == 0x000004, "Wrong alignment on TrajectoryErrorWarping_ApplyTrajectoryErrorWarping");
static_assert(sizeof(TrajectoryErrorWarping_ApplyTrajectoryErrorWarping) == 0x000008, "Wrong size on TrajectoryErrorWarping_ApplyTrajectoryErrorWarping");
static_assert(offsetof(TrajectoryErrorWarping_ApplyTrajectoryErrorWarping, DeltaTime) == 0x000000, "Member 'TrajectoryErrorWarping_ApplyTrajectoryErrorWarping::DeltaTime' has a wrong offset!");
static_assert(offsetof(TrajectoryErrorWarping_ApplyTrajectoryErrorWarping, PlaybackSpeed) == 0x000004, "Member 'TrajectoryErrorWarping_ApplyTrajectoryErrorWarping::PlaybackSpeed' has a wrong offset!");

// Function MotionSymphony.TrajectoryErrorWarping.SetMode
// 0x0014 (0x0014 - 0x0000)
struct TrajectoryErrorWarping_SetMode final
{
public:
	ETrajectoryErrorWarpMode                      InWarpMode;                                        // 0x0000(0x0001)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         InWarpRate;                                        // 0x0004(0x0004)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         InMinTrajectoryLength;                             // 0x0008(0x0004)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MinActivation;                                     // 0x000C(0x0004)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxActivation;                                     // 0x0010(0x0004)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(TrajectoryErrorWarping_SetMode) == 0x000004, "Wrong alignment on TrajectoryErrorWarping_SetMode");
static_assert(sizeof(TrajectoryErrorWarping_SetMode) == 0x000014, "Wrong size on TrajectoryErrorWarping_SetMode");
static_assert(offsetof(TrajectoryErrorWarping_SetMode, InWarpMode) == 0x000000, "Member 'TrajectoryErrorWarping_SetMode::InWarpMode' has a wrong offset!");
static_assert(offsetof(TrajectoryErrorWarping_SetMode, InWarpRate) == 0x000004, "Member 'TrajectoryErrorWarping_SetMode::InWarpRate' has a wrong offset!");
static_assert(offsetof(TrajectoryErrorWarping_SetMode, InMinTrajectoryLength) == 0x000008, "Member 'TrajectoryErrorWarping_SetMode::InMinTrajectoryLength' has a wrong offset!");
static_assert(offsetof(TrajectoryErrorWarping_SetMode, MinActivation) == 0x00000C, "Member 'TrajectoryErrorWarping_SetMode::MinActivation' has a wrong offset!");
static_assert(offsetof(TrajectoryErrorWarping_SetMode, MaxActivation) == 0x000010, "Member 'TrajectoryErrorWarping_SetMode::MaxActivation' has a wrong offset!");

// Function MotionSymphony.TrajectoryErrorWarping.CalculateTrajectoryErrorWarping
// 0x000C (0x000C - 0x0000)
struct TrajectoryErrorWarping_CalculateTrajectoryErrorWarping final
{
public:
	float                                         DeltaTime;                                         // 0x0000(0x0004)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PlaybackSpeed;                                     // 0x0004(0x0004)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ReturnValue;                                       // 0x0008(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(TrajectoryErrorWarping_CalculateTrajectoryErrorWarping) == 0x000004, "Wrong alignment on TrajectoryErrorWarping_CalculateTrajectoryErrorWarping");
static_assert(sizeof(TrajectoryErrorWarping_CalculateTrajectoryErrorWarping) == 0x00000C, "Wrong size on TrajectoryErrorWarping_CalculateTrajectoryErrorWarping");
static_assert(offsetof(TrajectoryErrorWarping_CalculateTrajectoryErrorWarping, DeltaTime) == 0x000000, "Member 'TrajectoryErrorWarping_CalculateTrajectoryErrorWarping::DeltaTime' has a wrong offset!");
static_assert(offsetof(TrajectoryErrorWarping_CalculateTrajectoryErrorWarping, PlaybackSpeed) == 0x000004, "Member 'TrajectoryErrorWarping_CalculateTrajectoryErrorWarping::PlaybackSpeed' has a wrong offset!");
static_assert(offsetof(TrajectoryErrorWarping_CalculateTrajectoryErrorWarping, ReturnValue) == 0x000008, "Member 'TrajectoryErrorWarping_CalculateTrajectoryErrorWarping::ReturnValue' has a wrong offset!");

// Function MotionSymphony.TrajectoryGenerator_Base.DrawTrajectoryDebug
// 0x0018 (0x0018 - 0x0000)
struct TrajectoryGenerator_Base_DrawTrajectoryDebug final
{
public:
	struct FVector                                DrawOffset;                                        // 0x0000(0x0018)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(TrajectoryGenerator_Base_DrawTrajectoryDebug) == 0x000008, "Wrong alignment on TrajectoryGenerator_Base_DrawTrajectoryDebug");
static_assert(sizeof(TrajectoryGenerator_Base_DrawTrajectoryDebug) == 0x000018, "Wrong size on TrajectoryGenerator_Base_DrawTrajectoryDebug");
static_assert(offsetof(TrajectoryGenerator_Base_DrawTrajectoryDebug, DrawOffset) == 0x000000, "Member 'TrajectoryGenerator_Base_DrawTrajectoryDebug::DrawOffset' has a wrong offset!");

// Function MotionSymphony.TrajectoryGenerator_Base.HasMoveInput
// 0x0001 (0x0001 - 0x0000)
struct TrajectoryGenerator_Base_HasMoveInput final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(TrajectoryGenerator_Base_HasMoveInput) == 0x000001, "Wrong alignment on TrajectoryGenerator_Base_HasMoveInput");
static_assert(sizeof(TrajectoryGenerator_Base_HasMoveInput) == 0x000001, "Wrong size on TrajectoryGenerator_Base_HasMoveInput");
static_assert(offsetof(TrajectoryGenerator_Base_HasMoveInput, ReturnValue) == 0x000000, "Member 'TrajectoryGenerator_Base_HasMoveInput::ReturnValue' has a wrong offset!");

// Function MotionSymphony.TrajectoryGenerator_Base.IsIdle
// 0x0001 (0x0001 - 0x0000)
struct TrajectoryGenerator_Base_IsIdle final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(TrajectoryGenerator_Base_IsIdle) == 0x000001, "Wrong alignment on TrajectoryGenerator_Base_IsIdle");
static_assert(sizeof(TrajectoryGenerator_Base_IsIdle) == 0x000001, "Wrong size on TrajectoryGenerator_Base_IsIdle");
static_assert(offsetof(TrajectoryGenerator_Base_IsIdle, ReturnValue) == 0x000000, "Member 'TrajectoryGenerator_Base_IsIdle::ReturnValue' has a wrong offset!");

// Function MotionSymphony.TrajectoryGenerator_Base.SetCharacterSkeletalMeshComponent
// 0x0008 (0x0008 - 0x0000)
struct TrajectoryGenerator_Base_SetCharacterSkeletalMeshComponent final
{
public:
	class USkeletalMeshComponent*                 InSkelMesh;                                        // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(TrajectoryGenerator_Base_SetCharacterSkeletalMeshComponent) == 0x000008, "Wrong alignment on TrajectoryGenerator_Base_SetCharacterSkeletalMeshComponent");
static_assert(sizeof(TrajectoryGenerator_Base_SetCharacterSkeletalMeshComponent) == 0x000008, "Wrong size on TrajectoryGenerator_Base_SetCharacterSkeletalMeshComponent");
static_assert(offsetof(TrajectoryGenerator_Base_SetCharacterSkeletalMeshComponent, InSkelMesh) == 0x000000, "Member 'TrajectoryGenerator_Base_SetCharacterSkeletalMeshComponent::InSkelMesh' has a wrong offset!");

// Function MotionSymphony.TrajectoryGenerator_Base.SetInputProfile
// 0x0010 (0x0010 - 0x0000)
struct TrajectoryGenerator_Base_SetInputProfile final
{
public:
	struct FInputProfile                          InInputProfile;                                    // 0x0000(0x0010)(Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(TrajectoryGenerator_Base_SetInputProfile) == 0x000008, "Wrong alignment on TrajectoryGenerator_Base_SetInputProfile");
static_assert(sizeof(TrajectoryGenerator_Base_SetInputProfile) == 0x000010, "Wrong size on TrajectoryGenerator_Base_SetInputProfile");
static_assert(offsetof(TrajectoryGenerator_Base_SetInputProfile, InInputProfile) == 0x000000, "Member 'TrajectoryGenerator_Base_SetInputProfile::InInputProfile' has a wrong offset!");

// Function MotionSymphony.TrajectoryGenerator_Base.SetTrajectoryInput
// 0x000C (0x000C - 0x0000)
struct TrajectoryGenerator_Base_SetTrajectoryInput final
{
public:
	float                                         XAxisValue;                                        // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         YAxisValue;                                        // 0x0004(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ZAxisValue;                                        // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(TrajectoryGenerator_Base_SetTrajectoryInput) == 0x000004, "Wrong alignment on TrajectoryGenerator_Base_SetTrajectoryInput");
static_assert(sizeof(TrajectoryGenerator_Base_SetTrajectoryInput) == 0x00000C, "Wrong size on TrajectoryGenerator_Base_SetTrajectoryInput");
static_assert(offsetof(TrajectoryGenerator_Base_SetTrajectoryInput, XAxisValue) == 0x000000, "Member 'TrajectoryGenerator_Base_SetTrajectoryInput::XAxisValue' has a wrong offset!");
static_assert(offsetof(TrajectoryGenerator_Base_SetTrajectoryInput, YAxisValue) == 0x000004, "Member 'TrajectoryGenerator_Base_SetTrajectoryInput::YAxisValue' has a wrong offset!");
static_assert(offsetof(TrajectoryGenerator_Base_SetTrajectoryInput, ZAxisValue) == 0x000008, "Member 'TrajectoryGenerator_Base_SetTrajectoryInput::ZAxisValue' has a wrong offset!");

// Function MotionSymphony.TrajectoryGenerator_Base.SetTrajectoryInputX
// 0x0004 (0x0004 - 0x0000)
struct TrajectoryGenerator_Base_SetTrajectoryInputX final
{
public:
	float                                         XAxisValue;                                        // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(TrajectoryGenerator_Base_SetTrajectoryInputX) == 0x000004, "Wrong alignment on TrajectoryGenerator_Base_SetTrajectoryInputX");
static_assert(sizeof(TrajectoryGenerator_Base_SetTrajectoryInputX) == 0x000004, "Wrong size on TrajectoryGenerator_Base_SetTrajectoryInputX");
static_assert(offsetof(TrajectoryGenerator_Base_SetTrajectoryInputX, XAxisValue) == 0x000000, "Member 'TrajectoryGenerator_Base_SetTrajectoryInputX::XAxisValue' has a wrong offset!");

// Function MotionSymphony.TrajectoryGenerator_Base.SetTrajectoryInputY
// 0x0004 (0x0004 - 0x0000)
struct TrajectoryGenerator_Base_SetTrajectoryInputY final
{
public:
	float                                         YAxisValue;                                        // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(TrajectoryGenerator_Base_SetTrajectoryInputY) == 0x000004, "Wrong alignment on TrajectoryGenerator_Base_SetTrajectoryInputY");
static_assert(sizeof(TrajectoryGenerator_Base_SetTrajectoryInputY) == 0x000004, "Wrong size on TrajectoryGenerator_Base_SetTrajectoryInputY");
static_assert(offsetof(TrajectoryGenerator_Base_SetTrajectoryInputY, YAxisValue) == 0x000000, "Member 'TrajectoryGenerator_Base_SetTrajectoryInputY::YAxisValue' has a wrong offset!");

// Function MotionSymphony.TrajectoryGenerator_Base.SetTrajectoryInputZ
// 0x0004 (0x0004 - 0x0000)
struct TrajectoryGenerator_Base_SetTrajectoryInputZ final
{
public:
	float                                         ZAxisValue;                                        // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(TrajectoryGenerator_Base_SetTrajectoryInputZ) == 0x000004, "Wrong alignment on TrajectoryGenerator_Base_SetTrajectoryInputZ");
static_assert(sizeof(TrajectoryGenerator_Base_SetTrajectoryInputZ) == 0x000004, "Wrong size on TrajectoryGenerator_Base_SetTrajectoryInputZ");
static_assert(offsetof(TrajectoryGenerator_Base_SetTrajectoryInputZ, ZAxisValue) == 0x000000, "Member 'TrajectoryGenerator_Base_SetTrajectoryInputZ::ZAxisValue' has a wrong offset!");

// Function MotionSymphony.TrajectoryGenerator_Base.GetCurrentTrajectory
// 0x0010 (0x0010 - 0x0000)
struct TrajectoryGenerator_Base_GetCurrentTrajectory final
{
public:
	struct FTrajectory                            ReturnValue;                                       // 0x0000(0x0010)(ConstParm, Parm, OutParm, ReturnParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(TrajectoryGenerator_Base_GetCurrentTrajectory) == 0x000008, "Wrong alignment on TrajectoryGenerator_Base_GetCurrentTrajectory");
static_assert(sizeof(TrajectoryGenerator_Base_GetCurrentTrajectory) == 0x000010, "Wrong size on TrajectoryGenerator_Base_GetCurrentTrajectory");
static_assert(offsetof(TrajectoryGenerator_Base_GetCurrentTrajectory, ReturnValue) == 0x000000, "Member 'TrajectoryGenerator_Base_GetCurrentTrajectory::ReturnValue' has a wrong offset!");

// Function MotionSymphony.TrajectoryGenerator.SetStrafeDirectionFromCamera
// 0x0008 (0x0008 - 0x0000)
struct TrajectoryGenerator_SetStrafeDirectionFromCamera final
{
public:
	class UCameraComponent*                       Camera;                                            // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(TrajectoryGenerator_SetStrafeDirectionFromCamera) == 0x000008, "Wrong alignment on TrajectoryGenerator_SetStrafeDirectionFromCamera");
static_assert(sizeof(TrajectoryGenerator_SetStrafeDirectionFromCamera) == 0x000008, "Wrong size on TrajectoryGenerator_SetStrafeDirectionFromCamera");
static_assert(offsetof(TrajectoryGenerator_SetStrafeDirectionFromCamera, Camera) == 0x000000, "Member 'TrajectoryGenerator_SetStrafeDirectionFromCamera::Camera' has a wrong offset!");

}

