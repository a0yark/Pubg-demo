#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: CommonCheatsRuntime

#include "Basic.hpp"

#include "CommonCheatsRuntime_classes.hpp"
#include "CommonCheatsRuntime_parameters.hpp"


namespace SDK
{

// Function CommonCheatsRuntime.AbilitySystemDebugCheatExtension.ServerSetAttributeValue
// (Net, NetReliable, Native, Event, Public, NetServer)
// Parameters:
// const class AActor*                     Actor                                                  (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FGameplayAttribute&        Attribute                                              (ConstParm, Parm, ReferenceParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   NewValue                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAbilitySystemDebugCheatExtension::ServerSetAttributeValue(const class AActor* Actor, const struct FGameplayAttribute& Attribute, float NewValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AbilitySystemDebugCheatExtension", "ServerSetAttributeValue");

	Params::AbilitySystemDebugCheatExtension_ServerSetAttributeValue Parms{};

	Parms.Actor = Actor;
	Parms.Attribute = std::move(Attribute);
	Parms.NewValue = NewValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function CommonCheatsRuntime.AdminCheatExtension.SetDeploymentStartNumPlayers
// (Final, Exec, Native, Public)
// Parameters:
// int32                                   NewMaxPlayers                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAdminCheatExtension::SetDeploymentStartNumPlayers(int32 NewMaxPlayers)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AdminCheatExtension", "SetDeploymentStartNumPlayers");

	Params::AdminCheatExtension_SetDeploymentStartNumPlayers Parms{};

	Parms.NewMaxPlayers = NewMaxPlayers;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function CommonCheatsRuntime.AdminCheatExtension.SetWaitingStartNumPlayers
// (Final, Exec, Native, Public)
// Parameters:
// int32                                   NewMinPlayers                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAdminCheatExtension::SetWaitingStartNumPlayers(int32 NewMinPlayers)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AdminCheatExtension", "SetWaitingStartNumPlayers");

	Params::AdminCheatExtension_SetWaitingStartNumPlayers Parms{};

	Parms.NewMinPlayers = NewMinPlayers;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function CommonCheatsRuntime.AdminCheatExtension.StartDeploy
// (Final, Exec, Native, Public)

void UAdminCheatExtension::StartDeploy()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AdminCheatExtension", "StartDeploy");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function CommonCheatsRuntime.AdminCheatExtension.StartMatch
// (Final, Exec, Native, Public)

void UAdminCheatExtension::StartMatch()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AdminCheatExtension", "StartMatch");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function CommonCheatsRuntime.AdminCheatExtension.TestKickPlayer
// (Final, Exec, Native, Public)
// Parameters:
// int32                                   InKickType                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAdminCheatExtension::TestKickPlayer(int32 InKickType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AdminCheatExtension", "TestKickPlayer");

	Params::AdminCheatExtension_TestKickPlayer Parms{};

	Parms.InKickType = InKickType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function CommonCheatsRuntime.AdminCheatExtension.TestKickPlayerWithReason
// (Final, Exec, Native, Public)
// Parameters:
// const class FString&                    InKickReason                                           (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAdminCheatExtension::TestKickPlayerWithReason(const class FString& InKickReason)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AdminCheatExtension", "TestKickPlayerWithReason");

	Params::AdminCheatExtension_TestKickPlayerWithReason Parms{};

	Parms.InKickReason = std::move(InKickReason);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function CommonCheatsRuntime.AdminCheatExtension.PauseRaidTimer
// (Final, Exec, Native, Public, Const)

void UAdminCheatExtension::PauseRaidTimer() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AdminCheatExtension", "PauseRaidTimer");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function CommonCheatsRuntime.AdminCheatExtension.ResumeRaidTimer
// (Final, Exec, Native, Public, Const)

void UAdminCheatExtension::ResumeRaidTimer() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AdminCheatExtension", "ResumeRaidTimer");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function CommonCheatsRuntime.AdminCheatExtension.SetRaidTimer
// (Final, Exec, Native, Public, Const)
// Parameters:
// const float                             RemainingSeconds                                       (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAdminCheatExtension::SetRaidTimer(const float RemainingSeconds) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AdminCheatExtension", "SetRaidTimer");

	Params::AdminCheatExtension_SetRaidTimer Parms{};

	Parms.RemainingSeconds = RemainingSeconds;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function CommonCheatsRuntime.AdminCheatExtension.SetWaitingTimer
// (Final, Exec, Native, Public, Const)
// Parameters:
// float                                   RemainingSeconds                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAdminCheatExtension::SetWaitingTimer(float RemainingSeconds) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AdminCheatExtension", "SetWaitingTimer");

	Params::AdminCheatExtension_SetWaitingTimer Parms{};

	Parms.RemainingSeconds = RemainingSeconds;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function CommonCheatsRuntime.AdminCheatExtension.ToggleForceExfilAreas
// (Final, Exec, Native, Public, Const)

void UAdminCheatExtension::ToggleForceExfilAreas() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AdminCheatExtension", "ToggleForceExfilAreas");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function CommonCheatsRuntime.AntiCheatExtension.ClientAntiCheatLogBunch
// (Final, Net, NetReliable, Native, Event, Private, NetClient)
// Parameters:
// const TArray<struct FAntiCheatLogEntry>&Entries                                                (ConstParm, Parm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)

void UAntiCheatExtension::ClientAntiCheatLogBunch(const TArray<struct FAntiCheatLogEntry>& Entries)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AntiCheatExtension", "ClientAntiCheatLogBunch");

	Params::AntiCheatExtension_ClientAntiCheatLogBunch Parms{};

	Parms.Entries = std::move(Entries);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function CommonCheatsRuntime.AntiCheatExtension.ClientMarkAnticheatComponentDisabled
// (Final, Net, NetReliable, Native, Event, Private, NetClient)

void UAntiCheatExtension::ClientMarkAnticheatComponentDisabled()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AntiCheatExtension", "ClientMarkAnticheatComponentDisabled");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function CommonCheatsRuntime.AntiCheatExtension.GetP2AntiCheatValuesServer
// (Final, Net, NetReliable, Native, Event, Private, NetServer)

void UAntiCheatExtension::GetP2AntiCheatValuesServer()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AntiCheatExtension", "GetP2AntiCheatValuesServer");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function CommonCheatsRuntime.AntiCheatExtension.OnRep_LogSize
// (Final, Native, Private)

void UAntiCheatExtension::OnRep_LogSize()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AntiCheatExtension", "OnRep_LogSize");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function CommonCheatsRuntime.AntiCheatExtension.ServerRequestAntiCheatLog
// (Final, Net, NetReliable, Native, Event, Private, NetServer)
// Parameters:
// int32                                   StartIndex                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Count                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAntiCheatExtension::ServerRequestAntiCheatLog(int32 StartIndex, int32 Count)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AntiCheatExtension", "ServerRequestAntiCheatLog");

	Params::AntiCheatExtension_ServerRequestAntiCheatLog Parms{};

	Parms.StartIndex = StartIndex;
	Parms.Count = Count;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function CommonCheatsRuntime.AntiCheatExtension.UpdateP2AntiCheatValuesClient
// (Final, Net, NetReliable, Native, Event, Private, NetClient)
// Parameters:
// const struct FAntiCheatValues&          AntiCheatValues                                        (ConstParm, Parm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)

void UAntiCheatExtension::UpdateP2AntiCheatValuesClient(const struct FAntiCheatValues& AntiCheatValues)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AntiCheatExtension", "UpdateP2AntiCheatValuesClient");

	Params::AntiCheatExtension_UpdateP2AntiCheatValuesClient Parms{};

	Parms.AntiCheatValues = std::move(AntiCheatValues);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function CommonCheatsRuntime.AntiCheatExtension.UpdateP2AntiCheatValuesServer
// (Final, Net, NetReliable, Native, Event, Private, NetServer)
// Parameters:
// const struct FAntiCheatValues&          AntiCheatValues                                        (ConstParm, Parm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)

void UAntiCheatExtension::UpdateP2AntiCheatValuesServer(const struct FAntiCheatValues& AntiCheatValues)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AntiCheatExtension", "UpdateP2AntiCheatValuesServer");

	Params::AntiCheatExtension_UpdateP2AntiCheatValuesServer Parms{};

	Parms.AntiCheatValues = std::move(AntiCheatValues);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function CommonCheatsRuntime.AntiCheatExtension.ToggleAntiCheatUELogs
// (Final, Exec, Native, Public, Const)

void UAntiCheatExtension::ToggleAntiCheatUELogs() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AntiCheatExtension", "ToggleAntiCheatUELogs");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function CommonCheatsRuntime.AudioCheatExtension.ToggleDebugRelativeEleavtion
// (Final, Exec, Native, Public)

void UAudioCheatExtension::ToggleDebugRelativeEleavtion()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AudioCheatExtension", "ToggleDebugRelativeEleavtion");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function CommonCheatsRuntime.DamageLogSubsystem.ExportLog
// (Final, Native, Private, Const)

void UDamageLogSubsystem::ExportLog() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DamageLogSubsystem", "ExportLog");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function CommonCheatsRuntime.DamageLogCheatExtension.ClientDamageLogBunch
// (Final, Net, NetReliable, Native, Event, Private, NetClient)
// Parameters:
// const TArray<struct FDamageLogEntry>&   Entries                                                (ConstParm, Parm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)

void UDamageLogCheatExtension::ClientDamageLogBunch(const TArray<struct FDamageLogEntry>& Entries)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DamageLogCheatExtension", "ClientDamageLogBunch");

	Params::DamageLogCheatExtension_ClientDamageLogBunch Parms{};

	Parms.Entries = std::move(Entries);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function CommonCheatsRuntime.DamageLogCheatExtension.OnRep_LogSize
// (Final, Native, Private)

void UDamageLogCheatExtension::OnRep_LogSize()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DamageLogCheatExtension", "OnRep_LogSize");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function CommonCheatsRuntime.DamageLogCheatExtension.ServerRequestDamageLog
// (Final, Net, NetReliable, Native, Event, Private, NetServer)
// Parameters:
// int32                                   StartIndex                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Count                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDamageLogCheatExtension::ServerRequestDamageLog(int32 StartIndex, int32 Count)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DamageLogCheatExtension", "ServerRequestDamageLog");

	Params::DamageLogCheatExtension_ServerRequestDamageLog Parms{};

	Parms.StartIndex = StartIndex;
	Parms.Count = Count;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function CommonCheatsRuntime.DebugCameraCheatExtension.ToggleDebugUI
// (Final, Exec, Native, Public)

void UDebugCameraCheatExtension::ToggleDebugUI()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DebugCameraCheatExtension", "ToggleDebugUI");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function CommonCheatsRuntime.DebugCameraCheatExtension.TeleportAtCurrentPosition
// (Final, Exec, Native, Public, Const)

void UDebugCameraCheatExtension::TeleportAtCurrentPosition() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DebugCameraCheatExtension", "TeleportAtCurrentPosition");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function CommonCheatsRuntime.P2DebugOptionsCheatExtension.DrawDebugCollisions
// (Final, Exec, Native, Public)
// Parameters:
// bool                                    InDrawDebugCollision                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UP2DebugOptionsCheatExtension::DrawDebugCollisions(bool InDrawDebugCollision)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("P2DebugOptionsCheatExtension", "DrawDebugCollisions");

	Params::P2DebugOptionsCheatExtension_DrawDebugCollisions Parms{};

	Parms.InDrawDebugCollision = InDrawDebugCollision;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function CommonCheatsRuntime.P2DebugOptionsCheatExtension.MuteSounds
// (Final, Exec, Native, Public)
// Parameters:
// bool                                    bMuteSound                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UP2DebugOptionsCheatExtension::MuteSounds(bool bMuteSound)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("P2DebugOptionsCheatExtension", "MuteSounds");

	Params::P2DebugOptionsCheatExtension_MuteSounds Parms{};

	Parms.bMuteSound = bMuteSound;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function CommonCheatsRuntime.DMCheatManagerExtension.RestartAllPayers
// (Final, Net, NetReliable, Native, Event, Private, NetServer)
// Parameters:
// const struct FGameplayTag&              StartSpot                                              (ConstParm, Parm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDMCheatManagerExtension::RestartAllPayers(const struct FGameplayTag& StartSpot)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DMCheatManagerExtension", "RestartAllPayers");

	Params::DMCheatManagerExtension_RestartAllPayers Parms{};

	Parms.StartSpot = std::move(StartSpot);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function CommonCheatsRuntime.DMCheatManagerExtension.SetSpawnTime
// (Final, Net, NetReliable, Native, Event, Private, NetServer)
// Parameters:
// uint32                                  InTime                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDMCheatManagerExtension::SetSpawnTime(uint32 InTime)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DMCheatManagerExtension", "SetSpawnTime");

	Params::DMCheatManagerExtension_SetSpawnTime Parms{};

	Parms.InTime = InTime;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function CommonCheatsRuntime.DMCheatManagerExtension.SetStartPoint
// (Final, Net, NetReliable, Native, Event, Private, NetServer)
// Parameters:
// const struct FGameplayTag&              StartSpot                                              (ConstParm, Parm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDMCheatManagerExtension::SetStartPoint(const struct FGameplayTag& StartSpot)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DMCheatManagerExtension", "SetStartPoint");

	Params::DMCheatManagerExtension_SetStartPoint Parms{};

	Parms.StartSpot = std::move(StartSpot);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function CommonCheatsRuntime.DMCheatManagerExtension.ShouldOnlyTeamRespawn
// (Final, Net, NetReliable, Native, Event, Private, NetServer)
// Parameters:
// bool                                    bEnabled                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDMCheatManagerExtension::ShouldOnlyTeamRespawn(bool bEnabled)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DMCheatManagerExtension", "ShouldOnlyTeamRespawn");

	Params::DMCheatManagerExtension_ShouldOnlyTeamRespawn Parms{};

	Parms.bEnabled = bEnabled;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function CommonCheatsRuntime.DMCheatManagerExtension.SetDMMatchStartNumPlayers
// (Final, Exec, Native, Public, Const)
// Parameters:
// uint32                                  InNum                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDMCheatManagerExtension::SetDMMatchStartNumPlayers(uint32 InNum) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DMCheatManagerExtension", "SetDMMatchStartNumPlayers");

	Params::DMCheatManagerExtension_SetDMMatchStartNumPlayers Parms{};

	Parms.InNum = InNum;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function CommonCheatsRuntime.DMCheatManagerExtension.SetDMMatchTimer
// (Final, Exec, Native, Public, Const)
// Parameters:
// float                                   RemainingSeconds                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDMCheatManagerExtension::SetDMMatchTimer(float RemainingSeconds) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DMCheatManagerExtension", "SetDMMatchTimer");

	Params::DMCheatManagerExtension_SetDMMatchTimer Parms{};

	Parms.RemainingSeconds = RemainingSeconds;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function CommonCheatsRuntime.DMCheatManagerExtension.SetDMRoundStartTime
// (Final, Exec, Native, Public, Const)
// Parameters:
// uint32                                  InTime                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDMCheatManagerExtension::SetDMRoundStartTime(uint32 InTime) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DMCheatManagerExtension", "SetDMRoundStartTime");

	Params::DMCheatManagerExtension_SetDMRoundStartTime Parms{};

	Parms.InTime = InTime;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function CommonCheatsRuntime.DMCheatManagerExtension.SetDMRoundTime
// (Final, Exec, Native, Public, Const)
// Parameters:
// uint32                                  InTime                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDMCheatManagerExtension::SetDMRoundTime(uint32 InTime) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DMCheatManagerExtension", "SetDMRoundTime");

	Params::DMCheatManagerExtension_SetDMRoundTime Parms{};

	Parms.InTime = InTime;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function CommonCheatsRuntime.DMCheatManagerExtension.SetDMWaitingTimer
// (Final, Exec, Native, Public, Const)
// Parameters:
// float                                   RemainingSeconds                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDMCheatManagerExtension::SetDMWaitingTimer(float RemainingSeconds) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DMCheatManagerExtension", "SetDMWaitingTimer");

	Params::DMCheatManagerExtension_SetDMWaitingTimer Parms{};

	Parms.RemainingSeconds = RemainingSeconds;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function CommonCheatsRuntime.DMCheatManagerExtension.SetMatchStartNumPlayersInternal
// (Final, Net, NetReliable, Native, Event, Private, NetServer, Const)
// Parameters:
// uint32                                  InNum                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDMCheatManagerExtension::SetMatchStartNumPlayersInternal(uint32 InNum) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DMCheatManagerExtension", "SetMatchStartNumPlayersInternal");

	Params::DMCheatManagerExtension_SetMatchStartNumPlayersInternal Parms{};

	Parms.InNum = InNum;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function CommonCheatsRuntime.DMCheatManagerExtension.SetMatchTimeInternal
// (Final, Net, NetReliable, Native, Event, Private, NetServer, Const)
// Parameters:
// uint32                                  InTime                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDMCheatManagerExtension::SetMatchTimeInternal(uint32 InTime) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DMCheatManagerExtension", "SetMatchTimeInternal");

	Params::DMCheatManagerExtension_SetMatchTimeInternal Parms{};

	Parms.InTime = InTime;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function CommonCheatsRuntime.DMCheatManagerExtension.SetRoundStartTime
// (Final, Net, NetReliable, Native, Event, Private, NetServer, Const)
// Parameters:
// uint32                                  InTime                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDMCheatManagerExtension::SetRoundStartTime(uint32 InTime) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DMCheatManagerExtension", "SetRoundStartTime");

	Params::DMCheatManagerExtension_SetRoundStartTime Parms{};

	Parms.InTime = InTime;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function CommonCheatsRuntime.DMCheatManagerExtension.SetRoundTime
// (Final, Net, NetReliable, Native, Event, Private, NetServer, Const)
// Parameters:
// uint32                                  InTime                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDMCheatManagerExtension::SetRoundTime(uint32 InTime) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DMCheatManagerExtension", "SetRoundTime");

	Params::DMCheatManagerExtension_SetRoundTime Parms{};

	Parms.InTime = InTime;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function CommonCheatsRuntime.DMCheatManagerExtension.SetWaitingTimeInternal
// (Final, Net, NetReliable, Native, Event, Private, NetServer, Const)
// Parameters:
// uint32                                  InTime                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDMCheatManagerExtension::SetWaitingTimeInternal(uint32 InTime) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DMCheatManagerExtension", "SetWaitingTimeInternal");

	Params::DMCheatManagerExtension_SetWaitingTimeInternal Parms{};

	Parms.InTime = InTime;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function CommonCheatsRuntime.FactionCheatExtension.ResetSquadContracts
// (Final, Exec, Native, Public)

void UFactionCheatExtension::ResetSquadContracts()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FactionCheatExtension", "ResetSquadContracts");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function CommonCheatsRuntime.FactionCheatExtension.ResetSquadContractsResetAnomaly
// (Final, Exec, Native, Public)

void UFactionCheatExtension::ResetSquadContractsResetAnomaly()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FactionCheatExtension", "ResetSquadContractsResetAnomaly");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function CommonCheatsRuntime.FactionCheatExtension.ServerAddContractToSelectedRaidContracts
// (Net, NetReliable, Native, Event, Public, NetServer, NetValidate)
// Parameters:
// const class UP2ContractData*            InContractData                                         (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    InForceRaidTaskIgnoreTime                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UFactionCheatExtension::ServerAddContractToSelectedRaidContracts(const class UP2ContractData* InContractData, bool InForceRaidTaskIgnoreTime)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FactionCheatExtension", "ServerAddContractToSelectedRaidContracts");

	Params::FactionCheatExtension_ServerAddContractToSelectedRaidContracts Parms{};

	Parms.InContractData = InContractData;
	Parms.InForceRaidTaskIgnoreTime = InForceRaidTaskIgnoreTime;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function CommonCheatsRuntime.FactionCheatExtension.ServerAllowedAllContractsToClient
// (Net, NetReliable, Native, Event, Public, NetServer, NetValidate)
// Parameters:
// bool                                    InValue                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UFactionCheatExtension::ServerAllowedAllContractsToClient(bool InValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FactionCheatExtension", "ServerAllowedAllContractsToClient");

	Params::FactionCheatExtension_ServerAllowedAllContractsToClient Parms{};

	Parms.InValue = InValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function CommonCheatsRuntime.FactionCheatExtension.ServerCalculateAvailableEventContracts
// (Net, NetReliable, Native, Event, Public, NetServer, NetValidate)
// Parameters:
// const bool                              bInOverrideCurrent                                     (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UFactionCheatExtension::ServerCalculateAvailableEventContracts(const bool bInOverrideCurrent)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FactionCheatExtension", "ServerCalculateAvailableEventContracts");

	Params::FactionCheatExtension_ServerCalculateAvailableEventContracts Parms{};

	Parms.bInOverrideCurrent = bInOverrideCurrent;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function CommonCheatsRuntime.FactionCheatExtension.ServerSetInitialFaction
// (Net, NetReliable, Native, Event, Public, NetServer, NetValidate)
// Parameters:
// const struct FGameplayTag&              InFactionTag                                           (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UFactionCheatExtension::ServerSetInitialFaction(const struct FGameplayTag& InFactionTag)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FactionCheatExtension", "ServerSetInitialFaction");

	Params::FactionCheatExtension_ServerSetInitialFaction Parms{};

	Parms.InFactionTag = std::move(InFactionTag);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function CommonCheatsRuntime.GunCheatExtension.Input_ToggleUI
// (Final, Native, Private)
// Parameters:
// const struct FKey&                      Key                                                    (Parm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FInputActionValue&         Value                                                  (Parm, NoDestructor, NativeAccessSpecifierPublic)

void UGunCheatExtension::Input_ToggleUI(const struct FKey& Key, const struct FInputActionValue& Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GunCheatExtension", "Input_ToggleUI");

	Params::GunCheatExtension_Input_ToggleUI Parms{};

	Parms.Key = std::move(Key);
	Parms.Value = std::move(Value);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function CommonCheatsRuntime.GunCheatExtension.ToggleGunDebug
// (Final, Exec, Native, Private)

void UGunCheatExtension::ToggleGunDebug()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GunCheatExtension", "ToggleGunDebug");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function CommonCheatsRuntime.HeroCheatExtension.AddBleedingStacks
// (Final, Exec, Native, Public)
// Parameters:
// int32                                   InStacks                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UHeroCheatExtension::AddBleedingStacks(int32 InStacks)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HeroCheatExtension", "AddBleedingStacks");

	Params::HeroCheatExtension_AddBleedingStacks Parms{};

	Parms.InStacks = InStacks;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function CommonCheatsRuntime.HeroCheatExtension.AddExperience
// (Final, Exec, Native, Public, HasOutParams)
// Parameters:
// int32                                   Val                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   BonusVal                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FGameplayTag&              Skill                                                  (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bAddToPersistentPool                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UHeroCheatExtension::AddExperience(int32 Val, int32 BonusVal, const struct FGameplayTag& Skill, bool bAddToPersistentPool)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HeroCheatExtension", "AddExperience");

	Params::HeroCheatExtension_AddExperience Parms{};

	Parms.Val = Val;
	Parms.BonusVal = BonusVal;
	Parms.Skill = std::move(Skill);
	Parms.bAddToPersistentPool = bAddToPersistentPool;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function CommonCheatsRuntime.HeroCheatExtension.AddLevel
// (Final, Exec, Native, Public, HasOutParams)
// Parameters:
// int32                                   Val                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FGameplayTag&              Skill                                                  (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UHeroCheatExtension::AddLevel(int32 Val, const struct FGameplayTag& Skill)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HeroCheatExtension", "AddLevel");

	Params::HeroCheatExtension_AddLevel Parms{};

	Parms.Val = Val;
	Parms.Skill = std::move(Skill);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function CommonCheatsRuntime.HeroCheatExtension.AddPoisonStacks
// (Final, Exec, Native, Public)
// Parameters:
// int32                                   InStacks                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UHeroCheatExtension::AddPoisonStacks(int32 InStacks)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HeroCheatExtension", "AddPoisonStacks");

	Params::HeroCheatExtension_AddPoisonStacks Parms{};

	Parms.InStacks = InStacks;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function CommonCheatsRuntime.HeroCheatExtension.ApplyFinalExperience
// (Final, Exec, Native, Public)

void UHeroCheatExtension::ApplyFinalExperience()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HeroCheatExtension", "ApplyFinalExperience");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function CommonCheatsRuntime.HeroCheatExtension.CancelActivatedAbilities
// (Final, Exec, Native, Public)

void UHeroCheatExtension::CancelActivatedAbilities()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HeroCheatExtension", "CancelActivatedAbilities");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function CommonCheatsRuntime.HeroCheatExtension.CycleAbilitySystemDebug
// (Final, Exec, Native, Public)

void UHeroCheatExtension::CycleAbilitySystemDebug()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HeroCheatExtension", "CycleAbilitySystemDebug");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function CommonCheatsRuntime.HeroCheatExtension.DamageSelf
// (Final, Exec, Native, Public)
// Parameters:
// float                                   DamageAmount                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   DamageToArmor                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Penetration                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class FString&                    Tags                                                   (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UHeroCheatExtension::DamageSelf(float DamageAmount, float DamageToArmor, float Penetration, const class FString& Tags)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HeroCheatExtension", "DamageSelf");

	Params::HeroCheatExtension_DamageSelf Parms{};

	Parms.DamageAmount = DamageAmount;
	Parms.DamageToArmor = DamageToArmor;
	Parms.Penetration = Penetration;
	Parms.Tags = std::move(Tags);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function CommonCheatsRuntime.HeroCheatExtension.DamageTarget
// (Final, Exec, Native, Public)
// Parameters:
// float                                   DamageAmount                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   DamageToArmor                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Penetration                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class FString&                    Tags                                                   (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UHeroCheatExtension::DamageTarget(float DamageAmount, float DamageToArmor, float Penetration, const class FString& Tags)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HeroCheatExtension", "DamageTarget");

	Params::HeroCheatExtension_DamageTarget Parms{};

	Parms.DamageAmount = DamageAmount;
	Parms.DamageToArmor = DamageToArmor;
	Parms.Penetration = Penetration;
	Parms.Tags = std::move(Tags);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function CommonCheatsRuntime.HeroCheatExtension.DbnoActivate
// (Final, Exec, Native, Public)

void UHeroCheatExtension::DbnoActivate()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HeroCheatExtension", "DbnoActivate");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function CommonCheatsRuntime.HeroCheatExtension.DbnoCancel
// (Final, Exec, Native, Public)

void UHeroCheatExtension::DbnoCancel()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HeroCheatExtension", "DbnoCancel");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function CommonCheatsRuntime.HeroCheatExtension.ExportEquipment
// (Final, Exec, Native, Public)

void UHeroCheatExtension::ExportEquipment()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HeroCheatExtension", "ExportEquipment");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function CommonCheatsRuntime.HeroCheatExtension.HealSelf
// (Final, Exec, Native, Public)
// Parameters:
// float                                   DamageAmount                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UHeroCheatExtension::HealSelf(float DamageAmount)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HeroCheatExtension", "HealSelf");

	Params::HeroCheatExtension_HealSelf Parms{};

	Parms.DamageAmount = DamageAmount;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function CommonCheatsRuntime.HeroCheatExtension.HealTarget
// (Final, Exec, Native, Public)
// Parameters:
// float                                   DamageAmount                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UHeroCheatExtension::HealTarget(float DamageAmount)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HeroCheatExtension", "HealTarget");

	Params::HeroCheatExtension_HealTarget Parms{};

	Parms.DamageAmount = DamageAmount;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function CommonCheatsRuntime.HeroCheatExtension.ImportEquipment
// (Final, Exec, Native, Public)

void UHeroCheatExtension::ImportEquipment()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HeroCheatExtension", "ImportEquipment");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function CommonCheatsRuntime.HeroCheatExtension.Input_CancelAbilities
// (Final, Native, Public)
// Parameters:
// const struct FKey&                      Key                                                    (Parm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FInputActionValue&         Value                                                  (Parm, NoDestructor, NativeAccessSpecifierPublic)

void UHeroCheatExtension::Input_CancelAbilities(const struct FKey& Key, const struct FInputActionValue& Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HeroCheatExtension", "Input_CancelAbilities");

	Params::HeroCheatExtension_Input_CancelAbilities Parms{};

	Parms.Key = std::move(Key);
	Parms.Value = std::move(Value);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function CommonCheatsRuntime.HeroCheatExtension.Input_InfiniteAmmo
// (Final, Native, Public)
// Parameters:
// const struct FKey&                      Key                                                    (Parm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FInputActionValue&         Value                                                  (Parm, NoDestructor, NativeAccessSpecifierPublic)

void UHeroCheatExtension::Input_InfiniteAmmo(const struct FKey& Key, const struct FInputActionValue& Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HeroCheatExtension", "Input_InfiniteAmmo");

	Params::HeroCheatExtension_Input_InfiniteAmmo Parms{};

	Parms.Key = std::move(Key);
	Parms.Value = std::move(Value);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function CommonCheatsRuntime.HeroCheatExtension.OnPlayerExperienceEvent
// (Final, Native, Private, HasOutParams)
// Parameters:
// int32                                   Exp                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ExpBonus                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FGameplayTag&              PlayerSkill                                            (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class FString&                    SourceName                                             (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UHeroCheatExtension::OnPlayerExperienceEvent(int32 Exp, int32 ExpBonus, const struct FGameplayTag& PlayerSkill, const class FString& SourceName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HeroCheatExtension", "OnPlayerExperienceEvent");

	Params::HeroCheatExtension_OnPlayerExperienceEvent Parms{};

	Parms.Exp = Exp;
	Parms.ExpBonus = ExpBonus;
	Parms.PlayerSkill = std::move(PlayerSkill);
	Parms.SourceName = std::move(SourceName);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function CommonCheatsRuntime.HeroCheatExtension.RemoveBleedingStacks
// (Final, Exec, Native, Public)
// Parameters:
// int32                                   InStacks                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UHeroCheatExtension::RemoveBleedingStacks(int32 InStacks)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HeroCheatExtension", "RemoveBleedingStacks");

	Params::HeroCheatExtension_RemoveBleedingStacks Parms{};

	Parms.InStacks = InStacks;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function CommonCheatsRuntime.HeroCheatExtension.RemovePoisonStacks
// (Final, Exec, Native, Public)
// Parameters:
// int32                                   InStacks                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UHeroCheatExtension::RemovePoisonStacks(int32 InStacks)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HeroCheatExtension", "RemovePoisonStacks");

	Params::HeroCheatExtension_RemovePoisonStacks Parms{};

	Parms.InStacks = InStacks;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function CommonCheatsRuntime.HeroCheatExtension.RestartPlayer
// (Final, Exec, Native, Public)

void UHeroCheatExtension::RestartPlayer()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HeroCheatExtension", "RestartPlayer");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function CommonCheatsRuntime.HeroCheatExtension.RunAutoMatchmaking
// (Final, Exec, Native, Public)
// Parameters:
// bool                                    bInStart                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   InTimerInterval                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UHeroCheatExtension::RunAutoMatchmaking(bool bInStart, int32 InTimerInterval)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HeroCheatExtension", "RunAutoMatchmaking");

	Params::HeroCheatExtension_RunAutoMatchmaking Parms{};

	Parms.bInStart = bInStart;
	Parms.InTimerInterval = InTimerInterval;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function CommonCheatsRuntime.HeroCheatExtension.SendHUDImportantMessage
// (Final, Exec, Native, Public, HasOutParams)
// Parameters:
// const class FText&                      InText                                                 (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// int32                                   InShowDuration                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UHeroCheatExtension::SendHUDImportantMessage(const class FText& InText, int32 InShowDuration)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HeroCheatExtension", "SendHUDImportantMessage");

	Params::HeroCheatExtension_SendHUDImportantMessage Parms{};

	Parms.InText = std::move(InText);
	Parms.InShowDuration = InShowDuration;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function CommonCheatsRuntime.HeroCheatExtension.SendHUDImportantMessageAll
// (Final, Exec, Native, Public, HasOutParams)
// Parameters:
// const class FText&                      InText                                                 (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// int32                                   InShowDuration                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UHeroCheatExtension::SendHUDImportantMessageAll(const class FText& InText, int32 InShowDuration)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HeroCheatExtension", "SendHUDImportantMessageAll");

	Params::HeroCheatExtension_SendHUDImportantMessageAll Parms{};

	Parms.InText = std::move(InText);
	Parms.InShowDuration = InShowDuration;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function CommonCheatsRuntime.HeroCheatExtension.SendHUDSystemMessage
// (Final, Exec, Native, Public, HasOutParams)
// Parameters:
// const class FText&                      InText                                                 (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UHeroCheatExtension::SendHUDSystemMessage(const class FText& InText)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HeroCheatExtension", "SendHUDSystemMessage");

	Params::HeroCheatExtension_SendHUDSystemMessage Parms{};

	Parms.InText = std::move(InText);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function CommonCheatsRuntime.HeroCheatExtension.SendHUDSystemMessageAll
// (Final, Exec, Native, Public, HasOutParams)
// Parameters:
// const class FText&                      InText                                                 (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UHeroCheatExtension::SendHUDSystemMessageAll(const class FText& InText)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HeroCheatExtension", "SendHUDSystemMessageAll");

	Params::HeroCheatExtension_SendHUDSystemMessageAll Parms{};

	Parms.InText = std::move(InText);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function CommonCheatsRuntime.HeroCheatExtension.SetExternalSkillLevel
// (Final, Exec, Native, Public, HasOutParams)
// Parameters:
// int32                                   Val                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FGameplayTag&              Skill                                                  (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UHeroCheatExtension::SetExternalSkillLevel(int32 Val, const struct FGameplayTag& Skill)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HeroCheatExtension", "SetExternalSkillLevel");

	Params::HeroCheatExtension_SetExternalSkillLevel Parms{};

	Parms.Val = Val;
	Parms.Skill = std::move(Skill);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function CommonCheatsRuntime.HeroCheatExtension.SetImmunity
// (Final, Exec, Native, Public)
// Parameters:
// bool                                    bEnable                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UHeroCheatExtension::SetImmunity(bool bEnable)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HeroCheatExtension", "SetImmunity");

	Params::HeroCheatExtension_SetImmunity Parms{};

	Parms.bEnable = bEnable;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function CommonCheatsRuntime.HeroCheatExtension.SetSelfMaxHealth
// (Final, Exec, Native, Public)
// Parameters:
// const float                             InMaxHealth                                            (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UHeroCheatExtension::SetSelfMaxHealth(const float InMaxHealth)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HeroCheatExtension", "SetSelfMaxHealth");

	Params::HeroCheatExtension_SetSelfMaxHealth Parms{};

	Parms.InMaxHealth = InMaxHealth;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function CommonCheatsRuntime.HeroCheatExtension.StatusEffect
// (Final, Exec, Native, Public)
// Parameters:
// const class FString&                    Effect                                                 (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   InStacks                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UHeroCheatExtension::StatusEffect(const class FString& Effect, int32 InStacks)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HeroCheatExtension", "StatusEffect");

	Params::HeroCheatExtension_StatusEffect Parms{};

	Parms.Effect = std::move(Effect);
	Parms.InStacks = InStacks;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function CommonCheatsRuntime.HeroCheatExtension.SubscribeToExpEvents
// (Final, Native, Private)

void UHeroCheatExtension::SubscribeToExpEvents()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HeroCheatExtension", "SubscribeToExpEvents");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function CommonCheatsRuntime.HeroCheatExtension.Suicide
// (Final, Exec, Native, Public)

void UHeroCheatExtension::Suicide()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HeroCheatExtension", "Suicide");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function CommonCheatsRuntime.HeroCheatExtension.ToggleAutoWalk
// (Final, Exec, Native, Public)

void UHeroCheatExtension::ToggleAutoWalk()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HeroCheatExtension", "ToggleAutoWalk");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function CommonCheatsRuntime.HeroCheatExtension.ToggleTeleportToMapClick
// (Final, Exec, Native, Public)

void UHeroCheatExtension::ToggleTeleportToMapClick()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HeroCheatExtension", "ToggleTeleportToMapClick");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function CommonCheatsRuntime.HeroCheatExtension.Unstuck
// (Final, Exec, Native, Public)

void UHeroCheatExtension::Unstuck()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HeroCheatExtension", "Unstuck");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function CommonCheatsRuntime.HeroCheatExtension.God
// (Final, Exec, Native, Public, Const)

void UHeroCheatExtension::God() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HeroCheatExtension", "God");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function CommonCheatsRuntime.HeroCheatExtension.InfiniteAmmo
// (Final, Exec, Native, Public, Const)

void UHeroCheatExtension::InfiniteAmmo() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HeroCheatExtension", "InfiniteAmmo");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function CommonCheatsRuntime.HeroCheatExtension.InfiniteStamina
// (Final, Exec, Native, Public, Const)

void UHeroCheatExtension::InfiniteStamina() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HeroCheatExtension", "InfiniteStamina");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function CommonCheatsRuntime.HeroCheatExtension.SetMovementAuthority
// (Final, Exec, Native, Public, Const)
// Parameters:
// EMovementAuthMode                       Mode                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UHeroCheatExtension::SetMovementAuthority(EMovementAuthMode Mode) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HeroCheatExtension", "SetMovementAuthority");

	Params::HeroCheatExtension_SetMovementAuthority Parms{};

	Parms.Mode = Mode;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function CommonCheatsRuntime.HeroCheatExtension.StaminaBlockRegen
// (Final, Exec, Native, Public, Const)
// Parameters:
// bool                                    bBlock                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UHeroCheatExtension::StaminaBlockRegen(bool bBlock) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HeroCheatExtension", "StaminaBlockRegen");

	Params::HeroCheatExtension_StaminaBlockRegen Parms{};

	Parms.bBlock = bBlock;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function CommonCheatsRuntime.HeroCheatExtension.StaminaSetValue
// (Final, Exec, Native, Public, Const)
// Parameters:
// float                                   Value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UHeroCheatExtension::StaminaSetValue(float Value) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HeroCheatExtension", "StaminaSetValue");

	Params::HeroCheatExtension_StaminaSetValue Parms{};

	Parms.Value = Value;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function CommonCheatsRuntime.HeroCheatExtension.ToggleGameplayTag
// (Final, Exec, Native, Public, Const)
// Parameters:
// const struct FGameplayTag&              Tag                                                    (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UHeroCheatExtension::ToggleGameplayTag(const struct FGameplayTag& Tag) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HeroCheatExtension", "ToggleGameplayTag");

	Params::HeroCheatExtension_ToggleGameplayTag Parms{};

	Parms.Tag = std::move(Tag);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function CommonCheatsRuntime.HeroCheatExtension.UnlimitedHealth
// (Final, Exec, Native, Public, Const)

void UHeroCheatExtension::UnlimitedHealth() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HeroCheatExtension", "UnlimitedHealth");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function CommonCheatsRuntime.P2InventoryCheatExtension.AddItemPresetToPlayerInventory
// (Final, Exec, Native, Private)
// Parameters:
// const class FString&                    ItemPresetString                                       (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UP2InventoryCheatExtension::AddItemPresetToPlayerInventory(const class FString& ItemPresetString)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("P2InventoryCheatExtension", "AddItemPresetToPlayerInventory");

	Params::P2InventoryCheatExtension_AddItemPresetToPlayerInventory Parms{};

	Parms.ItemPresetString = std::move(ItemPresetString);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function CommonCheatsRuntime.P2InventoryCheatExtension.AddItemToPlayerInventory
// (Final, Exec, Native, Public)
// Parameters:
// const class FString&                    AssetId                                                (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UP2InventoryCheatExtension::AddItemToPlayerInventory(const class FString& AssetId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("P2InventoryCheatExtension", "AddItemToPlayerInventory");

	Params::P2InventoryCheatExtension_AddItemToPlayerInventory Parms{};

	Parms.AssetId = std::move(AssetId);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function CommonCheatsRuntime.P2InventoryCheatExtension.ServerAddItemToBotInventory
// (Net, NetReliable, Native, Event, Protected, NetServer)
// Parameters:
// const class AP2HeroCharacter*           Bot                                                    (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class FString&                    AssetId                                                (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UP2InventoryCheatExtension::ServerAddItemToBotInventory(const class AP2HeroCharacter* Bot, const class FString& AssetId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("P2InventoryCheatExtension", "ServerAddItemToBotInventory");

	Params::P2InventoryCheatExtension_ServerAddItemToBotInventory Parms{};

	Parms.Bot = Bot;
	Parms.AssetId = std::move(AssetId);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function CommonCheatsRuntime.P2InventoryCheatExtension.ServerAddModdedItemToBotInventory
// (Net, NetReliable, Native, Event, Protected, NetServer)
// Parameters:
// const class AP2HeroCharacter*           Character                                              (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class FString&                    ItemJsonString                                         (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UP2InventoryCheatExtension::ServerAddModdedItemToBotInventory(const class AP2HeroCharacter* Character, const class FString& ItemJsonString)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("P2InventoryCheatExtension", "ServerAddModdedItemToBotInventory");

	Params::P2InventoryCheatExtension_ServerAddModdedItemToBotInventory Parms{};

	Parms.Character = Character;
	Parms.ItemJsonString = std::move(ItemJsonString);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function CommonCheatsRuntime.P2InventoryCheatExtension.SpawnItem
// (Final, Exec, Native, Public)
// Parameters:
// const class FString&                    AssetId                                                (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UP2InventoryCheatExtension::SpawnItem(const class FString& AssetId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("P2InventoryCheatExtension", "SpawnItem");

	Params::P2InventoryCheatExtension_SpawnItem Parms{};

	Parms.AssetId = std::move(AssetId);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function CommonCheatsRuntime.P2InventoryPresetCheatExtension.ServerApplyPreset
// (Final, Net, NetReliable, Native, Event, Private, NetServer)
// Parameters:
// class AP2HeroCharacter*                 Target                                                 (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FP2ItemPresetInfo&         Preset                                                 (ConstParm, Parm, ReferenceParm, NativeAccessSpecifierPublic)

void UP2InventoryPresetCheatExtension::ServerApplyPreset(class AP2HeroCharacter* Target, const struct FP2ItemPresetInfo& Preset)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("P2InventoryPresetCheatExtension", "ServerApplyPreset");

	Params::P2InventoryPresetCheatExtension_ServerApplyPreset Parms{};

	Parms.Target = Target;
	Parms.Preset = std::move(Preset);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function CommonCheatsRuntime.P2InventoryPresetCheatExtension.ServerApplyPresetToAllBots
// (Final, Net, NetReliable, Native, Event, Private, NetServer)
// Parameters:
// const struct FP2ItemPresetInfo&         Preset                                                 (ConstParm, Parm, ReferenceParm, NativeAccessSpecifierPublic)

void UP2InventoryPresetCheatExtension::ServerApplyPresetToAllBots(const struct FP2ItemPresetInfo& Preset)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("P2InventoryPresetCheatExtension", "ServerApplyPresetToAllBots");

	Params::P2InventoryPresetCheatExtension_ServerApplyPresetToAllBots Parms{};

	Parms.Preset = std::move(Preset);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function CommonCheatsRuntime.P2InventoryPresetCheatExtension.ServerApplyPresetToAllPlayers
// (Final, Net, NetReliable, Native, Event, Private, NetServer)
// Parameters:
// const struct FP2ItemPresetInfo&         Preset                                                 (ConstParm, Parm, ReferenceParm, NativeAccessSpecifierPublic)

void UP2InventoryPresetCheatExtension::ServerApplyPresetToAllPlayers(const struct FP2ItemPresetInfo& Preset)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("P2InventoryPresetCheatExtension", "ServerApplyPresetToAllPlayers");

	Params::P2InventoryPresetCheatExtension_ServerApplyPresetToAllPlayers Parms{};

	Parms.Preset = std::move(Preset);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function CommonCheatsRuntime.P2InventoryPresetCheatExtension.ServerApplySpawnPreset
// (Final, Net, NetReliable, Native, Event, Private, NetServer)
// Parameters:
// const struct FP2ItemPresetInfo&         Preset                                                 (ConstParm, Parm, ReferenceParm, NativeAccessSpecifierPublic)

void UP2InventoryPresetCheatExtension::ServerApplySpawnPreset(const struct FP2ItemPresetInfo& Preset)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("P2InventoryPresetCheatExtension", "ServerApplySpawnPreset");

	Params::P2InventoryPresetCheatExtension_ServerApplySpawnPreset Parms{};

	Parms.Preset = std::move(Preset);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function CommonCheatsRuntime.P2MannequinCheatExtension.OnSkinBuildEnded
// (Final, Native, Private)
// Parameters:
// class USkeletalMesh*                    InOutputMesh                                           (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UP2MannequinCheatExtension::OnSkinBuildEnded(class USkeletalMesh* InOutputMesh)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("P2MannequinCheatExtension", "OnSkinBuildEnded");

	Params::P2MannequinCheatExtension_OnSkinBuildEnded Parms{};

	Parms.InOutputMesh = InOutputMesh;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function CommonCheatsRuntime.P2OperationalTasksCheatExtension.ServerCalculateAvailableEventContracts
// (Net, NetReliable, Native, Event, Public, NetServer, NetValidate)
// Parameters:
// const bool                              bInOverrideCurrent                                     (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UP2OperationalTasksCheatExtension::ServerCalculateAvailableEventContracts(const bool bInOverrideCurrent)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("P2OperationalTasksCheatExtension", "ServerCalculateAvailableEventContracts");

	Params::P2OperationalTasksCheatExtension_ServerCalculateAvailableEventContracts Parms{};

	Parms.bInOverrideCurrent = bInOverrideCurrent;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function CommonCheatsRuntime.P2AnomalyCheatExtension.AnomalyForceSpawnBubble
// (Final, Exec, Native, Public)

void UP2AnomalyCheatExtension::AnomalyForceSpawnBubble()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("P2AnomalyCheatExtension", "AnomalyForceSpawnBubble");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function CommonCheatsRuntime.P2AnomalyCheatExtension.AnomalyOpenGates
// (Final, Exec, Native, Public)
// Parameters:
// const class FString&                    InGate                                                 (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UP2AnomalyCheatExtension::AnomalyOpenGates(const class FString& InGate)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("P2AnomalyCheatExtension", "AnomalyOpenGates");

	Params::P2AnomalyCheatExtension_AnomalyOpenGates Parms{};

	Parms.InGate = std::move(InGate);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function CommonCheatsRuntime.P2AnomalyCheatExtension.AnomalyToggleDisableAllClients
// (Final, Exec, Native, Public)

void UP2AnomalyCheatExtension::AnomalyToggleDisableAllClients()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("P2AnomalyCheatExtension", "AnomalyToggleDisableAllClients");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function CommonCheatsRuntime.P2AnomalyCheatExtension.AnomalyToggleDisableClient
// (Final, Exec, Native, Public)

void UP2AnomalyCheatExtension::AnomalyToggleDisableClient()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("P2AnomalyCheatExtension", "AnomalyToggleDisableClient");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function CommonCheatsRuntime.P2AnomalyCheatExtension.CheckExtractionTunnelValid
// (Final, Native, Private)
// Parameters:
// const class AP2ExtractionTunnel*        Tunnel                                                 (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EP2ExtractionTunnelFailReason           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

EP2ExtractionTunnelFailReason UP2AnomalyCheatExtension::CheckExtractionTunnelValid(const class AP2ExtractionTunnel* Tunnel)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("P2AnomalyCheatExtension", "CheckExtractionTunnelValid");

	Params::P2AnomalyCheatExtension_CheckExtractionTunnelValid Parms{};

	Parms.Tunnel = Tunnel;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function CommonCheatsRuntime.P2AnomalyCheatExtension.PrintExtractionTunnelDebug
// (Final, Exec, Native, Public)

void UP2AnomalyCheatExtension::PrintExtractionTunnelDebug()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("P2AnomalyCheatExtension", "PrintExtractionTunnelDebug");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function CommonCheatsRuntime.P2AnomalyCheatExtension.ShowAnomalyDebug
// (Final, Exec, Native, Public)

void UP2AnomalyCheatExtension::ShowAnomalyDebug()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("P2AnomalyCheatExtension", "ShowAnomalyDebug");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function CommonCheatsRuntime.P2AnomalyCheatExtension.ShowExtractionTunnelDebug
// (Final, Exec, Native, Public)
// Parameters:
// const class FString&                    InState                                                (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   MaxDistanceToPlayer                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UP2AnomalyCheatExtension::ShowExtractionTunnelDebug(const class FString& InState, float MaxDistanceToPlayer)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("P2AnomalyCheatExtension", "ShowExtractionTunnelDebug");

	Params::P2AnomalyCheatExtension_ShowExtractionTunnelDebug Parms{};

	Parms.InState = std::move(InState);
	Parms.MaxDistanceToPlayer = MaxDistanceToPlayer;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function CommonCheatsRuntime.P2CheatManagerExtension_CheatCommands.Cheat
// (Final, Exec, Native, Public)
// Parameters:
// const class FString&                    Msg                                                    (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UP2CheatManagerExtension_CheatCommands::Cheat(const class FString& Msg)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("P2CheatManagerExtension_CheatCommands", "Cheat");

	Params::P2CheatManagerExtension_CheatCommands_Cheat Parms{};

	Parms.Msg = std::move(Msg);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function CommonCheatsRuntime.P2CheatManagerExtension_CheatCommands.CheatAll
// (Final, Exec, Native, Public)
// Parameters:
// const class FString&                    Msg                                                    (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UP2CheatManagerExtension_CheatCommands::CheatAll(const class FString& Msg)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("P2CheatManagerExtension_CheatCommands", "CheatAll");

	Params::P2CheatManagerExtension_CheatCommands_CheatAll Parms{};

	Parms.Msg = std::move(Msg);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function CommonCheatsRuntime.P2ContextHelperCheatExtension.ServerApplyContextHelperPreset
// (Net, NetReliable, Native, Event, Protected, NetServer)
// Parameters:
// const class FString&                    ContextHelperPreset                                    (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UP2ContextHelperCheatExtension::ServerApplyContextHelperPreset(const class FString& ContextHelperPreset)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("P2ContextHelperCheatExtension", "ServerApplyContextHelperPreset");

	Params::P2ContextHelperCheatExtension_ServerApplyContextHelperPreset Parms{};

	Parms.ContextHelperPreset = std::move(ContextHelperPreset);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function CommonCheatsRuntime.P2ExtractionManagerCheatExtension.ActivateAllExtractions
// (Final, Exec, Native, Public)

void UP2ExtractionManagerCheatExtension::ActivateAllExtractions()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("P2ExtractionManagerCheatExtension", "ActivateAllExtractions");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function CommonCheatsRuntime.P2ExtractionManagerCheatExtension.ResetAllExtractions
// (Final, Exec, Native, Public)

void UP2ExtractionManagerCheatExtension::ResetAllExtractions()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("P2ExtractionManagerCheatExtension", "ResetAllExtractions");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function CommonCheatsRuntime.P2GameplayCueListener.OnGameplayCue
// (Event, Public, HasOutParams, BlueprintEvent)
// Parameters:
// class AActor*                           TargetActor                                            (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FGameplayTag&              Tag                                                    (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EGameplayCueEvent                       EventType                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FGameplayCueParameters&    Params_0                                               (ConstParm, Parm, OutParm, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)

void AP2GameplayCueListener::OnGameplayCue(class AActor* TargetActor, const struct FGameplayTag& Tag, EGameplayCueEvent EventType, const struct FGameplayCueParameters& Params_0)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("P2GameplayCueListener", "OnGameplayCue");

	Params::P2GameplayCueListener_OnGameplayCue Parms{};

	Parms.TargetActor = TargetActor;
	Parms.Tag = std::move(Tag);
	Parms.EventType = EventType;
	Parms.Params_0 = std::move(Params_0);

	UObject::ProcessEvent(Func, &Parms);
}


// Function CommonCheatsRuntime.P2LootSpawnCheatExtension.ClientExportLootLevelInstances
// (Final, Net, NetReliable, Native, Event, Private, NetClient)
// Parameters:
// const class FString&                    InExportedText                                         (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UP2LootSpawnCheatExtension::ClientExportLootLevelInstances(const class FString& InExportedText)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("P2LootSpawnCheatExtension", "ClientExportLootLevelInstances");

	Params::P2LootSpawnCheatExtension_ClientExportLootLevelInstances Parms{};

	Parms.InExportedText = std::move(InExportedText);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function CommonCheatsRuntime.P2LootSpawnCheatExtension.ClientExportLootSim
// (Final, Net, NetReliable, Native, Event, Private, NetClient)
// Parameters:
// const class FString&                    InExportedText                                         (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   InNumSim                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UP2LootSpawnCheatExtension::ClientExportLootSim(const class FString& InExportedText, int32 InNumSim)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("P2LootSpawnCheatExtension", "ClientExportLootSim");

	Params::P2LootSpawnCheatExtension_ClientExportLootSim Parms{};

	Parms.InExportedText = std::move(InExportedText);
	Parms.InNumSim = InNumSim;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function CommonCheatsRuntime.P2LootSpawnCheatExtension.ClientExportWorldLoot
// (Final, Net, NetReliable, Native, Event, Private, NetClient)
// Parameters:
// const class FString&                    InExportedText                                         (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UP2LootSpawnCheatExtension::ClientExportWorldLoot(const class FString& InExportedText)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("P2LootSpawnCheatExtension", "ClientExportWorldLoot");

	Params::P2LootSpawnCheatExtension_ClientExportWorldLoot Parms{};

	Parms.InExportedText = std::move(InExportedText);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function CommonCheatsRuntime.P2LootSpawnCheatExtension.ExportLootLevelInstances
// (Final, Exec, Native, Public)

void UP2LootSpawnCheatExtension::ExportLootLevelInstances()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("P2LootSpawnCheatExtension", "ExportLootLevelInstances");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function CommonCheatsRuntime.P2LootSpawnCheatExtension.ExportLootSim
// (Final, Exec, Native, Public)
// Parameters:
// const class FString&                    InNumSimulations                                       (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bInOneLinePerItem                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class FString&                    InLevelInstanceName                                    (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UP2LootSpawnCheatExtension::ExportLootSim(const class FString& InNumSimulations, bool bInOneLinePerItem, const class FString& InLevelInstanceName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("P2LootSpawnCheatExtension", "ExportLootSim");

	Params::P2LootSpawnCheatExtension_ExportLootSim Parms{};

	Parms.InNumSimulations = std::move(InNumSimulations);
	Parms.bInOneLinePerItem = bInOneLinePerItem;
	Parms.InLevelInstanceName = std::move(InLevelInstanceName);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function CommonCheatsRuntime.P2LootSpawnCheatExtension.ExportWorldLoot
// (Final, Exec, Native, Public)
// Parameters:
// const class FString&                    InLevelInstanceName                                    (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UP2LootSpawnCheatExtension::ExportWorldLoot(const class FString& InLevelInstanceName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("P2LootSpawnCheatExtension", "ExportWorldLoot");

	Params::P2LootSpawnCheatExtension_ExportWorldLoot Parms{};

	Parms.InLevelInstanceName = std::move(InLevelInstanceName);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function CommonCheatsRuntime.P2LootSpawnCheatExtension.OnSimulationStepComplete
// (Final, Native, Protected)

void UP2LootSpawnCheatExtension::OnSimulationStepComplete()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("P2LootSpawnCheatExtension", "OnSimulationStepComplete");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function CommonCheatsRuntime.P2LootSpawnCheatExtension.RegenLoot
// (Final, Exec, Native, Public)
// Parameters:
// const class FString&                    InCustomSeed                                           (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UP2LootSpawnCheatExtension::RegenLoot(const class FString& InCustomSeed)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("P2LootSpawnCheatExtension", "RegenLoot");

	Params::P2LootSpawnCheatExtension_RegenLoot Parms{};

	Parms.InCustomSeed = std::move(InCustomSeed);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function CommonCheatsRuntime.P2LootSpawnCheatExtension.RegenLootSameSeed
// (Final, Exec, Native, Public)

void UP2LootSpawnCheatExtension::RegenLootSameSeed()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("P2LootSpawnCheatExtension", "RegenLootSameSeed");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function CommonCheatsRuntime.P2MetricsCheatExtension.Input_RangeFinderFixPoint
// (Final, Native, Public)
// Parameters:
// const struct FKey&                      Key                                                    (Parm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FInputActionValue&         Value                                                  (Parm, NoDestructor, NativeAccessSpecifierPublic)

void UP2MetricsCheatExtension::Input_RangeFinderFixPoint(const struct FKey& Key, const struct FInputActionValue& Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("P2MetricsCheatExtension", "Input_RangeFinderFixPoint");

	Params::P2MetricsCheatExtension_Input_RangeFinderFixPoint Parms{};

	Parms.Key = std::move(Key);
	Parms.Value = std::move(Value);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function CommonCheatsRuntime.P2MetricsCheatExtension.Input_ToggleRangeFinder
// (Final, Native, Public)
// Parameters:
// const struct FKey&                      Key                                                    (Parm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FInputActionValue&         Value                                                  (Parm, NoDestructor, NativeAccessSpecifierPublic)

void UP2MetricsCheatExtension::Input_ToggleRangeFinder(const struct FKey& Key, const struct FInputActionValue& Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("P2MetricsCheatExtension", "Input_ToggleRangeFinder");

	Params::P2MetricsCheatExtension_Input_ToggleRangeFinder Parms{};

	Parms.Key = std::move(Key);
	Parms.Value = std::move(Value);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function CommonCheatsRuntime.P2MetricsCheatExtension.ToggleRangeFinder
// (Final, Exec, Native, Private)

void UP2MetricsCheatExtension::ToggleRangeFinder()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("P2MetricsCheatExtension", "ToggleRangeFinder");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function CommonCheatsRuntime.P2OnlineServiceCheatExtension.OnOnlineServiceNewsReceived
// (Final, Native, Protected)
// Parameters:
// const TArray<struct FP2OnlineServiceNewsItem>&InNewsItems                                            (Parm, ZeroConstructor, NativeAccessSpecifierPublic)

void UP2OnlineServiceCheatExtension::OnOnlineServiceNewsReceived(const TArray<struct FP2OnlineServiceNewsItem>& InNewsItems)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("P2OnlineServiceCheatExtension", "OnOnlineServiceNewsReceived");

	Params::P2OnlineServiceCheatExtension_OnOnlineServiceNewsReceived Parms{};

	Parms.InNewsItems = std::move(InNewsItems);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function CommonCheatsRuntime.P2RaidResultCheatExtension.OnRaidResultReceived
// (Final, Native, Protected)
// Parameters:
// int32                                   InResultNum                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const TArray<struct FP2RaidResultRecord>&InResults                                              (Parm, ZeroConstructor, NativeAccessSpecifierPublic)

void UP2RaidResultCheatExtension::OnRaidResultReceived(int32 InResultNum, const TArray<struct FP2RaidResultRecord>& InResults)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("P2RaidResultCheatExtension", "OnRaidResultReceived");

	Params::P2RaidResultCheatExtension_OnRaidResultReceived Parms{};

	Parms.InResultNum = InResultNum;
	Parms.InResults = std::move(InResults);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function CommonCheatsRuntime.P2RuntimeGridCheatExtension.Input_AssignCloseMid
// (Final, Native, Public)
// Parameters:
// const struct FKey&                      Key                                                    (Parm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FInputActionValue&         Value                                                  (Parm, NoDestructor, NativeAccessSpecifierPublic)

void UP2RuntimeGridCheatExtension::Input_AssignCloseMid(const struct FKey& Key, const struct FInputActionValue& Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("P2RuntimeGridCheatExtension", "Input_AssignCloseMid");

	Params::P2RuntimeGridCheatExtension_Input_AssignCloseMid Parms{};

	Parms.Key = std::move(Key);
	Parms.Value = std::move(Value);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function CommonCheatsRuntime.P2RuntimeGridCheatExtension.Input_AssignFar
// (Final, Native, Public)
// Parameters:
// const struct FKey&                      Key                                                    (Parm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FInputActionValue&         Value                                                  (Parm, NoDestructor, NativeAccessSpecifierPublic)

void UP2RuntimeGridCheatExtension::Input_AssignFar(const struct FKey& Key, const struct FInputActionValue& Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("P2RuntimeGridCheatExtension", "Input_AssignFar");

	Params::P2RuntimeGridCheatExtension_Input_AssignFar Parms{};

	Parms.Key = std::move(Key);
	Parms.Value = std::move(Value);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function CommonCheatsRuntime.P2RuntimeGridCheatExtension.Input_AssignFarMid
// (Final, Native, Public)
// Parameters:
// const struct FKey&                      Key                                                    (Parm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FInputActionValue&         Value                                                  (Parm, NoDestructor, NativeAccessSpecifierPublic)

void UP2RuntimeGridCheatExtension::Input_AssignFarMid(const struct FKey& Key, const struct FInputActionValue& Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("P2RuntimeGridCheatExtension", "Input_AssignFarMid");

	Params::P2RuntimeGridCheatExtension_Input_AssignFarMid Parms{};

	Parms.Key = std::move(Key);
	Parms.Value = std::move(Value);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function CommonCheatsRuntime.P2RuntimeGridCheatExtension.Input_AssignNear
// (Final, Native, Public)
// Parameters:
// const struct FKey&                      Key                                                    (Parm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FInputActionValue&         Value                                                  (Parm, NoDestructor, NativeAccessSpecifierPublic)

void UP2RuntimeGridCheatExtension::Input_AssignNear(const struct FKey& Key, const struct FInputActionValue& Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("P2RuntimeGridCheatExtension", "Input_AssignNear");

	Params::P2RuntimeGridCheatExtension_Input_AssignNear Parms{};

	Parms.Key = std::move(Key);
	Parms.Value = std::move(Value);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function CommonCheatsRuntime.P2RuntimeGridCheatExtension.Input_ExportToCsv
// (Final, Native, Public)
// Parameters:
// const struct FKey&                      Key                                                    (Parm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FInputActionValue&         Value                                                  (Parm, NoDestructor, NativeAccessSpecifierPublic)

void UP2RuntimeGridCheatExtension::Input_ExportToCsv(const struct FKey& Key, const struct FInputActionValue& Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("P2RuntimeGridCheatExtension", "Input_ExportToCsv");

	Params::P2RuntimeGridCheatExtension_Input_ExportToCsv Parms{};

	Parms.Key = std::move(Key);
	Parms.Value = std::move(Value);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function CommonCheatsRuntime.P2RuntimeGridCheatExtension.Input_ToggleRuntimeGridInfo
// (Final, Native, Public)
// Parameters:
// const struct FKey&                      Key                                                    (Parm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FInputActionValue&         Value                                                  (Parm, NoDestructor, NativeAccessSpecifierPublic)

void UP2RuntimeGridCheatExtension::Input_ToggleRuntimeGridInfo(const struct FKey& Key, const struct FInputActionValue& Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("P2RuntimeGridCheatExtension", "Input_ToggleRuntimeGridInfo");

	Params::P2RuntimeGridCheatExtension_Input_ToggleRuntimeGridInfo Parms{};

	Parms.Key = std::move(Key);
	Parms.Value = std::move(Value);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function CommonCheatsRuntime.P2RuntimeGridCheatExtension.ToggleRuntimeGridInfo
// (Final, Exec, Native, Private)

void UP2RuntimeGridCheatExtension::ToggleRuntimeGridInfo()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("P2RuntimeGridCheatExtension", "ToggleRuntimeGridInfo");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function CommonCheatsRuntime.P2SkinCheatExtension.ServerApplySkinToItem
// (Final, Net, NetReliable, Native, Event, Private, NetServer)
// Parameters:
// class UP2Item*                          Item                                                   (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const TArray<class UP2SkinSlotPreset*>& SkinPresets                                            (ConstParm, Parm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// class UP2ItemSkinContainer*             SkinContainer                                          (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UP2SkinCheatExtension::ServerApplySkinToItem(class UP2Item* Item, const TArray<class UP2SkinSlotPreset*>& SkinPresets, class UP2ItemSkinContainer* SkinContainer)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("P2SkinCheatExtension", "ServerApplySkinToItem");

	Params::P2SkinCheatExtension_ServerApplySkinToItem Parms{};

	Parms.Item = Item;
	Parms.SkinPresets = std::move(SkinPresets);
	Parms.SkinContainer = SkinContainer;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function CommonCheatsRuntime.P2SpectatorCheatExtension.SpectateNextPlayer
// (Final, Exec, Native, Public, Const)

void UP2SpectatorCheatExtension::SpectateNextPlayer() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("P2SpectatorCheatExtension", "SpectateNextPlayer");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function CommonCheatsRuntime.P2SpectatorCheatExtension.SpectatePreviousPlayer
// (Final, Exec, Native, Public, Const)

void UP2SpectatorCheatExtension::SpectatePreviousPlayer() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("P2SpectatorCheatExtension", "SpectatePreviousPlayer");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function CommonCheatsRuntime.P2SpectatorCheatExtension.ToggleP2SpectatorMode
// (Final, Exec, Native, Public, Const)

void UP2SpectatorCheatExtension::ToggleP2SpectatorMode() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("P2SpectatorCheatExtension", "ToggleP2SpectatorMode");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function CommonCheatsRuntime.PlayerStartCheatExtension.SetPlayerStartFilter
// (Final, Exec, Native, Private)
// Parameters:
// const class FString&                    Filter                                                 (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPlayerStartCheatExtension::SetPlayerStartFilter(const class FString& Filter)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerStartCheatExtension", "SetPlayerStartFilter");

	Params::PlayerStartCheatExtension_SetPlayerStartFilter Parms{};

	Parms.Filter = std::move(Filter);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function CommonCheatsRuntime.RaidCheatManagerExtension.AdminForcePerspective
// (Final, Exec, Native, Public)
// Parameters:
// const int32                             Index_0                                                (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URaidCheatManagerExtension::AdminForcePerspective(const int32 Index_0)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RaidCheatManagerExtension", "AdminForcePerspective");

	Params::RaidCheatManagerExtension_AdminForcePerspective Parms{};

	Parms.Index_0 = Index_0;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function CommonCheatsRuntime.RaidCheatManagerExtension.RequestExitRaid
// (Final, Exec, Native, Public)

void URaidCheatManagerExtension::RequestExitRaid()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RaidCheatManagerExtension", "RequestExitRaid");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function CommonCheatsRuntime.RaidCheatManagerExtension.ToggleCurrentRaidResultsUI
// (Final, Exec, Native, Public)

void URaidCheatManagerExtension::ToggleCurrentRaidResultsUI()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RaidCheatManagerExtension", "ToggleCurrentRaidResultsUI");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function CommonCheatsRuntime.TeamCheatExtension.DbnoEnabled
// (Final, Exec, Native, Public)
// Parameters:
// bool                                    bEnabled                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTeamCheatExtension::DbnoEnabled(bool bEnabled)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TeamCheatExtension", "DbnoEnabled");

	Params::TeamCheatExtension_DbnoEnabled Parms{};

	Parms.bEnabled = bEnabled;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function CommonCheatsRuntime.TeamCheatExtension.FriendlyFire
// (Final, Exec, Native, Public)
// Parameters:
// bool                                    bEnabled                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTeamCheatExtension::FriendlyFire(bool bEnabled)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TeamCheatExtension", "FriendlyFire");

	Params::TeamCheatExtension_FriendlyFire Parms{};

	Parms.bEnabled = bEnabled;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function CommonCheatsRuntime.TeamCheatExtension.RequestPlayerBotInfo
// (Final, Exec, Native, Public)

void UTeamCheatExtension::RequestPlayerBotInfo()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TeamCheatExtension", "RequestPlayerBotInfo");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function CommonCheatsRuntime.TeamCheatExtension.RequestPlayerBotTeamInfo
// (Final, Exec, Native, Public)

void UTeamCheatExtension::RequestPlayerBotTeamInfo()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TeamCheatExtension", "RequestPlayerBotTeamInfo");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function CommonCheatsRuntime.TeamCheatExtension.SendClientPlayerBotInfo
// (Net, NetReliable, Native, Event, Public, NetClient)
// Parameters:
// const TArray<struct FP2PlayerBotDebugInfo>&InPlayerBotDebugInfoArray                              (ConstParm, Parm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)

void UTeamCheatExtension::SendClientPlayerBotInfo(const TArray<struct FP2PlayerBotDebugInfo>& InPlayerBotDebugInfoArray)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TeamCheatExtension", "SendClientPlayerBotInfo");

	Params::TeamCheatExtension_SendClientPlayerBotInfo Parms{};

	Parms.InPlayerBotDebugInfoArray = std::move(InPlayerBotDebugInfoArray);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function CommonCheatsRuntime.TeamCheatExtension.SendClientPlayerBotTeamInfo
// (Net, NetReliable, Native, Event, Public, NetClient)
// Parameters:
// const TArray<struct FP2PlayerBotTeamDebugInfo>&InPlayerBotTeamDebugInfoArray                          (ConstParm, Parm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)

void UTeamCheatExtension::SendClientPlayerBotTeamInfo(const TArray<struct FP2PlayerBotTeamDebugInfo>& InPlayerBotTeamDebugInfoArray)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TeamCheatExtension", "SendClientPlayerBotTeamInfo");

	Params::TeamCheatExtension_SendClientPlayerBotTeamInfo Parms{};

	Parms.InPlayerBotTeamDebugInfoArray = std::move(InPlayerBotTeamDebugInfoArray);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function CommonCheatsRuntime.TeamCheatExtension.SetTeamSquadUserStatusMyself
// (Final, Exec, Native, Public)
// Parameters:
// int32                                   StateId                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTeamCheatExtension::SetTeamSquadUserStatusMyself(int32 StateId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TeamCheatExtension", "SetTeamSquadUserStatusMyself");

	Params::TeamCheatExtension_SetTeamSquadUserStatusMyself Parms{};

	Parms.StateId = StateId;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function CommonCheatsRuntime.TeamCheatExtension.TeamAddPlayer
// (Final, Exec, Native, Public)
// Parameters:
// int32                                   TeamId                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTeamCheatExtension::TeamAddPlayer(int32 TeamId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TeamCheatExtension", "TeamAddPlayer");

	Params::TeamCheatExtension_TeamAddPlayer Parms{};

	Parms.TeamId = TeamId;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function CommonCheatsRuntime.TeamCheatExtension.TeamChangeForPlayer
// (Final, Exec, Native, Public)
// Parameters:
// int32                                   PlayerId                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   TeamId                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTeamCheatExtension::TeamChangeForPlayer(int32 PlayerId, int32 TeamId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TeamCheatExtension", "TeamChangeForPlayer");

	Params::TeamCheatExtension_TeamChangeForPlayer Parms{};

	Parms.PlayerId = PlayerId;
	Parms.TeamId = TeamId;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function CommonCheatsRuntime.TeamCheatExtension.TeamCreate
// (Final, Exec, Native, Public)

void UTeamCheatExtension::TeamCreate()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TeamCheatExtension", "TeamCreate");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function CommonCheatsRuntime.TeamCheatExtension.TeamFriendlyFire
// (Final, Exec, Native, Public)
// Parameters:
// int32                                   TeamId                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bEnabled                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTeamCheatExtension::TeamFriendlyFire(int32 TeamId, bool bEnabled)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TeamCheatExtension", "TeamFriendlyFire");

	Params::TeamCheatExtension_TeamFriendlyFire Parms{};

	Parms.TeamId = TeamId;
	Parms.bEnabled = bEnabled;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function CommonCheatsRuntime.TeamCheatExtension.TeamHideoutSync
// (Final, Exec, Native, Public)
// Parameters:
// bool                                    bEnabled                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTeamCheatExtension::TeamHideoutSync(bool bEnabled)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TeamCheatExtension", "TeamHideoutSync");

	Params::TeamCheatExtension_TeamHideoutSync Parms{};

	Parms.bEnabled = bEnabled;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function CommonCheatsRuntime.TeamCheatExtension.TeamRemove
// (Final, Exec, Native, Public)
// Parameters:
// int32                                   TeamId                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTeamCheatExtension::TeamRemove(int32 TeamId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TeamCheatExtension", "TeamRemove");

	Params::TeamCheatExtension_TeamRemove Parms{};

	Parms.TeamId = TeamId;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function CommonCheatsRuntime.UICheatExtension.HiddenHUD
// (Final, Exec, Native, Public, Const)
// Parameters:
// bool                                    InIsHidden                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UUICheatExtension::HiddenHUD(bool InIsHidden) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UICheatExtension", "HiddenHUD");

	Params::UICheatExtension_HiddenHUD Parms{};

	Parms.InIsHidden = InIsHidden;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}

}

