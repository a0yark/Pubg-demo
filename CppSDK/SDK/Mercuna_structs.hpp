#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: Mercuna

#include "Basic.hpp"

#include "CoreUObject_structs.hpp"


namespace SDK
{

// Enum Mercuna.EMercunaNavigationLinkDirection
// NumValues: 0x0004
enum class EMercunaNavigationLinkDirection : uint8
{
	BothWays                                 = 0,
	LeftToRight                              = 1,
	RightToLeft                              = 2,
	EMercunaNavigationLinkDirection_MAX      = 3,
};

// Enum Mercuna.EMercunaGridType
// NumValues: 0x0005
enum class EMercunaGridType : uint32
{
	None                                     = 0,
	Ground                                   = 1,
	Surface                                  = 2,
	Both                                     = 3,
	EMercunaGridType_MAX                     = 4,
};

// Enum Mercuna.EMercunaPathEvent
// NumValues: 0x0004
enum class EMercunaPathEvent : uint8
{
	Ready                                    = 0,
	Updated                                  = 1,
	Invalid                                  = 2,
	EMercunaPathEvent_MAX                    = 3,
};

// Enum Mercuna.EMercunaMoveResult
// NumValues: 0x0006
enum class EMercunaMoveResult : uint8
{
	Success                                  = 0,
	Failed                                   = 1,
	Cancelled                                = 2,
	Blocked                                  = 3,
	Invalid                                  = 4,
	EMercunaMoveResult_MAX                   = 5,
};

// Enum Mercuna.EMercunaAvoidanceMode
// NumValues: 0x0004
enum class EMercunaAvoidanceMode : uint8
{
	None                                     = 0,
	ORCA                                     = 1,
	ContextualSteering                       = 2,
	EMercunaAvoidanceMode_MAX                = 3,
};

// Enum Mercuna.EMercunaAvoidanceWhenStationary
// NumValues: 0x0004
enum class EMercunaAvoidanceWhenStationary : uint8
{
	None                                     = 0,
	CollisionOnly                            = 1,
	Full                                     = 2,
	EMercunaAvoidanceWhenStationary_MAX      = 3,
};

// Enum Mercuna.EMercunaAutoNavLinkTraversalType
// NumValues: 0x0003
enum class EMercunaAutoNavLinkTraversalType : uint8
{
	OneWay                                   = 0,
	Bidirectional                            = 1,
	EMercunaAutoNavLinkTraversalType_MAX     = 2,
};

// Enum Mercuna.EMerNavigationTrajectory
// NumValues: 0x0005
enum class EMerNavigationTrajectory : uint8
{
	Trajectory                               = 0,
	Avoiding                                 = 1,
	NavLink                                  = 2,
	None                                     = 3,
	EMerNavigationTrajectory_MAX             = 4,
};

// Enum Mercuna.EMercunaMoveInForwardDirection
// NumValues: 0x0004
enum class EMercunaMoveInForwardDirection : uint8
{
	Always                                   = 0,
	Prefer                                   = 1,
	Independent                              = 2,
	EMercunaMoveInForwardDirection_MAX       = 3,
};

// Enum Mercuna.EMercunaPointDistribution
// NumValues: 0x0003
enum class EMercunaPointDistribution : uint8
{
	Uniform                                  = 0,
	Random                                   = 1,
	EMercunaPointDistribution_MAX            = 2,
};

// Enum Mercuna.EMercunaProjectionType
// NumValues: 0x0004
enum class EMercunaProjectionType : uint8
{
	Up                                       = 0,
	Down                                     = 1,
	UpOrDown                                 = 2,
	EMercunaProjectionType_MAX               = 3,
};

// Enum Mercuna.EMercunaNavLinkQueryMode
// NumValues: 0x0004
enum class EMercunaNavLinkQueryMode : uint8
{
	All                                      = 0,
	CurrentGrid                              = 1,
	None                                     = 2,
	EMercunaNavLinkQueryMode_MAX             = 3,
};

// Enum Mercuna.EMercunaInvokerVolumeType
// NumValues: 0x0003
enum class EMercunaInvokerVolumeType : uint8
{
	Always                                   = 0,
	OnOverlap                                = 1,
	EMercunaInvokerVolumeType_MAX            = 2,
};

// Enum Mercuna.EMercunaLevelOfDetail
// NumValues: 0x0006
enum class EMercunaLevelOfDetail : uint8
{
	Full                                     = 0,
	Half                                     = 1,
	Quarter                                  = 2,
	Eighth                                   = 3,
	Sixteenth                                = 4,
	EMercunaLevelOfDetail_MAX                = 5,
};

// Enum Mercuna.EMercunaObstacleType
// NumValues: 0x0004
enum class EMercunaObstacleType : uint8
{
	Sphere                                   = 0,
	Box                                      = 1,
	Cylinder                                 = 2,
	EMercunaObstacleType_MAX                 = 3,
};

// Enum Mercuna.EMercunaObstacleMovementType
// NumValues: 0x0005
enum class EMercunaObstacleMovementType : uint8
{
	ThreeDimensional                         = 0,
	Character                                = 1,
	Vehicle                                  = 2,
	None                                     = 3,
	EMercunaObstacleMovementType_MAX         = 4,
};

// Enum Mercuna.EMercunaObstacleReaction
// NumValues: 0x0003
enum class EMercunaObstacleReaction : uint8
{
	Avoid                                    = 0,
	DoNotAvoid                               = 1,
	EMercunaObstacleReaction_MAX             = 2,
};

// Enum Mercuna.EMerOctreeDebugDrawMode
// NumValues: 0x0008
enum class EMerOctreeDebugDrawMode : uint8
{
	DISABLED                                 = 0,
	UNNAVIGABLE                              = 1,
	NAVIGABLE                                = 2,
	CROSS_SECTION                            = 3,
	REACHABLE                                = 4,
	PATHFIND                                 = 5,
	REGION                                   = 6,
	EMerOctreeDebugDrawMode_MAX              = 7,
};

// Enum Mercuna.EMerGridDebugDrawMode
// NumValues: 0x0005
enum class EMerGridDebugDrawMode : uint8
{
	DISABLED                                 = 0,
	GRID                                     = 1,
	POLYMESH                                 = 2,
	QUERY                                    = 3,
	EMerGridDebugDrawMode_MAX                = 4,
};

// Enum Mercuna.EMerGridDebugDrawSubmode
// NumValues: 0x000D
enum class EMerGridDebugDrawSubmode : uint8
{
	NAVIGABLE                                = 0,
	SURFACE_TYPE                             = 1,
	USAGE_TYPE                               = 2,
	ORIENTATIONS                             = 3,
	NAVLINKS                                 = 4,
	SURFACE_NORMALS                          = 5,
	POLYGONS                                 = 6,
	CONNECTIONS                              = 7,
	QUERY_COST                               = 8,
	QUERY_HEURISTIC                          = 9,
	QUERY_TOTAL                              = 10,
	QUERY_DISTANCE_FIELD                     = 11,
	EMerGridDebugDrawSubmode_MAX             = 12,
};

// Enum Mercuna.EMercunaModifierVolumeShape
// NumValues: 0x0005
enum class EMercunaModifierVolumeShape : uint8
{
	Box                                      = 0,
	Sphere                                   = 1,
	Cylinder                                 = 2,
	Prism                                    = 3,
	EMercunaModifierVolumeShape_MAX          = 4,
};

// Enum Mercuna.EMercunaNavigationExclusionType
// NumValues: 0x0004
enum class EMercunaNavigationExclusionType : uint8
{
	Navigation                               = 0,
	AutoLinks                                = 1,
	All                                      = 2,
	EMercunaNavigationExclusionType_MAX      = 3,
};

// Enum Mercuna.EMercunaMoveGoal
// NumValues: 0x0004
enum class EMercunaMoveGoal : uint8
{
	Actor                                    = 0,
	Vector                                   = 1,
	None                                     = 2,
	EMercunaMoveGoal_MAX                     = 3,
};

// Enum Mercuna.EMercunaNavGraphType
// NumValues: 0x0005
enum class EMercunaNavGraphType : uint8
{
	ThreeDimensional                         = 0,
	Ground                                   = 1,
	Surface                                  = 2,
	Invalid                                  = 3,
	EMercunaNavGraphType_MAX                 = 4,
};

// Enum Mercuna.EMercunaGroundAgentCategory
// NumValues: 0x0004
enum class EMercunaGroundAgentCategory : uint8
{
	Character                                = 0,
	Animal                                   = 1,
	Vehicle                                  = 2,
	EMercunaGroundAgentCategory_MAX          = 3,
};

// Enum Mercuna.EMercunaGroundAgentShape
// NumValues: 0x0003
enum class EMercunaGroundAgentShape : uint8
{
	Rectangle                                = 0,
	Circle                                   = 1,
	EMercunaGroundAgentShape_MAX             = 2,
};

// Enum Mercuna.EMercunaTurnInPlace
// NumValues: 0x0004
enum class EMercunaTurnInPlace : uint8
{
	Never                                    = 0,
	PreferNotTo                              = 1,
	Allowed                                  = 2,
	EMercunaTurnInPlace_MAX                  = 3,
};

// Enum Mercuna.EMercunaDeepWaterMode
// NumValues: 0x0004
enum class EMercunaDeepWaterMode : uint8
{
	Unnavigable                              = 0,
	NavigateOnBottom                         = 1,
	NavigateOnSurface                        = 2,
	EMercunaDeepWaterMode_MAX                = 3,
};

// Enum Mercuna.EMercunaProjectionDirection
// NumValues: 0x0004
enum class EMercunaProjectionDirection : uint8
{
	Down                                     = 0,
	Up                                       = 1,
	Closest                                  = 2,
	EMercunaProjectionDirection_MAX          = 3,
};

// Enum Mercuna.EMercunaNavGraphVolumeOrientation
// NumValues: 0x0004
enum class EMercunaNavGraphVolumeOrientation : uint8
{
	LinkedRotation                           = 0,
	RotateVolumesToGraphs                    = 1,
	NoRotation                               = 2,
	EMercunaNavGraphVolumeOrientation_MAX    = 3,
};

// Enum Mercuna.EMercunaWorkerThreadType
// NumValues: 0x0004
enum class EMercunaWorkerThreadType : uint8
{
	UnrealThreadPool                         = 0,
	UnrealTaskGraph                          = 1,
	IndependentWorkerThreads                 = 2,
	EMercunaWorkerThreadType_MAX             = 3,
};

// ScriptStruct Mercuna.MerOctreeEditorSettings
// 0x0030 (0x0030 - 0x0000)
struct FMerOctreeEditorSettings final
{
public:
	struct FLinearColor                           NavigableColor;                                    // 0x0000(0x0010)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           HighCostColor;                                     // 0x0010(0x0010)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           UnnavigableColor;                                  // 0x0020(0x0010)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMerOctreeEditorSettings) == 0x000004, "Wrong alignment on FMerOctreeEditorSettings");
static_assert(sizeof(FMerOctreeEditorSettings) == 0x000030, "Wrong size on FMerOctreeEditorSettings");
static_assert(offsetof(FMerOctreeEditorSettings, NavigableColor) == 0x000000, "Member 'FMerOctreeEditorSettings::NavigableColor' has a wrong offset!");
static_assert(offsetof(FMerOctreeEditorSettings, HighCostColor) == 0x000010, "Member 'FMerOctreeEditorSettings::HighCostColor' has a wrong offset!");
static_assert(offsetof(FMerOctreeEditorSettings, UnnavigableColor) == 0x000020, "Member 'FMerOctreeEditorSettings::UnnavigableColor' has a wrong offset!");

// ScriptStruct Mercuna.MercunaUsageTypes
// 0x0004 (0x0004 - 0x0000)
struct alignas(0x04) FMercunaUsageTypes final
{
public:
	uint8                                         bUsageType0 : 1;                                   // 0x0000(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bUsageType1 : 1;                                   // 0x0000(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bUsageType2 : 1;                                   // 0x0000(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bUsageType3 : 1;                                   // 0x0000(0x0001)(BitIndex: 0x03, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bUsageType4 : 1;                                   // 0x0000(0x0001)(BitIndex: 0x04, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bUsageType5 : 1;                                   // 0x0000(0x0001)(BitIndex: 0x05, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bUsageType6 : 1;                                   // 0x0000(0x0001)(BitIndex: 0x06, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bUsageType7 : 1;                                   // 0x0000(0x0001)(BitIndex: 0x07, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bUsageType8 : 1;                                   // 0x0001(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bUsageType9 : 1;                                   // 0x0001(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bUsageType10 : 1;                                  // 0x0001(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bUsageType11 : 1;                                  // 0x0001(0x0001)(BitIndex: 0x03, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bUsageType12 : 1;                                  // 0x0001(0x0001)(BitIndex: 0x04, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bUsageType13 : 1;                                  // 0x0001(0x0001)(BitIndex: 0x05, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bUsageType14 : 1;                                  // 0x0001(0x0001)(BitIndex: 0x06, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bUsageType15 : 1;                                  // 0x0001(0x0001)(BitIndex: 0x07, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bUsageType16 : 1;                                  // 0x0002(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bUsageType17 : 1;                                  // 0x0002(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bUsageType18 : 1;                                  // 0x0002(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bUsageType19 : 1;                                  // 0x0002(0x0001)(BitIndex: 0x03, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bUsageType20 : 1;                                  // 0x0002(0x0001)(BitIndex: 0x04, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bUsageType21 : 1;                                  // 0x0002(0x0001)(BitIndex: 0x05, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bUsageType22 : 1;                                  // 0x0002(0x0001)(BitIndex: 0x06, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bUsageType23 : 1;                                  // 0x0002(0x0001)(BitIndex: 0x07, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bUsageType24 : 1;                                  // 0x0003(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bUsageType25 : 1;                                  // 0x0003(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bUsageType26 : 1;                                  // 0x0003(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bUsageType27 : 1;                                  // 0x0003(0x0001)(BitIndex: 0x03, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bUsageType28 : 1;                                  // 0x0003(0x0001)(BitIndex: 0x04, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bUsageType29 : 1;                                  // 0x0003(0x0001)(BitIndex: 0x05, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bUsageType30 : 1;                                  // 0x0003(0x0001)(BitIndex: 0x06, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bUsageType31 : 1;                                  // 0x0003(0x0001)(BitIndex: 0x07, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
};
static_assert(alignof(FMercunaUsageTypes) == 0x000004, "Wrong alignment on FMercunaUsageTypes");
static_assert(sizeof(FMercunaUsageTypes) == 0x000004, "Wrong size on FMercunaUsageTypes");

// ScriptStruct Mercuna.MercunaGroundNavigationSteeringParameters
// 0x0020 (0x0020 - 0x0000)
struct FMercunaGroundNavigationSteeringParameters final
{
public:
	bool                                          bKinematicPathfinding;                             // 0x0000(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MaxSpeed;                                          // 0x0004(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxAcceleration;                                   // 0x0008(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         IdealTurningRadius;                                // 0x000C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MinTurningRadius;                                  // 0x0010(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxThrottleAcceleration;                           // 0x0014(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxBrakeDeceleration;                              // 0x0018(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         GroundFriction;                                    // 0x001C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMercunaGroundNavigationSteeringParameters) == 0x000004, "Wrong alignment on FMercunaGroundNavigationSteeringParameters");
static_assert(sizeof(FMercunaGroundNavigationSteeringParameters) == 0x000020, "Wrong size on FMercunaGroundNavigationSteeringParameters");
static_assert(offsetof(FMercunaGroundNavigationSteeringParameters, bKinematicPathfinding) == 0x000000, "Member 'FMercunaGroundNavigationSteeringParameters::bKinematicPathfinding' has a wrong offset!");
static_assert(offsetof(FMercunaGroundNavigationSteeringParameters, MaxSpeed) == 0x000004, "Member 'FMercunaGroundNavigationSteeringParameters::MaxSpeed' has a wrong offset!");
static_assert(offsetof(FMercunaGroundNavigationSteeringParameters, MaxAcceleration) == 0x000008, "Member 'FMercunaGroundNavigationSteeringParameters::MaxAcceleration' has a wrong offset!");
static_assert(offsetof(FMercunaGroundNavigationSteeringParameters, IdealTurningRadius) == 0x00000C, "Member 'FMercunaGroundNavigationSteeringParameters::IdealTurningRadius' has a wrong offset!");
static_assert(offsetof(FMercunaGroundNavigationSteeringParameters, MinTurningRadius) == 0x000010, "Member 'FMercunaGroundNavigationSteeringParameters::MinTurningRadius' has a wrong offset!");
static_assert(offsetof(FMercunaGroundNavigationSteeringParameters, MaxThrottleAcceleration) == 0x000014, "Member 'FMercunaGroundNavigationSteeringParameters::MaxThrottleAcceleration' has a wrong offset!");
static_assert(offsetof(FMercunaGroundNavigationSteeringParameters, MaxBrakeDeceleration) == 0x000018, "Member 'FMercunaGroundNavigationSteeringParameters::MaxBrakeDeceleration' has a wrong offset!");
static_assert(offsetof(FMercunaGroundNavigationSteeringParameters, GroundFriction) == 0x00001C, "Member 'FMercunaGroundNavigationSteeringParameters::GroundFriction' has a wrong offset!");

// ScriptStruct Mercuna.Mercuna2DAgentProperties
// 0x00B8 (0x00B8 - 0x0000)
struct FMercuna2DAgentProperties
{
public:
	uint8                                         Pad_0[0x8];                                        // 0x0000(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         StepHeight;                                        // 0x0008(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HeightClearance;                                   // 0x000C(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxAngleChange;                                    // 0x0010(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSet<struct FSoftObjectPath>                  NavigableMaterials;                                // 0x0018(0x0050)(Edit, Config, NativeAccessSpecifierPublic)
	TSet<struct FSoftObjectPath>                  UnnavigableMaterials;                              // 0x0068(0x0050)(Edit, Config, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMercuna2DAgentProperties) == 0x000008, "Wrong alignment on FMercuna2DAgentProperties");
static_assert(sizeof(FMercuna2DAgentProperties) == 0x0000B8, "Wrong size on FMercuna2DAgentProperties");
static_assert(offsetof(FMercuna2DAgentProperties, StepHeight) == 0x000008, "Member 'FMercuna2DAgentProperties::StepHeight' has a wrong offset!");
static_assert(offsetof(FMercuna2DAgentProperties, HeightClearance) == 0x00000C, "Member 'FMercuna2DAgentProperties::HeightClearance' has a wrong offset!");
static_assert(offsetof(FMercuna2DAgentProperties, MaxAngleChange) == 0x000010, "Member 'FMercuna2DAgentProperties::MaxAngleChange' has a wrong offset!");
static_assert(offsetof(FMercuna2DAgentProperties, NavigableMaterials) == 0x000018, "Member 'FMercuna2DAgentProperties::NavigableMaterials' has a wrong offset!");
static_assert(offsetof(FMercuna2DAgentProperties, UnnavigableMaterials) == 0x000068, "Member 'FMercuna2DAgentProperties::UnnavigableMaterials' has a wrong offset!");

// ScriptStruct Mercuna.MercunaSurfaceAgentProperties
// 0x0008 (0x00C0 - 0x00B8)
struct FMercunaSurfaceAgentProperties final : public FMercuna2DAgentProperties
{
public:
	float                                         PawnRadius;                                        // 0x00B8(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_BC[0x4];                                       // 0x00BC(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FMercunaSurfaceAgentProperties) == 0x000008, "Wrong alignment on FMercunaSurfaceAgentProperties");
static_assert(sizeof(FMercunaSurfaceAgentProperties) == 0x0000C0, "Wrong size on FMercunaSurfaceAgentProperties");
static_assert(offsetof(FMercunaSurfaceAgentProperties, PawnRadius) == 0x0000B8, "Member 'FMercunaSurfaceAgentProperties::PawnRadius' has a wrong offset!");

// ScriptStruct Mercuna.MercunaNavLinkIdentifier
// 0x0020 (0x0020 - 0x0000)
struct alignas(0x08) FMercunaNavLinkIdentifier final
{
public:
	uint8                                         Pad_0[0x20];                                       // 0x0000(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FMercunaNavLinkIdentifier) == 0x000008, "Wrong alignment on FMercunaNavLinkIdentifier");
static_assert(sizeof(FMercunaNavLinkIdentifier) == 0x000020, "Wrong size on FMercunaNavLinkIdentifier");

// ScriptStruct Mercuna.MercunaAutoNavLink
// 0x0098 (0x0098 - 0x0000)
struct FMercunaAutoNavLink final
{
public:
	struct FMercunaNavLinkIdentifier              Identifier;                                        // 0x0000(0x0020)(BlueprintVisible, BlueprintReadOnly, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          bEnabled;                                          // 0x0020(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EMercunaAutoNavLinkTraversalType              TraversalType;                                     // 0x0021(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_22[0x2];                                       // 0x0022(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	struct FMercunaUsageTypes                     UsageTypes;                                        // 0x0024(0x0004)(BlueprintVisible, BlueprintReadOnly, NoDestructor, NativeAccessSpecifierPublic)
	struct FVector                                Start;                                             // 0x0028(0x0018)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                StartHalfRail;                                     // 0x0040(0x0018)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                End;                                               // 0x0058(0x0018)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                EndHalfRail;                                       // 0x0070(0x0018)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Cost;                                              // 0x0088(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HeightMin;                                         // 0x008C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HeightMax;                                         // 0x0090(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_94[0x4];                                       // 0x0094(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FMercunaAutoNavLink) == 0x000008, "Wrong alignment on FMercunaAutoNavLink");
static_assert(sizeof(FMercunaAutoNavLink) == 0x000098, "Wrong size on FMercunaAutoNavLink");
static_assert(offsetof(FMercunaAutoNavLink, Identifier) == 0x000000, "Member 'FMercunaAutoNavLink::Identifier' has a wrong offset!");
static_assert(offsetof(FMercunaAutoNavLink, bEnabled) == 0x000020, "Member 'FMercunaAutoNavLink::bEnabled' has a wrong offset!");
static_assert(offsetof(FMercunaAutoNavLink, TraversalType) == 0x000021, "Member 'FMercunaAutoNavLink::TraversalType' has a wrong offset!");
static_assert(offsetof(FMercunaAutoNavLink, UsageTypes) == 0x000024, "Member 'FMercunaAutoNavLink::UsageTypes' has a wrong offset!");
static_assert(offsetof(FMercunaAutoNavLink, Start) == 0x000028, "Member 'FMercunaAutoNavLink::Start' has a wrong offset!");
static_assert(offsetof(FMercunaAutoNavLink, StartHalfRail) == 0x000040, "Member 'FMercunaAutoNavLink::StartHalfRail' has a wrong offset!");
static_assert(offsetof(FMercunaAutoNavLink, End) == 0x000058, "Member 'FMercunaAutoNavLink::End' has a wrong offset!");
static_assert(offsetof(FMercunaAutoNavLink, EndHalfRail) == 0x000070, "Member 'FMercunaAutoNavLink::EndHalfRail' has a wrong offset!");
static_assert(offsetof(FMercunaAutoNavLink, Cost) == 0x000088, "Member 'FMercunaAutoNavLink::Cost' has a wrong offset!");
static_assert(offsetof(FMercunaAutoNavLink, HeightMin) == 0x00008C, "Member 'FMercunaAutoNavLink::HeightMin' has a wrong offset!");
static_assert(offsetof(FMercunaAutoNavLink, HeightMax) == 0x000090, "Member 'FMercunaAutoNavLink::HeightMax' has a wrong offset!");

// ScriptStruct Mercuna.MercunaAgentType
// 0x000C (0x000C - 0x0000)
struct FMercunaAgentType
{
public:
	class FName                                   Name;                                              // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EMercunaGridType                              GridType;                                          // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMercunaAgentType) == 0x000004, "Wrong alignment on FMercunaAgentType");
static_assert(sizeof(FMercunaAgentType) == 0x00000C, "Wrong size on FMercunaAgentType");
static_assert(offsetof(FMercunaAgentType, Name) == 0x000000, "Member 'FMercunaAgentType::Name' has a wrong offset!");
static_assert(offsetof(FMercunaAgentType, GridType) == 0x000008, "Member 'FMercunaAgentType::GridType' has a wrong offset!");

// ScriptStruct Mercuna.MercunaSupportedAgentTypes
// 0x00A8 (0x00A8 - 0x0000)
struct FMercunaSupportedAgentTypes final
{
public:
	TSet<struct FMercunaAgentType>                AgentTypes;                                        // 0x0000(0x0050)(Edit, NativeAccessSpecifierPublic)
	EMercunaGridType                              GridType;                                          // 0x0050(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_54[0x4];                                       // 0x0054(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<struct FMercunaAgentType, int32>         Types;                                             // 0x0058(0x0050)(NativeAccessSpecifierPrivate)
};
static_assert(alignof(FMercunaSupportedAgentTypes) == 0x000008, "Wrong alignment on FMercunaSupportedAgentTypes");
static_assert(sizeof(FMercunaSupportedAgentTypes) == 0x0000A8, "Wrong size on FMercunaSupportedAgentTypes");
static_assert(offsetof(FMercunaSupportedAgentTypes, AgentTypes) == 0x000000, "Member 'FMercunaSupportedAgentTypes::AgentTypes' has a wrong offset!");
static_assert(offsetof(FMercunaSupportedAgentTypes, GridType) == 0x000050, "Member 'FMercunaSupportedAgentTypes::GridType' has a wrong offset!");
static_assert(offsetof(FMercunaSupportedAgentTypes, Types) == 0x000058, "Member 'FMercunaSupportedAgentTypes::Types' has a wrong offset!");

// ScriptStruct Mercuna.Mercuna3DNavigationConfiguration
// 0x001C (0x001C - 0x0000)
struct FMercuna3DNavigationConfiguration final
{
public:
	float                                         MaxPitch;                                          // 0x0000(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxRoll;                                           // 0x0004(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EMercunaMoveInForwardDirection                MoveInForwardDirection;                            // 0x0008(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          StopAtDestination;                                 // 0x0009(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EMercunaAvoidanceWhenStationary               AvoidanceWhenStationary;                           // 0x000A(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_B[0x1];                                        // 0x000B(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         HeightChangePenalty;                               // 0x000C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          SmoothPaths;                                       // 0x0010(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x3];                                       // 0x0011(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         LookAheadTime;                                     // 0x0014(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RollAnticipationTime;                              // 0x0018(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMercuna3DNavigationConfiguration) == 0x000004, "Wrong alignment on FMercuna3DNavigationConfiguration");
static_assert(sizeof(FMercuna3DNavigationConfiguration) == 0x00001C, "Wrong size on FMercuna3DNavigationConfiguration");
static_assert(offsetof(FMercuna3DNavigationConfiguration, MaxPitch) == 0x000000, "Member 'FMercuna3DNavigationConfiguration::MaxPitch' has a wrong offset!");
static_assert(offsetof(FMercuna3DNavigationConfiguration, MaxRoll) == 0x000004, "Member 'FMercuna3DNavigationConfiguration::MaxRoll' has a wrong offset!");
static_assert(offsetof(FMercuna3DNavigationConfiguration, MoveInForwardDirection) == 0x000008, "Member 'FMercuna3DNavigationConfiguration::MoveInForwardDirection' has a wrong offset!");
static_assert(offsetof(FMercuna3DNavigationConfiguration, StopAtDestination) == 0x000009, "Member 'FMercuna3DNavigationConfiguration::StopAtDestination' has a wrong offset!");
static_assert(offsetof(FMercuna3DNavigationConfiguration, AvoidanceWhenStationary) == 0x00000A, "Member 'FMercuna3DNavigationConfiguration::AvoidanceWhenStationary' has a wrong offset!");
static_assert(offsetof(FMercuna3DNavigationConfiguration, HeightChangePenalty) == 0x00000C, "Member 'FMercuna3DNavigationConfiguration::HeightChangePenalty' has a wrong offset!");
static_assert(offsetof(FMercuna3DNavigationConfiguration, SmoothPaths) == 0x000010, "Member 'FMercuna3DNavigationConfiguration::SmoothPaths' has a wrong offset!");
static_assert(offsetof(FMercuna3DNavigationConfiguration, LookAheadTime) == 0x000014, "Member 'FMercuna3DNavigationConfiguration::LookAheadTime' has a wrong offset!");
static_assert(offsetof(FMercuna3DNavigationConfiguration, RollAnticipationTime) == 0x000018, "Member 'FMercuna3DNavigationConfiguration::RollAnticipationTime' has a wrong offset!");

// ScriptStruct Mercuna.MercunaContextualSteeringActorParameters
// 0x0010 (0x0010 - 0x0000)
struct FMercunaContextualSteeringActorParameters final
{
public:
	float                                         RepulsionDistance;                                 // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RepulsionWeight;                                   // 0x0004(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CohesionDistance;                                  // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CohesionWeight;                                    // 0x000C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMercunaContextualSteeringActorParameters) == 0x000004, "Wrong alignment on FMercunaContextualSteeringActorParameters");
static_assert(sizeof(FMercunaContextualSteeringActorParameters) == 0x000010, "Wrong size on FMercunaContextualSteeringActorParameters");
static_assert(offsetof(FMercunaContextualSteeringActorParameters, RepulsionDistance) == 0x000000, "Member 'FMercunaContextualSteeringActorParameters::RepulsionDistance' has a wrong offset!");
static_assert(offsetof(FMercunaContextualSteeringActorParameters, RepulsionWeight) == 0x000004, "Member 'FMercunaContextualSteeringActorParameters::RepulsionWeight' has a wrong offset!");
static_assert(offsetof(FMercunaContextualSteeringActorParameters, CohesionDistance) == 0x000008, "Member 'FMercunaContextualSteeringActorParameters::CohesionDistance' has a wrong offset!");
static_assert(offsetof(FMercunaContextualSteeringActorParameters, CohesionWeight) == 0x00000C, "Member 'FMercunaContextualSteeringActorParameters::CohesionWeight' has a wrong offset!");

// ScriptStruct Mercuna.MercunaTrackRequest
// 0x0030 (0x0030 - 0x0000)
struct FMercunaTrackRequest
{
public:
	class AActor*                                 TrackActor;                                        // 0x0000(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_8[0x28];                                       // 0x0008(0x0028)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FMercunaTrackRequest) == 0x000008, "Wrong alignment on FMercunaTrackRequest");
static_assert(sizeof(FMercunaTrackRequest) == 0x000030, "Wrong size on FMercunaTrackRequest");
static_assert(offsetof(FMercunaTrackRequest, TrackActor) == 0x000000, "Member 'FMercunaTrackRequest::TrackActor' has a wrong offset!");

// ScriptStruct Mercuna.MercunaTrackRequestSurface
// 0x0008 (0x0038 - 0x0030)
struct FMercunaTrackRequestSurface final : public FMercunaTrackRequest
{
public:
	uint8                                         Pad_30[0x8];                                       // 0x0030(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FMercunaTrackRequestSurface) == 0x000008, "Wrong alignment on FMercunaTrackRequestSurface");
static_assert(sizeof(FMercunaTrackRequestSurface) == 0x000038, "Wrong size on FMercunaTrackRequestSurface");

// ScriptStruct Mercuna.MercunaNavigation2DQueryFilter
// 0x0008 (0x0008 - 0x0000)
struct alignas(0x08) FMercunaNavigation2DQueryFilter
{
public:
	uint8                                         Pad_0[0x8];                                        // 0x0000(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FMercunaNavigation2DQueryFilter) == 0x000008, "Wrong alignment on FMercunaNavigation2DQueryFilter");
static_assert(sizeof(FMercunaNavigation2DQueryFilter) == 0x000008, "Wrong size on FMercunaNavigation2DQueryFilter");

// ScriptStruct Mercuna.MercunaOverrideDefaultCostQueryFilter
// 0x0008 (0x0010 - 0x0008)
struct FMercunaOverrideDefaultCostQueryFilter final : public FMercunaNavigation2DQueryFilter
{
public:
	float                                         DefaultCostMultiplierOverride;                     // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FMercunaOverrideDefaultCostQueryFilter) == 0x000008, "Wrong alignment on FMercunaOverrideDefaultCostQueryFilter");
static_assert(sizeof(FMercunaOverrideDefaultCostQueryFilter) == 0x000010, "Wrong size on FMercunaOverrideDefaultCostQueryFilter");
static_assert(offsetof(FMercunaOverrideDefaultCostQueryFilter, DefaultCostMultiplierOverride) == 0x000008, "Member 'FMercunaOverrideDefaultCostQueryFilter::DefaultCostMultiplierOverride' has a wrong offset!");

// ScriptStruct Mercuna.MercunaNavigationLink
// 0x00E0 (0x00E0 - 0x0000)
struct FMercunaNavigationLink final
{
public:
	struct FTransform                             Left;                                              // 0x0000(0x0060)(Edit, BlueprintVisible, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FTransform                             Right;                                             // 0x0060(0x0060)(Edit, BlueprintVisible, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EMercunaNavigationLinkDirection               Direction;                                         // 0x00C0(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUseDistanceAsCost;                                // 0x00C1(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C2[0x2];                                       // 0x00C2(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         LeftToRightCost;                                   // 0x00C4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RightToLeftCost;                                   // 0x00C8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LeftAutoCompletionDistance;                        // 0x00CC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RightAutoCompletionDistance;                       // 0x00D0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LeftEntryAngle;                                    // 0x00D4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RightEntryAngle;                                   // 0x00D8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_DC[0x4];                                       // 0x00DC(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FMercunaNavigationLink) == 0x000010, "Wrong alignment on FMercunaNavigationLink");
static_assert(sizeof(FMercunaNavigationLink) == 0x0000E0, "Wrong size on FMercunaNavigationLink");
static_assert(offsetof(FMercunaNavigationLink, Left) == 0x000000, "Member 'FMercunaNavigationLink::Left' has a wrong offset!");
static_assert(offsetof(FMercunaNavigationLink, Right) == 0x000060, "Member 'FMercunaNavigationLink::Right' has a wrong offset!");
static_assert(offsetof(FMercunaNavigationLink, Direction) == 0x0000C0, "Member 'FMercunaNavigationLink::Direction' has a wrong offset!");
static_assert(offsetof(FMercunaNavigationLink, bUseDistanceAsCost) == 0x0000C1, "Member 'FMercunaNavigationLink::bUseDistanceAsCost' has a wrong offset!");
static_assert(offsetof(FMercunaNavigationLink, LeftToRightCost) == 0x0000C4, "Member 'FMercunaNavigationLink::LeftToRightCost' has a wrong offset!");
static_assert(offsetof(FMercunaNavigationLink, RightToLeftCost) == 0x0000C8, "Member 'FMercunaNavigationLink::RightToLeftCost' has a wrong offset!");
static_assert(offsetof(FMercunaNavigationLink, LeftAutoCompletionDistance) == 0x0000CC, "Member 'FMercunaNavigationLink::LeftAutoCompletionDistance' has a wrong offset!");
static_assert(offsetof(FMercunaNavigationLink, RightAutoCompletionDistance) == 0x0000D0, "Member 'FMercunaNavigationLink::RightAutoCompletionDistance' has a wrong offset!");
static_assert(offsetof(FMercunaNavigationLink, LeftEntryAngle) == 0x0000D4, "Member 'FMercunaNavigationLink::LeftEntryAngle' has a wrong offset!");
static_assert(offsetof(FMercunaNavigationLink, RightEntryAngle) == 0x0000D8, "Member 'FMercunaNavigationLink::RightEntryAngle' has a wrong offset!");

// ScriptStruct Mercuna.MercunaPreferPhysicalMaterialQueryFilter
// 0x0010 (0x0018 - 0x0008)
struct FMercunaPreferPhysicalMaterialQueryFilter final : public FMercunaNavigation2DQueryFilter
{
public:
	class UPhysicalMaterial*                      PreferredPhysicalMaterial;                         // 0x0008(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         NonPreferredMaterialCostMultiplierOverride;        // 0x0010(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FMercunaPreferPhysicalMaterialQueryFilter) == 0x000008, "Wrong alignment on FMercunaPreferPhysicalMaterialQueryFilter");
static_assert(sizeof(FMercunaPreferPhysicalMaterialQueryFilter) == 0x000018, "Wrong size on FMercunaPreferPhysicalMaterialQueryFilter");
static_assert(offsetof(FMercunaPreferPhysicalMaterialQueryFilter, PreferredPhysicalMaterial) == 0x000008, "Member 'FMercunaPreferPhysicalMaterialQueryFilter::PreferredPhysicalMaterial' has a wrong offset!");
static_assert(offsetof(FMercunaPreferPhysicalMaterialQueryFilter, NonPreferredMaterialCostMultiplierOverride) == 0x000010, "Member 'FMercunaPreferPhysicalMaterialQueryFilter::NonPreferredMaterialCostMultiplierOverride' has a wrong offset!");

// ScriptStruct Mercuna.MercunaUsageSpec
// 0x0008 (0x0008 - 0x0000)
struct FMercunaUsageSpec final
{
public:
	struct FMercunaUsageTypes                     RequiredUsageTypes;                                // 0x0000(0x0004)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FMercunaUsageTypes                     AllowedUsageTypes;                                 // 0x0004(0x0004)(Edit, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMercunaUsageSpec) == 0x000004, "Wrong alignment on FMercunaUsageSpec");
static_assert(sizeof(FMercunaUsageSpec) == 0x000008, "Wrong size on FMercunaUsageSpec");
static_assert(offsetof(FMercunaUsageSpec, RequiredUsageTypes) == 0x000000, "Member 'FMercunaUsageSpec::RequiredUsageTypes' has a wrong offset!");
static_assert(offsetof(FMercunaUsageSpec, AllowedUsageTypes) == 0x000004, "Member 'FMercunaUsageSpec::AllowedUsageTypes' has a wrong offset!");

// ScriptStruct Mercuna.MercunaSurfaceAgentType
// 0x0000 (0x000C - 0x000C)
struct FMercunaSurfaceAgentType final : public FMercunaAgentType
{
};
static_assert(alignof(FMercunaSurfaceAgentType) == 0x000004, "Wrong alignment on FMercunaSurfaceAgentType");
static_assert(sizeof(FMercunaSurfaceAgentType) == 0x00000C, "Wrong size on FMercunaSurfaceAgentType");

// ScriptStruct Mercuna.MercunaGroundNavigationConfiguration
// 0x001C (0x001C - 0x0000)
struct FMercunaGroundNavigationConfiguration final
{
public:
	bool                                          StopAtDestination;                                 // 0x0000(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MinAvoidanceTime;                                  // 0x0004(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EMercunaAvoidanceWhenStationary               AvoidanceWhenStationary;                           // 0x0008(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x3];                                        // 0x0009(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         SlopePenalty;                                      // 0x000C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TractionEstimate;                                  // 0x0010(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LookAheadDistance;                                 // 0x0014(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ShrinkCapsuleDuringAutoJumps;                      // 0x0018(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19[0x3];                                       // 0x0019(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FMercunaGroundNavigationConfiguration) == 0x000004, "Wrong alignment on FMercunaGroundNavigationConfiguration");
static_assert(sizeof(FMercunaGroundNavigationConfiguration) == 0x00001C, "Wrong size on FMercunaGroundNavigationConfiguration");
static_assert(offsetof(FMercunaGroundNavigationConfiguration, StopAtDestination) == 0x000000, "Member 'FMercunaGroundNavigationConfiguration::StopAtDestination' has a wrong offset!");
static_assert(offsetof(FMercunaGroundNavigationConfiguration, MinAvoidanceTime) == 0x000004, "Member 'FMercunaGroundNavigationConfiguration::MinAvoidanceTime' has a wrong offset!");
static_assert(offsetof(FMercunaGroundNavigationConfiguration, AvoidanceWhenStationary) == 0x000008, "Member 'FMercunaGroundNavigationConfiguration::AvoidanceWhenStationary' has a wrong offset!");
static_assert(offsetof(FMercunaGroundNavigationConfiguration, SlopePenalty) == 0x00000C, "Member 'FMercunaGroundNavigationConfiguration::SlopePenalty' has a wrong offset!");
static_assert(offsetof(FMercunaGroundNavigationConfiguration, TractionEstimate) == 0x000010, "Member 'FMercunaGroundNavigationConfiguration::TractionEstimate' has a wrong offset!");
static_assert(offsetof(FMercunaGroundNavigationConfiguration, LookAheadDistance) == 0x000014, "Member 'FMercunaGroundNavigationConfiguration::LookAheadDistance' has a wrong offset!");
static_assert(offsetof(FMercunaGroundNavigationConfiguration, ShrinkCapsuleDuringAutoJumps) == 0x000018, "Member 'FMercunaGroundNavigationConfiguration::ShrinkCapsuleDuringAutoJumps' has a wrong offset!");

// ScriptStruct Mercuna.MercunaMoveRequest
// 0x0060 (0x0060 - 0x0000)
struct FMercunaMoveRequest
{
public:
	uint8                                         Pad_0[0x8];                                        // 0x0000(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class AActor*                                 GoalActor;                                         // 0x0008(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_10[0x50];                                      // 0x0010(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FMercunaMoveRequest) == 0x000008, "Wrong alignment on FMercunaMoveRequest");
static_assert(sizeof(FMercunaMoveRequest) == 0x000060, "Wrong size on FMercunaMoveRequest");
static_assert(offsetof(FMercunaMoveRequest, GoalActor) == 0x000008, "Member 'FMercunaMoveRequest::GoalActor' has a wrong offset!");

// ScriptStruct Mercuna.MercunaMoveRequest2D
// 0x0018 (0x0078 - 0x0060)
struct FMercunaMoveRequest2D : public FMercunaMoveRequest
{
public:
	uint8                                         Pad_60[0x18];                                      // 0x0060(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FMercunaMoveRequest2D) == 0x000008, "Wrong alignment on FMercunaMoveRequest2D");
static_assert(sizeof(FMercunaMoveRequest2D) == 0x000078, "Wrong size on FMercunaMoveRequest2D");

// ScriptStruct Mercuna.MercunaMoveRequestSurface
// 0x0008 (0x0080 - 0x0078)
struct FMercunaMoveRequestSurface final : public FMercunaMoveRequest2D
{
public:
	uint8                                         Pad_78[0x8];                                       // 0x0078(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FMercunaMoveRequestSurface) == 0x000008, "Wrong alignment on FMercunaMoveRequestSurface");
static_assert(sizeof(FMercunaMoveRequestSurface) == 0x000080, "Wrong size on FMercunaMoveRequestSurface");

// ScriptStruct Mercuna.MercunaGroundNavigationDynamicSteeringParameters
// 0x0010 (0x0010 - 0x0000)
struct FMercunaGroundNavigationDynamicSteeringParameters final
{
public:
	float                                         MaxSpeed;                                          // 0x0000(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxAcceleration;                                   // 0x0004(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxBrakingDeceleration;                            // 0x0008(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PowerToWeightRatio;                                // 0x000C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMercunaGroundNavigationDynamicSteeringParameters) == 0x000004, "Wrong alignment on FMercunaGroundNavigationDynamicSteeringParameters");
static_assert(sizeof(FMercunaGroundNavigationDynamicSteeringParameters) == 0x000010, "Wrong size on FMercunaGroundNavigationDynamicSteeringParameters");
static_assert(offsetof(FMercunaGroundNavigationDynamicSteeringParameters, MaxSpeed) == 0x000000, "Member 'FMercunaGroundNavigationDynamicSteeringParameters::MaxSpeed' has a wrong offset!");
static_assert(offsetof(FMercunaGroundNavigationDynamicSteeringParameters, MaxAcceleration) == 0x000004, "Member 'FMercunaGroundNavigationDynamicSteeringParameters::MaxAcceleration' has a wrong offset!");
static_assert(offsetof(FMercunaGroundNavigationDynamicSteeringParameters, MaxBrakingDeceleration) == 0x000008, "Member 'FMercunaGroundNavigationDynamicSteeringParameters::MaxBrakingDeceleration' has a wrong offset!");
static_assert(offsetof(FMercunaGroundNavigationDynamicSteeringParameters, PowerToWeightRatio) == 0x00000C, "Member 'FMercunaGroundNavigationDynamicSteeringParameters::PowerToWeightRatio' has a wrong offset!");

// ScriptStruct Mercuna.MercunaAutoNavLinkForUpdate
// 0x0030 (0x0030 - 0x0000)
struct FMercunaAutoNavLinkForUpdate final
{
public:
	struct FMercunaNavLinkIdentifier              Identifier;                                        // 0x0000(0x0020)(BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          bEnabled;                                          // 0x0020(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EMercunaAutoNavLinkTraversalType              TraversalType;                                     // 0x0021(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_22[0x2];                                       // 0x0022(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	struct FMercunaUsageTypes                     UsageTypes;                                        // 0x0024(0x0004)(BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	float                                         Cost;                                              // 0x0028(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C[0x4];                                       // 0x002C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FMercunaAutoNavLinkForUpdate) == 0x000008, "Wrong alignment on FMercunaAutoNavLinkForUpdate");
static_assert(sizeof(FMercunaAutoNavLinkForUpdate) == 0x000030, "Wrong size on FMercunaAutoNavLinkForUpdate");
static_assert(offsetof(FMercunaAutoNavLinkForUpdate, Identifier) == 0x000000, "Member 'FMercunaAutoNavLinkForUpdate::Identifier' has a wrong offset!");
static_assert(offsetof(FMercunaAutoNavLinkForUpdate, bEnabled) == 0x000020, "Member 'FMercunaAutoNavLinkForUpdate::bEnabled' has a wrong offset!");
static_assert(offsetof(FMercunaAutoNavLinkForUpdate, TraversalType) == 0x000021, "Member 'FMercunaAutoNavLinkForUpdate::TraversalType' has a wrong offset!");
static_assert(offsetof(FMercunaAutoNavLinkForUpdate, UsageTypes) == 0x000024, "Member 'FMercunaAutoNavLinkForUpdate::UsageTypes' has a wrong offset!");
static_assert(offsetof(FMercunaAutoNavLinkForUpdate, Cost) == 0x000028, "Member 'FMercunaAutoNavLinkForUpdate::Cost' has a wrong offset!");

// ScriptStruct Mercuna.MercunaGroundAgentType
// 0x0000 (0x000C - 0x000C)
struct FMercunaGroundAgentType final : public FMercunaAgentType
{
};
static_assert(alignof(FMercunaGroundAgentType) == 0x000004, "Wrong alignment on FMercunaGroundAgentType");
static_assert(sizeof(FMercunaGroundAgentType) == 0x00000C, "Wrong size on FMercunaGroundAgentType");

// ScriptStruct Mercuna.MercunaMoveRequest3D
// 0x0008 (0x0068 - 0x0060)
struct FMercunaMoveRequest3D final : public FMercunaMoveRequest
{
public:
	uint8                                         Pad_60[0x8];                                       // 0x0060(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FMercunaMoveRequest3D) == 0x000008, "Wrong alignment on FMercunaMoveRequest3D");
static_assert(sizeof(FMercunaMoveRequest3D) == 0x000068, "Wrong size on FMercunaMoveRequest3D");

// ScriptStruct Mercuna.MercunaMoveRequestGround
// 0x0000 (0x0078 - 0x0078)
struct FMercunaMoveRequestGround final : public FMercunaMoveRequest2D
{
};
static_assert(alignof(FMercunaMoveRequestGround) == 0x000008, "Wrong alignment on FMercunaMoveRequestGround");
static_assert(sizeof(FMercunaMoveRequestGround) == 0x000078, "Wrong size on FMercunaMoveRequestGround");

// ScriptStruct Mercuna.MercunaNavMeshEdge
// 0x0030 (0x0030 - 0x0000)
struct FMercunaNavMeshEdge final
{
public:
	struct FVector                                EdgeStart;                                         // 0x0000(0x0018)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                EdgeEnd;                                           // 0x0018(0x0018)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMercunaNavMeshEdge) == 0x000008, "Wrong alignment on FMercunaNavMeshEdge");
static_assert(sizeof(FMercunaNavMeshEdge) == 0x000030, "Wrong size on FMercunaNavMeshEdge");
static_assert(offsetof(FMercunaNavMeshEdge, EdgeStart) == 0x000000, "Member 'FMercunaNavMeshEdge::EdgeStart' has a wrong offset!");
static_assert(offsetof(FMercunaNavMeshEdge, EdgeEnd) == 0x000018, "Member 'FMercunaNavMeshEdge::EdgeEnd' has a wrong offset!");

// ScriptStruct Mercuna.MercunaNavInvoker
// 0x001C (0x001C - 0x0000)
struct alignas(0x04) FMercunaNavInvoker final
{
public:
	uint8                                         Pad_0[0x1C];                                       // 0x0000(0x001C)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FMercunaNavInvoker) == 0x000004, "Wrong alignment on FMercunaNavInvoker");
static_assert(sizeof(FMercunaNavInvoker) == 0x00001C, "Wrong size on FMercunaNavInvoker");

// ScriptStruct Mercuna.MercunaDisallowUsageTypesQueryFilter
// 0x0008 (0x0010 - 0x0008)
struct FMercunaDisallowUsageTypesQueryFilter final : public FMercunaNavigation2DQueryFilter
{
public:
	struct FMercunaUsageTypes                     DisallowedUsageTypes;                              // 0x0008(0x0004)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FMercunaDisallowUsageTypesQueryFilter) == 0x000008, "Wrong alignment on FMercunaDisallowUsageTypesQueryFilter");
static_assert(sizeof(FMercunaDisallowUsageTypesQueryFilter) == 0x000010, "Wrong size on FMercunaDisallowUsageTypesQueryFilter");
static_assert(offsetof(FMercunaDisallowUsageTypesQueryFilter, DisallowedUsageTypes) == 0x000008, "Member 'FMercunaDisallowUsageTypesQueryFilter::DisallowedUsageTypes' has a wrong offset!");

// ScriptStruct Mercuna.MercunaRestrictNavLinkTypesQueryFilter
// 0x0050 (0x0058 - 0x0008)
struct FMercunaRestrictNavLinkTypesQueryFilter final : public FMercunaNavigation2DQueryFilter
{
public:
	TSet<class FName>                             AllowedNavLinks;                                   // 0x0008(0x0050)(Edit, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMercunaRestrictNavLinkTypesQueryFilter) == 0x000008, "Wrong alignment on FMercunaRestrictNavLinkTypesQueryFilter");
static_assert(sizeof(FMercunaRestrictNavLinkTypesQueryFilter) == 0x000058, "Wrong size on FMercunaRestrictNavLinkTypesQueryFilter");
static_assert(offsetof(FMercunaRestrictNavLinkTypesQueryFilter, AllowedNavLinks) == 0x000008, "Member 'FMercunaRestrictNavLinkTypesQueryFilter::AllowedNavLinks' has a wrong offset!");

// ScriptStruct Mercuna.MercunaAllRequiredUsageTypesQueryFilter
// 0x0000 (0x0008 - 0x0008)
struct FMercunaAllRequiredUsageTypesQueryFilter final : public FMercunaNavigation2DQueryFilter
{
};
static_assert(alignof(FMercunaAllRequiredUsageTypesQueryFilter) == 0x000008, "Wrong alignment on FMercunaAllRequiredUsageTypesQueryFilter");
static_assert(sizeof(FMercunaAllRequiredUsageTypesQueryFilter) == 0x000008, "Wrong size on FMercunaAllRequiredUsageTypesQueryFilter");

// ScriptStruct Mercuna.MercunaRestrictToWaterQueryFilter
// 0x0000 (0x0008 - 0x0008)
struct FMercunaRestrictToWaterQueryFilter final : public FMercunaNavigation2DQueryFilter
{
};
static_assert(alignof(FMercunaRestrictToWaterQueryFilter) == 0x000008, "Wrong alignment on FMercunaRestrictToWaterQueryFilter");
static_assert(sizeof(FMercunaRestrictToWaterQueryFilter) == 0x000008, "Wrong size on FMercunaRestrictToWaterQueryFilter");

// ScriptStruct Mercuna.MercunaModifier
// 0x0008 (0x0008 - 0x0000)
struct FMercunaModifier final
{
public:
	float                                         CostMultiplier;                                    // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FMercunaUsageTypes                     UsageTypes;                                        // 0x0004(0x0004)(Edit, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMercunaModifier) == 0x000004, "Wrong alignment on FMercunaModifier");
static_assert(sizeof(FMercunaModifier) == 0x000008, "Wrong size on FMercunaModifier");
static_assert(offsetof(FMercunaModifier, CostMultiplier) == 0x000000, "Member 'FMercunaModifier::CostMultiplier' has a wrong offset!");
static_assert(offsetof(FMercunaModifier, UsageTypes) == 0x000004, "Member 'FMercunaModifier::UsageTypes' has a wrong offset!");

// ScriptStruct Mercuna.MercunaNavLinkInfo
// 0x0038 (0x0038 - 0x0000)
struct alignas(0x08) FMercunaNavLinkInfo final
{
public:
	uint8                                         Pad_0[0x38];                                       // 0x0000(0x0038)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FMercunaNavLinkInfo) == 0x000008, "Wrong alignment on FMercunaNavLinkInfo");
static_assert(sizeof(FMercunaNavLinkInfo) == 0x000038, "Wrong size on FMercunaNavLinkInfo");

// ScriptStruct Mercuna.MercunaSurfaceNavigationSteeringParameters
// 0x0014 (0x0014 - 0x0000)
struct FMercunaSurfaceNavigationSteeringParameters final
{
public:
	float                                         MaxSpeed;                                          // 0x0000(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxAcceleration;                                   // 0x0004(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         IdealTurningRadius;                                // 0x0008(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxBrakeDeceleration;                              // 0x000C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         GroundFriction;                                    // 0x0010(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMercunaSurfaceNavigationSteeringParameters) == 0x000004, "Wrong alignment on FMercunaSurfaceNavigationSteeringParameters");
static_assert(sizeof(FMercunaSurfaceNavigationSteeringParameters) == 0x000014, "Wrong size on FMercunaSurfaceNavigationSteeringParameters");
static_assert(offsetof(FMercunaSurfaceNavigationSteeringParameters, MaxSpeed) == 0x000000, "Member 'FMercunaSurfaceNavigationSteeringParameters::MaxSpeed' has a wrong offset!");
static_assert(offsetof(FMercunaSurfaceNavigationSteeringParameters, MaxAcceleration) == 0x000004, "Member 'FMercunaSurfaceNavigationSteeringParameters::MaxAcceleration' has a wrong offset!");
static_assert(offsetof(FMercunaSurfaceNavigationSteeringParameters, IdealTurningRadius) == 0x000008, "Member 'FMercunaSurfaceNavigationSteeringParameters::IdealTurningRadius' has a wrong offset!");
static_assert(offsetof(FMercunaSurfaceNavigationSteeringParameters, MaxBrakeDeceleration) == 0x00000C, "Member 'FMercunaSurfaceNavigationSteeringParameters::MaxBrakeDeceleration' has a wrong offset!");
static_assert(offsetof(FMercunaSurfaceNavigationSteeringParameters, GroundFriction) == 0x000010, "Member 'FMercunaSurfaceNavigationSteeringParameters::GroundFriction' has a wrong offset!");

// ScriptStruct Mercuna.MercunaSurfaceNavigationDynamicSteeringParameters
// 0x000C (0x000C - 0x0000)
struct FMercunaSurfaceNavigationDynamicSteeringParameters final
{
public:
	float                                         MaxSpeed;                                          // 0x0000(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxAcceleration;                                   // 0x0004(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxBrakingDeceleration;                            // 0x0008(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMercunaSurfaceNavigationDynamicSteeringParameters) == 0x000004, "Wrong alignment on FMercunaSurfaceNavigationDynamicSteeringParameters");
static_assert(sizeof(FMercunaSurfaceNavigationDynamicSteeringParameters) == 0x00000C, "Wrong size on FMercunaSurfaceNavigationDynamicSteeringParameters");
static_assert(offsetof(FMercunaSurfaceNavigationDynamicSteeringParameters, MaxSpeed) == 0x000000, "Member 'FMercunaSurfaceNavigationDynamicSteeringParameters::MaxSpeed' has a wrong offset!");
static_assert(offsetof(FMercunaSurfaceNavigationDynamicSteeringParameters, MaxAcceleration) == 0x000004, "Member 'FMercunaSurfaceNavigationDynamicSteeringParameters::MaxAcceleration' has a wrong offset!");
static_assert(offsetof(FMercunaSurfaceNavigationDynamicSteeringParameters, MaxBrakingDeceleration) == 0x000008, "Member 'FMercunaSurfaceNavigationDynamicSteeringParameters::MaxBrakingDeceleration' has a wrong offset!");

// ScriptStruct Mercuna.MercunaSurfaceNavigationConfiguration
// 0x0010 (0x0010 - 0x0000)
struct FMercunaSurfaceNavigationConfiguration final
{
public:
	bool                                          StopAtDestination;                                 // 0x0000(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MinAvoidanceTime;                                  // 0x0004(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EMercunaAvoidanceWhenStationary               AvoidanceWhenStationary;                           // 0x0008(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x3];                                        // 0x0009(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         LookAheadDistance;                                 // 0x000C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMercunaSurfaceNavigationConfiguration) == 0x000004, "Wrong alignment on FMercunaSurfaceNavigationConfiguration");
static_assert(sizeof(FMercunaSurfaceNavigationConfiguration) == 0x000010, "Wrong size on FMercunaSurfaceNavigationConfiguration");
static_assert(offsetof(FMercunaSurfaceNavigationConfiguration, StopAtDestination) == 0x000000, "Member 'FMercunaSurfaceNavigationConfiguration::StopAtDestination' has a wrong offset!");
static_assert(offsetof(FMercunaSurfaceNavigationConfiguration, MinAvoidanceTime) == 0x000004, "Member 'FMercunaSurfaceNavigationConfiguration::MinAvoidanceTime' has a wrong offset!");
static_assert(offsetof(FMercunaSurfaceNavigationConfiguration, AvoidanceWhenStationary) == 0x000008, "Member 'FMercunaSurfaceNavigationConfiguration::AvoidanceWhenStationary' has a wrong offset!");
static_assert(offsetof(FMercunaSurfaceNavigationConfiguration, LookAheadDistance) == 0x00000C, "Member 'FMercunaSurfaceNavigationConfiguration::LookAheadDistance' has a wrong offset!");

// ScriptStruct Mercuna.MercunaNavEdge
// 0x0030 (0x0030 - 0x0000)
struct FMercunaNavEdge final
{
public:
	struct FVector                                Start;                                             // 0x0000(0x0018)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                End;                                               // 0x0018(0x0018)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMercunaNavEdge) == 0x000008, "Wrong alignment on FMercunaNavEdge");
static_assert(sizeof(FMercunaNavEdge) == 0x000030, "Wrong size on FMercunaNavEdge");
static_assert(offsetof(FMercunaNavEdge, Start) == 0x000000, "Member 'FMercunaNavEdge::Start' has a wrong offset!");
static_assert(offsetof(FMercunaNavEdge, End) == 0x000018, "Member 'FMercunaNavEdge::End' has a wrong offset!");

// ScriptStruct Mercuna.MercunaWaterProperties
// 0x0014 (0x0014 - 0x0000)
struct FMercunaWaterProperties final
{
public:
	float                                         MinimumShallowWaterDepth;                          // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MinimumDeepWaterDepth;                             // 0x0004(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EMercunaDeepWaterMode                         DeepWaterMode;                                     // 0x0008(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x3];                                        // 0x0009(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ShallowWaterCostMultiplier;                        // 0x000C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DeepWaterCostMultiplier;                           // 0x0010(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMercunaWaterProperties) == 0x000004, "Wrong alignment on FMercunaWaterProperties");
static_assert(sizeof(FMercunaWaterProperties) == 0x000014, "Wrong size on FMercunaWaterProperties");
static_assert(offsetof(FMercunaWaterProperties, MinimumShallowWaterDepth) == 0x000000, "Member 'FMercunaWaterProperties::MinimumShallowWaterDepth' has a wrong offset!");
static_assert(offsetof(FMercunaWaterProperties, MinimumDeepWaterDepth) == 0x000004, "Member 'FMercunaWaterProperties::MinimumDeepWaterDepth' has a wrong offset!");
static_assert(offsetof(FMercunaWaterProperties, DeepWaterMode) == 0x000008, "Member 'FMercunaWaterProperties::DeepWaterMode' has a wrong offset!");
static_assert(offsetof(FMercunaWaterProperties, ShallowWaterCostMultiplier) == 0x00000C, "Member 'FMercunaWaterProperties::ShallowWaterCostMultiplier' has a wrong offset!");
static_assert(offsetof(FMercunaWaterProperties, DeepWaterCostMultiplier) == 0x000010, "Member 'FMercunaWaterProperties::DeepWaterCostMultiplier' has a wrong offset!");

// ScriptStruct Mercuna.MercunaGroundAgentProperties
// 0x0040 (0x00F8 - 0x00B8)
struct FMercunaGroundAgentProperties final : public FMercuna2DAgentProperties
{
public:
	EMercunaGroundAgentCategory                   Category;                                          // 0x00B8(0x0001)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EMercunaGroundAgentShape                      Shape;                                             // 0x00B9(0x0001)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_BA[0x2];                                       // 0x00BA(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         PawnWidth;                                         // 0x00BC(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PawnLength;                                        // 0x00C0(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxSlopeAngle;                                     // 0x00C4(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LedgeMarginFraction;                               // 0x00C8(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxLaunchSpeed;                                    // 0x00CC(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxImpactSpeed;                                    // 0x00D0(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MinLaunchAngle;                                    // 0x00D4(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxLaunchOrLandAngle;                              // 0x00D8(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxPerpendicularLaunchAngle;                       // 0x00DC(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         JumpCostMultiplier;                                // 0x00E0(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FMercunaWaterProperties                WaterProperties;                                   // 0x00E4(0x0014)(Edit, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMercunaGroundAgentProperties) == 0x000008, "Wrong alignment on FMercunaGroundAgentProperties");
static_assert(sizeof(FMercunaGroundAgentProperties) == 0x0000F8, "Wrong size on FMercunaGroundAgentProperties");
static_assert(offsetof(FMercunaGroundAgentProperties, Category) == 0x0000B8, "Member 'FMercunaGroundAgentProperties::Category' has a wrong offset!");
static_assert(offsetof(FMercunaGroundAgentProperties, Shape) == 0x0000B9, "Member 'FMercunaGroundAgentProperties::Shape' has a wrong offset!");
static_assert(offsetof(FMercunaGroundAgentProperties, PawnWidth) == 0x0000BC, "Member 'FMercunaGroundAgentProperties::PawnWidth' has a wrong offset!");
static_assert(offsetof(FMercunaGroundAgentProperties, PawnLength) == 0x0000C0, "Member 'FMercunaGroundAgentProperties::PawnLength' has a wrong offset!");
static_assert(offsetof(FMercunaGroundAgentProperties, MaxSlopeAngle) == 0x0000C4, "Member 'FMercunaGroundAgentProperties::MaxSlopeAngle' has a wrong offset!");
static_assert(offsetof(FMercunaGroundAgentProperties, LedgeMarginFraction) == 0x0000C8, "Member 'FMercunaGroundAgentProperties::LedgeMarginFraction' has a wrong offset!");
static_assert(offsetof(FMercunaGroundAgentProperties, MaxLaunchSpeed) == 0x0000CC, "Member 'FMercunaGroundAgentProperties::MaxLaunchSpeed' has a wrong offset!");
static_assert(offsetof(FMercunaGroundAgentProperties, MaxImpactSpeed) == 0x0000D0, "Member 'FMercunaGroundAgentProperties::MaxImpactSpeed' has a wrong offset!");
static_assert(offsetof(FMercunaGroundAgentProperties, MinLaunchAngle) == 0x0000D4, "Member 'FMercunaGroundAgentProperties::MinLaunchAngle' has a wrong offset!");
static_assert(offsetof(FMercunaGroundAgentProperties, MaxLaunchOrLandAngle) == 0x0000D8, "Member 'FMercunaGroundAgentProperties::MaxLaunchOrLandAngle' has a wrong offset!");
static_assert(offsetof(FMercunaGroundAgentProperties, MaxPerpendicularLaunchAngle) == 0x0000DC, "Member 'FMercunaGroundAgentProperties::MaxPerpendicularLaunchAngle' has a wrong offset!");
static_assert(offsetof(FMercunaGroundAgentProperties, JumpCostMultiplier) == 0x0000E0, "Member 'FMercunaGroundAgentProperties::JumpCostMultiplier' has a wrong offset!");
static_assert(offsetof(FMercunaGroundAgentProperties, WaterProperties) == 0x0000E4, "Member 'FMercunaGroundAgentProperties::WaterProperties' has a wrong offset!");

// ScriptStruct Mercuna.MerGridEditorSettings
// 0x0028 (0x0028 - 0x0000)
struct FMerGridEditorSettings final
{
public:
	struct FLinearColor                           NavigableColor;                                    // 0x0000(0x0010)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           AutoJumpLinkColor;                                 // 0x0010(0x0010)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         VerticalOffset;                                    // 0x0020(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LineThickness;                                     // 0x0024(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMerGridEditorSettings) == 0x000004, "Wrong alignment on FMerGridEditorSettings");
static_assert(sizeof(FMerGridEditorSettings) == 0x000028, "Wrong size on FMerGridEditorSettings");
static_assert(offsetof(FMerGridEditorSettings, NavigableColor) == 0x000000, "Member 'FMerGridEditorSettings::NavigableColor' has a wrong offset!");
static_assert(offsetof(FMerGridEditorSettings, AutoJumpLinkColor) == 0x000010, "Member 'FMerGridEditorSettings::AutoJumpLinkColor' has a wrong offset!");
static_assert(offsetof(FMerGridEditorSettings, VerticalOffset) == 0x000020, "Member 'FMerGridEditorSettings::VerticalOffset' has a wrong offset!");
static_assert(offsetof(FMerGridEditorSettings, LineThickness) == 0x000024, "Member 'FMerGridEditorSettings::LineThickness' has a wrong offset!");

}

