#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: MultiWorld

#include "Basic.hpp"

#include "MultiWorld_classes.hpp"
#include "MultiWorld_parameters.hpp"


namespace SDK
{

// Function MultiWorld.MultiWorldActorInterface.OnEnteringWorld
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)

void IMultiWorldActorInterface::OnEnteringWorld()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = AsUObject()->Class->GetFunction("MultiWorldActorInterface", "OnEnteringWorld");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	AsUObject()->ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function MultiWorld.MultiWorldActorInterface.OnExitingWorld
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)

void IMultiWorldActorInterface::OnExitingWorld()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = AsUObject()->Class->GetFunction("MultiWorldActorInterface", "OnExitingWorld");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	AsUObject()->ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function MultiWorld.MultiWorldSeamTransition.OnPreWorldEnded
// (Final, Native, Private)
// Parameters:
// const struct FMultiWorldHandle&         InWorldToEnd                                           (Parm, NoDestructor, NativeAccessSpecifierPublic)

void UMultiWorldSeamTransition::OnPreWorldEnded(const struct FMultiWorldHandle& InWorldToEnd)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MultiWorldSeamTransition", "OnPreWorldEnded");

	Params::MultiWorldSeamTransition_OnPreWorldEnded Parms{};

	Parms.InWorldToEnd = std::move(InWorldToEnd);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function MultiWorld.MultiWorldSeamTransition.SetDefaultFXLayerZOrder
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   ZOrder                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMultiWorldSeamTransition::SetDefaultFXLayerZOrder(int32 ZOrder)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MultiWorldSeamTransition", "SetDefaultFXLayerZOrder");

	Params::MultiWorldSeamTransition_SetDefaultFXLayerZOrder Parms{};

	Parms.ZOrder = ZOrder;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function MultiWorld.MultiWorldSeamTransition.StartTransition
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FMultiWorldHandle&         InDestinationWorldHandle                               (Parm, NoDestructor, NativeAccessSpecifierPublic)
// class UMaterialInterface*               TransitionMaterial                                     (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const TDelegate<void()>&                OnTransitionEnd_0                                      (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   DurationInSeconds                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   WorldSwitchNormalizedTime                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bForceWorldsTickingDuringTransition                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bAutoHandleAudioFade                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UMultiWorldSeamTransition::StartTransition(class UObject* WorldContextObject, const struct FMultiWorldHandle& InDestinationWorldHandle, class UMaterialInterface* TransitionMaterial, const TDelegate<void()>& OnTransitionEnd_0, float DurationInSeconds, float WorldSwitchNormalizedTime, bool bForceWorldsTickingDuringTransition, bool bAutoHandleAudioFade)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MultiWorldSeamTransition", "StartTransition");

	Params::MultiWorldSeamTransition_StartTransition Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.InDestinationWorldHandle = std::move(InDestinationWorldHandle);
	Parms.TransitionMaterial = TransitionMaterial;
	Parms.OnTransitionEnd_0 = OnTransitionEnd_0;
	Parms.DurationInSeconds = DurationInSeconds;
	Parms.WorldSwitchNormalizedTime = WorldSwitchNormalizedTime;
	Parms.bForceWorldsTickingDuringTransition = bForceWorldsTickingDuringTransition;
	Parms.bAutoHandleAudioFade = bAutoHandleAudioFade;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function MultiWorld.MultiWorldSeamTransition.IsInTransition
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UMultiWorldSeamTransition::IsInTransition() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MultiWorldSeamTransition", "IsInTransition");

	Params::MultiWorldSeamTransition_IsInTransition Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function MultiWorld.MultiWorldSeamTransitionFXLayer.SetEffect
// (Event, Public, BlueprintEvent)
// Parameters:
// class UMaterialInstance*                InMaterial                                             (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMultiWorldSeamTransitionFXLayer::SetEffect(class UMaterialInstance* InMaterial)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MultiWorldSeamTransitionFXLayer", "SetEffect");

	Params::MultiWorldSeamTransitionFXLayer_SetEffect Parms{};

	Parms.InMaterial = InMaterial;

	UObject::ProcessEvent(Func, &Parms);
}


// Function MultiWorld.MultiWorldStatics.AreWorldsEquals
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// const struct FMultiWorldHandle&         InWorldHandleA                                         (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// const struct FMultiWorldHandle&         InWorldHandleB                                         (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UMultiWorldStatics::AreWorldsEquals(const struct FMultiWorldHandle& InWorldHandleA, const struct FMultiWorldHandle& InWorldHandleB)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MultiWorldStatics", "AreWorldsEquals");

	Params::MultiWorldStatics_AreWorldsEquals Parms{};

	Parms.InWorldHandleA = std::move(InWorldHandleA);
	Parms.InWorldHandleB = std::move(InWorldHandleB);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function MultiWorld.MultiWorldStatics.EndWorld
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const class UObject*                    WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FMultiWorldHandle&         InWorldHandle                                          (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// bool                                    bCallImmediately                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMultiWorldStatics::EndWorld(const class UObject* WorldContextObject, const struct FMultiWorldHandle& InWorldHandle, bool bCallImmediately)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MultiWorldStatics", "EndWorld");

	Params::MultiWorldStatics_EndWorld Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.InWorldHandle = std::move(InWorldHandle);
	Parms.bCallImmediately = bCallImmediately;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function MultiWorld.MultiWorldStatics.ExecuteConsoleCommandInWorld
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const struct FMultiWorldHandle&         InWorldHandle                                          (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// const class FString&                    Command                                                (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMultiWorldStatics::ExecuteConsoleCommandInWorld(const struct FMultiWorldHandle& InWorldHandle, const class FString& Command)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MultiWorldStatics", "ExecuteConsoleCommandInWorld");

	Params::MultiWorldStatics_ExecuteConsoleCommandInWorld Parms{};

	Parms.InWorldHandle = std::move(InWorldHandle);
	Parms.Command = std::move(Command);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function MultiWorld.MultiWorldStatics.GetActiveWorldHandle
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const class UObject*                    WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FMultiWorldHandle                ReturnValue                                            (Parm, OutParm, ReturnParm, NoDestructor, NativeAccessSpecifierPublic)

struct FMultiWorldHandle UMultiWorldStatics::GetActiveWorldHandle(const class UObject* WorldContextObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MultiWorldStatics", "GetActiveWorldHandle");

	Params::MultiWorldStatics_GetActiveWorldHandle Parms{};

	Parms.WorldContextObject = WorldContextObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function MultiWorld.MultiWorldStatics.GetActorOfClass
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const struct FMultiWorldHandle&         InWorldHandle                                          (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// TSubclassOf<class AActor>               ActorClass                                             (Parm, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AActor* UMultiWorldStatics::GetActorOfClass(const struct FMultiWorldHandle& InWorldHandle, TSubclassOf<class AActor> ActorClass)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MultiWorldStatics", "GetActorOfClass");

	Params::MultiWorldStatics_GetActorOfClass Parms{};

	Parms.InWorldHandle = std::move(InWorldHandle);
	Parms.ActorClass = ActorClass;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function MultiWorld.MultiWorldStatics.GetAllActorsOfClass
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const struct FMultiWorldHandle&         InWorldHandle                                          (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// TSubclassOf<class AActor>               ActorClass                                             (Parm, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class AActor*>*                  OutActors                                              (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)

void UMultiWorldStatics::GetAllActorsOfClass(const struct FMultiWorldHandle& InWorldHandle, TSubclassOf<class AActor> ActorClass, TArray<class AActor*>* OutActors)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MultiWorldStatics", "GetAllActorsOfClass");

	Params::MultiWorldStatics_GetAllActorsOfClass Parms{};

	Parms.InWorldHandle = std::move(InWorldHandle);
	Parms.ActorClass = ActorClass;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutActors != nullptr)
		*OutActors = std::move(Parms.OutActors);
}


// Function MultiWorld.MultiWorldStatics.GetAllActorsOfClassWithTag
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const struct FMultiWorldHandle&         InWorldHandle                                          (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// TSubclassOf<class AActor>               ActorClass                                             (Parm, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             Tag                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class AActor*>*                  OutActors                                              (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)

void UMultiWorldStatics::GetAllActorsOfClassWithTag(const struct FMultiWorldHandle& InWorldHandle, TSubclassOf<class AActor> ActorClass, class FName Tag, TArray<class AActor*>* OutActors)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MultiWorldStatics", "GetAllActorsOfClassWithTag");

	Params::MultiWorldStatics_GetAllActorsOfClassWithTag Parms{};

	Parms.InWorldHandle = std::move(InWorldHandle);
	Parms.ActorClass = ActorClass;
	Parms.Tag = Tag;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutActors != nullptr)
		*OutActors = std::move(Parms.OutActors);
}


// Function MultiWorld.MultiWorldStatics.GetAllActorsWithInterface
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const struct FMultiWorldHandle&         InWorldHandle                                          (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// TSubclassOf<class IInterface>           Interface                                              (Parm, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class AActor*>*                  OutActors                                              (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)

void UMultiWorldStatics::GetAllActorsWithInterface(const struct FMultiWorldHandle& InWorldHandle, TSubclassOf<class IInterface> Interface, TArray<class AActor*>* OutActors)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MultiWorldStatics", "GetAllActorsWithInterface");

	Params::MultiWorldStatics_GetAllActorsWithInterface Parms{};

	Parms.InWorldHandle = std::move(InWorldHandle);
	Parms.Interface = Interface;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutActors != nullptr)
		*OutActors = std::move(Parms.OutActors);
}


// Function MultiWorld.MultiWorldStatics.GetAllActorsWithTag
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const struct FMultiWorldHandle&         InWorldHandle                                          (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// class FName                             Tag                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class AActor*>*                  OutActors                                              (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)

void UMultiWorldStatics::GetAllActorsWithTag(const struct FMultiWorldHandle& InWorldHandle, class FName Tag, TArray<class AActor*>* OutActors)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MultiWorldStatics", "GetAllActorsWithTag");

	Params::MultiWorldStatics_GetAllActorsWithTag Parms{};

	Parms.InWorldHandle = std::move(InWorldHandle);
	Parms.Tag = Tag;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutActors != nullptr)
		*OutActors = std::move(Parms.OutActors);
}


// Function MultiWorld.MultiWorldStatics.GetAllObjectsWithInterface
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const struct FMultiWorldHandle&         InWorldHandle                                          (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// TSubclassOf<class IInterface>           Interface                                              (Parm, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class UObject*>*                 OutObjects                                             (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)

void UMultiWorldStatics::GetAllObjectsWithInterface(const struct FMultiWorldHandle& InWorldHandle, TSubclassOf<class IInterface> Interface, TArray<class UObject*>* OutObjects)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MultiWorldStatics", "GetAllObjectsWithInterface");

	Params::MultiWorldStatics_GetAllObjectsWithInterface Parms{};

	Parms.InWorldHandle = std::move(InWorldHandle);
	Parms.Interface = Interface;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutObjects != nullptr)
		*OutObjects = std::move(Parms.OutObjects);
}


// Function MultiWorld.MultiWorldStatics.GetMainWorldHandle
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const class UObject*                    WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FMultiWorldHandle                ReturnValue                                            (Parm, OutParm, ReturnParm, NoDestructor, NativeAccessSpecifierPublic)

struct FMultiWorldHandle UMultiWorldStatics::GetMainWorldHandle(const class UObject* WorldContextObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MultiWorldStatics", "GetMainWorldHandle");

	Params::MultiWorldStatics_GetMainWorldHandle Parms{};

	Parms.WorldContextObject = WorldContextObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function MultiWorld.MultiWorldStatics.GetPlayerController
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const class UObject*                    WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   PlayerIndex                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class APlayerController*                ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class APlayerController* UMultiWorldStatics::GetPlayerController(const class UObject* WorldContextObject, int32 PlayerIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MultiWorldStatics", "GetPlayerController");

	Params::MultiWorldStatics_GetPlayerController Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.PlayerIndex = PlayerIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function MultiWorld.MultiWorldStatics.GetThisWorldHandle
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const class UObject*                    WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FMultiWorldHandle                ReturnValue                                            (Parm, OutParm, ReturnParm, NoDestructor, NativeAccessSpecifierPublic)

struct FMultiWorldHandle UMultiWorldStatics::GetThisWorldHandle(const class UObject* WorldContextObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MultiWorldStatics", "GetThisWorldHandle");

	Params::MultiWorldStatics_GetThisWorldHandle Parms{};

	Parms.WorldContextObject = WorldContextObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function MultiWorld.MultiWorldStatics.GetWorldHandleByName
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const class UObject*                    WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             WorldName                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FMultiWorldHandle                ReturnValue                                            (Parm, OutParm, ReturnParm, NoDestructor, NativeAccessSpecifierPublic)

struct FMultiWorldHandle UMultiWorldStatics::GetWorldHandleByName(const class UObject* WorldContextObject, class FName WorldName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MultiWorldStatics", "GetWorldHandleByName");

	Params::MultiWorldStatics_GetWorldHandleByName Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.WorldName = WorldName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function MultiWorld.MultiWorldStatics.InitializeWorld
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const class UObject*                    WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FMultiWorldHandle&         InWorldHandle                                          (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)

void UMultiWorldStatics::InitializeWorld(const class UObject* WorldContextObject, const struct FMultiWorldHandle& InWorldHandle)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MultiWorldStatics", "InitializeWorld");

	Params::MultiWorldStatics_InitializeWorld Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.InWorldHandle = std::move(InWorldHandle);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function MultiWorld.MultiWorldStatics.IsValidHandle
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// const class UObject*                    WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FMultiWorldHandle&         InWorldHandle                                          (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UMultiWorldStatics::IsValidHandle(const class UObject* WorldContextObject, const struct FMultiWorldHandle& InWorldHandle)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MultiWorldStatics", "IsValidHandle");

	Params::MultiWorldStatics_IsValidHandle Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.InWorldHandle = std::move(InWorldHandle);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function MultiWorld.MultiWorldStatics.LoadWorldAsyncWithDelegate
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// const class UObject*                    WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TSoftObjectPtr<class UWorld>            InMapAsset                                             (Parm, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FMultiWorldLoadParameters& InParams                                               (Parm, NoDestructor, NativeAccessSpecifierPublic)
// TDelegate<void(bool Success, const struct FMultiWorldHandle& WorldHandle, const struct FMultiWorldLoadParameters& LoadParams)>OnComplete                                             (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMultiWorldStatics::LoadWorldAsyncWithDelegate(const class UObject* WorldContextObject, TSoftObjectPtr<class UWorld> InMapAsset, const struct FMultiWorldLoadParameters& InParams, TDelegate<void(bool Success, const struct FMultiWorldHandle& WorldHandle, const struct FMultiWorldLoadParameters& LoadParams)> OnComplete)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MultiWorldStatics", "LoadWorldAsyncWithDelegate");

	Params::MultiWorldStatics_LoadWorldAsyncWithDelegate Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.InMapAsset = InMapAsset;
	Parms.InParams = std::move(InParams);
	Parms.OnComplete = OnComplete;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function MultiWorld.MultiWorldStatics.LoadWorldWithDelegate
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// const class UObject*                    WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TSoftObjectPtr<class UWorld>            InMapAsset                                             (Parm, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FMultiWorldLoadParameters& InParams                                               (Parm, NoDestructor, NativeAccessSpecifierPublic)
// TDelegate<void(bool Success, const struct FMultiWorldHandle& WorldHandle, const struct FMultiWorldLoadParameters& LoadParams)>OnComplete                                             (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMultiWorldStatics::LoadWorldWithDelegate(const class UObject* WorldContextObject, TSoftObjectPtr<class UWorld> InMapAsset, const struct FMultiWorldLoadParameters& InParams, TDelegate<void(bool Success, const struct FMultiWorldHandle& WorldHandle, const struct FMultiWorldLoadParameters& LoadParams)> OnComplete)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MultiWorldStatics", "LoadWorldWithDelegate");

	Params::MultiWorldStatics_LoadWorldWithDelegate Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.InMapAsset = InMapAsset;
	Parms.InParams = std::move(InParams);
	Parms.OnComplete = OnComplete;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function MultiWorld.MultiWorldStatics.RequestSwitchWorld
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const class UObject*                    WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FMultiWorldHandle&         InWorldHandle                                          (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)

void UMultiWorldStatics::RequestSwitchWorld(const class UObject* WorldContextObject, const struct FMultiWorldHandle& InWorldHandle)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MultiWorldStatics", "RequestSwitchWorld");

	Params::MultiWorldStatics_RequestSwitchWorld Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.InWorldHandle = std::move(InWorldHandle);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function MultiWorld.MultiWorldStatics.ReturnToMainWorld
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// const class UObject*                    WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UMultiWorldStatics::ReturnToMainWorld(const class UObject* WorldContextObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MultiWorldStatics", "ReturnToMainWorld");

	Params::MultiWorldStatics_ReturnToMainWorld Parms{};

	Parms.WorldContextObject = WorldContextObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function MultiWorld.MultiWorldStatics.SetAutoHandleWidgetsForMainWorld
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// const class UObject*                    WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bAutoHandleWidgets                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMultiWorldStatics::SetAutoHandleWidgetsForMainWorld(const class UObject* WorldContextObject, bool bAutoHandleWidgets)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MultiWorldStatics", "SetAutoHandleWidgetsForMainWorld");

	Params::MultiWorldStatics_SetAutoHandleWidgetsForMainWorld Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.bAutoHandleWidgets = bAutoHandleWidgets;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function MultiWorld.MultiWorldStatics.SetPhysicsActorTransform
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// class AActor*                           Actor                                                  (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FTransform&                NewTransform                                           (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ETeleportType                           Teleport                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMultiWorldStatics::SetPhysicsActorTransform(class AActor* Actor, const struct FTransform& NewTransform, ETeleportType Teleport)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MultiWorldStatics", "SetPhysicsActorTransform");

	Params::MultiWorldStatics_SetPhysicsActorTransform Parms{};

	Parms.Actor = Actor;
	Parms.NewTransform = std::move(NewTransform);
	Parms.Teleport = Teleport;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function MultiWorld.MultiWorldStatics.SetShouldTickWhenInBackground
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const class UObject*                    WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FMultiWorldHandle&         InWorldHandle                                          (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// bool                                    bShouldTick                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMultiWorldStatics::SetShouldTickWhenInBackground(const class UObject* WorldContextObject, const struct FMultiWorldHandle& InWorldHandle, bool bShouldTick)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MultiWorldStatics", "SetShouldTickWhenInBackground");

	Params::MultiWorldStatics_SetShouldTickWhenInBackground Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.InWorldHandle = std::move(InWorldHandle);
	Parms.bShouldTick = bShouldTick;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function MultiWorld.MultiWorldStatics.SpawnActorInWorld
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// const class UObject*                    WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TSubclassOf<class AActor>               ActorClass                                             (Parm, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FMultiWorldHandle&         InWorldHandle                                          (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// const struct FTransform&                SpawnTransform                                         (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ESpawnActorCollisionHandlingMethod      CollisionHandlingOverride                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           Owner                                                  (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AActor* UMultiWorldStatics::SpawnActorInWorld(const class UObject* WorldContextObject, TSubclassOf<class AActor> ActorClass, const struct FMultiWorldHandle& InWorldHandle, const struct FTransform& SpawnTransform, ESpawnActorCollisionHandlingMethod CollisionHandlingOverride, class AActor* Owner)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MultiWorldStatics", "SpawnActorInWorld");

	Params::MultiWorldStatics_SpawnActorInWorld Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.ActorClass = ActorClass;
	Parms.InWorldHandle = std::move(InWorldHandle);
	Parms.SpawnTransform = std::move(SpawnTransform);
	Parms.CollisionHandlingOverride = CollisionHandlingOverride;
	Parms.Owner = Owner;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function MultiWorld.MultiWorldStatics.SwitchWorld
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const class UObject*                    WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FMultiWorldHandle&         InWorldHandle                                          (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UMultiWorldStatics::SwitchWorld(const class UObject* WorldContextObject, const struct FMultiWorldHandle& InWorldHandle)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MultiWorldStatics", "SwitchWorld");

	Params::MultiWorldStatics_SwitchWorld Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.InWorldHandle = std::move(InWorldHandle);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function MultiWorld.MultiWorldStatics.TransferActorToWorld
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const class UObject*                    WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           InActor                                                (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FMultiWorldHandle&         InWorldHandle                                          (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// const struct FMultiWorldTransferActorParameters&OPTIONS                                                (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)

void UMultiWorldStatics::TransferActorToWorld(const class UObject* WorldContextObject, class AActor* InActor, const struct FMultiWorldHandle& InWorldHandle, const struct FMultiWorldTransferActorParameters& OPTIONS)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MultiWorldStatics", "TransferActorToWorld");

	Params::MultiWorldStatics_TransferActorToWorld Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.InActor = InActor;
	Parms.InWorldHandle = std::move(InWorldHandle);
	Parms.OPTIONS = std::move(OPTIONS);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function MultiWorld.LoadWorldAction.LoadWorld
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TSoftObjectPtr<class UWorld>            InMapAsset                                             (Parm, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FMultiWorldLoadParameters& InParams                                               (Parm, NoDestructor, NativeAccessSpecifierPublic)
// class ULoadWorldAction*                 ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ULoadWorldAction* ULoadWorldAction::LoadWorld(class UObject* WorldContextObject, TSoftObjectPtr<class UWorld> InMapAsset, const struct FMultiWorldLoadParameters& InParams)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LoadWorldAction", "LoadWorld");

	Params::LoadWorldAction_LoadWorld Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.InMapAsset = InMapAsset;
	Parms.InParams = std::move(InParams);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function MultiWorld.LoadWorldAction.OnCompleted
// (Final, Native, Private)
// Parameters:
// bool                                    Success                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FMultiWorldHandle&         WorldHandle                                            (Parm, NoDestructor, NativeAccessSpecifierPublic)
// const struct FMultiWorldLoadParameters& LoadParams                                             (Parm, NoDestructor, NativeAccessSpecifierPublic)

void ULoadWorldAction::OnCompleted(bool Success, const struct FMultiWorldHandle& WorldHandle, const struct FMultiWorldLoadParameters& LoadParams)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LoadWorldAction", "OnCompleted");

	Params::LoadWorldAction_OnCompleted Parms{};

	Parms.Success = Success;
	Parms.WorldHandle = std::move(WorldHandle);
	Parms.LoadParams = std::move(LoadParams);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function MultiWorld.LoadWorldAsyncAction.LoadWorldAsync
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TSoftObjectPtr<class UWorld>            InMapAsset                                             (Parm, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FMultiWorldLoadParameters& InParams                                               (Parm, NoDestructor, NativeAccessSpecifierPublic)
// class ULoadWorldAsyncAction*            ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ULoadWorldAsyncAction* ULoadWorldAsyncAction::LoadWorldAsync(class UObject* WorldContextObject, TSoftObjectPtr<class UWorld> InMapAsset, const struct FMultiWorldLoadParameters& InParams)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LoadWorldAsyncAction", "LoadWorldAsync");

	Params::LoadWorldAsyncAction_LoadWorldAsync Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.InMapAsset = InMapAsset;
	Parms.InParams = std::move(InParams);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function MultiWorld.LoadWorldAsyncAction.OnCompleted
// (Final, Native, Private)
// Parameters:
// bool                                    Success                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FMultiWorldHandle&         WorldHandle                                            (Parm, NoDestructor, NativeAccessSpecifierPublic)
// const struct FMultiWorldLoadParameters& LoadParams                                             (Parm, NoDestructor, NativeAccessSpecifierPublic)

void ULoadWorldAsyncAction::OnCompleted(bool Success, const struct FMultiWorldHandle& WorldHandle, const struct FMultiWorldLoadParameters& LoadParams)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LoadWorldAsyncAction", "OnCompleted");

	Params::LoadWorldAsyncAction_OnCompleted Parms{};

	Parms.Success = Success;
	Parms.WorldHandle = std::move(WorldHandle);
	Parms.LoadParams = std::move(LoadParams);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}

}

